{"mappings":"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,EAAxC,G,C,C,EAFvB,iBAAA,SAAA,CAAA,EAGqB,OAAA,GAAA,IAAA,E,EAHrB,UAAA,W,O,E,C,EC5DA,GAAA,SAAA,CAAA,E,I,EJsBE,A,E,Y,GAAA,QAAA,C,E,G,E,iB,IItBF,OAAA,SAAA,CAAA,E,I,E,E,GAAA,OAAA,SAAAyS,CAAAA,EAO6B,IAAA,EAAAzS,EAA0ByS,GAA1B,OAAA,SAAA,CAAA,EAAa,OAAA,EAAA,EAAb,G,C,C,C,EAE7B,GAAA,CAAA,kBAAA,SAAA,CAAA,EACsB,OAAA,GAAA,IAAA,E,EADtB,kBAAA,W,O,E,EAAA,mBAAA,W,O,E,EAAA,aAAA,W,O,E,C,ECwHA,G,GnChGO,SAAiB,CAAA,CAAI,CAAA,CAAK,CAAA,CAAG,CAAA,EAClC,OAAO,KAAK,EAAI,EAAI,CAAA,CAAE,EAAE,EAAI,CAC9B,G,G,K,E,G,M,EoCuDA,GAKa,CAvCb,EAuCa,GAAA,KAAA,CAvCb,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EACuB,OAAA,EAAE,GAAIA,E,C,GAsChB,GAAA,MAAA,EAwBb,GACW,GAnEX,SAAA,CAAA,EAAA,OAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EAC+C,OAAA,GAAA,EAAA,GAAA,EAAU,GAAA,EAAU,GAAA,EAAU,GAAA,EAAU,GAAGA,EAAE,E,C,C,GA6D5F,GACU,GApEV,SAAA,CAAA,EAAA,OAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EAC8C,OAAA,GAAA,EAAA,GAAA,EAAU,GAAA,EAAU,GAAA,EAAU,GAAGA,EAAA,EAAS,GAAG,E,C,C,GCjG3F,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,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,E,O,S,C,E,O,I,C,C,C,ECiDA,GAAA,C,c,W,M,O,C,E,G,G,I,G,GD/CA,C,Q,S,C,E,O,S,C,E,O,G,G,E,C,E,I,W,O,E,C,G,G,G,I,G,G,I,G,E,I,G,G,G,KChCA,GAAA,SAAA,CAAA,EAAA,OAAA,C,EAmCA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAjCA,GAAA,C,G,S,C,E,O,S,C,E,O,G,G,E,C,C,EAcA,GAAA,GACwC,kBDhB5B,wCCYZ,GAAA,CAAA,WAAA,SAAA,CAAA,EAC+B,OAAA,GAAA,GAAA,IAAS,SAAA4gB,CAAAA,MpE0NxC,EoE1NuD,MAAA,CpE0NvD,EoE1NuD,SAAA,CAAA,EAAM,OAMhC,GANqCA,GAMnC,GANuC,EpE0NtE,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EACO,GAAP,aAAA,GAAA,OAAA,EAAA,GACO,GADP,aAAA,GACiB,OADjB,EAAA,EAAA,MAAA,CAAA,OAAA,AAAA,MAAA,kFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,GoE3NsE,IDApE,AAFF,ADZ8B,GEc2DA,GDAxE,IAAA,GCAwEA,GDCvF,GAAA,KAAA,C,E,C,ECmEF,GAAA,GAAA,GAAA,GAAA/M,GAAA,GAAAsB,GAAA,GAAA,GAAA,KAAA,GAAA,GAAA,KAAA,IAHA,C,c,W,M,M,C,QAAA,C,c,W,M,I,C,QAGA,cAAAA,GAAA,GAAA,GA5BA,CAAA,WAAA,SAAA,CAAA,EACoB,IAAA,EAAA,OAAA,IAAA,EAAA,GAAA,IAAA,GAAsB,IAAtB,SAAA,CAAA,EAAA,OAAA,EAIlB,AAAA,AAAA,YAJkB,E,I,G,G,K,EAKlB,AAAA,aALkB,E,I,G,G,K,EAMlB,AAAA,YANkB,E,I,G,G,K,EAOlB,AAAA,gBAPkB,E,I,G,G,K,EAQlB,AAAA,WARkB,E,I,G,G,K,EASlB,AAAA,YATkB,E,I,G,G,K,EAUlB,AAAA,YAVkB,E,I,G,G,K,EAWlB,GAAA,KAAA,C,IAXmF,GAAA,G,C,IA2BrF,IAHA,C,c,W,M,M,C,QAGA,SAHA,C,c,W,M,O,C,U,G,E,I,G,G,I,G,G,I,G,E,G,G,C3CiRiB,EAAA,G,IAZjB,SAAA,CAAA,E,O,A,G,I,E,G,K,G,G,I,I7B3MiC,EAAA,G,IADjC,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,SAAA,CAAA,AAAAwG,EAC6B,GAAa,cAD1C,EAAA,C,C,G,G,C,E,G,I6BsRA,SAAA,CAAA,EACU,OAAA,GAAA,GAAA1nB,E,G,I,I/CzUE,EAAA,E,GADZ,SAAAqR,CAAAA,EAAA,OAAA,SAAA,CAAA,EACiB,OAAA,EAAA,SAAA8V,CAAAA,EAAMA,OAAAA,EAAE,EAAG9V,GAAAA,E,C,G,G,G,I,G,G,I,I,I,E,G,IuD46B5B,SAAA,CAAA,EACW,OAAA,GAAAoW,GAAW,E,G,G,GrD5+BtB,CAAA,KAAA,SAAA,CAAA,EACW,MAAA,CAAE,EAAF,A,EADX,OAAA,W,O,E,C,G,G,G,G,K,G,E,G,G,G,I,IgB6HkB,EAAA,GwEjJlB,C,Q,S,C,E,O,S,C,E,O,G,G,E,C,E,I,W,O,E,C,GxEgJA,SAAAN,CAAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAC2BA,OAAAA,EAAAA,EAAE,IAAIA,EAAE,G,C,C,G,G,G,I,G,G,I,I,G,G,I,G,E4CzHnC,G,GtBlBU,EAAA,C,GhC4CV,SAAA,CAAA,EAAA,MAAA,CACO,GAAA,GAAA,GAAA,EAAA,KAAA,C,C,E,G,GA6BP,CAAA,SAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EACmB,MAAA,CAAA,C,C,C,C,KmFhFM,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,C,c,W,M,K,CAAA,GAAA,OAAA,C,c,W,M,K,CAAA,GAAA,OAAA,C,c,W,M,M,CAAA,GAAA,GAAA,GAAA,GAAA,GAAA,C,c,W,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","sources":["<anon>","bundle/worker.js","node_modules/big-integer/BigInteger.js","output/Control.Bind/foreign.js","output/Control.Apply/foreign.js",".spago/packages/prelude-6.0.1/src/Control/Semigroupoid.purs",".spago/packages/prelude-6.0.1/src/Control/Category.purs",".spago/packages/prelude-6.0.1/src/Data/Boolean.purs",".spago/packages/prelude-6.0.1/src/Data/Function.purs","output/Data.Functor/foreign.js","output/Data.Unit/foreign.js",".spago/packages/prelude-6.0.1/src/Type/Proxy.purs",".spago/packages/prelude-6.0.1/src/Data/Functor.purs",".spago/packages/prelude-6.0.1/src/Control/Apply.purs",".spago/packages/prelude-6.0.1/src/Control/Applicative.purs",".spago/packages/prelude-6.0.1/src/Control/Bind.purs","output/Data.Argonaut.Core/foreign.js","output/Data.Eq/foreign.js",".spago/packages/prelude-6.0.1/src/Data/Symbol.purs","output/Record.Unsafe/foreign.js",".spago/packages/prelude-6.0.1/src/Data/Eq.purs","output/Data.Semigroup/foreign.js",".spago/packages/prelude-6.0.1/src/Data/Semigroup.purs",".spago/packages/control-6.0.0/src/Control/Alt.purs","output/Data.Bounded/foreign.js","output/Data.Ord/foreign.js",".spago/packages/prelude-6.0.1/src/Data/Ordering.purs","output/Data.Semiring/foreign.js",".spago/packages/prelude-6.0.1/src/Data/Semiring.purs",".spago/packages/prelude-6.0.1/src/Data/Ring.purs",".spago/packages/prelude-6.0.1/src/Data/Ord.purs",".spago/packages/prelude-6.0.1/src/Data/Bounded.purs","output/Data.Show/foreign.js",".spago/packages/prelude-6.0.1/src/Data/Show.purs",".spago/packages/maybe-6.0.0/src/Data/Maybe.purs","output/Foreign.Object/foreign.js","output/Control.Monad.ST.Internal/foreign.js",".spago/packages/prelude-6.0.1/src/Control/Monad.purs",".spago/packages/either-6.1.0/src/Data/Either.purs",".spago/packages/prelude-6.0.1/src/Data/EuclideanRing.purs",".spago/packages/prelude-6.0.1/src/Data/Monoid.purs","output/Effect/foreign.js",".spago/packages/effect-4.0.0/src/Effect.purs",".spago/packages/st-6.2.0/src/Control/Monad/ST/Internal.purs","output/Data.Array/foreign.js","output/Data.Array.ST/foreign.js","output/Control.Monad.ST.Uncurried/foreign.js",".spago/packages/arrays-7.3.0/src/Data/Array/ST.purs","output/Data.HeytingAlgebra/foreign.js",".spago/packages/prelude-6.0.1/src/Data/HeytingAlgebra.purs",".spago/packages/arrays-7.3.0/src/Data/Array/ST/Iterator.purs","output/Data.Foldable/foreign.js",".spago/packages/control-6.0.0/src/Control/Plus.purs",".spago/packages/tuples-7.0.0/src/Data/Tuple.purs",".spago/packages/bifunctors-6.0.0/src/Data/Bifunctor.purs",".spago/packages/prelude-6.0.1/src/Data/Monoid/Conj.purs","output/Unsafe.Coerce/foreign.js",".spago/packages/safe-coerce-2.0.0/src/Safe/Coerce.purs",".spago/packages/newtype-5.0.0/src/Data/Newtype.purs",".spago/packages/foldable-traversable-6.0.0/src/Data/Foldable.purs","output/Data.Function.Uncurried/foreign.js","output/Data.FunctorWithIndex/foreign.js",".spago/packages/prelude-6.0.1/src/Data/Monoid/Additive.purs",".spago/packages/foldable-traversable-6.0.0/src/Data/FunctorWithIndex.purs","output/Data.Traversable/foreign.js",".spago/packages/foldable-traversable-6.0.0/src/Data/Traversable.purs",".spago/packages/foldable-traversable-6.0.0/src/Data/Semigroup/Foldable.purs",".spago/packages/arrays-7.3.0/src/Data/Array.purs",".spago/packages/foldable-traversable-6.0.0/src/Data/FoldableWithIndex.purs",".spago/packages/foldable-traversable-6.0.0/src/Data/TraversableWithIndex.purs",".spago/packages/foreign-object-4.1.0/src/Foreign/Object.purs",".spago/packages/argonaut-core-7.0.0/src/Data/Argonaut/Core.purs",".spago/packages/argonaut-codecs-9.1.0/src/Data/Argonaut/Decode/Error.purs","output/Data.Array.NonEmpty.Internal/foreign.js",".spago/packages/arrays-7.3.0/src/Data/Array/NonEmpty/Internal.purs",".spago/packages/arrays-7.3.0/src/Data/Array/NonEmpty.purs","output/Data.Int/foreign.js","output/Data.Number/foreign.js",".spago/packages/integers-6.0.0/src/Data/Int.purs",".spago/packages/lists-7.0.0/src/Data/List/Types.purs",".spago/packages/lists-7.0.0/src/Data/List.purs","output/Data.String.CodePoints/foreign.js",".spago/packages/argonaut-codecs-9.1.0/src/Data/Argonaut/Decode/Decoders.purs",".spago/packages/record-4.0.0/src/Record.purs",".spago/packages/argonaut-codecs-9.1.0/src/Data/Argonaut/Decode/Class.purs","output/Data.BigInt/foreign.js",".spago/packages/bigints-7.0.1/src/Data/BigInt.purs",".spago/packages/effect-4.0.0/src/Effect/Class.purs","output/Effect.Console/foreign.js",".spago/packages/console-6.1.0/src/Effect/Class/Console.purs","output/Foreign/foreign.js",".spago/packages/foreign-7.0.0/src/Foreign.purs","src/TcgCalculator/Math.purs","node_modules/uuid/dist/esm-browser/regex.js","node_modules/uuid/dist/esm-browser/validate.js","node_modules/uuid/dist/esm-browser/stringify.js","node_modules/uuid/dist/esm-browser/parse.js","node_modules/uuid/dist/esm-browser/v35.js","node_modules/uuid/dist/esm-browser/sha1.js","node_modules/uuid/dist/esm-browser/v5.js","output/Data.UUID/foreign.js",".spago/packages/uuid-9.0.0/src/Data/UUID.purs","src/TcgCalculator/Types.purs","src/TcgCalculator.purs","output/Web.Worker.GlobalScope/foreign.js",".spago/packages/web-workers-1.1.0/src/Web/Worker/GlobalScope.purs","output/Web.Worker.MessageEvent/foreign.js","src/Worker/Main.purs","bundle/<stdin>"],"sourcesContent":["(() => {\n(()=>{\n    var __create = Object.create;\n    var __defProp = Object.defineProperty;\n    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames = Object.getOwnPropertyNames;\n    var __getProtoOf = Object.getPrototypeOf;\n    var __hasOwnProp = Object.prototype.hasOwnProperty;\n    var __commonJS = (cb, mod2)=>function __require() {\n            return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = {\n                exports: {}\n            }).exports, mod2), mod2.exports;\n        };\n    var __copyProps = (to, from2, except, desc)=>{\n        if (from2 && typeof from2 === \"object\" || typeof from2 === \"function\") {\n            for (let key of __getOwnPropNames(from2))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n                get: ()=>from2[key],\n                enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable\n            });\n        }\n        return to;\n    };\n    var __toESM = (mod2, isNodeMode, target)=>(target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n        // file that has been converted to a CommonJS file using a Babel-\n        // compatible transform (i.e. \"__esModule\" has not been set), then set\n        // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n        isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", {\n            value: mod2,\n            enumerable: true\n        }) : target, mod2));\n    // node_modules/big-integer/BigInteger.js\n    var require_BigInteger = __commonJS({\n        \"node_modules/big-integer/BigInteger.js\" (exports, module) {\n            var bigInt2 = function(undefined2) {\n                \"use strict\";\n                var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n                var supportsNativeBigInt = typeof BigInt === \"function\";\n                function Integer(v, radix, alphabet, caseSensitive) {\n                    if (typeof v === \"undefined\") return Integer[0];\n                    if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\n                    return parseValue(v);\n                }\n                function BigInteger(value, sign2) {\n                    this.value = value;\n                    this.sign = sign2;\n                    this.isSmall = false;\n                }\n                BigInteger.prototype = Object.create(Integer.prototype);\n                function SmallInteger(value) {\n                    this.value = value;\n                    this.sign = value < 0;\n                    this.isSmall = true;\n                }\n                SmallInteger.prototype = Object.create(Integer.prototype);\n                function NativeBigInt(value) {\n                    this.value = value;\n                }\n                NativeBigInt.prototype = Object.create(Integer.prototype);\n                function isPrecise(n) {\n                    return -MAX_INT < n && n < MAX_INT;\n                }\n                function smallToArray(n) {\n                    if (n < 1e7) return [\n                        n\n                    ];\n                    if (n < 1e14) return [\n                        n % 1e7,\n                        Math.floor(n / 1e7)\n                    ];\n                    return [\n                        n % 1e7,\n                        Math.floor(n / 1e7) % 1e7,\n                        Math.floor(n / 1e14)\n                    ];\n                }\n                function arrayToSmall(arr) {\n                    trim2(arr);\n                    var length4 = arr.length;\n                    if (length4 < 4 && compareAbs(arr, MAX_INT_ARR) < 0) switch(length4){\n                        case 0:\n                            return 0;\n                        case 1:\n                            return arr[0];\n                        case 2:\n                            return arr[0] + arr[1] * BASE;\n                        default:\n                            return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\n                    }\n                    return arr;\n                }\n                function trim2(v) {\n                    var i2 = v.length;\n                    while(v[--i2] === 0);\n                    v.length = i2 + 1;\n                }\n                function createArray(length4) {\n                    var x = new Array(length4);\n                    var i2 = -1;\n                    while(++i2 < length4)x[i2] = 0;\n                    return x;\n                }\n                function truncate(n) {\n                    if (n > 0) return Math.floor(n);\n                    return Math.ceil(n);\n                }\n                function add4(a, b) {\n                    var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum3, i2;\n                    for(i2 = 0; i2 < l_b; i2++){\n                        sum3 = a[i2] + b[i2] + carry;\n                        carry = sum3 >= base ? 1 : 0;\n                        r[i2] = sum3 - carry * base;\n                    }\n                    while(i2 < l_a){\n                        sum3 = a[i2] + carry;\n                        carry = sum3 === base ? 1 : 0;\n                        r[i2++] = sum3 - carry * base;\n                    }\n                    if (carry > 0) r.push(carry);\n                    return r;\n                }\n                function addAny(a, b) {\n                    if (a.length >= b.length) return add4(a, b);\n                    return add4(b, a);\n                }\n                function addSmall(a, carry) {\n                    var l = a.length, r = new Array(l), base = BASE, sum3, i2;\n                    for(i2 = 0; i2 < l; i2++){\n                        sum3 = a[i2] - base + carry;\n                        carry = Math.floor(sum3 / base);\n                        r[i2] = sum3 - carry * base;\n                        carry += 1;\n                    }\n                    while(carry > 0){\n                        r[i2++] = carry % base;\n                        carry = Math.floor(carry / base);\n                    }\n                    return r;\n                }\n                BigInteger.prototype.add = function(v) {\n                    var n = parseValue(v);\n                    if (this.sign !== n.sign) return this.subtract(n.negate());\n                    var a = this.value, b = n.value;\n                    if (n.isSmall) return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\n                    return new BigInteger(addAny(a, b), this.sign);\n                };\n                BigInteger.prototype.plus = BigInteger.prototype.add;\n                SmallInteger.prototype.add = function(v) {\n                    var n = parseValue(v);\n                    var a = this.value;\n                    if (a < 0 !== n.sign) return this.subtract(n.negate());\n                    var b = n.value;\n                    if (n.isSmall) {\n                        if (isPrecise(a + b)) return new SmallInteger(a + b);\n                        b = smallToArray(Math.abs(b));\n                    }\n                    return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\n                };\n                SmallInteger.prototype.plus = SmallInteger.prototype.add;\n                NativeBigInt.prototype.add = function(v) {\n                    return new NativeBigInt(this.value + parseValue(v).value);\n                };\n                NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\n                function subtract(a, b) {\n                    var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference3;\n                    for(i2 = 0; i2 < b_l; i2++){\n                        difference3 = a[i2] - borrow - b[i2];\n                        if (difference3 < 0) {\n                            difference3 += base;\n                            borrow = 1;\n                        } else borrow = 0;\n                        r[i2] = difference3;\n                    }\n                    for(i2 = b_l; i2 < a_l; i2++){\n                        difference3 = a[i2] - borrow;\n                        if (difference3 < 0) difference3 += base;\n                        else {\n                            r[i2++] = difference3;\n                            break;\n                        }\n                        r[i2] = difference3;\n                    }\n                    for(; i2 < a_l; i2++)r[i2] = a[i2];\n                    trim2(r);\n                    return r;\n                }\n                function subtractAny(a, b, sign2) {\n                    var value;\n                    if (compareAbs(a, b) >= 0) value = subtract(a, b);\n                    else {\n                        value = subtract(b, a);\n                        sign2 = !sign2;\n                    }\n                    value = arrayToSmall(value);\n                    if (typeof value === \"number\") {\n                        if (sign2) value = -value;\n                        return new SmallInteger(value);\n                    }\n                    return new BigInteger(value, sign2);\n                }\n                function subtractSmall(a, b, sign2) {\n                    var l = a.length, r = new Array(l), carry = -b, base = BASE, i2, difference3;\n                    for(i2 = 0; i2 < l; i2++){\n                        difference3 = a[i2] + carry;\n                        carry = Math.floor(difference3 / base);\n                        difference3 %= base;\n                        r[i2] = difference3 < 0 ? difference3 + base : difference3;\n                    }\n                    r = arrayToSmall(r);\n                    if (typeof r === \"number\") {\n                        if (sign2) r = -r;\n                        return new SmallInteger(r);\n                    }\n                    return new BigInteger(r, sign2);\n                }\n                BigInteger.prototype.subtract = function(v) {\n                    var n = parseValue(v);\n                    if (this.sign !== n.sign) return this.add(n.negate());\n                    var a = this.value, b = n.value;\n                    if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);\n                    return subtractAny(a, b, this.sign);\n                };\n                BigInteger.prototype.minus = BigInteger.prototype.subtract;\n                SmallInteger.prototype.subtract = function(v) {\n                    var n = parseValue(v);\n                    var a = this.value;\n                    if (a < 0 !== n.sign) return this.add(n.negate());\n                    var b = n.value;\n                    if (n.isSmall) return new SmallInteger(a - b);\n                    return subtractSmall(b, Math.abs(a), a >= 0);\n                };\n                SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\n                NativeBigInt.prototype.subtract = function(v) {\n                    return new NativeBigInt(this.value - parseValue(v).value);\n                };\n                NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\n                BigInteger.prototype.negate = function() {\n                    return new BigInteger(this.value, !this.sign);\n                };\n                SmallInteger.prototype.negate = function() {\n                    var sign2 = this.sign;\n                    var small = new SmallInteger(-this.value);\n                    small.sign = !sign2;\n                    return small;\n                };\n                NativeBigInt.prototype.negate = function() {\n                    return new NativeBigInt(-this.value);\n                };\n                BigInteger.prototype.abs = function() {\n                    return new BigInteger(this.value, false);\n                };\n                SmallInteger.prototype.abs = function() {\n                    return new SmallInteger(Math.abs(this.value));\n                };\n                NativeBigInt.prototype.abs = function() {\n                    return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\n                };\n                function multiplyLong(a, b) {\n                    var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product5, carry, i2, a_i, b_j;\n                    for(i2 = 0; i2 < a_l; ++i2){\n                        a_i = a[i2];\n                        for(var j = 0; j < b_l; ++j){\n                            b_j = b[j];\n                            product5 = a_i * b_j + r[i2 + j];\n                            carry = Math.floor(product5 / base);\n                            r[i2 + j] = product5 - carry * base;\n                            r[i2 + j + 1] += carry;\n                        }\n                    }\n                    trim2(r);\n                    return r;\n                }\n                function multiplySmall(a, b) {\n                    var l = a.length, r = new Array(l), base = BASE, carry = 0, product5, i2;\n                    for(i2 = 0; i2 < l; i2++){\n                        product5 = a[i2] * b + carry;\n                        carry = Math.floor(product5 / base);\n                        r[i2] = product5 - carry * base;\n                    }\n                    while(carry > 0){\n                        r[i2++] = carry % base;\n                        carry = Math.floor(carry / base);\n                    }\n                    return r;\n                }\n                function shiftLeft(x, n) {\n                    var r = [];\n                    while(n-- > 0)r.push(0);\n                    return r.concat(x);\n                }\n                function multiplyKaratsuba(x, y) {\n                    var n = Math.max(x.length, y.length);\n                    if (n <= 30) return multiplyLong(x, y);\n                    n = Math.ceil(n / 2);\n                    var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);\n                    var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\n                    var product5 = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\n                    trim2(product5);\n                    return product5;\n                }\n                function useKaratsuba(l1, l2) {\n                    return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;\n                }\n                BigInteger.prototype.multiply = function(v) {\n                    var n = parseValue(v), a = this.value, b = n.value, sign2 = this.sign !== n.sign, abs4;\n                    if (n.isSmall) {\n                        if (b === 0) return Integer[0];\n                        if (b === 1) return this;\n                        if (b === -1) return this.negate();\n                        abs4 = Math.abs(b);\n                        if (abs4 < BASE) return new BigInteger(multiplySmall(a, abs4), sign2);\n                        b = smallToArray(abs4);\n                    }\n                    if (useKaratsuba(a.length, b.length)) return new BigInteger(multiplyKaratsuba(a, b), sign2);\n                    return new BigInteger(multiplyLong(a, b), sign2);\n                };\n                BigInteger.prototype.times = BigInteger.prototype.multiply;\n                function multiplySmallAndArray(a, b, sign2) {\n                    if (a < BASE) return new BigInteger(multiplySmall(b, a), sign2);\n                    return new BigInteger(multiplyLong(b, smallToArray(a)), sign2);\n                }\n                SmallInteger.prototype._multiplyBySmall = function(a) {\n                    if (isPrecise(a.value * this.value)) return new SmallInteger(a.value * this.value);\n                    return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\n                };\n                BigInteger.prototype._multiplyBySmall = function(a) {\n                    if (a.value === 0) return Integer[0];\n                    if (a.value === 1) return this;\n                    if (a.value === -1) return this.negate();\n                    return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\n                };\n                SmallInteger.prototype.multiply = function(v) {\n                    return parseValue(v)._multiplyBySmall(this);\n                };\n                SmallInteger.prototype.times = SmallInteger.prototype.multiply;\n                NativeBigInt.prototype.multiply = function(v) {\n                    return new NativeBigInt(this.value * parseValue(v).value);\n                };\n                NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\n                function square(a) {\n                    var l = a.length, r = createArray(l + l), base = BASE, product5, carry, i2, a_i, a_j;\n                    for(i2 = 0; i2 < l; i2++){\n                        a_i = a[i2];\n                        carry = 0 - a_i * a_i;\n                        for(var j = i2; j < l; j++){\n                            a_j = a[j];\n                            product5 = 2 * (a_i * a_j) + r[i2 + j] + carry;\n                            carry = Math.floor(product5 / base);\n                            r[i2 + j] = product5 - carry * base;\n                        }\n                        r[i2 + l] = carry;\n                    }\n                    trim2(r);\n                    return r;\n                }\n                BigInteger.prototype.square = function() {\n                    return new BigInteger(square(this.value), false);\n                };\n                SmallInteger.prototype.square = function() {\n                    var value = this.value * this.value;\n                    if (isPrecise(value)) return new SmallInteger(value);\n                    return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\n                };\n                NativeBigInt.prototype.square = function(v) {\n                    return new NativeBigInt(this.value * this.value);\n                };\n                function divMod1(a, b) {\n                    var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder2 = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l, q;\n                    if (remainder2.length <= a_l) remainder2.push(0);\n                    divisor.push(0);\n                    divisorMostSignificantDigit = divisor[b_l - 1];\n                    for(shift = a_l - b_l; shift >= 0; shift--){\n                        quotientDigit = base - 1;\n                        if (remainder2[shift + b_l] !== divisorMostSignificantDigit) quotientDigit = Math.floor((remainder2[shift + b_l] * base + remainder2[shift + b_l - 1]) / divisorMostSignificantDigit);\n                        carry = 0;\n                        borrow = 0;\n                        l = divisor.length;\n                        for(i2 = 0; i2 < l; i2++){\n                            carry += quotientDigit * divisor[i2];\n                            q = Math.floor(carry / base);\n                            borrow += remainder2[shift + i2] - (carry - q * base);\n                            carry = q;\n                            if (borrow < 0) {\n                                remainder2[shift + i2] = borrow + base;\n                                borrow = -1;\n                            } else {\n                                remainder2[shift + i2] = borrow;\n                                borrow = 0;\n                            }\n                        }\n                        while(borrow !== 0){\n                            quotientDigit -= 1;\n                            carry = 0;\n                            for(i2 = 0; i2 < l; i2++){\n                                carry += remainder2[shift + i2] - base + divisor[i2];\n                                if (carry < 0) {\n                                    remainder2[shift + i2] = carry + base;\n                                    carry = 0;\n                                } else {\n                                    remainder2[shift + i2] = carry;\n                                    carry = 1;\n                                }\n                            }\n                            borrow += carry;\n                        }\n                        result[shift] = quotientDigit;\n                    }\n                    remainder2 = divModSmall(remainder2, lambda)[0];\n                    return [\n                        arrayToSmall(result),\n                        arrayToSmall(remainder2)\n                    ];\n                }\n                function divMod2(a, b) {\n                    var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;\n                    while(a_l){\n                        part.unshift(a[--a_l]);\n                        trim2(part);\n                        if (compareAbs(part, b) < 0) {\n                            result.push(0);\n                            continue;\n                        }\n                        xlen = part.length;\n                        highx = part[xlen - 1] * base + part[xlen - 2];\n                        highy = b[b_l - 1] * base + b[b_l - 2];\n                        if (xlen > b_l) highx = (highx + 1) * base;\n                        guess = Math.ceil(highx / highy);\n                        do {\n                            check = multiplySmall(b, guess);\n                            if (compareAbs(check, part) <= 0) break;\n                            guess--;\n                        }while (guess);\n                        result.push(guess);\n                        part = subtract(part, check);\n                    }\n                    result.reverse();\n                    return [\n                        arrayToSmall(result),\n                        arrayToSmall(part)\n                    ];\n                }\n                function divModSmall(value, lambda) {\n                    var length4 = value.length, quotient = createArray(length4), base = BASE, i2, q, remainder2, divisor;\n                    remainder2 = 0;\n                    for(i2 = length4 - 1; i2 >= 0; --i2){\n                        divisor = remainder2 * base + value[i2];\n                        q = truncate(divisor / lambda);\n                        remainder2 = divisor - q * lambda;\n                        quotient[i2] = q | 0;\n                    }\n                    return [\n                        quotient,\n                        remainder2 | 0\n                    ];\n                }\n                function divModAny(self2, v) {\n                    var value, n = parseValue(v);\n                    if (supportsNativeBigInt) return [\n                        new NativeBigInt(self2.value / n.value),\n                        new NativeBigInt(self2.value % n.value)\n                    ];\n                    var a = self2.value, b = n.value;\n                    var quotient;\n                    if (b === 0) throw new Error(\"Cannot divide by zero\");\n                    if (self2.isSmall) {\n                        if (n.isSmall) return [\n                            new SmallInteger(truncate(a / b)),\n                            new SmallInteger(a % b)\n                        ];\n                        return [\n                            Integer[0],\n                            self2\n                        ];\n                    }\n                    if (n.isSmall) {\n                        if (b === 1) return [\n                            self2,\n                            Integer[0]\n                        ];\n                        if (b == -1) return [\n                            self2.negate(),\n                            Integer[0]\n                        ];\n                        var abs4 = Math.abs(b);\n                        if (abs4 < BASE) {\n                            value = divModSmall(a, abs4);\n                            quotient = arrayToSmall(value[0]);\n                            var remainder2 = value[1];\n                            if (self2.sign) remainder2 = -remainder2;\n                            if (typeof quotient === \"number\") {\n                                if (self2.sign !== n.sign) quotient = -quotient;\n                                return [\n                                    new SmallInteger(quotient),\n                                    new SmallInteger(remainder2)\n                                ];\n                            }\n                            return [\n                                new BigInteger(quotient, self2.sign !== n.sign),\n                                new SmallInteger(remainder2)\n                            ];\n                        }\n                        b = smallToArray(abs4);\n                    }\n                    var comparison = compareAbs(a, b);\n                    if (comparison === -1) return [\n                        Integer[0],\n                        self2\n                    ];\n                    if (comparison === 0) return [\n                        Integer[self2.sign === n.sign ? 1 : -1],\n                        Integer[0]\n                    ];\n                    if (a.length + b.length <= 200) value = divMod1(a, b);\n                    else value = divMod2(a, b);\n                    quotient = value[0];\n                    var qSign = self2.sign !== n.sign, mod2 = value[1], mSign = self2.sign;\n                    if (typeof quotient === \"number\") {\n                        if (qSign) quotient = -quotient;\n                        quotient = new SmallInteger(quotient);\n                    } else quotient = new BigInteger(quotient, qSign);\n                    if (typeof mod2 === \"number\") {\n                        if (mSign) mod2 = -mod2;\n                        mod2 = new SmallInteger(mod2);\n                    } else mod2 = new BigInteger(mod2, mSign);\n                    return [\n                        quotient,\n                        mod2\n                    ];\n                }\n                BigInteger.prototype.divmod = function(v) {\n                    var result = divModAny(this, v);\n                    return {\n                        quotient: result[0],\n                        remainder: result[1]\n                    };\n                };\n                NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\n                BigInteger.prototype.divide = function(v) {\n                    return divModAny(this, v)[0];\n                };\n                NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {\n                    return new NativeBigInt(this.value / parseValue(v).value);\n                };\n                SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\n                BigInteger.prototype.mod = function(v) {\n                    return divModAny(this, v)[1];\n                };\n                NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {\n                    return new NativeBigInt(this.value % parseValue(v).value);\n                };\n                SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\n                BigInteger.prototype.pow = function(v) {\n                    var n = parseValue(v), a = this.value, b = n.value, value, x, y;\n                    if (b === 0) return Integer[1];\n                    if (a === 0) return Integer[0];\n                    if (a === 1) return Integer[1];\n                    if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\n                    if (n.sign) return Integer[0];\n                    if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\n                    if (this.isSmall) {\n                        if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));\n                    }\n                    x = this;\n                    y = Integer[1];\n                    while(true){\n                        if (b & true) {\n                            y = y.times(x);\n                            --b;\n                        }\n                        if (b === 0) break;\n                        b /= 2;\n                        x = x.square();\n                    }\n                    return y;\n                };\n                SmallInteger.prototype.pow = BigInteger.prototype.pow;\n                NativeBigInt.prototype.pow = function(v) {\n                    var n = parseValue(v);\n                    var a = this.value, b = n.value;\n                    var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\n                    if (b === _0) return Integer[1];\n                    if (a === _0) return Integer[0];\n                    if (a === _1) return Integer[1];\n                    if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\n                    if (n.isNegative()) return new NativeBigInt(_0);\n                    var x = this;\n                    var y = Integer[1];\n                    while(true){\n                        if ((b & _1) === _1) {\n                            y = y.times(x);\n                            --b;\n                        }\n                        if (b === _0) break;\n                        b /= _2;\n                        x = x.square();\n                    }\n                    return y;\n                };\n                BigInteger.prototype.modPow = function(exp2, mod2) {\n                    exp2 = parseValue(exp2);\n                    mod2 = parseValue(mod2);\n                    if (mod2.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\n                    var r = Integer[1], base = this.mod(mod2);\n                    if (exp2.isNegative()) {\n                        exp2 = exp2.multiply(Integer[-1]);\n                        base = base.modInv(mod2);\n                    }\n                    while(exp2.isPositive()){\n                        if (base.isZero()) return Integer[0];\n                        if (exp2.isOdd()) r = r.multiply(base).mod(mod2);\n                        exp2 = exp2.divide(2);\n                        base = base.square().mod(mod2);\n                    }\n                    return r;\n                };\n                NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\n                function compareAbs(a, b) {\n                    if (a.length !== b.length) return a.length > b.length ? 1 : -1;\n                    for(var i2 = a.length - 1; i2 >= 0; i2--){\n                        if (a[i2] !== b[i2]) return a[i2] > b[i2] ? 1 : -1;\n                    }\n                    return 0;\n                }\n                BigInteger.prototype.compareAbs = function(v) {\n                    var n = parseValue(v), a = this.value, b = n.value;\n                    if (n.isSmall) return 1;\n                    return compareAbs(a, b);\n                };\n                SmallInteger.prototype.compareAbs = function(v) {\n                    var n = parseValue(v), a = Math.abs(this.value), b = n.value;\n                    if (n.isSmall) {\n                        b = Math.abs(b);\n                        return a === b ? 0 : a > b ? 1 : -1;\n                    }\n                    return -1;\n                };\n                NativeBigInt.prototype.compareAbs = function(v) {\n                    var a = this.value;\n                    var b = parseValue(v).value;\n                    a = a >= 0 ? a : -a;\n                    b = b >= 0 ? b : -b;\n                    return a === b ? 0 : a > b ? 1 : -1;\n                };\n                BigInteger.prototype.compare = function(v) {\n                    if (v === Infinity) return -1;\n                    if (v === -Infinity) return 1;\n                    var n = parseValue(v), a = this.value, b = n.value;\n                    if (this.sign !== n.sign) return n.sign ? 1 : -1;\n                    if (n.isSmall) return this.sign ? -1 : 1;\n                    return compareAbs(a, b) * (this.sign ? -1 : 1);\n                };\n                BigInteger.prototype.compareTo = BigInteger.prototype.compare;\n                SmallInteger.prototype.compare = function(v) {\n                    if (v === Infinity) return -1;\n                    if (v === -Infinity) return 1;\n                    var n = parseValue(v), a = this.value, b = n.value;\n                    if (n.isSmall) return a == b ? 0 : a > b ? 1 : -1;\n                    if (a < 0 !== n.sign) return a < 0 ? -1 : 1;\n                    return a < 0 ? 1 : -1;\n                };\n                SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\n                NativeBigInt.prototype.compare = function(v) {\n                    if (v === Infinity) return -1;\n                    if (v === -Infinity) return 1;\n                    var a = this.value;\n                    var b = parseValue(v).value;\n                    return a === b ? 0 : a > b ? 1 : -1;\n                };\n                NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\n                BigInteger.prototype.equals = function(v) {\n                    return this.compare(v) === 0;\n                };\n                NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\n                BigInteger.prototype.notEquals = function(v) {\n                    return this.compare(v) !== 0;\n                };\n                NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\n                BigInteger.prototype.greater = function(v) {\n                    return this.compare(v) > 0;\n                };\n                NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\n                BigInteger.prototype.lesser = function(v) {\n                    return this.compare(v) < 0;\n                };\n                NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\n                BigInteger.prototype.greaterOrEquals = function(v) {\n                    return this.compare(v) >= 0;\n                };\n                NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\n                BigInteger.prototype.lesserOrEquals = function(v) {\n                    return this.compare(v) <= 0;\n                };\n                NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\n                BigInteger.prototype.isEven = function() {\n                    return (this.value[0] & 1) === 0;\n                };\n                SmallInteger.prototype.isEven = function() {\n                    return (this.value & 1) === 0;\n                };\n                NativeBigInt.prototype.isEven = function() {\n                    return (this.value & BigInt(1)) === BigInt(0);\n                };\n                BigInteger.prototype.isOdd = function() {\n                    return (this.value[0] & 1) === 1;\n                };\n                SmallInteger.prototype.isOdd = function() {\n                    return (this.value & 1) === 1;\n                };\n                NativeBigInt.prototype.isOdd = function() {\n                    return (this.value & BigInt(1)) === BigInt(1);\n                };\n                BigInteger.prototype.isPositive = function() {\n                    return !this.sign;\n                };\n                SmallInteger.prototype.isPositive = function() {\n                    return this.value > 0;\n                };\n                NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\n                BigInteger.prototype.isNegative = function() {\n                    return this.sign;\n                };\n                SmallInteger.prototype.isNegative = function() {\n                    return this.value < 0;\n                };\n                NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\n                BigInteger.prototype.isUnit = function() {\n                    return false;\n                };\n                SmallInteger.prototype.isUnit = function() {\n                    return Math.abs(this.value) === 1;\n                };\n                NativeBigInt.prototype.isUnit = function() {\n                    return this.abs().value === BigInt(1);\n                };\n                BigInteger.prototype.isZero = function() {\n                    return false;\n                };\n                SmallInteger.prototype.isZero = function() {\n                    return this.value === 0;\n                };\n                NativeBigInt.prototype.isZero = function() {\n                    return this.value === BigInt(0);\n                };\n                BigInteger.prototype.isDivisibleBy = function(v) {\n                    var n = parseValue(v);\n                    if (n.isZero()) return false;\n                    if (n.isUnit()) return true;\n                    if (n.compareAbs(2) === 0) return this.isEven();\n                    return this.mod(n).isZero();\n                };\n                NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\n                function isBasicPrime(v) {\n                    var n = v.abs();\n                    if (n.isUnit()) return false;\n                    if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\n                    if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\n                    if (n.lesser(49)) return true;\n                }\n                function millerRabinTest(n, a) {\n                    var nPrev = n.prev(), b = nPrev, r = 0, d, t, i2, x;\n                    while(b.isEven())b = b.divide(2), r++;\n                    next: for(i2 = 0; i2 < a.length; i2++){\n                        if (n.lesser(a[i2])) continue;\n                        x = bigInt2(a[i2]).modPow(b, n);\n                        if (x.isUnit() || x.equals(nPrev)) continue;\n                        for(d = r - 1; d != 0; d--){\n                            x = x.square().mod(n);\n                            if (x.isUnit()) return false;\n                            if (x.equals(nPrev)) continue next;\n                        }\n                        return false;\n                    }\n                    return true;\n                }\n                BigInteger.prototype.isPrime = function(strict) {\n                    var isPrime = isBasicPrime(this);\n                    if (isPrime !== undefined2) return isPrime;\n                    var n = this.abs();\n                    var bits = n.bitLength();\n                    if (bits <= 64) return millerRabinTest(n, [\n                        2,\n                        3,\n                        5,\n                        7,\n                        11,\n                        13,\n                        17,\n                        19,\n                        23,\n                        29,\n                        31,\n                        37\n                    ]);\n                    var logN = Math.log(2) * bits.toJSNumber();\n                    var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);\n                    for(var a = [], i2 = 0; i2 < t; i2++)a.push(bigInt2(i2 + 2));\n                    return millerRabinTest(n, a);\n                };\n                NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\n                BigInteger.prototype.isProbablePrime = function(iterations, rng) {\n                    var isPrime = isBasicPrime(this);\n                    if (isPrime !== undefined2) return isPrime;\n                    var n = this.abs();\n                    var t = iterations === undefined2 ? 5 : iterations;\n                    for(var a = [], i2 = 0; i2 < t; i2++)a.push(bigInt2.randBetween(2, n.minus(2), rng));\n                    return millerRabinTest(n, a);\n                };\n                NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\n                BigInteger.prototype.modInv = function(n) {\n                    var t = bigInt2.zero, newT = bigInt2.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\n                    while(!newR.isZero()){\n                        q = r.divide(newR);\n                        lastT = t;\n                        lastR = r;\n                        t = newT;\n                        r = newR;\n                        newT = lastT.subtract(q.multiply(newT));\n                        newR = lastR.subtract(q.multiply(newR));\n                    }\n                    if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\n                    if (t.compare(0) === -1) t = t.add(n);\n                    if (this.isNegative()) return t.negate();\n                    return t;\n                };\n                NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\n                BigInteger.prototype.next = function() {\n                    var value = this.value;\n                    if (this.sign) return subtractSmall(value, 1, this.sign);\n                    return new BigInteger(addSmall(value, 1), this.sign);\n                };\n                SmallInteger.prototype.next = function() {\n                    var value = this.value;\n                    if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\n                    return new BigInteger(MAX_INT_ARR, false);\n                };\n                NativeBigInt.prototype.next = function() {\n                    return new NativeBigInt(this.value + BigInt(1));\n                };\n                BigInteger.prototype.prev = function() {\n                    var value = this.value;\n                    if (this.sign) return new BigInteger(addSmall(value, 1), true);\n                    return subtractSmall(value, 1, this.sign);\n                };\n                SmallInteger.prototype.prev = function() {\n                    var value = this.value;\n                    if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\n                    return new BigInteger(MAX_INT_ARR, true);\n                };\n                NativeBigInt.prototype.prev = function() {\n                    return new NativeBigInt(this.value - BigInt(1));\n                };\n                var powersOfTwo = [\n                    1\n                ];\n                while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\n                var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\n                function shift_isSmall(n) {\n                    return Math.abs(n) <= BASE;\n                }\n                BigInteger.prototype.shiftLeft = function(v) {\n                    var n = parseValue(v).toJSNumber();\n                    if (!shift_isSmall(n)) throw new Error(String(n) + \" is too large for shifting.\");\n                    if (n < 0) return this.shiftRight(-n);\n                    var result = this;\n                    if (result.isZero()) return result;\n                    while(n >= powers2Length){\n                        result = result.multiply(highestPower2);\n                        n -= powers2Length - 1;\n                    }\n                    return result.multiply(powersOfTwo[n]);\n                };\n                NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\n                BigInteger.prototype.shiftRight = function(v) {\n                    var remQuo;\n                    var n = parseValue(v).toJSNumber();\n                    if (!shift_isSmall(n)) throw new Error(String(n) + \" is too large for shifting.\");\n                    if (n < 0) return this.shiftLeft(-n);\n                    var result = this;\n                    while(n >= powers2Length){\n                        if (result.isZero() || result.isNegative() && result.isUnit()) return result;\n                        remQuo = divModAny(result, highestPower2);\n                        result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n                        n -= powers2Length - 1;\n                    }\n                    remQuo = divModAny(result, powersOfTwo[n]);\n                    return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n                };\n                NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\n                function bitwise(x, y, fn) {\n                    y = parseValue(y);\n                    var xSign = x.isNegative(), ySign = y.isNegative();\n                    var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;\n                    var xDigit = 0, yDigit = 0;\n                    var xDivMod = null, yDivMod = null;\n                    var result = [];\n                    while(!xRem.isZero() || !yRem.isZero()){\n                        xDivMod = divModAny(xRem, highestPower2);\n                        xDigit = xDivMod[1].toJSNumber();\n                        if (xSign) xDigit = highestPower2 - 1 - xDigit;\n                        yDivMod = divModAny(yRem, highestPower2);\n                        yDigit = yDivMod[1].toJSNumber();\n                        if (ySign) yDigit = highestPower2 - 1 - yDigit;\n                        xRem = xDivMod[0];\n                        yRem = yDivMod[0];\n                        result.push(fn(xDigit, yDigit));\n                    }\n                    var sum3 = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);\n                    for(var i2 = result.length - 1; i2 >= 0; i2 -= 1)sum3 = sum3.multiply(highestPower2).add(bigInt2(result[i2]));\n                    return sum3;\n                }\n                BigInteger.prototype.not = function() {\n                    return this.negate().prev();\n                };\n                NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\n                BigInteger.prototype.and = function(n) {\n                    return bitwise(this, n, function(a, b) {\n                        return a & b;\n                    });\n                };\n                NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\n                BigInteger.prototype.or = function(n) {\n                    return bitwise(this, n, function(a, b) {\n                        return a | b;\n                    });\n                };\n                NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\n                BigInteger.prototype.xor = function(n) {\n                    return bitwise(this, n, function(a, b) {\n                        return a ^ b;\n                    });\n                };\n                NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\n                var LOBMASK_I = 1073741824, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\n                function roughLOB(n) {\n                    var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;\n                    return x & -x;\n                }\n                function integerLogarithm(value, base) {\n                    if (base.compareTo(value) <= 0) {\n                        var tmp = integerLogarithm(value, base.square(base));\n                        var p = tmp.p;\n                        var e = tmp.e;\n                        var t = p.multiply(base);\n                        return t.compareTo(value) <= 0 ? {\n                            p: t,\n                            e: e * 2 + 1\n                        } : {\n                            p: p,\n                            e: e * 2\n                        };\n                    }\n                    return {\n                        p: bigInt2(1),\n                        e: 0\n                    };\n                }\n                BigInteger.prototype.bitLength = function() {\n                    var n = this;\n                    if (n.compareTo(bigInt2(0)) < 0) n = n.negate().subtract(bigInt2(1));\n                    if (n.compareTo(bigInt2(0)) === 0) return bigInt2(0);\n                    return bigInt2(integerLogarithm(n, bigInt2(2)).e).add(bigInt2(1));\n                };\n                NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\n                function max3(a, b) {\n                    a = parseValue(a);\n                    b = parseValue(b);\n                    return a.greater(b) ? a : b;\n                }\n                function min5(a, b) {\n                    a = parseValue(a);\n                    b = parseValue(b);\n                    return a.lesser(b) ? a : b;\n                }\n                function gcd(a, b) {\n                    a = parseValue(a).abs();\n                    b = parseValue(b).abs();\n                    if (a.equals(b)) return a;\n                    if (a.isZero()) return b;\n                    if (b.isZero()) return a;\n                    var c = Integer[1], d, t;\n                    while(a.isEven() && b.isEven()){\n                        d = min5(roughLOB(a), roughLOB(b));\n                        a = a.divide(d);\n                        b = b.divide(d);\n                        c = c.multiply(d);\n                    }\n                    while(a.isEven())a = a.divide(roughLOB(a));\n                    do {\n                        while(b.isEven())b = b.divide(roughLOB(b));\n                        if (a.greater(b)) {\n                            t = b;\n                            b = a;\n                            a = t;\n                        }\n                        b = b.subtract(a);\n                    }while (!b.isZero());\n                    return c.isUnit() ? a : a.multiply(c);\n                }\n                function lcm(a, b) {\n                    a = parseValue(a).abs();\n                    b = parseValue(b).abs();\n                    return a.divide(gcd(a, b)).multiply(b);\n                }\n                function randBetween(a, b, rng) {\n                    a = parseValue(a);\n                    b = parseValue(b);\n                    var usedRNG = rng || Math.random;\n                    var low = min5(a, b), high = max3(a, b);\n                    var range3 = high.subtract(low).add(1);\n                    if (range3.isSmall) return low.add(Math.floor(usedRNG() * range3));\n                    var digits = toBase2(range3, BASE).value;\n                    var result = [], restricted = true;\n                    for(var i2 = 0; i2 < digits.length; i2++){\n                        var top3 = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;\n                        var digit = truncate(usedRNG() * top3);\n                        result.push(digit);\n                        if (digit < digits[i2]) restricted = false;\n                    }\n                    return low.add(Integer.fromArray(result, BASE, false));\n                }\n                var parseBase = function(text, base, alphabet, caseSensitive) {\n                    alphabet = alphabet || DEFAULT_ALPHABET;\n                    text = String(text);\n                    if (!caseSensitive) {\n                        text = text.toLowerCase();\n                        alphabet = alphabet.toLowerCase();\n                    }\n                    var length4 = text.length;\n                    var i2;\n                    var absBase = Math.abs(base);\n                    var alphabetValues = {};\n                    for(i2 = 0; i2 < alphabet.length; i2++)alphabetValues[alphabet[i2]] = i2;\n                    for(i2 = 0; i2 < length4; i2++){\n                        var c = text[i2];\n                        if (c === \"-\") continue;\n                        if (c in alphabetValues) {\n                            if (alphabetValues[c] >= absBase) {\n                                if (c === \"1\" && absBase === 1) continue;\n                                throw new Error(c + \" is not a valid digit in base \" + base + \".\");\n                            }\n                        }\n                    }\n                    base = parseValue(base);\n                    var digits = [];\n                    var isNegative = text[0] === \"-\";\n                    for(i2 = isNegative ? 1 : 0; i2 < text.length; i2++){\n                        var c = text[i2];\n                        if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\n                        else if (c === \"<\") {\n                            var start = i2;\n                            do i2++;\n                            while (text[i2] !== \">\" && i2 < text.length);\n                            digits.push(parseValue(text.slice(start + 1, i2)));\n                        } else throw new Error(c + \" is not a valid character\");\n                    }\n                    return parseBaseFromArray(digits, base, isNegative);\n                };\n                function parseBaseFromArray(digits, base, isNegative) {\n                    var val = Integer[0], pow4 = Integer[1], i2;\n                    for(i2 = digits.length - 1; i2 >= 0; i2--){\n                        val = val.add(digits[i2].times(pow4));\n                        pow4 = pow4.times(base);\n                    }\n                    return isNegative ? val.negate() : val;\n                }\n                function stringify2(digit, alphabet) {\n                    alphabet = alphabet || DEFAULT_ALPHABET;\n                    if (digit < alphabet.length) return alphabet[digit];\n                    return \"<\" + digit + \">\";\n                }\n                function toBase2(n, base) {\n                    base = bigInt2(base);\n                    if (base.isZero()) {\n                        if (n.isZero()) return {\n                            value: [\n                                0\n                            ],\n                            isNegative: false\n                        };\n                        throw new Error(\"Cannot convert nonzero numbers to base 0.\");\n                    }\n                    if (base.equals(-1)) {\n                        if (n.isZero()) return {\n                            value: [\n                                0\n                            ],\n                            isNegative: false\n                        };\n                        if (n.isNegative()) return {\n                            value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [\n                                1,\n                                0\n                            ])),\n                            isNegative: false\n                        };\n                        var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [\n                            0,\n                            1\n                        ]);\n                        arr.unshift([\n                            1\n                        ]);\n                        return {\n                            value: [].concat.apply([], arr),\n                            isNegative: false\n                        };\n                    }\n                    var neg = false;\n                    if (n.isNegative() && base.isPositive()) {\n                        neg = true;\n                        n = n.abs();\n                    }\n                    if (base.isUnit()) {\n                        if (n.isZero()) return {\n                            value: [\n                                0\n                            ],\n                            isNegative: false\n                        };\n                        return {\n                            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),\n                            isNegative: neg\n                        };\n                    }\n                    var out = [];\n                    var left = n, divmod;\n                    while(left.isNegative() || left.compareAbs(base) >= 0){\n                        divmod = left.divmod(base);\n                        left = divmod.quotient;\n                        var digit = divmod.remainder;\n                        if (digit.isNegative()) {\n                            digit = base.minus(digit).abs();\n                            left = left.next();\n                        }\n                        out.push(digit.toJSNumber());\n                    }\n                    out.push(left.toJSNumber());\n                    return {\n                        value: out.reverse(),\n                        isNegative: neg\n                    };\n                }\n                function toBaseString(n, base, alphabet) {\n                    var arr = toBase2(n, base);\n                    return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function(x) {\n                        return stringify2(x, alphabet);\n                    }).join(\"\");\n                }\n                BigInteger.prototype.toArray = function(radix) {\n                    return toBase2(this, radix);\n                };\n                SmallInteger.prototype.toArray = function(radix) {\n                    return toBase2(this, radix);\n                };\n                NativeBigInt.prototype.toArray = function(radix) {\n                    return toBase2(this, radix);\n                };\n                BigInteger.prototype.toString = function(radix, alphabet) {\n                    if (radix === undefined2) radix = 10;\n                    if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);\n                    var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\n                    while(--l >= 0){\n                        digit = String(v[l]);\n                        str += zeros.slice(digit.length) + digit;\n                    }\n                    var sign2 = this.sign ? \"-\" : \"\";\n                    return sign2 + str;\n                };\n                SmallInteger.prototype.toString = function(radix, alphabet) {\n                    if (radix === undefined2) radix = 10;\n                    if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);\n                    return String(this.value);\n                };\n                NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\n                NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {\n                    return this.toString();\n                };\n                BigInteger.prototype.valueOf = function() {\n                    return parseInt(this.toString(), 10);\n                };\n                BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\n                SmallInteger.prototype.valueOf = function() {\n                    return this.value;\n                };\n                SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\n                NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {\n                    return parseInt(this.toString(), 10);\n                };\n                function parseStringValue(v) {\n                    if (isPrecise(+v)) {\n                        var x = +v;\n                        if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\n                        throw new Error(\"Invalid integer: \" + v);\n                    }\n                    var sign2 = v[0] === \"-\";\n                    if (sign2) v = v.slice(1);\n                    var split2 = v.split(/e/i);\n                    if (split2.length > 2) throw new Error(\"Invalid integer: \" + split2.join(\"e\"));\n                    if (split2.length === 2) {\n                        var exp2 = split2[1];\n                        if (exp2[0] === \"+\") exp2 = exp2.slice(1);\n                        exp2 = +exp2;\n                        if (exp2 !== truncate(exp2) || !isPrecise(exp2)) throw new Error(\"Invalid integer: \" + exp2 + \" is not a valid exponent.\");\n                        var text = split2[0];\n                        var decimalPlace = text.indexOf(\".\");\n                        if (decimalPlace >= 0) {\n                            exp2 -= text.length - decimalPlace - 1;\n                            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\n                        }\n                        if (exp2 < 0) throw new Error(\"Cannot include negative exponent part for integers\");\n                        text += new Array(exp2 + 1).join(\"0\");\n                        v = text;\n                    }\n                    var isValid = /^([0-9][0-9]*)$/.test(v);\n                    if (!isValid) throw new Error(\"Invalid integer: \" + v);\n                    if (supportsNativeBigInt) return new NativeBigInt(BigInt(sign2 ? \"-\" + v : v));\n                    var r = [], max4 = v.length, l = LOG_BASE, min6 = max4 - l;\n                    while(max4 > 0){\n                        r.push(+v.slice(min6, max4));\n                        min6 -= l;\n                        if (min6 < 0) min6 = 0;\n                        max4 -= l;\n                    }\n                    trim2(r);\n                    return new BigInteger(r, sign2);\n                }\n                function parseNumberValue(v) {\n                    if (supportsNativeBigInt) return new NativeBigInt(BigInt(v));\n                    if (isPrecise(v)) {\n                        if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\n                        return new SmallInteger(v);\n                    }\n                    return parseStringValue(v.toString());\n                }\n                function parseValue(v) {\n                    if (typeof v === \"number\") return parseNumberValue(v);\n                    if (typeof v === \"string\") return parseStringValue(v);\n                    if (typeof v === \"bigint\") return new NativeBigInt(v);\n                    return v;\n                }\n                for(var i = 0; i < 1e3; i++){\n                    Integer[i] = parseValue(i);\n                    if (i > 0) Integer[-i] = parseValue(-i);\n                }\n                Integer.one = Integer[1];\n                Integer.zero = Integer[0];\n                Integer.minusOne = Integer[-1];\n                Integer.max = max3;\n                Integer.min = min5;\n                Integer.gcd = gcd;\n                Integer.lcm = lcm;\n                Integer.isInstance = function(x) {\n                    return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;\n                };\n                Integer.randBetween = randBetween;\n                Integer.fromArray = function(digits, base, isNegative) {\n                    return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\n                };\n                return Integer;\n            }();\n            if (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) module.exports = bigInt2;\n            if (typeof define === \"function\" && define.amd) define(function() {\n                return bigInt2;\n            });\n        }\n    });\n    // output/Control.Bind/foreign.js\n    var arrayBind = function(arr) {\n        return function(f2) {\n            var result = [];\n            for(var i = 0, l = arr.length; i < l; i++)Array.prototype.push.apply(result, f2(arr[i]));\n            return result;\n        };\n    };\n    // output/Control.Apply/foreign.js\n    var arrayApply = function(fs) {\n        return function(xs) {\n            var l = fs.length;\n            var k = xs.length;\n            var result = new Array(l * k);\n            var n = 0;\n            for(var i = 0; i < l; i++){\n                var f2 = fs[i];\n                for(var j = 0; j < k; j++)result[n++] = f2(xs[j]);\n            }\n            return result;\n        };\n    };\n    // output/Control.Semigroupoid/index.js\n    var semigroupoidFn = {\n        compose: function(f2) {\n            return function(g) {\n                return function(x) {\n                    return f2(g(x));\n                };\n            };\n        }\n    };\n    var compose = function(dict) {\n        return dict.compose;\n    };\n    // output/Control.Category/index.js\n    var identity = function(dict) {\n        return dict.identity;\n    };\n    var categoryFn = {\n        identity: function(x) {\n            return x;\n        },\n        Semigroupoid0: function() {\n            return semigroupoidFn;\n        }\n    };\n    // output/Data.Boolean/index.js\n    var otherwise = true;\n    // output/Data.Function/index.js\n    var on = function(f2) {\n        return function(g) {\n            return function(x) {\n                return function(y) {\n                    return f2(g(x))(g(y));\n                };\n            };\n        };\n    };\n    var flip = function(f2) {\n        return function(b) {\n            return function(a) {\n                return f2(a)(b);\n            };\n        };\n    };\n    var $$const = function(a) {\n        return function(v) {\n            return a;\n        };\n    };\n    // output/Data.Functor/foreign.js\n    var arrayMap = function(f2) {\n        return function(arr) {\n            var l = arr.length;\n            var result = new Array(l);\n            for(var i = 0; i < l; i++)result[i] = f2(arr[i]);\n            return result;\n        };\n    };\n    // output/Data.Unit/foreign.js\n    var unit = void 0;\n    // output/Type.Proxy/index.js\n    var $$Proxy = /* @__PURE__ */ function() {\n        function $$Proxy2() {}\n        $$Proxy2.value = new $$Proxy2();\n        return $$Proxy2;\n    }();\n    // output/Data.Functor/index.js\n    var map = function(dict) {\n        return dict.map;\n    };\n    var mapFlipped = function(dictFunctor) {\n        var map12 = map(dictFunctor);\n        return function(fa) {\n            return function(f2) {\n                return map12(f2)(fa);\n            };\n        };\n    };\n    var $$void = function(dictFunctor) {\n        return map(dictFunctor)($$const(unit));\n    };\n    var functorFn = {\n        map: /* @__PURE__ */ compose(semigroupoidFn)\n    };\n    var functorArray = {\n        map: arrayMap\n    };\n    var flap = function(dictFunctor) {\n        var map12 = map(dictFunctor);\n        return function(ff2) {\n            return function(x) {\n                return map12(function(f2) {\n                    return f2(x);\n                })(ff2);\n            };\n        };\n    };\n    // output/Control.Apply/index.js\n    var applyArray = {\n        apply: arrayApply,\n        Functor0: function() {\n            return functorArray;\n        }\n    };\n    var apply = function(dict) {\n        return dict.apply;\n    };\n    // output/Control.Applicative/index.js\n    var pure = function(dict) {\n        return dict.pure;\n    };\n    var when = function(dictApplicative) {\n        var pure1 = pure(dictApplicative);\n        return function(v) {\n            return function(v1) {\n                if (v) return v1;\n                if (!v) return pure1(unit);\n                throw new Error(\"Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        };\n    };\n    var liftA1 = function(dictApplicative) {\n        var apply2 = apply(dictApplicative.Apply0());\n        var pure1 = pure(dictApplicative);\n        return function(f2) {\n            return function(a) {\n                return apply2(pure1(f2))(a);\n            };\n        };\n    };\n    var applicativeArray = {\n        pure: function(x) {\n            return [\n                x\n            ];\n        },\n        Apply0: function() {\n            return applyArray;\n        }\n    };\n    // output/Control.Bind/index.js\n    var bindArray = {\n        bind: arrayBind,\n        Apply0: function() {\n            return applyArray;\n        }\n    };\n    var bind = function(dict) {\n        return dict.bind;\n    };\n    var bindFlipped = function(dictBind) {\n        return flip(bind(dictBind));\n    };\n    var composeKleisliFlipped = function(dictBind) {\n        var bindFlipped1 = bindFlipped(dictBind);\n        return function(f2) {\n            return function(g) {\n                return function(a) {\n                    return bindFlipped1(f2)(g(a));\n                };\n            };\n        };\n    };\n    // output/Data.Argonaut.Core/foreign.js\n    function stringify(j) {\n        return JSON.stringify(j);\n    }\n    function _caseJson(isNull3, isBool, isNum, isStr, isArr, isObj, j) {\n        if (j == null) return isNull3();\n        else if (typeof j === \"boolean\") return isBool(j);\n        else if (typeof j === \"number\") return isNum(j);\n        else if (typeof j === \"string\") return isStr(j);\n        else if (Object.prototype.toString.call(j) === \"[object Array]\") return isArr(j);\n        else return isObj(j);\n    }\n    // output/Data.Eq/foreign.js\n    var refEq = function(r1) {\n        return function(r2) {\n            return r1 === r2;\n        };\n    };\n    var eqIntImpl = refEq;\n    var eqStringImpl = refEq;\n    var eqArrayImpl = function(f2) {\n        return function(xs) {\n            return function(ys) {\n                if (xs.length !== ys.length) return false;\n                for(var i = 0; i < xs.length; i++){\n                    if (!f2(xs[i])(ys[i])) return false;\n                }\n                return true;\n            };\n        };\n    };\n    // output/Data.Symbol/index.js\n    var reflectSymbol = function(dict) {\n        return dict.reflectSymbol;\n    };\n    // output/Record.Unsafe/foreign.js\n    var unsafeGet = function(label) {\n        return function(rec) {\n            return rec[label];\n        };\n    };\n    var unsafeSet = function(label) {\n        return function(value) {\n            return function(rec) {\n                var copy = {};\n                for(var key in rec)if (({}).hasOwnProperty.call(rec, key)) copy[key] = rec[key];\n                copy[label] = value;\n                return copy;\n            };\n        };\n    };\n    // output/Data.Eq/index.js\n    var eqString = {\n        eq: eqStringImpl\n    };\n    var eqRowNil = {\n        eqRecord: function(v) {\n            return function(v1) {\n                return function(v2) {\n                    return true;\n                };\n            };\n        }\n    };\n    var eqRecord = function(dict) {\n        return dict.eqRecord;\n    };\n    var eqRec = function() {\n        return function(dictEqRecord) {\n            return {\n                eq: eqRecord(dictEqRecord)($$Proxy.value)\n            };\n        };\n    };\n    var eqInt = {\n        eq: eqIntImpl\n    };\n    var eq = function(dict) {\n        return dict.eq;\n    };\n    var eqArray = function(dictEq) {\n        return {\n            eq: eqArrayImpl(eq(dictEq))\n        };\n    };\n    var eqRowCons = function(dictEqRecord) {\n        var eqRecord1 = eqRecord(dictEqRecord);\n        return function() {\n            return function(dictIsSymbol) {\n                var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n                return function(dictEq) {\n                    var eq32 = eq(dictEq);\n                    return {\n                        eqRecord: function(v) {\n                            return function(ra) {\n                                return function(rb) {\n                                    var tail2 = eqRecord1($$Proxy.value)(ra)(rb);\n                                    var key = reflectSymbol2($$Proxy.value);\n                                    var get2 = unsafeGet(key);\n                                    return eq32(get2(ra))(get2(rb)) && tail2;\n                                };\n                            };\n                        }\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Semigroup/foreign.js\n    var concatArray = function(xs) {\n        return function(ys) {\n            if (xs.length === 0) return ys;\n            if (ys.length === 0) return xs;\n            return xs.concat(ys);\n        };\n    };\n    // output/Data.Semigroup/index.js\n    var semigroupArray = {\n        append: concatArray\n    };\n    var append = function(dict) {\n        return dict.append;\n    };\n    // output/Control.Alt/index.js\n    var altArray = {\n        alt: /* @__PURE__ */ append(semigroupArray),\n        Functor0: function() {\n            return functorArray;\n        }\n    };\n    // output/Data.Bounded/foreign.js\n    var topInt = 2147483647;\n    var bottomInt = -2147483648;\n    var topChar = String.fromCharCode(65535);\n    var bottomChar = String.fromCharCode(0);\n    var topNumber = Number.POSITIVE_INFINITY;\n    var bottomNumber = Number.NEGATIVE_INFINITY;\n    // output/Data.Ord/foreign.js\n    var unsafeCompareImpl = function(lt) {\n        return function(eq4) {\n            return function(gt) {\n                return function(x) {\n                    return function(y) {\n                        return x < y ? lt : x === y ? eq4 : gt;\n                    };\n                };\n            };\n        };\n    };\n    var ordIntImpl = unsafeCompareImpl;\n    var ordStringImpl = unsafeCompareImpl;\n    // output/Data.Ordering/index.js\n    var LT = /* @__PURE__ */ function() {\n        function LT2() {}\n        LT2.value = new LT2();\n        return LT2;\n    }();\n    var GT = /* @__PURE__ */ function() {\n        function GT2() {}\n        GT2.value = new GT2();\n        return GT2;\n    }();\n    var EQ = /* @__PURE__ */ function() {\n        function EQ2() {}\n        EQ2.value = new EQ2();\n        return EQ2;\n    }();\n    var eqOrdering = {\n        eq: function(v) {\n            return function(v1) {\n                if (v instanceof LT && v1 instanceof LT) return true;\n                if (v instanceof GT && v1 instanceof GT) return true;\n                if (v instanceof EQ && v1 instanceof EQ) return true;\n                return false;\n            };\n        }\n    };\n    // output/Data.Semiring/foreign.js\n    var intAdd = function(x) {\n        return function(y) {\n            return x + y | 0;\n        };\n    };\n    var intMul = function(x) {\n        return function(y) {\n            return x * y | 0;\n        };\n    };\n    // output/Data.Semiring/index.js\n    var zero = function(dict) {\n        return dict.zero;\n    };\n    var semiringInt = {\n        add: intAdd,\n        zero: 0,\n        mul: intMul,\n        one: 1\n    };\n    var one = function(dict) {\n        return dict.one;\n    };\n    var mul = function(dict) {\n        return dict.mul;\n    };\n    var add = function(dict) {\n        return dict.add;\n    };\n    // output/Data.Ring/index.js\n    var sub = function(dict) {\n        return dict.sub;\n    };\n    // output/Data.Ord/index.js\n    var ordString = /* @__PURE__ */ function() {\n        return {\n            compare: ordStringImpl(LT.value)(EQ.value)(GT.value),\n            Eq0: function() {\n                return eqString;\n            }\n        };\n    }();\n    var ordInt = /* @__PURE__ */ function() {\n        return {\n            compare: ordIntImpl(LT.value)(EQ.value)(GT.value),\n            Eq0: function() {\n                return eqInt;\n            }\n        };\n    }();\n    var compare = function(dict) {\n        return dict.compare;\n    };\n    var comparing = function(dictOrd) {\n        var compare32 = compare(dictOrd);\n        return function(f2) {\n            return function(x) {\n                return function(y) {\n                    return compare32(f2(x))(f2(y));\n                };\n            };\n        };\n    };\n    var greaterThanOrEq = function(dictOrd) {\n        var compare32 = compare(dictOrd);\n        return function(a1) {\n            return function(a2) {\n                var v = compare32(a1)(a2);\n                if (v instanceof LT) return false;\n                return true;\n            };\n        };\n    };\n    var min = function(dictOrd) {\n        var compare32 = compare(dictOrd);\n        return function(x) {\n            return function(y) {\n                var v = compare32(x)(y);\n                if (v instanceof LT) return x;\n                if (v instanceof EQ) return x;\n                if (v instanceof GT) return y;\n                throw new Error(\"Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): \" + [\n                    v.constructor.name\n                ]);\n            };\n        };\n    };\n    // output/Data.Bounded/index.js\n    var top = function(dict) {\n        return dict.top;\n    };\n    var boundedInt = {\n        top: topInt,\n        bottom: bottomInt,\n        Ord0: function() {\n            return ordInt;\n        }\n    };\n    var bottom = function(dict) {\n        return dict.bottom;\n    };\n    // output/Data.Show/foreign.js\n    var showIntImpl = function(n) {\n        return n.toString();\n    };\n    // output/Data.Show/index.js\n    var showInt = {\n        show: showIntImpl\n    };\n    var show = function(dict) {\n        return dict.show;\n    };\n    // output/Data.Maybe/index.js\n    var identity2 = /* @__PURE__ */ identity(categoryFn);\n    var Nothing = /* @__PURE__ */ function() {\n        function Nothing2() {}\n        Nothing2.value = new Nothing2();\n        return Nothing2;\n    }();\n    var Just = /* @__PURE__ */ function() {\n        function Just2(value0) {\n            this.value0 = value0;\n        }\n        Just2.create = function(value0) {\n            return new Just2(value0);\n        };\n        return Just2;\n    }();\n    var maybe$prime = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v2 instanceof Nothing) return v(unit);\n                if (v2 instanceof Just) return v1(v2.value0);\n                throw new Error(\"Failed pattern match at Data.Maybe (line 250, column 1 - line 250, column 62): \" + [\n                    v.constructor.name,\n                    v1.constructor.name,\n                    v2.constructor.name\n                ]);\n            };\n        };\n    };\n    var maybe = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v2 instanceof Nothing) return v;\n                if (v2 instanceof Just) return v1(v2.value0);\n                throw new Error(\"Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): \" + [\n                    v.constructor.name,\n                    v1.constructor.name,\n                    v2.constructor.name\n                ]);\n            };\n        };\n    };\n    var functorMaybe = {\n        map: function(v) {\n            return function(v1) {\n                if (v1 instanceof Just) return new Just(v(v1.value0));\n                return Nothing.value;\n            };\n        }\n    };\n    var map2 = /* @__PURE__ */ map(functorMaybe);\n    var fromMaybe = function(a) {\n        return maybe(a)(identity2);\n    };\n    var fromJust = function() {\n        return function(v) {\n            if (v instanceof Just) return v.value0;\n            throw new Error(\"Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): \" + [\n                v.constructor.name\n            ]);\n        };\n    };\n    var applyMaybe = {\n        apply: function(v) {\n            return function(v1) {\n                if (v instanceof Just) return map2(v.value0)(v1);\n                if (v instanceof Nothing) return Nothing.value;\n                throw new Error(\"Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        },\n        Functor0: function() {\n            return functorMaybe;\n        }\n    };\n    var bindMaybe = {\n        bind: function(v) {\n            return function(v1) {\n                if (v instanceof Just) return v1(v.value0);\n                if (v instanceof Nothing) return Nothing.value;\n                throw new Error(\"Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        },\n        Apply0: function() {\n            return applyMaybe;\n        }\n    };\n    // output/Foreign.Object/foreign.js\n    function _lookup(no, yes, k, m) {\n        return k in m ? yes(m[k]) : no;\n    }\n    function toArrayWithKey(f2) {\n        return function(m) {\n            var r = [];\n            for(var k in m)if (hasOwnProperty.call(m, k)) r.push(f2(k)(m[k]));\n            return r;\n        };\n    }\n    var keys = Object.keys || toArrayWithKey(function(k) {\n        return function() {\n            return k;\n        };\n    });\n    // output/Control.Monad.ST.Internal/foreign.js\n    var map_ = function(f2) {\n        return function(a) {\n            return function() {\n                return f2(a());\n            };\n        };\n    };\n    var pure_ = function(a) {\n        return function() {\n            return a;\n        };\n    };\n    var bind_ = function(a) {\n        return function(f2) {\n            return function() {\n                return f2(a())();\n            };\n        };\n    };\n    var foreach = function(as) {\n        return function(f2) {\n            return function() {\n                for(var i = 0, l = as.length; i < l; i++)f2(as[i])();\n            };\n        };\n    };\n    function newSTRef(val) {\n        return function() {\n            return {\n                value: val\n            };\n        };\n    }\n    var read = function(ref) {\n        return function() {\n            return ref.value;\n        };\n    };\n    var modifyImpl = function(f2) {\n        return function(ref) {\n            return function() {\n                var t = f2(ref.value);\n                ref.value = t.state;\n                return t.value;\n            };\n        };\n    };\n    var write = function(a) {\n        return function(ref) {\n            return function() {\n                return ref.value = a;\n            };\n        };\n    };\n    // output/Control.Monad/index.js\n    var ap = function(dictMonad) {\n        var bind5 = bind(dictMonad.Bind1());\n        var pure3 = pure(dictMonad.Applicative0());\n        return function(f2) {\n            return function(a) {\n                return bind5(f2)(function(f$prime) {\n                    return bind5(a)(function(a$prime) {\n                        return pure3(f$prime(a$prime));\n                    });\n                });\n            };\n        };\n    };\n    // output/Data.Either/index.js\n    var Left = /* @__PURE__ */ function() {\n        function Left2(value0) {\n            this.value0 = value0;\n        }\n        Left2.create = function(value0) {\n            return new Left2(value0);\n        };\n        return Left2;\n    }();\n    var Right = /* @__PURE__ */ function() {\n        function Right2(value0) {\n            this.value0 = value0;\n        }\n        Right2.create = function(value0) {\n            return new Right2(value0);\n        };\n        return Right2;\n    }();\n    var note = function(a) {\n        return maybe(new Left(a))(Right.create);\n    };\n    var functorEither = {\n        map: function(f2) {\n            return function(m) {\n                if (m instanceof Left) return new Left(m.value0);\n                if (m instanceof Right) return new Right(f2(m.value0));\n                throw new Error(\"Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): \" + [\n                    m.constructor.name\n                ]);\n            };\n        }\n    };\n    var map3 = /* @__PURE__ */ map(functorEither);\n    var either = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v2 instanceof Left) return v(v2.value0);\n                if (v2 instanceof Right) return v1(v2.value0);\n                throw new Error(\"Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): \" + [\n                    v.constructor.name,\n                    v1.constructor.name,\n                    v2.constructor.name\n                ]);\n            };\n        };\n    };\n    var applyEither = {\n        apply: function(v) {\n            return function(v1) {\n                if (v instanceof Left) return new Left(v.value0);\n                if (v instanceof Right) return map3(v.value0)(v1);\n                throw new Error(\"Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        },\n        Functor0: function() {\n            return functorEither;\n        }\n    };\n    var bindEither = {\n        bind: /* @__PURE__ */ either(function(e) {\n            return function(v) {\n                return new Left(e);\n            };\n        })(function(a) {\n            return function(f2) {\n                return f2(a);\n            };\n        }),\n        Apply0: function() {\n            return applyEither;\n        }\n    };\n    var applicativeEither = /* @__PURE__ */ function() {\n        return {\n            pure: Right.create,\n            Apply0: function() {\n                return applyEither;\n            }\n        };\n    }();\n    // output/Data.EuclideanRing/index.js\n    var mod = function(dict) {\n        return dict.mod;\n    };\n    var div = function(dict) {\n        return dict.div;\n    };\n    // output/Data.Monoid/index.js\n    var monoidArray = {\n        mempty: [],\n        Semigroup0: function() {\n            return semigroupArray;\n        }\n    };\n    var mempty = function(dict) {\n        return dict.mempty;\n    };\n    // output/Effect/foreign.js\n    var pureE = function(a) {\n        return function() {\n            return a;\n        };\n    };\n    var bindE = function(a) {\n        return function(f2) {\n            return function() {\n                return f2(a())();\n            };\n        };\n    };\n    // output/Effect/index.js\n    var $runtime_lazy = function(name2, moduleName, init3) {\n        var state2 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state2 === 2) return val;\n            if (state2 === 1) throw new ReferenceError(name2 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state2 = 1;\n            val = init3();\n            state2 = 2;\n            return val;\n        };\n    };\n    var monadEffect = {\n        Applicative0: function() {\n            return applicativeEffect;\n        },\n        Bind1: function() {\n            return bindEffect;\n        }\n    };\n    var bindEffect = {\n        bind: bindE,\n        Apply0: function() {\n            return $lazy_applyEffect(0);\n        }\n    };\n    var applicativeEffect = {\n        pure: pureE,\n        Apply0: function() {\n            return $lazy_applyEffect(0);\n        }\n    };\n    var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy(\"functorEffect\", \"Effect\", function() {\n        return {\n            map: liftA1(applicativeEffect)\n        };\n    });\n    var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy(\"applyEffect\", \"Effect\", function() {\n        return {\n            apply: ap(monadEffect),\n            Functor0: function() {\n                return $lazy_functorEffect(0);\n            }\n        };\n    });\n    // output/Control.Monad.ST.Internal/index.js\n    var $runtime_lazy2 = function(name2, moduleName, init3) {\n        var state2 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state2 === 2) return val;\n            if (state2 === 1) throw new ReferenceError(name2 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state2 = 1;\n            val = init3();\n            state2 = 2;\n            return val;\n        };\n    };\n    var modify$prime = modifyImpl;\n    var modify = function(f2) {\n        return modify$prime(function(s) {\n            var s$prime = f2(s);\n            return {\n                state: s$prime,\n                value: s$prime\n            };\n        });\n    };\n    var functorST = {\n        map: map_\n    };\n    var monadST = {\n        Applicative0: function() {\n            return applicativeST;\n        },\n        Bind1: function() {\n            return bindST;\n        }\n    };\n    var bindST = {\n        bind: bind_,\n        Apply0: function() {\n            return $lazy_applyST(0);\n        }\n    };\n    var applicativeST = {\n        pure: pure_,\n        Apply0: function() {\n            return $lazy_applyST(0);\n        }\n    };\n    var $lazy_applyST = /* @__PURE__ */ $runtime_lazy2(\"applyST\", \"Control.Monad.ST.Internal\", function() {\n        return {\n            apply: ap(monadST),\n            Functor0: function() {\n                return functorST;\n            }\n        };\n    });\n    // output/Data.Array/foreign.js\n    var rangeImpl = function(start, end) {\n        var step = start > end ? -1 : 1;\n        var result = new Array(step * (end - start) + 1);\n        var i = start, n = 0;\n        while(i !== end){\n            result[n++] = i;\n            i += step;\n        }\n        result[n] = i;\n        return result;\n    };\n    var replicateFill = function(count, value) {\n        if (count < 1) return [];\n        var result = new Array(count);\n        return result.fill(value);\n    };\n    var replicatePolyfill = function(count, value) {\n        var result = [];\n        var n = 0;\n        for(var i = 0; i < count; i++)result[n++] = value;\n        return result;\n    };\n    var replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n    var fromFoldableImpl = /* @__PURE__ */ function() {\n        function Cons2(head3, tail2) {\n            this.head = head3;\n            this.tail = tail2;\n        }\n        var emptyList = {};\n        function curryCons(head3) {\n            return function(tail2) {\n                return new Cons2(head3, tail2);\n            };\n        }\n        function listToArray(list) {\n            var result = [];\n            var count = 0;\n            var xs = list;\n            while(xs !== emptyList){\n                result[count++] = xs.head;\n                xs = xs.tail;\n            }\n            return result;\n        }\n        return function(foldr3, xs) {\n            return listToArray(foldr3(curryCons)(emptyList)(xs));\n        };\n    }();\n    var length = function(xs) {\n        return xs.length;\n    };\n    var unconsImpl = function(empty5, next2, xs) {\n        return xs.length === 0 ? empty5({}) : next2(xs[0])(xs.slice(1));\n    };\n    var indexImpl = function(just, nothing, xs, i) {\n        return i < 0 || i >= xs.length ? nothing : just(xs[i]);\n    };\n    var findIndexImpl = function(just, nothing, f2, xs) {\n        for(var i = 0, l = xs.length; i < l; i++){\n            if (f2(xs[i])) return just(i);\n        }\n        return nothing;\n    };\n    var _insertAt = function(just, nothing, i, a, l) {\n        if (i < 0 || i > l.length) return nothing;\n        var l1 = l.slice();\n        l1.splice(i, 0, a);\n        return just(l1);\n    };\n    var _deleteAt = function(just, nothing, i, l) {\n        if (i < 0 || i >= l.length) return nothing;\n        var l1 = l.slice();\n        l1.splice(i, 1);\n        return just(l1);\n    };\n    var concat = function(xss) {\n        if (xss.length <= 1e4) return Array.prototype.concat.apply([], xss);\n        var result = [];\n        for(var i = 0, l = xss.length; i < l; i++){\n            var xs = xss[i];\n            for(var j = 0, m = xs.length; j < m; j++)result.push(xs[j]);\n        }\n        return result;\n    };\n    var filterImpl = function(f2, xs) {\n        return xs.filter(f2);\n    };\n    var sortByImpl = /* @__PURE__ */ function() {\n        function mergeFromTo(compare5, fromOrdering, xs1, xs2, from2, to) {\n            var mid;\n            var i;\n            var j;\n            var k;\n            var x;\n            var y;\n            var c;\n            mid = from2 + (to - from2 >> 1);\n            if (mid - from2 > 1) mergeFromTo(compare5, fromOrdering, xs2, xs1, from2, mid);\n            if (to - mid > 1) mergeFromTo(compare5, fromOrdering, xs2, xs1, mid, to);\n            i = from2;\n            j = mid;\n            k = from2;\n            while(i < mid && j < to){\n                x = xs2[i];\n                y = xs2[j];\n                c = fromOrdering(compare5(x)(y));\n                if (c > 0) {\n                    xs1[k++] = y;\n                    ++j;\n                } else {\n                    xs1[k++] = x;\n                    ++i;\n                }\n            }\n            while(i < mid)xs1[k++] = xs2[i++];\n            while(j < to)xs1[k++] = xs2[j++];\n        }\n        return function(compare5, fromOrdering, xs) {\n            var out;\n            if (xs.length < 2) return xs;\n            out = xs.slice(0);\n            mergeFromTo(compare5, fromOrdering, out, xs.slice(0), 0, xs.length);\n            return out;\n        };\n    }();\n    var sliceImpl = function(s, e, l) {\n        return l.slice(s, e);\n    };\n    var zipWithImpl = function(f2, xs, ys) {\n        var l = xs.length < ys.length ? xs.length : ys.length;\n        var result = new Array(l);\n        for(var i = 0; i < l; i++)result[i] = f2(xs[i])(ys[i]);\n        return result;\n    };\n    var anyImpl = function(p, xs) {\n        var len = xs.length;\n        for(var i = 0; i < len; i++){\n            if (p(xs[i])) return true;\n        }\n        return false;\n    };\n    var allImpl = function(p, xs) {\n        var len = xs.length;\n        for(var i = 0; i < len; i++){\n            if (!p(xs[i])) return false;\n        }\n        return true;\n    };\n    var unsafeIndexImpl = function(xs, n) {\n        return xs[n];\n    };\n    // output/Data.Array.ST/foreign.js\n    function newSTArray() {\n        return [];\n    }\n    function unsafeFreezeThawImpl(xs) {\n        return xs;\n    }\n    var unsafeFreezeImpl = unsafeFreezeThawImpl;\n    var pushImpl = function(a, xs) {\n        return xs.push(a);\n    };\n    // output/Control.Monad.ST.Uncurried/foreign.js\n    var runSTFn1 = function runSTFn12(fn) {\n        return function(a) {\n            return function() {\n                return fn(a);\n            };\n        };\n    };\n    var runSTFn2 = function runSTFn22(fn) {\n        return function(a) {\n            return function(b) {\n                return function() {\n                    return fn(a, b);\n                };\n            };\n        };\n    };\n    // output/Data.Array.ST/index.js\n    var unsafeFreeze = /* @__PURE__ */ runSTFn1(unsafeFreezeImpl);\n    var push = /* @__PURE__ */ runSTFn2(pushImpl);\n    // output/Data.HeytingAlgebra/foreign.js\n    var boolConj = function(b1) {\n        return function(b2) {\n            return b1 && b2;\n        };\n    };\n    var boolDisj = function(b1) {\n        return function(b2) {\n            return b1 || b2;\n        };\n    };\n    var boolNot = function(b) {\n        return !b;\n    };\n    // output/Data.HeytingAlgebra/index.js\n    var tt = function(dict) {\n        return dict.tt;\n    };\n    var not = function(dict) {\n        return dict.not;\n    };\n    var disj = function(dict) {\n        return dict.disj;\n    };\n    var heytingAlgebraBoolean = {\n        ff: false,\n        tt: true,\n        implies: function(a) {\n            return function(b) {\n                return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);\n            };\n        },\n        conj: boolConj,\n        disj: boolDisj,\n        not: boolNot\n    };\n    var conj = function(dict) {\n        return dict.conj;\n    };\n    // output/Data.Array.ST.Iterator/index.js\n    var map4 = /* @__PURE__ */ map(functorST);\n    var not2 = /* @__PURE__ */ not(heytingAlgebraBoolean);\n    var $$void2 = /* @__PURE__ */ $$void(functorST);\n    var Iterator = /* @__PURE__ */ function() {\n        function Iterator2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Iterator2.create = function(value0) {\n            return function(value1) {\n                return new Iterator2(value0, value1);\n            };\n        };\n        return Iterator2;\n    }();\n    var peek = function(v) {\n        return function __do() {\n            var i = read(v.value1)();\n            return v.value0(i);\n        };\n    };\n    var next = function(v) {\n        return function __do() {\n            var i = read(v.value1)();\n            modify(function(v1) {\n                return v1 + 1 | 0;\n            })(v.value1)();\n            return v.value0(i);\n        };\n    };\n    var pushWhile = function(p) {\n        return function(iter) {\n            return function(array) {\n                return function __do() {\n                    var $$break = newSTRef(false)();\n                    while(map4(not2)(read($$break))())(function __do2() {\n                        var mx = peek(iter)();\n                        if (mx instanceof Just && p(mx.value0)) {\n                            push(mx.value0)(array)();\n                            return $$void2(next(iter))();\n                        }\n                        return $$void2(write(true)($$break))();\n                    })();\n                    return {};\n                };\n            };\n        };\n    };\n    var iterator = function(f2) {\n        return map4(Iterator.create(f2))(newSTRef(0));\n    };\n    var iterate = function(iter) {\n        return function(f2) {\n            return function __do() {\n                var $$break = newSTRef(false)();\n                while(map4(not2)(read($$break))())(function __do2() {\n                    var mx = next(iter)();\n                    if (mx instanceof Just) return f2(mx.value0)();\n                    if (mx instanceof Nothing) return $$void2(write(true)($$break))();\n                    throw new Error(\"Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): \" + [\n                        mx.constructor.name\n                    ]);\n                })();\n                return {};\n            };\n        };\n    };\n    // output/Data.Foldable/foreign.js\n    var foldrArray = function(f2) {\n        return function(init3) {\n            return function(xs) {\n                var acc = init3;\n                var len = xs.length;\n                for(var i = len - 1; i >= 0; i--)acc = f2(xs[i])(acc);\n                return acc;\n            };\n        };\n    };\n    var foldlArray = function(f2) {\n        return function(init3) {\n            return function(xs) {\n                var acc = init3;\n                var len = xs.length;\n                for(var i = 0; i < len; i++)acc = f2(acc)(xs[i]);\n                return acc;\n            };\n        };\n    };\n    // output/Control.Plus/index.js\n    var plusArray = {\n        empty: [],\n        Alt0: function() {\n            return altArray;\n        }\n    };\n    var empty = function(dict) {\n        return dict.empty;\n    };\n    // output/Data.Tuple/index.js\n    var Tuple = /* @__PURE__ */ function() {\n        function Tuple2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Tuple2.create = function(value0) {\n            return function(value1) {\n                return new Tuple2(value0, value1);\n            };\n        };\n        return Tuple2;\n    }();\n    // output/Data.Bifunctor/index.js\n    var identity3 = /* @__PURE__ */ identity(categoryFn);\n    var bimap = function(dict) {\n        return dict.bimap;\n    };\n    var lmap = function(dictBifunctor) {\n        var bimap1 = bimap(dictBifunctor);\n        return function(f2) {\n            return bimap1(f2)(identity3);\n        };\n    };\n    var bifunctorEither = {\n        bimap: function(v) {\n            return function(v1) {\n                return function(v2) {\n                    if (v2 instanceof Left) return new Left(v(v2.value0));\n                    if (v2 instanceof Right) return new Right(v1(v2.value0));\n                    throw new Error(\"Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): \" + [\n                        v.constructor.name,\n                        v1.constructor.name,\n                        v2.constructor.name\n                    ]);\n                };\n            };\n        }\n    };\n    // output/Data.Monoid.Conj/index.js\n    var Conj = function(x) {\n        return x;\n    };\n    var semigroupConj = function(dictHeytingAlgebra) {\n        var conj2 = conj(dictHeytingAlgebra);\n        return {\n            append: function(v) {\n                return function(v1) {\n                    return conj2(v)(v1);\n                };\n            }\n        };\n    };\n    var monoidConj = function(dictHeytingAlgebra) {\n        var semigroupConj1 = semigroupConj(dictHeytingAlgebra);\n        return {\n            mempty: tt(dictHeytingAlgebra),\n            Semigroup0: function() {\n                return semigroupConj1;\n            }\n        };\n    };\n    // output/Unsafe.Coerce/foreign.js\n    var unsafeCoerce2 = function(x) {\n        return x;\n    };\n    // output/Safe.Coerce/index.js\n    var coerce = function() {\n        return unsafeCoerce2;\n    };\n    // output/Data.Newtype/index.js\n    var coerce2 = /* @__PURE__ */ coerce();\n    var alaF = function() {\n        return function() {\n            return function() {\n                return function() {\n                    return function(v) {\n                        return coerce2;\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Foldable/index.js\n    var identity4 = /* @__PURE__ */ identity(categoryFn);\n    var eq12 = /* @__PURE__ */ eq(eqOrdering);\n    var alaF2 = /* @__PURE__ */ alaF()()()();\n    var foldr = function(dict) {\n        return dict.foldr;\n    };\n    var foldl = function(dict) {\n        return dict.foldl;\n    };\n    var maximumBy = function(dictFoldable) {\n        var foldl22 = foldl(dictFoldable);\n        return function(cmp) {\n            var max$prime = function(v) {\n                return function(v1) {\n                    if (v instanceof Nothing) return new Just(v1);\n                    if (v instanceof Just) return new Just(function() {\n                        var $303 = eq12(cmp(v.value0)(v1))(GT.value);\n                        if ($303) return v.value0;\n                        return v1;\n                    }());\n                    throw new Error(\"Failed pattern match at Data.Foldable (line 441, column 3 - line 441, column 27): \" + [\n                        v.constructor.name,\n                        v1.constructor.name\n                    ]);\n                };\n            };\n            return foldl22(max$prime)(Nothing.value);\n        };\n    };\n    var maximum = function(dictOrd) {\n        var compare5 = compare(dictOrd);\n        return function(dictFoldable) {\n            return maximumBy(dictFoldable)(compare5);\n        };\n    };\n    var product = function(dictFoldable) {\n        var foldl22 = foldl(dictFoldable);\n        return function(dictSemiring) {\n            return foldl22(mul(dictSemiring))(one(dictSemiring));\n        };\n    };\n    var sum = function(dictFoldable) {\n        var foldl22 = foldl(dictFoldable);\n        return function(dictSemiring) {\n            return foldl22(add(dictSemiring))(zero(dictSemiring));\n        };\n    };\n    var foldableMaybe = {\n        foldr: function(v) {\n            return function(v1) {\n                return function(v2) {\n                    if (v2 instanceof Nothing) return v1;\n                    if (v2 instanceof Just) return v(v2.value0)(v1);\n                    throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [\n                        v.constructor.name,\n                        v1.constructor.name,\n                        v2.constructor.name\n                    ]);\n                };\n            };\n        },\n        foldl: function(v) {\n            return function(v1) {\n                return function(v2) {\n                    if (v2 instanceof Nothing) return v1;\n                    if (v2 instanceof Just) return v(v1)(v2.value0);\n                    throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [\n                        v.constructor.name,\n                        v1.constructor.name,\n                        v2.constructor.name\n                    ]);\n                };\n            };\n        },\n        foldMap: function(dictMonoid) {\n            var mempty2 = mempty(dictMonoid);\n            return function(v) {\n                return function(v1) {\n                    if (v1 instanceof Nothing) return mempty2;\n                    if (v1 instanceof Just) return v(v1.value0);\n                    throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [\n                        v.constructor.name,\n                        v1.constructor.name\n                    ]);\n                };\n            };\n        }\n    };\n    var foldMapDefaultR = function(dictFoldable) {\n        var foldr22 = foldr(dictFoldable);\n        return function(dictMonoid) {\n            var append5 = append(dictMonoid.Semigroup0());\n            var mempty2 = mempty(dictMonoid);\n            return function(f2) {\n                return foldr22(function(x) {\n                    return function(acc) {\n                        return append5(f2(x))(acc);\n                    };\n                })(mempty2);\n            };\n        };\n    };\n    var foldableArray = {\n        foldr: foldrArray,\n        foldl: foldlArray,\n        foldMap: function(dictMonoid) {\n            return foldMapDefaultR(foldableArray)(dictMonoid);\n        }\n    };\n    var foldMap = function(dict) {\n        return dict.foldMap;\n    };\n    var fold = function(dictFoldable) {\n        var foldMap22 = foldMap(dictFoldable);\n        return function(dictMonoid) {\n            return foldMap22(dictMonoid)(identity4);\n        };\n    };\n    var all = function(dictFoldable) {\n        var foldMap22 = foldMap(dictFoldable);\n        return function(dictHeytingAlgebra) {\n            return alaF2(Conj)(foldMap22(monoidConj(dictHeytingAlgebra)));\n        };\n    };\n    var and = function(dictFoldable) {\n        var all1 = all(dictFoldable);\n        return function(dictHeytingAlgebra) {\n            return all1(dictHeytingAlgebra)(identity4);\n        };\n    };\n    // output/Data.Function.Uncurried/foreign.js\n    var runFn2 = function(fn) {\n        return function(a) {\n            return function(b) {\n                return fn(a, b);\n            };\n        };\n    };\n    var runFn3 = function(fn) {\n        return function(a) {\n            return function(b) {\n                return function(c) {\n                    return fn(a, b, c);\n                };\n            };\n        };\n    };\n    var runFn4 = function(fn) {\n        return function(a) {\n            return function(b) {\n                return function(c) {\n                    return function(d) {\n                        return fn(a, b, c, d);\n                    };\n                };\n            };\n        };\n    };\n    var runFn5 = function(fn) {\n        return function(a) {\n            return function(b) {\n                return function(c) {\n                    return function(d) {\n                        return function(e) {\n                            return fn(a, b, c, d, e);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.FunctorWithIndex/foreign.js\n    var mapWithIndexArray = function(f2) {\n        return function(xs) {\n            var l = xs.length;\n            var result = Array(l);\n            for(var i = 0; i < l; i++)result[i] = f2(i)(xs[i]);\n            return result;\n        };\n    };\n    // output/Data.Monoid.Additive/index.js\n    var Additive = function(x) {\n        return x;\n    };\n    var semigroupAdditive = function(dictSemiring) {\n        var add4 = add(dictSemiring);\n        return {\n            append: function(v) {\n                return function(v1) {\n                    return add4(v)(v1);\n                };\n            }\n        };\n    };\n    var monoidAdditive = function(dictSemiring) {\n        var semigroupAdditive1 = semigroupAdditive(dictSemiring);\n        return {\n            mempty: zero(dictSemiring),\n            Semigroup0: function() {\n                return semigroupAdditive1;\n            }\n        };\n    };\n    // output/Data.FunctorWithIndex/index.js\n    var mapWithIndex = function(dict) {\n        return dict.mapWithIndex;\n    };\n    var functorWithIndexArray = {\n        mapWithIndex: mapWithIndexArray,\n        Functor0: function() {\n            return functorArray;\n        }\n    };\n    // output/Data.Traversable/foreign.js\n    var traverseArrayImpl = /* @__PURE__ */ function() {\n        function array1(a) {\n            return [\n                a\n            ];\n        }\n        function array2(a) {\n            return function(b) {\n                return [\n                    a,\n                    b\n                ];\n            };\n        }\n        function array3(a) {\n            return function(b) {\n                return function(c) {\n                    return [\n                        a,\n                        b,\n                        c\n                    ];\n                };\n            };\n        }\n        function concat2(xs) {\n            return function(ys) {\n                return xs.concat(ys);\n            };\n        }\n        return function(apply2) {\n            return function(map10) {\n                return function(pure3) {\n                    return function(f2) {\n                        return function(array) {\n                            function go(bot, top3) {\n                                switch(top3 - bot){\n                                    case 0:\n                                        return pure3([]);\n                                    case 1:\n                                        return map10(array1)(f2(array[bot]));\n                                    case 2:\n                                        return apply2(map10(array2)(f2(array[bot])))(f2(array[bot + 1]));\n                                    case 3:\n                                        return apply2(apply2(map10(array3)(f2(array[bot])))(f2(array[bot + 1])))(f2(array[bot + 2]));\n                                    default:\n                                        var pivot = bot + Math.floor((top3 - bot) / 4) * 2;\n                                        return apply2(map10(concat2)(go(bot, pivot)))(go(pivot, top3));\n                                }\n                            }\n                            return go(0, array.length);\n                        };\n                    };\n                };\n            };\n        };\n    }();\n    // output/Data.Traversable/index.js\n    var identity5 = /* @__PURE__ */ identity(categoryFn);\n    var traverse = function(dict) {\n        return dict.traverse;\n    };\n    var sequenceDefault = function(dictTraversable) {\n        var traverse2 = traverse(dictTraversable);\n        return function(dictApplicative) {\n            return traverse2(dictApplicative)(identity5);\n        };\n    };\n    var traversableArray = {\n        traverse: function(dictApplicative) {\n            var Apply0 = dictApplicative.Apply0();\n            return traverseArrayImpl(apply(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));\n        },\n        sequence: function(dictApplicative) {\n            return sequenceDefault(traversableArray)(dictApplicative);\n        },\n        Functor0: function() {\n            return functorArray;\n        },\n        Foldable1: function() {\n            return foldableArray;\n        }\n    };\n    var sequence = function(dict) {\n        return dict.sequence;\n    };\n    // output/Data.Semigroup.Foldable/index.js\n    var foldl1 = function(dict) {\n        return dict.foldl1;\n    };\n    var foldMap1DefaultL = function(dictFoldable1) {\n        var foldl11 = foldl1(dictFoldable1);\n        return function(dictFunctor) {\n            var map10 = map(dictFunctor);\n            return function(dictSemigroup) {\n                var append5 = append(dictSemigroup);\n                return function(f2) {\n                    var $162 = foldl11(append5);\n                    var $163 = map10(f2);\n                    return function($164) {\n                        return $162($163($164));\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Array/index.js\n    var $$void3 = /* @__PURE__ */ $$void(functorST);\n    var map5 = /* @__PURE__ */ map(functorMaybe);\n    var map22 = /* @__PURE__ */ map(functorST);\n    var fromJust2 = /* @__PURE__ */ fromJust();\n    var when2 = /* @__PURE__ */ when(applicativeST);\n    var eq13 = /* @__PURE__ */ eq(eqOrdering);\n    var foldMap1 = /* @__PURE__ */ foldMap(foldableArray);\n    var append2 = /* @__PURE__ */ append(semigroupArray);\n    var zipWith = /* @__PURE__ */ runFn3(zipWithImpl);\n    var unsafeIndex = function() {\n        return runFn2(unsafeIndexImpl);\n    };\n    var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();\n    var uncons = /* @__PURE__ */ function() {\n        return runFn3(unconsImpl)($$const(Nothing.value))(function(x) {\n            return function(xs) {\n                return new Just({\n                    head: x,\n                    tail: xs\n                });\n            };\n        });\n    }();\n    var sortBy = function(comp) {\n        return runFn3(sortByImpl)(comp)(function(v) {\n            if (v instanceof GT) return 1;\n            if (v instanceof EQ) return 0;\n            if (v instanceof LT) return -1;\n            throw new Error(\"Failed pattern match at Data.Array (line 897, column 38 - line 900, column 11): \" + [\n                v.constructor.name\n            ]);\n        });\n    };\n    var slice = /* @__PURE__ */ runFn3(sliceImpl);\n    var take = function(n) {\n        return function(xs) {\n            var $152 = n < 1;\n            if ($152) return [];\n            return slice(0)(n)(xs);\n        };\n    };\n    var singleton2 = function(a) {\n        return [\n            a\n        ];\n    };\n    var replicate = /* @__PURE__ */ runFn2(replicateImpl);\n    var range2 = /* @__PURE__ */ runFn2(rangeImpl);\n    var insertAt = /* @__PURE__ */ function() {\n        return runFn5(_insertAt)(Just.create)(Nothing.value);\n    }();\n    var index = /* @__PURE__ */ function() {\n        return runFn4(indexImpl)(Just.create)(Nothing.value);\n    }();\n    var head = function(xs) {\n        return index(xs)(0);\n    };\n    var groupBy = function(op) {\n        return function(xs) {\n            return function __do() {\n                var result = newSTArray();\n                var iter = iterator(function(v) {\n                    return index(xs)(v);\n                })();\n                iterate(iter)(function(x) {\n                    return $$void3(function __do2() {\n                        var sub1 = newSTArray();\n                        push(x)(sub1)();\n                        pushWhile(op(x))(iter)(sub1)();\n                        var grp = unsafeFreeze(sub1)();\n                        return push(grp)(result)();\n                    });\n                })();\n                return unsafeFreeze(result)();\n            }();\n        };\n    };\n    var groupAllBy = function(cmp) {\n        var $186 = groupBy(function(x) {\n            return function(y) {\n                return eq13(cmp(x)(y))(EQ.value);\n            };\n        });\n        var $187 = sortBy(cmp);\n        return function($188) {\n            return $186($187($188));\n        };\n    };\n    var group = function(dictEq) {\n        var eq22 = eq(dictEq);\n        return function(xs) {\n            return groupBy(eq22)(xs);\n        };\n    };\n    var fromFoldable = function(dictFoldable) {\n        return runFn2(fromFoldableImpl)(foldr(dictFoldable));\n    };\n    var foldl2 = /* @__PURE__ */ foldl(foldableArray);\n    var foldMap2 = function(dictMonoid) {\n        return foldMap1(dictMonoid);\n    };\n    var findIndex = /* @__PURE__ */ function() {\n        return runFn4(findIndexImpl)(Just.create)(Nothing.value);\n    }();\n    var find2 = function(f2) {\n        return function(xs) {\n            return map5(unsafeIndex1(xs))(findIndex(f2)(xs));\n        };\n    };\n    var filter = /* @__PURE__ */ runFn2(filterImpl);\n    var deleteAt = /* @__PURE__ */ function() {\n        return runFn4(_deleteAt)(Just.create)(Nothing.value);\n    }();\n    var deleteBy = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v2.length === 0) return [];\n                return maybe(v2)(function(i) {\n                    return fromJust2(deleteAt(i)(v2));\n                })(findIndex(v(v1))(v2));\n            };\n        };\n    };\n    var cons = function(x) {\n        return function(xs) {\n            return append2([\n                x\n            ])(xs);\n        };\n    };\n    var any2 = /* @__PURE__ */ runFn2(anyImpl);\n    var nubByEq = function(eq22) {\n        return function(xs) {\n            return function __do() {\n                var arr = newSTArray();\n                foreach(xs)(function(x) {\n                    return function __do2() {\n                        var e = map22(function() {\n                            var $194 = any2(function(v) {\n                                return eq22(v)(x);\n                            });\n                            return function($195) {\n                                return !$194($195);\n                            };\n                        }())(unsafeFreeze(arr))();\n                        return when2(e)($$void3(push(x)(arr)))();\n                    };\n                })();\n                return unsafeFreeze(arr)();\n            }();\n        };\n    };\n    var nubEq = function(dictEq) {\n        return nubByEq(eq(dictEq));\n    };\n    var unionBy = function(eq22) {\n        return function(xs) {\n            return function(ys) {\n                return append2(xs)(foldl2(flip(deleteBy(eq22)))(nubByEq(eq22)(ys))(xs));\n            };\n        };\n    };\n    var all2 = /* @__PURE__ */ runFn2(allImpl);\n    // output/Data.FoldableWithIndex/index.js\n    var foldr8 = /* @__PURE__ */ foldr(foldableArray);\n    var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);\n    var foldl8 = /* @__PURE__ */ foldl(foldableArray);\n    var foldrWithIndex = function(dict) {\n        return dict.foldrWithIndex;\n    };\n    var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {\n        var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);\n        return function(dictMonoid) {\n            var append5 = append(dictMonoid.Semigroup0());\n            var mempty2 = mempty(dictMonoid);\n            return function(f2) {\n                return foldrWithIndex1(function(i) {\n                    return function(x) {\n                        return function(acc) {\n                            return append5(f2(i)(x))(acc);\n                        };\n                    };\n                })(mempty2);\n            };\n        };\n    };\n    var foldableWithIndexArray = {\n        foldrWithIndex: function(f2) {\n            return function(z) {\n                var $291 = foldr8(function(v) {\n                    return function(y) {\n                        return f2(v.value0)(v.value1)(y);\n                    };\n                })(z);\n                var $292 = mapWithIndex2(Tuple.create);\n                return function($293) {\n                    return $291($292($293));\n                };\n            };\n        },\n        foldlWithIndex: function(f2) {\n            return function(z) {\n                var $294 = foldl8(function(y) {\n                    return function(v) {\n                        return f2(v.value0)(y)(v.value1);\n                    };\n                })(z);\n                var $295 = mapWithIndex2(Tuple.create);\n                return function($296) {\n                    return $294($295($296));\n                };\n            };\n        },\n        foldMapWithIndex: function(dictMonoid) {\n            return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);\n        },\n        Foldable0: function() {\n            return foldableArray;\n        }\n    };\n    // output/Data.TraversableWithIndex/index.js\n    var traverseWithIndexDefault = function(dictTraversableWithIndex) {\n        var sequence2 = sequence(dictTraversableWithIndex.Traversable2());\n        var mapWithIndex4 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());\n        return function(dictApplicative) {\n            var sequence12 = sequence2(dictApplicative);\n            return function(f2) {\n                var $174 = mapWithIndex4(f2);\n                return function($175) {\n                    return sequence12($174($175));\n                };\n            };\n        };\n    };\n    var traverseWithIndex = function(dict) {\n        return dict.traverseWithIndex;\n    };\n    var traversableWithIndexArray = {\n        traverseWithIndex: function(dictApplicative) {\n            return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);\n        },\n        FunctorWithIndex0: function() {\n            return functorWithIndexArray;\n        },\n        FoldableWithIndex1: function() {\n            return foldableWithIndexArray;\n        },\n        Traversable2: function() {\n            return traversableArray;\n        }\n    };\n    // output/Foreign.Object/index.js\n    var lookup = /* @__PURE__ */ function() {\n        return runFn4(_lookup)(Nothing.value)(Just.create);\n    }();\n    // output/Data.Argonaut.Core/index.js\n    var verbJsonType = function(def) {\n        return function(f2) {\n            return function(g) {\n                return g(def)(f2);\n            };\n        };\n    };\n    var toJsonType = /* @__PURE__ */ function() {\n        return verbJsonType(Nothing.value)(Just.create);\n    }();\n    var caseJsonString = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), $$const(d), $$const(d), f2, $$const(d), $$const(d), j);\n            };\n        };\n    };\n    var caseJsonObject = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), $$const(d), f2, j);\n            };\n        };\n    };\n    var toObject = /* @__PURE__ */ toJsonType(caseJsonObject);\n    var caseJsonNumber = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), $$const(d), f2, $$const(d), $$const(d), $$const(d), j);\n            };\n        };\n    };\n    var caseJsonArray = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), f2, $$const(d), j);\n            };\n        };\n    };\n    var toArray = /* @__PURE__ */ toJsonType(caseJsonArray);\n    // output/Data.Argonaut.Decode.Error/index.js\n    var show1 = /* @__PURE__ */ show(showInt);\n    var TypeMismatch = /* @__PURE__ */ function() {\n        function TypeMismatch2(value0) {\n            this.value0 = value0;\n        }\n        TypeMismatch2.create = function(value0) {\n            return new TypeMismatch2(value0);\n        };\n        return TypeMismatch2;\n    }();\n    var UnexpectedValue = /* @__PURE__ */ function() {\n        function UnexpectedValue2(value0) {\n            this.value0 = value0;\n        }\n        UnexpectedValue2.create = function(value0) {\n            return new UnexpectedValue2(value0);\n        };\n        return UnexpectedValue2;\n    }();\n    var AtIndex = /* @__PURE__ */ function() {\n        function AtIndex2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        AtIndex2.create = function(value0) {\n            return function(value1) {\n                return new AtIndex2(value0, value1);\n            };\n        };\n        return AtIndex2;\n    }();\n    var AtKey = /* @__PURE__ */ function() {\n        function AtKey2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        AtKey2.create = function(value0) {\n            return function(value1) {\n                return new AtKey2(value0, value1);\n            };\n        };\n        return AtKey2;\n    }();\n    var Named = /* @__PURE__ */ function() {\n        function Named2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Named2.create = function(value0) {\n            return function(value1) {\n                return new Named2(value0, value1);\n            };\n        };\n        return Named2;\n    }();\n    var MissingValue = /* @__PURE__ */ function() {\n        function MissingValue2() {}\n        MissingValue2.value = new MissingValue2();\n        return MissingValue2;\n    }();\n    var printJsonDecodeError = function(err) {\n        var go = function(v) {\n            if (v instanceof TypeMismatch) return \"  Expected value of type '\" + (v.value0 + \"'.\");\n            if (v instanceof UnexpectedValue) return \"  Unexpected value \" + (stringify(v.value0) + \".\");\n            if (v instanceof AtIndex) return \"  At array index \" + (show1(v.value0) + (\":\\n\" + go(v.value1)));\n            if (v instanceof AtKey) return \"  At object key '\" + (v.value0 + (\"':\\n\" + go(v.value1)));\n            if (v instanceof Named) return \"  Under '\" + (v.value0 + (\"':\\n\" + go(v.value1)));\n            if (v instanceof MissingValue) return \"  No value was found.\";\n            throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Error (line 37, column 8 - line 43, column 44): \" + [\n                v.constructor.name\n            ]);\n        };\n        return \"An error occurred while decoding a JSON value:\\n\" + go(err);\n    };\n    // output/Data.Array.NonEmpty.Internal/foreign.js\n    var foldr1Impl = function(f2, xs) {\n        var acc = xs[xs.length - 1];\n        for(var i = xs.length - 2; i >= 0; i--)acc = f2(xs[i])(acc);\n        return acc;\n    };\n    var foldl1Impl = function(f2, xs) {\n        var acc = xs[0];\n        var len = xs.length;\n        for(var i = 1; i < len; i++)acc = f2(acc)(xs[i]);\n        return acc;\n    };\n    // output/Data.Array.NonEmpty.Internal/index.js\n    var NonEmptyArray = function(x) {\n        return x;\n    };\n    var traversableNonEmptyArray = traversableArray;\n    var functorNonEmptyArray = functorArray;\n    var foldableNonEmptyArray = foldableArray;\n    var foldable1NonEmptyArray = {\n        foldMap1: function(dictSemigroup) {\n            return foldMap1DefaultL(foldable1NonEmptyArray)(functorNonEmptyArray)(dictSemigroup);\n        },\n        foldr1: /* @__PURE__ */ runFn2(foldr1Impl),\n        foldl1: /* @__PURE__ */ runFn2(foldl1Impl),\n        Foldable0: function() {\n            return foldableNonEmptyArray;\n        }\n    };\n    // output/Data.Array.NonEmpty/index.js\n    var unsafeFromArray = NonEmptyArray;\n    var foldl12 = /* @__PURE__ */ foldl1(foldable1NonEmptyArray);\n    var cons$prime = function(x) {\n        return function(xs) {\n            return unsafeFromArray(cons(x)(xs));\n        };\n    };\n    // output/Data.Int/foreign.js\n    var fromNumberImpl = function(just) {\n        return function(nothing) {\n            return function(n) {\n                return (n | 0) === n ? just(n) : nothing;\n            };\n        };\n    };\n    var toNumber = function(n) {\n        return n;\n    };\n    // output/Data.Number/foreign.js\n    var isFiniteImpl = isFinite;\n    var floor = Math.floor;\n    // output/Data.Int/index.js\n    var top2 = /* @__PURE__ */ top(boundedInt);\n    var bottom2 = /* @__PURE__ */ bottom(boundedInt);\n    var fromNumber = /* @__PURE__ */ function() {\n        return fromNumberImpl(Just.create)(Nothing.value);\n    }();\n    var unsafeClamp = function(x) {\n        if (!isFiniteImpl(x)) return 0;\n        if (x >= toNumber(top2)) return top2;\n        if (x <= toNumber(bottom2)) return bottom2;\n        if (otherwise) return fromMaybe(0)(fromNumber(x));\n        throw new Error(\"Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): \" + [\n            x.constructor.name\n        ]);\n    };\n    var floor2 = function($39) {\n        return unsafeClamp(floor($39));\n    };\n    // output/Data.List.Types/index.js\n    var Nil = /* @__PURE__ */ function() {\n        function Nil2() {}\n        Nil2.value = new Nil2();\n        return Nil2;\n    }();\n    var Cons = /* @__PURE__ */ function() {\n        function Cons2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Cons2.create = function(value0) {\n            return function(value1) {\n                return new Cons2(value0, value1);\n            };\n        };\n        return Cons2;\n    }();\n    var foldableList = {\n        foldr: function(f2) {\n            return function(b) {\n                var rev = function() {\n                    var go = function($copy_v) {\n                        return function($copy_v1) {\n                            var $tco_var_v = $copy_v;\n                            var $tco_done = false;\n                            var $tco_result;\n                            function $tco_loop(v, v1) {\n                                if (v1 instanceof Nil) {\n                                    $tco_done = true;\n                                    return v;\n                                }\n                                if (v1 instanceof Cons) {\n                                    $tco_var_v = new Cons(v1.value0, v);\n                                    $copy_v1 = v1.value1;\n                                    return;\n                                }\n                                throw new Error(\"Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): \" + [\n                                    v.constructor.name,\n                                    v1.constructor.name\n                                ]);\n                            }\n                            while(!$tco_done)$tco_result = $tco_loop($tco_var_v, $copy_v1);\n                            return $tco_result;\n                        };\n                    };\n                    return go(Nil.value);\n                }();\n                var $284 = foldl(foldableList)(flip(f2))(b);\n                return function($285) {\n                    return $284(rev($285));\n                };\n            };\n        },\n        foldl: function(f2) {\n            var go = function($copy_b) {\n                return function($copy_v) {\n                    var $tco_var_b = $copy_b;\n                    var $tco_done1 = false;\n                    var $tco_result;\n                    function $tco_loop(b, v) {\n                        if (v instanceof Nil) {\n                            $tco_done1 = true;\n                            return b;\n                        }\n                        if (v instanceof Cons) {\n                            $tco_var_b = f2(b)(v.value0);\n                            $copy_v = v.value1;\n                            return;\n                        }\n                        throw new Error(\"Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): \" + [\n                            v.constructor.name\n                        ]);\n                    }\n                    while(!$tco_done1)$tco_result = $tco_loop($tco_var_b, $copy_v);\n                    return $tco_result;\n                };\n            };\n            return go;\n        },\n        foldMap: function(dictMonoid) {\n            var append22 = append(dictMonoid.Semigroup0());\n            var mempty2 = mempty(dictMonoid);\n            return function(f2) {\n                return foldl(foldableList)(function(acc) {\n                    var $286 = append22(acc);\n                    return function($287) {\n                        return $286(f2($287));\n                    };\n                })(mempty2);\n            };\n        }\n    };\n    // output/Data.List/index.js\n    var singleton5 = function(a) {\n        return new Cons(a, Nil.value);\n    };\n    var head2 = function(v) {\n        if (v instanceof Nil) return Nothing.value;\n        if (v instanceof Cons) return new Just(v.value0);\n        throw new Error(\"Failed pattern match at Data.List (line 230, column 1 - line 230, column 22): \" + [\n            v.constructor.name\n        ]);\n    };\n    // output/Data.String.CodePoints/foreign.js\n    var hasArrayFrom = typeof Array.from === \"function\";\n    var hasStringIterator = typeof Symbol !== \"undefined\" && Symbol != null && typeof Symbol.iterator !== \"undefined\" && typeof String.prototype[Symbol.iterator] === \"function\";\n    var hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\n    var hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n    // output/Data.Argonaut.Decode.Decoders/index.js\n    var map6 = /* @__PURE__ */ map(functorEither);\n    var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);\n    var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(bindEither);\n    var traverse12 = /* @__PURE__ */ traverse(traversableNonEmptyArray)(applicativeEither);\n    var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeEither);\n    var decodeString = /* @__PURE__ */ function() {\n        return caseJsonString(new Left(new TypeMismatch(\"String\")))(Right.create);\n    }();\n    var decodeNumber = /* @__PURE__ */ function() {\n        return caseJsonNumber(new Left(new TypeMismatch(\"Number\")))(Right.create);\n    }();\n    var decodeJArray = /* @__PURE__ */ function() {\n        var $52 = note(new TypeMismatch(\"Array\"));\n        return function($53) {\n            return $52(toArray($53));\n        };\n    }();\n    var decodeNonEmptyArray = function(decoder) {\n        return composeKleisliFlipped2(function() {\n            var $60 = lmap2(Named.create(\"NonEmptyArray\"));\n            var $61 = traverse12(decoder);\n            return function($62) {\n                return $60($61($62));\n            };\n        }())(composeKleisliFlipped2(function() {\n            var $63 = map6(function(x) {\n                return cons$prime(x.head)(x.tail);\n            });\n            var $64 = note(new TypeMismatch(\"NonEmptyArray\"));\n            return function($65) {\n                return $63($64(uncons($65)));\n            };\n        }())(decodeJArray));\n    };\n    var decodeInt = /* @__PURE__ */ composeKleisliFlipped2(/* @__PURE__ */ function() {\n        var $84 = note(new TypeMismatch(\"Integer\"));\n        return function($85) {\n            return $84(fromNumber($85));\n        };\n    }())(decodeNumber);\n    var decodeArray = function(decoder) {\n        return composeKleisliFlipped2(function() {\n            var $89 = lmap2(Named.create(\"Array\"));\n            var $90 = traverseWithIndex2(function(i) {\n                var $92 = lmap2(AtIndex.create(i));\n                return function($93) {\n                    return $92(decoder($93));\n                };\n            });\n            return function($91) {\n                return $89($90($91));\n            };\n        }())(decodeJArray);\n    };\n    // output/Record/index.js\n    var insert3 = function(dictIsSymbol) {\n        var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n        return function() {\n            return function() {\n                return function(l) {\n                    return function(a) {\n                        return function(r) {\n                            return unsafeSet(reflectSymbol2(l))(a)(r);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Argonaut.Decode.Class/index.js\n    var bind2 = /* @__PURE__ */ bind(bindEither);\n    var lmap3 = /* @__PURE__ */ lmap(bifunctorEither);\n    var map7 = /* @__PURE__ */ map(functorMaybe);\n    var gDecodeJsonNil = {\n        gDecodeJson: function(v) {\n            return function(v1) {\n                return new Right({});\n            };\n        }\n    };\n    var gDecodeJson = function(dict) {\n        return dict.gDecodeJson;\n    };\n    var decodeRecord = function(dictGDecodeJson) {\n        var gDecodeJson1 = gDecodeJson(dictGDecodeJson);\n        return function() {\n            return {\n                decodeJson: function(json) {\n                    var v = toObject(json);\n                    if (v instanceof Just) return gDecodeJson1(v.value0)($$Proxy.value);\n                    if (v instanceof Nothing) return new Left(new TypeMismatch(\"Object\"));\n                    throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Class (line 103, column 5 - line 105, column 46): \" + [\n                        v.constructor.name\n                    ]);\n                }\n            };\n        };\n    };\n    var decodeJsonString = {\n        decodeJson: decodeString\n    };\n    var decodeJsonInt = {\n        decodeJson: decodeInt\n    };\n    var decodeJsonField = function(dict) {\n        return dict.decodeJsonField;\n    };\n    var gDecodeJsonCons = function(dictDecodeJsonField) {\n        var decodeJsonField1 = decodeJsonField(dictDecodeJsonField);\n        return function(dictGDecodeJson) {\n            var gDecodeJson1 = gDecodeJson(dictGDecodeJson);\n            return function(dictIsSymbol) {\n                var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n                var insert5 = insert3(dictIsSymbol)()();\n                return function() {\n                    return function() {\n                        return {\n                            gDecodeJson: function(object) {\n                                return function(v) {\n                                    var fieldName = reflectSymbol2($$Proxy.value);\n                                    var fieldValue = lookup(fieldName)(object);\n                                    var v1 = decodeJsonField1(fieldValue);\n                                    if (v1 instanceof Just) return bind2(lmap3(AtKey.create(fieldName))(v1.value0))(function(val) {\n                                        return bind2(gDecodeJson1(object)($$Proxy.value))(function(rest) {\n                                            return new Right(insert5($$Proxy.value)(val)(rest));\n                                        });\n                                    });\n                                    if (v1 instanceof Nothing) return new Left(new AtKey(fieldName, MissingValue.value));\n                                    throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Class (line 127, column 5 - line 134, column 44): \" + [\n                                        v1.constructor.name\n                                    ]);\n                                };\n                            }\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var decodeJson = function(dict) {\n        return dict.decodeJson;\n    };\n    var decodeJsonNonEmptyArray = function(dictDecodeJson) {\n        return {\n            decodeJson: decodeNonEmptyArray(decodeJson(dictDecodeJson))\n        };\n    };\n    var decodeFieldId = function(dictDecodeJson) {\n        var decodeJson1 = decodeJson(dictDecodeJson);\n        return {\n            decodeJsonField: function(j) {\n                return map7(decodeJson1)(j);\n            }\n        };\n    };\n    var decodeArray2 = function(dictDecodeJson) {\n        return {\n            decodeJson: decodeArray(decodeJson(dictDecodeJson))\n        };\n    };\n    // output/Data.BigInt/foreign.js\n    var import_big_integer = __toESM(require_BigInteger(), 1);\n    function fromInt(n) {\n        return (0, import_big_integer.default)(n);\n    }\n    function toBase(base) {\n        return function(x) {\n            return x.toString(base);\n        };\n    }\n    function toNumber2(x) {\n        return x.toJSNumber();\n    }\n    function biAdd(x) {\n        return function(y) {\n            return x.add(y);\n        };\n    }\n    function biMul(x) {\n        return function(y) {\n            return x.multiply(y);\n        };\n    }\n    function biSub(x) {\n        return function(y) {\n            return x.minus(y);\n        };\n    }\n    function biMod(x) {\n        return function(y) {\n            return x.mod(y);\n        };\n    }\n    function biDiv(x) {\n        return function(y) {\n            return x.divide(y);\n        };\n    }\n    function abs3(x) {\n        return x.abs();\n    }\n    // output/Data.BigInt/index.js\n    var toString2 = /* @__PURE__ */ toBase(10);\n    var semiringBigInt = {\n        add: biAdd,\n        zero: /* @__PURE__ */ fromInt(0),\n        mul: biMul,\n        one: /* @__PURE__ */ fromInt(1)\n    };\n    var add2 = /* @__PURE__ */ add(semiringBigInt);\n    var ringBigInt = {\n        sub: biSub,\n        Semiring0: function() {\n            return semiringBigInt;\n        }\n    };\n    var sub2 = /* @__PURE__ */ sub(ringBigInt);\n    var commutativeRingBigInt = {\n        Ring0: function() {\n            return ringBigInt;\n        }\n    };\n    var euclideanRingBigInt = {\n        div: function(x) {\n            return function(y) {\n                return biDiv(sub2(x)(mod(euclideanRingBigInt)(x)(y)))(y);\n            };\n        },\n        mod: function(x) {\n            return function(y) {\n                var yy = abs3(y);\n                return biMod(add2(biMod(x)(yy))(yy))(yy);\n            };\n        },\n        degree: function($13) {\n            return floor2(toNumber2(abs3($13)));\n        },\n        CommutativeRing0: function() {\n            return commutativeRingBigInt;\n        }\n    };\n    // output/Effect.Class/index.js\n    var monadEffectEffect = {\n        liftEffect: /* @__PURE__ */ identity(categoryFn),\n        Monad0: function() {\n            return monadEffect;\n        }\n    };\n    var liftEffect = function(dict) {\n        return dict.liftEffect;\n    };\n    // output/Effect.Console/foreign.js\n    var error = function(s) {\n        return function() {\n            console.error(s);\n        };\n    };\n    // output/Effect.Class.Console/index.js\n    var error2 = function(dictMonadEffect) {\n        var $79 = liftEffect(dictMonadEffect);\n        return function($80) {\n            return $79(error($80));\n        };\n    };\n    // output/Foreign/foreign.js\n    var isArray = Array.isArray || function(value) {\n        return Object.prototype.toString.call(value) === \"[object Array]\";\n    };\n    // output/Foreign/index.js\n    var unsafeFromForeign = unsafeCoerce2;\n    // output/TcgCalculator.Math/index.js\n    var bind3 = /* @__PURE__ */ bind(bindArray);\n    var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorArray);\n    var fold2 = /* @__PURE__ */ fold(foldableMaybe)(monoidArray);\n    var add3 = /* @__PURE__ */ add(semiringBigInt);\n    var append3 = /* @__PURE__ */ append(semigroupArray);\n    var zero2 = /* @__PURE__ */ zero(semiringBigInt);\n    var one2 = /* @__PURE__ */ one(semiringBigInt);\n    var map8 = /* @__PURE__ */ map(functorArray);\n    var bind1 = /* @__PURE__ */ bind(bindMaybe);\n    var product3 = /* @__PURE__ */ product(foldableArray)(semiringBigInt);\n    var min3 = /* @__PURE__ */ min(ordInt);\n    var div2 = /* @__PURE__ */ div(euclideanRingBigInt);\n    var fromFoldable5 = /* @__PURE__ */ fromFoldable(foldableList);\n    var ptCacheSize = 256;\n    var permutations = function(v) {\n        if (v.length === 0) return [\n            []\n        ];\n        if (v.length === 1) return [\n            [\n                v[0]\n            ]\n        ];\n        var v1 = uncons(v);\n        if (v1 instanceof Just) {\n            var r = range2(0)(length(v1.value0.tail));\n            return bind3(permutations(v1.value0.tail))(function(p) {\n                return mapFlipped2(r)(function(i) {\n                    return fold2(insertAt(i)(v1.value0.head)(p));\n                });\n            });\n        }\n        return [];\n    };\n    var createPascalTriangle = function(size3) {\n        var f2 = function(v) {\n            return function(v1) {\n                if (v1 <= 0) return [];\n                return cons(v)(f2(zipWith(add3)(append3([\n                    zero2\n                ])(v))(append3(v)([\n                    zero2\n                ])))(v1 - 1 | 0));\n            };\n        };\n        return f2([\n            one2\n        ])(size3);\n    };\n    var pascalTriangle = /* @__PURE__ */ createPascalTriangle(ptCacheSize);\n    var combinations = function(n) {\n        return function(a) {\n            if (n === 0) return [\n                []\n            ];\n            if (n === 1) return map8(singleton2)(a);\n            if (length(a) === n) return [\n                a\n            ];\n            if (length(a) < n) return [];\n            if (otherwise) {\n                var v = uncons(a);\n                if (v instanceof Just) return append3(map8(function(v1) {\n                    return cons(v.value0.head)(v1);\n                })(combinations(n - 1 | 0)(v.value0.tail)))(combinations(n)(v.value0.tail));\n                return [];\n            }\n            throw new Error(\"Failed pattern match at TcgCalculator.Math (line 98, column 1 - line 98, column 58): \" + [\n                n.constructor.name,\n                a.constructor.name\n            ]);\n        };\n    };\n    var combinationNumber = function(n) {\n        return function(r) {\n            if (n < r) return zero2;\n            if (r === 0 || n === r) return one2;\n            if (r === 1) return fromInt(n);\n            if (n < ptCacheSize) return fromMaybe(zero2)(bind1(index(pascalTriangle)(n))(function(v) {\n                return index(v)(r);\n            }));\n            if (otherwise) {\n                var product$prime = function() {\n                    var $59 = map8(fromInt);\n                    return function($60) {\n                        return product3($59($60));\n                    };\n                }();\n                var k = min3(r)(n - r | 0);\n                return div2(product$prime(range2((n - k | 0) + 1 | 0)(n)))(product$prime(range2(1)(k)));\n            }\n            throw new Error(\"Failed pattern match at TcgCalculator.Math (line 40, column 1 - line 40, column 42): \" + [\n                n.constructor.name,\n                r.constructor.name\n            ]);\n        };\n    };\n    var buildPartitionNumbers = function(v) {\n        if (v === 0) return singleton5([\n            []\n        ]);\n        var $$new2 = function(v1) {\n            return function(v2) {\n                if (v1 instanceof Cons) return append3($$new2(v1.value1)(v2 + 1 | 0))(map8(function(v3) {\n                    return cons(v2)(v3);\n                })(filter(function() {\n                    var $61 = fromMaybe(0);\n                    return function($62) {\n                        return function(v3) {\n                            return v3 <= v2;\n                        }($61(head($62)));\n                    };\n                }())(v1.value0)));\n                return [];\n            };\n        };\n        var prev = buildPartitionNumbers(v - 1 | 0);\n        return new Cons($$new2(prev)(1), prev);\n    };\n    var partitionNumber = function(v) {\n        if (v < 0) return [];\n        if (v === 0) return [\n            []\n        ];\n        return fold2(head2(buildPartitionNumbers(v)));\n    };\n    var partitionNumbers = function(v) {\n        if (v < 0) return [];\n        if (v === 0) return [\n            [\n                []\n            ]\n        ];\n        return fromFoldable5(buildPartitionNumbers(v));\n    };\n    // node_modules/uuid/dist/esm-browser/regex.js\n    var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n    // node_modules/uuid/dist/esm-browser/validate.js\n    function validate(uuid) {\n        return typeof uuid === \"string\" && regex_default.test(uuid);\n    }\n    var validate_default = validate;\n    // node_modules/uuid/dist/esm-browser/stringify.js\n    var byteToHex = [];\n    for(let i = 0; i < 256; ++i)byteToHex.push((i + 256).toString(16).slice(1));\n    function unsafeStringify(arr, offset = 0) {\n        return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n    }\n    // node_modules/uuid/dist/esm-browser/parse.js\n    function parse(uuid) {\n        if (!validate_default(uuid)) throw TypeError(\"Invalid UUID\");\n        let v;\n        const arr = new Uint8Array(16);\n        arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n        arr[1] = v >>> 16 & 255;\n        arr[2] = v >>> 8 & 255;\n        arr[3] = v & 255;\n        arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n        arr[5] = v & 255;\n        arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n        arr[7] = v & 255;\n        arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n        arr[9] = v & 255;\n        arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;\n        arr[11] = v / 4294967296 & 255;\n        arr[12] = v >>> 24 & 255;\n        arr[13] = v >>> 16 & 255;\n        arr[14] = v >>> 8 & 255;\n        arr[15] = v & 255;\n        return arr;\n    }\n    var parse_default = parse;\n    // node_modules/uuid/dist/esm-browser/v35.js\n    function stringToBytes(str) {\n        str = unescape(encodeURIComponent(str));\n        const bytes = [];\n        for(let i = 0; i < str.length; ++i)bytes.push(str.charCodeAt(i));\n        return bytes;\n    }\n    var DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n    var URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\n    function v35(name2, version, hashfunc) {\n        function generateUUID(value, namespace, buf, offset) {\n            var _namespace;\n            if (typeof value === \"string\") value = stringToBytes(value);\n            if (typeof namespace === \"string\") namespace = parse_default(namespace);\n            if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n            let bytes = new Uint8Array(16 + value.length);\n            bytes.set(namespace);\n            bytes.set(value, namespace.length);\n            bytes = hashfunc(bytes);\n            bytes[6] = bytes[6] & 15 | version;\n            bytes[8] = bytes[8] & 63 | 128;\n            if (buf) {\n                offset = offset || 0;\n                for(let i = 0; i < 16; ++i)buf[offset + i] = bytes[i];\n                return buf;\n            }\n            return unsafeStringify(bytes);\n        }\n        try {\n            generateUUID.name = name2;\n        } catch (err) {}\n        generateUUID.DNS = DNS;\n        generateUUID.URL = URL;\n        return generateUUID;\n    }\n    // node_modules/uuid/dist/esm-browser/sha1.js\n    function f(s, x, y, z) {\n        switch(s){\n            case 0:\n                return x & y ^ ~x & z;\n            case 1:\n                return x ^ y ^ z;\n            case 2:\n                return x & y ^ x & z ^ y & z;\n            case 3:\n                return x ^ y ^ z;\n        }\n    }\n    function ROTL(x, n) {\n        return x << n | x >>> 32 - n;\n    }\n    function sha1(bytes) {\n        const K = [\n            1518500249,\n            1859775393,\n            2400959708,\n            3395469782\n        ];\n        const H = [\n            1732584193,\n            4023233417,\n            2562383102,\n            271733878,\n            3285377520\n        ];\n        if (typeof bytes === \"string\") {\n            const msg = unescape(encodeURIComponent(bytes));\n            bytes = [];\n            for(let i = 0; i < msg.length; ++i)bytes.push(msg.charCodeAt(i));\n        } else if (!Array.isArray(bytes)) bytes = Array.prototype.slice.call(bytes);\n        bytes.push(128);\n        const l = bytes.length / 4 + 2;\n        const N = Math.ceil(l / 16);\n        const M = new Array(N);\n        for(let i = 0; i < N; ++i){\n            const arr = new Uint32Array(16);\n            for(let j = 0; j < 16; ++j)arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n            M[i] = arr;\n        }\n        M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n        M[N - 1][14] = Math.floor(M[N - 1][14]);\n        M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n        for(let i = 0; i < N; ++i){\n            const W = new Uint32Array(80);\n            for(let t = 0; t < 16; ++t)W[t] = M[i][t];\n            for(let t = 16; t < 80; ++t)W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n            let a = H[0];\n            let b = H[1];\n            let c = H[2];\n            let d = H[3];\n            let e = H[4];\n            for(let t = 0; t < 80; ++t){\n                const s = Math.floor(t / 20);\n                const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n                e = d;\n                d = c;\n                c = ROTL(b, 30) >>> 0;\n                b = a;\n                a = T;\n            }\n            H[0] = H[0] + a >>> 0;\n            H[1] = H[1] + b >>> 0;\n            H[2] = H[2] + c >>> 0;\n            H[3] = H[3] + d >>> 0;\n            H[4] = H[4] + e >>> 0;\n        }\n        return [\n            H[0] >> 24 & 255,\n            H[0] >> 16 & 255,\n            H[0] >> 8 & 255,\n            H[0] & 255,\n            H[1] >> 24 & 255,\n            H[1] >> 16 & 255,\n            H[1] >> 8 & 255,\n            H[1] & 255,\n            H[2] >> 24 & 255,\n            H[2] >> 16 & 255,\n            H[2] >> 8 & 255,\n            H[2] & 255,\n            H[3] >> 24 & 255,\n            H[3] >> 16 & 255,\n            H[3] >> 8 & 255,\n            H[3] & 255,\n            H[4] >> 24 & 255,\n            H[4] >> 16 & 255,\n            H[4] >> 8 & 255,\n            H[4] & 255\n        ];\n    }\n    var sha1_default = sha1;\n    // node_modules/uuid/dist/esm-browser/v5.js\n    var v5 = v35(\"v5\", 80, sha1_default);\n    var v5_default = v5;\n    // output/Data.UUID/foreign.js\n    var getUUID5Impl = function(str) {\n        return function(namespace) {\n            return v5_default(str, namespace);\n        };\n    };\n    var validateV4UUID = validate_default;\n    // output/Data.UUID/index.js\n    var compare2 = /* @__PURE__ */ compare(ordString);\n    var parseUUID = function(str) {\n        var v = validateV4UUID(str);\n        if (v) return new Just(str);\n        return Nothing.value;\n    };\n    var genv5UUID = function(s) {\n        return function(v) {\n            return getUUID5Impl(s)(v);\n        };\n    };\n    var eqUUID = {\n        eq: function(x) {\n            return function(y) {\n                return x === y;\n            };\n        }\n    };\n    var ordUUID = {\n        compare: function(x) {\n            return function(y) {\n                return compare2(x)(y);\n            };\n        },\n        Eq0: function() {\n            return eqUUID;\n        }\n    };\n    var emptyUUID = \"00000000-0000-0000-0000-000000000000\";\n    // output/TcgCalculator.Types/index.js\n    var cardsIsSymbol = {\n        reflectSymbol: function() {\n            return \"cards\";\n        }\n    };\n    var countIsSymbol = {\n        reflectSymbol: function() {\n            return \"count\";\n        }\n    };\n    var modeIsSymbol = {\n        reflectSymbol: function() {\n            return \"mode\";\n        }\n    };\n    var idIsSymbol = {\n        reflectSymbol: function() {\n            return \"id\";\n        }\n    };\n    var nameIsSymbol = {\n        reflectSymbol: function() {\n            return \"name\";\n        }\n    };\n    var eq2 = /* @__PURE__ */ eq(eqUUID);\n    var compare3 = /* @__PURE__ */ compare(ordUUID);\n    var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindEither);\n    var decodeJson2 = /* @__PURE__ */ decodeJson(decodeJsonString);\n    var mapFlipped3 = /* @__PURE__ */ mapFlipped(functorEither);\n    var gDecodeJsonCons2 = /* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonInt));\n    var Id = function(x) {\n        return x;\n    };\n    var AtLeast = /* @__PURE__ */ function() {\n        function AtLeast2() {}\n        AtLeast2.value = new AtLeast2();\n        return AtLeast2;\n    }();\n    var JustDraw = /* @__PURE__ */ function() {\n        function JustDraw2() {}\n        JustDraw2.value = new JustDraw2();\n        return JustDraw2;\n    }();\n    var Remains = /* @__PURE__ */ function() {\n        function Remains2() {}\n        Remains2.value = new Remains2();\n        return Remains2;\n    }();\n    var JustRemains = /* @__PURE__ */ function() {\n        function JustRemains2() {}\n        JustRemains2.value = new JustRemains2();\n        return JustRemains2;\n    }();\n    var Choice = /* @__PURE__ */ function() {\n        function Choice2() {}\n        Choice2.value = new Choice2();\n        return Choice2;\n    }();\n    var LeftOne = /* @__PURE__ */ function() {\n        function LeftOne2() {}\n        LeftOne2.value = new LeftOne2();\n        return LeftOne2;\n    }();\n    var LeftAll = /* @__PURE__ */ function() {\n        function LeftAll2() {}\n        LeftAll2.value = new LeftAll2();\n        return LeftAll2;\n    }();\n    var eqId = {\n        eq: function(x) {\n            return function(y) {\n                return eq2(x)(y);\n            };\n        }\n    };\n    var ordId = {\n        compare: function(x) {\n            return function(y) {\n                return compare3(x)(y);\n            };\n        },\n        Eq0: function() {\n            return eqId;\n        }\n    };\n    var readConditionMode = function(v) {\n        if (v === \"AtLeast\") return new Just(AtLeast.value);\n        if (v === \"JustDraw\") return new Just(JustDraw.value);\n        if (v === \"Remains\") return new Just(Remains.value);\n        if (v === \"JustRemains\") return new Just(JustRemains.value);\n        if (v === \"Choice\") return new Just(Choice.value);\n        if (v === \"LeftOne\") return new Just(LeftOne.value);\n        if (v === \"LeftAll\") return new Just(LeftAll.value);\n        return Nothing.value;\n    };\n    var decodeJsonConditionMode = {\n        decodeJson: function(json) {\n            return bindFlipped2(function() {\n                var $263 = note(new UnexpectedValue(json));\n                return function($264) {\n                    return $263(readConditionMode($264));\n                };\n            }())(decodeJson2(json));\n        }\n    };\n    var namespaceTcgCalculator = /* @__PURE__ */ genv5UUID(\"tcg-calculator\")(emptyUUID);\n    var mkId = function(s) {\n        return genv5UUID(s)(namespaceTcgCalculator);\n    };\n    var decodeJsonId = {\n        decodeJson: function(json) {\n            return mapFlipped3(decodeJson2(json))(function(id2) {\n                return maybe$prime(function(v) {\n                    return mkId(id2);\n                })(Id)(parseUUID(id2));\n            });\n        }\n    };\n    var decodeJsonCondition = /* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonId))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonString))(gDecodeJsonNil)(nameIsSymbol)()())(idIsSymbol)()())(countIsSymbol)()())())))(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonConditionMode))(gDecodeJsonNil)(modeIsSymbol)()())(countIsSymbol)()())(cardsIsSymbol)()())();\n    // output/TcgCalculator/index.js\n    var map9 = /* @__PURE__ */ map(functorMaybe);\n    var eq3 = /* @__PURE__ */ eq(eqId);\n    var compare4 = /* @__PURE__ */ compare(ordInt);\n    var map1 = /* @__PURE__ */ map(functorArray);\n    var and3 = /* @__PURE__ */ and(foldableArray)(heytingAlgebraBoolean);\n    var greaterThanOrEq2 = /* @__PURE__ */ greaterThanOrEq(ordInt);\n    var maximum2 = /* @__PURE__ */ maximum(ordInt)(foldableArray);\n    var flap2 = /* @__PURE__ */ flap(functorFn);\n    var bind4 = /* @__PURE__ */ bind(bindArray);\n    var fold3 = /* @__PURE__ */ fold(foldableMaybe)(monoidArray);\n    var group4 = /* @__PURE__ */ group(eqInt);\n    var pure2 = /* @__PURE__ */ pure(applicativeArray);\n    var nubEq3 = /* @__PURE__ */ nubEq(/* @__PURE__ */ eqArray(eqInt));\n    var mapFlipped4 = /* @__PURE__ */ mapFlipped(functorArray);\n    var min4 = /* @__PURE__ */ min(ordInt);\n    var comparing2 = /* @__PURE__ */ comparing(ordId);\n    var append4 = /* @__PURE__ */ append(semigroupArray);\n    var product4 = /* @__PURE__ */ product(foldableArray)(semiringBigInt);\n    var mul2 = /* @__PURE__ */ mul(semiringBigInt);\n    var map23 = /* @__PURE__ */ map(functorNonEmptyArray);\n    var empty4 = /* @__PURE__ */ empty(plusArray);\n    var eqRec2 = /* @__PURE__ */ eqRec();\n    var eqRowCons2 = /* @__PURE__ */ eqRowCons(eqRowNil)();\n    var nubEq1 = /* @__PURE__ */ nubEq(/* @__PURE__ */ eqArray(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({\n        reflectSymbol: function() {\n            return \"min\";\n        }\n    })(eqInt))()({\n        reflectSymbol: function() {\n            return \"max\";\n        }\n    })(eqInt))()({\n        reflectSymbol: function() {\n            return \"card\";\n        }\n    })(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({\n        reflectSymbol: function() {\n            return \"name\";\n        }\n    })(eqString))()({\n        reflectSymbol: function() {\n            return \"id\";\n        }\n    })(eqId))()({\n        reflectSymbol: function() {\n            return \"count\";\n        }\n    })(eqInt))))));\n    var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindArray);\n    var sum2 = /* @__PURE__ */ sum(foldableArray)(semiringBigInt);\n    var sumBy = /* @__PURE__ */ alaF()()()()(Additive)(/* @__PURE__ */ foldMap2(/* @__PURE__ */ monoidAdditive(semiringInt)));\n    var satisfyCondition = function(dp) {\n        return all2(function(v) {\n            return fromMaybe(false)(map9(function(v1) {\n                return v.min <= v1.draw && v1.draw <= v.max;\n            })(find2(function($171) {\n                return function(v1) {\n                    return eq3(v1)(v.card.id);\n                }(function(v1) {\n                    return v1.card.id;\n                }($171));\n            })(dp)));\n        });\n    };\n    var mkDrawPattern$prime = function(v) {\n        return function(v1) {\n            if (v1.length === 0) return [];\n            if (v1.length === 1 && v1[0].length === 0) return [\n                []\n            ];\n            var cardsLength = length(v);\n            var cardCounts = sortBy(flip(compare4))(map1(function(v2) {\n                return v2.count;\n            })(v));\n            var pattern$prime = filter(function() {\n                var $177 = zipWith(greaterThanOrEq2)(cardCounts);\n                return function($178) {\n                    return and3($177($178));\n                };\n            }())(map1(sortBy(flip(compare4)))(filter(function($179) {\n                return function(v2) {\n                    return v2 <= cardsLength;\n                }(length($179));\n            })(v1)));\n            var maxPatternLength = fromMaybe(0)(maximum2(map1(length)(pattern$prime)));\n            var cardCombinations = map1(flap2(combinations)(v))(range2(0)(maxPatternLength));\n            return bind4(pattern$prime)(function(p) {\n                var len = length(p);\n                var con = fold3(index(cardCombinations)(len));\n                return bind4((function() {\n                    var v2 = length(group4(p));\n                    if (v2 === 1) return pure2;\n                    if (v2 === len) return permutations;\n                    return function($180) {\n                        return nubEq3(permutations($180));\n                    };\n                })()(p))(function(p$prime) {\n                    return filter(all2(function(d) {\n                        return d.draw <= d.card.count;\n                    }))(map1(zipWith(function(v2) {\n                        return function(v3) {\n                            return {\n                                draw: v2,\n                                card: v3\n                            };\n                        };\n                    })(p$prime))(con));\n                });\n            });\n        };\n    };\n    var mkDrawPattern = function(cards) {\n        return function(count) {\n            return mkDrawPattern$prime(cards)(partitionNumber(count));\n        };\n    };\n    var mkConditionPattern = function($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v.mode instanceof AtLeast) {\n                $tco_done = true;\n                return map1(function(v1) {\n                    return mapFlipped4(v1)(function(p) {\n                        return {\n                            card: p.card,\n                            min: p.draw,\n                            max: p.card.count\n                        };\n                    });\n                })(mkDrawPattern(v.cards)(v.count));\n            }\n            if (v.mode instanceof JustDraw) {\n                $tco_done = true;\n                return map1(function(v1) {\n                    var cond = mapFlipped4(v1)(function(p) {\n                        return {\n                            card: p.card,\n                            min: p.draw,\n                            max: p.draw\n                        };\n                    });\n                    return unionBy(on(eq3)(function(v2) {\n                        return v2.card.id;\n                    }))(cond)(map1(function(v2) {\n                        return {\n                            card: v2,\n                            min: 0,\n                            max: 0\n                        };\n                    })(v.cards));\n                })(mkDrawPattern(v.cards)(v.count));\n            }\n            if (v.mode instanceof Remains) {\n                $tco_done = true;\n                return map1(function(v1) {\n                    var cond = mapFlipped4(v1)(function(p) {\n                        return {\n                            card: p.card,\n                            min: 0,\n                            max: p.draw\n                        };\n                    });\n                    return unionBy(on(eq3)(function(v2) {\n                        return v2.card.id;\n                    }))(cond)(map1(function(v2) {\n                        return {\n                            card: v2,\n                            min: 0,\n                            max: 0\n                        };\n                    })(v.cards));\n                })(mkDrawPattern(v.cards)(sumBy(function(v1) {\n                    return v1.count;\n                })(v.cards) - v.count | 0));\n            }\n            if (v.mode instanceof JustRemains) {\n                $copy_v = {\n                    mode: JustDraw.value,\n                    count: sumBy(function(v1) {\n                        return v1.count;\n                    })(v.cards) - v.count | 0,\n                    cards: v.cards\n                };\n                return;\n            }\n            if (v.mode instanceof Choice) {\n                $tco_done = true;\n                return map1(function(v1) {\n                    return mapFlipped4(v1)(function(p) {\n                        return {\n                            card: p.card,\n                            min: 1,\n                            max: p.card.count\n                        };\n                    });\n                })(mkDrawPattern$prime(v.cards)([\n                    replicate(v.count)(1)\n                ]));\n            }\n            if (v.mode instanceof LeftOne) {\n                $tco_done = true;\n                return map1(function(v1) {\n                    return mapFlipped4(v1)(function(p) {\n                        return {\n                            card: p.card,\n                            min: 0,\n                            max: p.card.count - 1 | 0\n                        };\n                    });\n                })(mkDrawPattern$prime(v.cards)([\n                    replicate(v.count)(1)\n                ]));\n            }\n            if (v.mode instanceof LeftAll) {\n                $tco_done = true;\n                return map1(function(v1) {\n                    return mapFlipped4(v1)(function(p) {\n                        return {\n                            card: p.card,\n                            min: 0,\n                            max: 0\n                        };\n                    });\n                })(mkDrawPattern$prime(v.cards)([\n                    replicate(v.count)(0)\n                ]));\n            }\n            throw new Error(\"Failed pattern match at TcgCalculator (line 88, column 57 - line 117, column 58): \" + [\n                v.mode.constructor.name\n            ]);\n        }\n        while(!$tco_done)$tco_result = $tco_loop($copy_v);\n        return $tco_result;\n    };\n    var mergeConditionPattern = function(left) {\n        return function(right) {\n            var merge = function(v) {\n                return function(v1) {\n                    return {\n                        card: v.card,\n                        min: v.min + v1.min | 0,\n                        max: min4(v.max)(v1.max)\n                    };\n                };\n            };\n            return map1(foldl12(merge))(groupAllBy(comparing2(function(v) {\n                return v.card.id;\n            }))(append4(left)(right)));\n        };\n    };\n    var isValidConditionPattern = /* @__PURE__ */ all2(function(v) {\n        return v.min <= v.max && v.min <= v.card.count;\n    });\n    var generateDrawPatterns = function(v) {\n        var zeroDrawPattern = map1(function(v1) {\n            return {\n                card: v1,\n                draw: 0\n            };\n        })(v.cards);\n        var maxDrawCount = min4(v.hand)(sumBy(function(v1) {\n            return v1.count;\n        })(v.cards));\n        var maxPatternLength = (v.others - (v.hand - maxDrawCount | 0) | 0) + 1 | 0;\n        return map1(function(v1) {\n            return unionBy(on(eq3)(function(v2) {\n                return v2.card.id;\n            }))(v1)(zeroDrawPattern);\n        })(mkDrawPattern$prime(v.cards)(concat(take(maxPatternLength)(partitionNumbers(maxDrawCount)))));\n    };\n    var calculatePatternCount = function(v) {\n        return function(pattern) {\n            var patternCount = product4(mapFlipped4(pattern)(function(v1) {\n                return combinationNumber(v1.card.count)(v1.draw);\n            }));\n            var drawCount = sumBy(function(v1) {\n                return v1.draw;\n            })(pattern);\n            return mul2(patternCount)(combinationNumber(v.others)(v.hand - drawCount | 0));\n        };\n    };\n    var buildConditionPattern = function(conditions) {\n        var patterns = map23(mkConditionPattern)(conditions);\n        return flap2(foldl12)(patterns)(function(left) {\n            return function(right) {\n                return bind4(left)(function(l) {\n                    return bind4(right)(function(r) {\n                        var merged = mergeConditionPattern(l)(r);\n                        var $170 = isValidConditionPattern(merged);\n                        if ($170) return pure2(merged);\n                        return empty4;\n                    });\n                });\n            };\n        });\n    };\n    var calculate = function(deck) {\n        return function(conditions) {\n            var drawPattern = generateDrawPatterns(deck);\n            var conditionPattern = nubEq1(bindFlipped3(buildConditionPattern)(conditions));\n            var pattern = filter(function(dp) {\n                return any2(satisfyCondition(dp))(conditionPattern);\n            })(drawPattern);\n            return sum2(map1(calculatePatternCount(deck))(pattern));\n        };\n    };\n    // output/Web.Worker.GlobalScope/foreign.js\n    function postMessageImpl(data) {\n        return function(tr) {\n            return function() {\n                self.postMessage(data, tr.length > 0 ? tr : void 0);\n            };\n        };\n    }\n    function onMessage(f2) {\n        return function() {\n            self.onmessage = function(ev) {\n                f2(ev)();\n            };\n        };\n    }\n    // output/Web.Worker.GlobalScope/index.js\n    var postMessage = function(msg) {\n        return postMessageImpl(msg)([]);\n    };\n    // output/Web.Worker.MessageEvent/foreign.js\n    function data_(ev) {\n        return ev.data;\n    }\n    // output/Worker.Main/index.js\n    var gDecodeJsonCons3 = /* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonInt));\n    var decodeJson3 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeJsonNonEmptyArray(decodeJsonCondition))))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons3(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonId))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonString))(gDecodeJsonNil)({\n        reflectSymbol: function() {\n            return \"name\";\n        }\n    })()())({\n        reflectSymbol: function() {\n            return \"id\";\n        }\n    })()())({\n        reflectSymbol: function() {\n            return \"count\";\n        }\n    })()())())))(/* @__PURE__ */ gDecodeJsonCons3(/* @__PURE__ */ gDecodeJsonCons3(gDecodeJsonNil)({\n        reflectSymbol: function() {\n            return \"others\";\n        }\n    })()())({\n        reflectSymbol: function() {\n            return \"hand\";\n        }\n    })()())({\n        reflectSymbol: function() {\n            return \"cards\";\n        }\n    })()())()))(gDecodeJsonNil)({\n        reflectSymbol: function() {\n            return \"deck\";\n        }\n    })()())({\n        reflectSymbol: function() {\n            return \"conditions\";\n        }\n    })()())());\n    var error4 = /* @__PURE__ */ error2(monadEffectEffect);\n    var main = /* @__PURE__ */ onMessage(function(event) {\n        var v = decodeJson3(unsafeFromForeign(data_(event)));\n        if (v instanceof Left) return error4(printJsonDecodeError(v.value0));\n        if (v instanceof Right) {\n            var result = calculate(v.value0.deck)(v.value0.conditions);\n            return postMessage(toString2(result));\n        }\n        throw new Error(\"Failed pattern match at Worker.Main (line 21, column 5 - line 25, column 52): \" + [\n            v.constructor.name\n        ]);\n    });\n    // <stdin>\n    main();\n})();\n\n})();\n//# sourceMappingURL=worker.js.map\n","(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod2) => function __require() {\n    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n  };\n  var __copyProps = (to, from2, except, desc) => {\n    if (from2 && typeof from2 === \"object\" || typeof from2 === \"function\") {\n      for (let key of __getOwnPropNames(from2))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n    mod2\n  ));\n\n  // node_modules/big-integer/BigInteger.js\n  var require_BigInteger = __commonJS({\n    \"node_modules/big-integer/BigInteger.js\"(exports, module) {\n      var bigInt2 = function(undefined2) {\n        \"use strict\";\n        var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n        var supportsNativeBigInt = typeof BigInt === \"function\";\n        function Integer(v, radix, alphabet, caseSensitive) {\n          if (typeof v === \"undefined\")\n            return Integer[0];\n          if (typeof radix !== \"undefined\")\n            return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\n          return parseValue(v);\n        }\n        function BigInteger(value, sign2) {\n          this.value = value;\n          this.sign = sign2;\n          this.isSmall = false;\n        }\n        BigInteger.prototype = Object.create(Integer.prototype);\n        function SmallInteger(value) {\n          this.value = value;\n          this.sign = value < 0;\n          this.isSmall = true;\n        }\n        SmallInteger.prototype = Object.create(Integer.prototype);\n        function NativeBigInt(value) {\n          this.value = value;\n        }\n        NativeBigInt.prototype = Object.create(Integer.prototype);\n        function isPrecise(n) {\n          return -MAX_INT < n && n < MAX_INT;\n        }\n        function smallToArray(n) {\n          if (n < 1e7)\n            return [n];\n          if (n < 1e14)\n            return [n % 1e7, Math.floor(n / 1e7)];\n          return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\n        }\n        function arrayToSmall(arr) {\n          trim2(arr);\n          var length4 = arr.length;\n          if (length4 < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\n            switch (length4) {\n              case 0:\n                return 0;\n              case 1:\n                return arr[0];\n              case 2:\n                return arr[0] + arr[1] * BASE;\n              default:\n                return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\n            }\n          }\n          return arr;\n        }\n        function trim2(v) {\n          var i2 = v.length;\n          while (v[--i2] === 0)\n            ;\n          v.length = i2 + 1;\n        }\n        function createArray(length4) {\n          var x = new Array(length4);\n          var i2 = -1;\n          while (++i2 < length4) {\n            x[i2] = 0;\n          }\n          return x;\n        }\n        function truncate(n) {\n          if (n > 0)\n            return Math.floor(n);\n          return Math.ceil(n);\n        }\n        function add4(a, b) {\n          var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum3, i2;\n          for (i2 = 0; i2 < l_b; i2++) {\n            sum3 = a[i2] + b[i2] + carry;\n            carry = sum3 >= base ? 1 : 0;\n            r[i2] = sum3 - carry * base;\n          }\n          while (i2 < l_a) {\n            sum3 = a[i2] + carry;\n            carry = sum3 === base ? 1 : 0;\n            r[i2++] = sum3 - carry * base;\n          }\n          if (carry > 0)\n            r.push(carry);\n          return r;\n        }\n        function addAny(a, b) {\n          if (a.length >= b.length)\n            return add4(a, b);\n          return add4(b, a);\n        }\n        function addSmall(a, carry) {\n          var l = a.length, r = new Array(l), base = BASE, sum3, i2;\n          for (i2 = 0; i2 < l; i2++) {\n            sum3 = a[i2] - base + carry;\n            carry = Math.floor(sum3 / base);\n            r[i2] = sum3 - carry * base;\n            carry += 1;\n          }\n          while (carry > 0) {\n            r[i2++] = carry % base;\n            carry = Math.floor(carry / base);\n          }\n          return r;\n        }\n        BigInteger.prototype.add = function(v) {\n          var n = parseValue(v);\n          if (this.sign !== n.sign) {\n            return this.subtract(n.negate());\n          }\n          var a = this.value, b = n.value;\n          if (n.isSmall) {\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\n          }\n          return new BigInteger(addAny(a, b), this.sign);\n        };\n        BigInteger.prototype.plus = BigInteger.prototype.add;\n        SmallInteger.prototype.add = function(v) {\n          var n = parseValue(v);\n          var a = this.value;\n          if (a < 0 !== n.sign) {\n            return this.subtract(n.negate());\n          }\n          var b = n.value;\n          if (n.isSmall) {\n            if (isPrecise(a + b))\n              return new SmallInteger(a + b);\n            b = smallToArray(Math.abs(b));\n          }\n          return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\n        };\n        SmallInteger.prototype.plus = SmallInteger.prototype.add;\n        NativeBigInt.prototype.add = function(v) {\n          return new NativeBigInt(this.value + parseValue(v).value);\n        };\n        NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\n        function subtract(a, b) {\n          var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference3;\n          for (i2 = 0; i2 < b_l; i2++) {\n            difference3 = a[i2] - borrow - b[i2];\n            if (difference3 < 0) {\n              difference3 += base;\n              borrow = 1;\n            } else\n              borrow = 0;\n            r[i2] = difference3;\n          }\n          for (i2 = b_l; i2 < a_l; i2++) {\n            difference3 = a[i2] - borrow;\n            if (difference3 < 0)\n              difference3 += base;\n            else {\n              r[i2++] = difference3;\n              break;\n            }\n            r[i2] = difference3;\n          }\n          for (; i2 < a_l; i2++) {\n            r[i2] = a[i2];\n          }\n          trim2(r);\n          return r;\n        }\n        function subtractAny(a, b, sign2) {\n          var value;\n          if (compareAbs(a, b) >= 0) {\n            value = subtract(a, b);\n          } else {\n            value = subtract(b, a);\n            sign2 = !sign2;\n          }\n          value = arrayToSmall(value);\n          if (typeof value === \"number\") {\n            if (sign2)\n              value = -value;\n            return new SmallInteger(value);\n          }\n          return new BigInteger(value, sign2);\n        }\n        function subtractSmall(a, b, sign2) {\n          var l = a.length, r = new Array(l), carry = -b, base = BASE, i2, difference3;\n          for (i2 = 0; i2 < l; i2++) {\n            difference3 = a[i2] + carry;\n            carry = Math.floor(difference3 / base);\n            difference3 %= base;\n            r[i2] = difference3 < 0 ? difference3 + base : difference3;\n          }\n          r = arrayToSmall(r);\n          if (typeof r === \"number\") {\n            if (sign2)\n              r = -r;\n            return new SmallInteger(r);\n          }\n          return new BigInteger(r, sign2);\n        }\n        BigInteger.prototype.subtract = function(v) {\n          var n = parseValue(v);\n          if (this.sign !== n.sign) {\n            return this.add(n.negate());\n          }\n          var a = this.value, b = n.value;\n          if (n.isSmall)\n            return subtractSmall(a, Math.abs(b), this.sign);\n          return subtractAny(a, b, this.sign);\n        };\n        BigInteger.prototype.minus = BigInteger.prototype.subtract;\n        SmallInteger.prototype.subtract = function(v) {\n          var n = parseValue(v);\n          var a = this.value;\n          if (a < 0 !== n.sign) {\n            return this.add(n.negate());\n          }\n          var b = n.value;\n          if (n.isSmall) {\n            return new SmallInteger(a - b);\n          }\n          return subtractSmall(b, Math.abs(a), a >= 0);\n        };\n        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\n        NativeBigInt.prototype.subtract = function(v) {\n          return new NativeBigInt(this.value - parseValue(v).value);\n        };\n        NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\n        BigInteger.prototype.negate = function() {\n          return new BigInteger(this.value, !this.sign);\n        };\n        SmallInteger.prototype.negate = function() {\n          var sign2 = this.sign;\n          var small = new SmallInteger(-this.value);\n          small.sign = !sign2;\n          return small;\n        };\n        NativeBigInt.prototype.negate = function() {\n          return new NativeBigInt(-this.value);\n        };\n        BigInteger.prototype.abs = function() {\n          return new BigInteger(this.value, false);\n        };\n        SmallInteger.prototype.abs = function() {\n          return new SmallInteger(Math.abs(this.value));\n        };\n        NativeBigInt.prototype.abs = function() {\n          return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\n        };\n        function multiplyLong(a, b) {\n          var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product5, carry, i2, a_i, b_j;\n          for (i2 = 0; i2 < a_l; ++i2) {\n            a_i = a[i2];\n            for (var j = 0; j < b_l; ++j) {\n              b_j = b[j];\n              product5 = a_i * b_j + r[i2 + j];\n              carry = Math.floor(product5 / base);\n              r[i2 + j] = product5 - carry * base;\n              r[i2 + j + 1] += carry;\n            }\n          }\n          trim2(r);\n          return r;\n        }\n        function multiplySmall(a, b) {\n          var l = a.length, r = new Array(l), base = BASE, carry = 0, product5, i2;\n          for (i2 = 0; i2 < l; i2++) {\n            product5 = a[i2] * b + carry;\n            carry = Math.floor(product5 / base);\n            r[i2] = product5 - carry * base;\n          }\n          while (carry > 0) {\n            r[i2++] = carry % base;\n            carry = Math.floor(carry / base);\n          }\n          return r;\n        }\n        function shiftLeft(x, n) {\n          var r = [];\n          while (n-- > 0)\n            r.push(0);\n          return r.concat(x);\n        }\n        function multiplyKaratsuba(x, y) {\n          var n = Math.max(x.length, y.length);\n          if (n <= 30)\n            return multiplyLong(x, y);\n          n = Math.ceil(n / 2);\n          var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);\n          var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\n          var product5 = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\n          trim2(product5);\n          return product5;\n        }\n        function useKaratsuba(l1, l2) {\n          return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;\n        }\n        BigInteger.prototype.multiply = function(v) {\n          var n = parseValue(v), a = this.value, b = n.value, sign2 = this.sign !== n.sign, abs4;\n          if (n.isSmall) {\n            if (b === 0)\n              return Integer[0];\n            if (b === 1)\n              return this;\n            if (b === -1)\n              return this.negate();\n            abs4 = Math.abs(b);\n            if (abs4 < BASE) {\n              return new BigInteger(multiplySmall(a, abs4), sign2);\n            }\n            b = smallToArray(abs4);\n          }\n          if (useKaratsuba(a.length, b.length))\n            return new BigInteger(multiplyKaratsuba(a, b), sign2);\n          return new BigInteger(multiplyLong(a, b), sign2);\n        };\n        BigInteger.prototype.times = BigInteger.prototype.multiply;\n        function multiplySmallAndArray(a, b, sign2) {\n          if (a < BASE) {\n            return new BigInteger(multiplySmall(b, a), sign2);\n          }\n          return new BigInteger(multiplyLong(b, smallToArray(a)), sign2);\n        }\n        SmallInteger.prototype._multiplyBySmall = function(a) {\n          if (isPrecise(a.value * this.value)) {\n            return new SmallInteger(a.value * this.value);\n          }\n          return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\n        };\n        BigInteger.prototype._multiplyBySmall = function(a) {\n          if (a.value === 0)\n            return Integer[0];\n          if (a.value === 1)\n            return this;\n          if (a.value === -1)\n            return this.negate();\n          return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\n        };\n        SmallInteger.prototype.multiply = function(v) {\n          return parseValue(v)._multiplyBySmall(this);\n        };\n        SmallInteger.prototype.times = SmallInteger.prototype.multiply;\n        NativeBigInt.prototype.multiply = function(v) {\n          return new NativeBigInt(this.value * parseValue(v).value);\n        };\n        NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\n        function square(a) {\n          var l = a.length, r = createArray(l + l), base = BASE, product5, carry, i2, a_i, a_j;\n          for (i2 = 0; i2 < l; i2++) {\n            a_i = a[i2];\n            carry = 0 - a_i * a_i;\n            for (var j = i2; j < l; j++) {\n              a_j = a[j];\n              product5 = 2 * (a_i * a_j) + r[i2 + j] + carry;\n              carry = Math.floor(product5 / base);\n              r[i2 + j] = product5 - carry * base;\n            }\n            r[i2 + l] = carry;\n          }\n          trim2(r);\n          return r;\n        }\n        BigInteger.prototype.square = function() {\n          return new BigInteger(square(this.value), false);\n        };\n        SmallInteger.prototype.square = function() {\n          var value = this.value * this.value;\n          if (isPrecise(value))\n            return new SmallInteger(value);\n          return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\n        };\n        NativeBigInt.prototype.square = function(v) {\n          return new NativeBigInt(this.value * this.value);\n        };\n        function divMod1(a, b) {\n          var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder2 = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l, q;\n          if (remainder2.length <= a_l)\n            remainder2.push(0);\n          divisor.push(0);\n          divisorMostSignificantDigit = divisor[b_l - 1];\n          for (shift = a_l - b_l; shift >= 0; shift--) {\n            quotientDigit = base - 1;\n            if (remainder2[shift + b_l] !== divisorMostSignificantDigit) {\n              quotientDigit = Math.floor((remainder2[shift + b_l] * base + remainder2[shift + b_l - 1]) / divisorMostSignificantDigit);\n            }\n            carry = 0;\n            borrow = 0;\n            l = divisor.length;\n            for (i2 = 0; i2 < l; i2++) {\n              carry += quotientDigit * divisor[i2];\n              q = Math.floor(carry / base);\n              borrow += remainder2[shift + i2] - (carry - q * base);\n              carry = q;\n              if (borrow < 0) {\n                remainder2[shift + i2] = borrow + base;\n                borrow = -1;\n              } else {\n                remainder2[shift + i2] = borrow;\n                borrow = 0;\n              }\n            }\n            while (borrow !== 0) {\n              quotientDigit -= 1;\n              carry = 0;\n              for (i2 = 0; i2 < l; i2++) {\n                carry += remainder2[shift + i2] - base + divisor[i2];\n                if (carry < 0) {\n                  remainder2[shift + i2] = carry + base;\n                  carry = 0;\n                } else {\n                  remainder2[shift + i2] = carry;\n                  carry = 1;\n                }\n              }\n              borrow += carry;\n            }\n            result[shift] = quotientDigit;\n          }\n          remainder2 = divModSmall(remainder2, lambda)[0];\n          return [arrayToSmall(result), arrayToSmall(remainder2)];\n        }\n        function divMod2(a, b) {\n          var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;\n          while (a_l) {\n            part.unshift(a[--a_l]);\n            trim2(part);\n            if (compareAbs(part, b) < 0) {\n              result.push(0);\n              continue;\n            }\n            xlen = part.length;\n            highx = part[xlen - 1] * base + part[xlen - 2];\n            highy = b[b_l - 1] * base + b[b_l - 2];\n            if (xlen > b_l) {\n              highx = (highx + 1) * base;\n            }\n            guess = Math.ceil(highx / highy);\n            do {\n              check = multiplySmall(b, guess);\n              if (compareAbs(check, part) <= 0)\n                break;\n              guess--;\n            } while (guess);\n            result.push(guess);\n            part = subtract(part, check);\n          }\n          result.reverse();\n          return [arrayToSmall(result), arrayToSmall(part)];\n        }\n        function divModSmall(value, lambda) {\n          var length4 = value.length, quotient = createArray(length4), base = BASE, i2, q, remainder2, divisor;\n          remainder2 = 0;\n          for (i2 = length4 - 1; i2 >= 0; --i2) {\n            divisor = remainder2 * base + value[i2];\n            q = truncate(divisor / lambda);\n            remainder2 = divisor - q * lambda;\n            quotient[i2] = q | 0;\n          }\n          return [quotient, remainder2 | 0];\n        }\n        function divModAny(self2, v) {\n          var value, n = parseValue(v);\n          if (supportsNativeBigInt) {\n            return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];\n          }\n          var a = self2.value, b = n.value;\n          var quotient;\n          if (b === 0)\n            throw new Error(\"Cannot divide by zero\");\n          if (self2.isSmall) {\n            if (n.isSmall) {\n              return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\n            }\n            return [Integer[0], self2];\n          }\n          if (n.isSmall) {\n            if (b === 1)\n              return [self2, Integer[0]];\n            if (b == -1)\n              return [self2.negate(), Integer[0]];\n            var abs4 = Math.abs(b);\n            if (abs4 < BASE) {\n              value = divModSmall(a, abs4);\n              quotient = arrayToSmall(value[0]);\n              var remainder2 = value[1];\n              if (self2.sign)\n                remainder2 = -remainder2;\n              if (typeof quotient === \"number\") {\n                if (self2.sign !== n.sign)\n                  quotient = -quotient;\n                return [new SmallInteger(quotient), new SmallInteger(remainder2)];\n              }\n              return [new BigInteger(quotient, self2.sign !== n.sign), new SmallInteger(remainder2)];\n            }\n            b = smallToArray(abs4);\n          }\n          var comparison = compareAbs(a, b);\n          if (comparison === -1)\n            return [Integer[0], self2];\n          if (comparison === 0)\n            return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];\n          if (a.length + b.length <= 200)\n            value = divMod1(a, b);\n          else\n            value = divMod2(a, b);\n          quotient = value[0];\n          var qSign = self2.sign !== n.sign, mod2 = value[1], mSign = self2.sign;\n          if (typeof quotient === \"number\") {\n            if (qSign)\n              quotient = -quotient;\n            quotient = new SmallInteger(quotient);\n          } else\n            quotient = new BigInteger(quotient, qSign);\n          if (typeof mod2 === \"number\") {\n            if (mSign)\n              mod2 = -mod2;\n            mod2 = new SmallInteger(mod2);\n          } else\n            mod2 = new BigInteger(mod2, mSign);\n          return [quotient, mod2];\n        }\n        BigInteger.prototype.divmod = function(v) {\n          var result = divModAny(this, v);\n          return {\n            quotient: result[0],\n            remainder: result[1]\n          };\n        };\n        NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\n        BigInteger.prototype.divide = function(v) {\n          return divModAny(this, v)[0];\n        };\n        NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {\n          return new NativeBigInt(this.value / parseValue(v).value);\n        };\n        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\n        BigInteger.prototype.mod = function(v) {\n          return divModAny(this, v)[1];\n        };\n        NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {\n          return new NativeBigInt(this.value % parseValue(v).value);\n        };\n        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\n        BigInteger.prototype.pow = function(v) {\n          var n = parseValue(v), a = this.value, b = n.value, value, x, y;\n          if (b === 0)\n            return Integer[1];\n          if (a === 0)\n            return Integer[0];\n          if (a === 1)\n            return Integer[1];\n          if (a === -1)\n            return n.isEven() ? Integer[1] : Integer[-1];\n          if (n.sign) {\n            return Integer[0];\n          }\n          if (!n.isSmall)\n            throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\n          if (this.isSmall) {\n            if (isPrecise(value = Math.pow(a, b)))\n              return new SmallInteger(truncate(value));\n          }\n          x = this;\n          y = Integer[1];\n          while (true) {\n            if (b & true) {\n              y = y.times(x);\n              --b;\n            }\n            if (b === 0)\n              break;\n            b /= 2;\n            x = x.square();\n          }\n          return y;\n        };\n        SmallInteger.prototype.pow = BigInteger.prototype.pow;\n        NativeBigInt.prototype.pow = function(v) {\n          var n = parseValue(v);\n          var a = this.value, b = n.value;\n          var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\n          if (b === _0)\n            return Integer[1];\n          if (a === _0)\n            return Integer[0];\n          if (a === _1)\n            return Integer[1];\n          if (a === BigInt(-1))\n            return n.isEven() ? Integer[1] : Integer[-1];\n          if (n.isNegative())\n            return new NativeBigInt(_0);\n          var x = this;\n          var y = Integer[1];\n          while (true) {\n            if ((b & _1) === _1) {\n              y = y.times(x);\n              --b;\n            }\n            if (b === _0)\n              break;\n            b /= _2;\n            x = x.square();\n          }\n          return y;\n        };\n        BigInteger.prototype.modPow = function(exp2, mod2) {\n          exp2 = parseValue(exp2);\n          mod2 = parseValue(mod2);\n          if (mod2.isZero())\n            throw new Error(\"Cannot take modPow with modulus 0\");\n          var r = Integer[1], base = this.mod(mod2);\n          if (exp2.isNegative()) {\n            exp2 = exp2.multiply(Integer[-1]);\n            base = base.modInv(mod2);\n          }\n          while (exp2.isPositive()) {\n            if (base.isZero())\n              return Integer[0];\n            if (exp2.isOdd())\n              r = r.multiply(base).mod(mod2);\n            exp2 = exp2.divide(2);\n            base = base.square().mod(mod2);\n          }\n          return r;\n        };\n        NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\n        function compareAbs(a, b) {\n          if (a.length !== b.length) {\n            return a.length > b.length ? 1 : -1;\n          }\n          for (var i2 = a.length - 1; i2 >= 0; i2--) {\n            if (a[i2] !== b[i2])\n              return a[i2] > b[i2] ? 1 : -1;\n          }\n          return 0;\n        }\n        BigInteger.prototype.compareAbs = function(v) {\n          var n = parseValue(v), a = this.value, b = n.value;\n          if (n.isSmall)\n            return 1;\n          return compareAbs(a, b);\n        };\n        SmallInteger.prototype.compareAbs = function(v) {\n          var n = parseValue(v), a = Math.abs(this.value), b = n.value;\n          if (n.isSmall) {\n            b = Math.abs(b);\n            return a === b ? 0 : a > b ? 1 : -1;\n          }\n          return -1;\n        };\n        NativeBigInt.prototype.compareAbs = function(v) {\n          var a = this.value;\n          var b = parseValue(v).value;\n          a = a >= 0 ? a : -a;\n          b = b >= 0 ? b : -b;\n          return a === b ? 0 : a > b ? 1 : -1;\n        };\n        BigInteger.prototype.compare = function(v) {\n          if (v === Infinity) {\n            return -1;\n          }\n          if (v === -Infinity) {\n            return 1;\n          }\n          var n = parseValue(v), a = this.value, b = n.value;\n          if (this.sign !== n.sign) {\n            return n.sign ? 1 : -1;\n          }\n          if (n.isSmall) {\n            return this.sign ? -1 : 1;\n          }\n          return compareAbs(a, b) * (this.sign ? -1 : 1);\n        };\n        BigInteger.prototype.compareTo = BigInteger.prototype.compare;\n        SmallInteger.prototype.compare = function(v) {\n          if (v === Infinity) {\n            return -1;\n          }\n          if (v === -Infinity) {\n            return 1;\n          }\n          var n = parseValue(v), a = this.value, b = n.value;\n          if (n.isSmall) {\n            return a == b ? 0 : a > b ? 1 : -1;\n          }\n          if (a < 0 !== n.sign) {\n            return a < 0 ? -1 : 1;\n          }\n          return a < 0 ? 1 : -1;\n        };\n        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\n        NativeBigInt.prototype.compare = function(v) {\n          if (v === Infinity) {\n            return -1;\n          }\n          if (v === -Infinity) {\n            return 1;\n          }\n          var a = this.value;\n          var b = parseValue(v).value;\n          return a === b ? 0 : a > b ? 1 : -1;\n        };\n        NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\n        BigInteger.prototype.equals = function(v) {\n          return this.compare(v) === 0;\n        };\n        NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\n        BigInteger.prototype.notEquals = function(v) {\n          return this.compare(v) !== 0;\n        };\n        NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\n        BigInteger.prototype.greater = function(v) {\n          return this.compare(v) > 0;\n        };\n        NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\n        BigInteger.prototype.lesser = function(v) {\n          return this.compare(v) < 0;\n        };\n        NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\n        BigInteger.prototype.greaterOrEquals = function(v) {\n          return this.compare(v) >= 0;\n        };\n        NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\n        BigInteger.prototype.lesserOrEquals = function(v) {\n          return this.compare(v) <= 0;\n        };\n        NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\n        BigInteger.prototype.isEven = function() {\n          return (this.value[0] & 1) === 0;\n        };\n        SmallInteger.prototype.isEven = function() {\n          return (this.value & 1) === 0;\n        };\n        NativeBigInt.prototype.isEven = function() {\n          return (this.value & BigInt(1)) === BigInt(0);\n        };\n        BigInteger.prototype.isOdd = function() {\n          return (this.value[0] & 1) === 1;\n        };\n        SmallInteger.prototype.isOdd = function() {\n          return (this.value & 1) === 1;\n        };\n        NativeBigInt.prototype.isOdd = function() {\n          return (this.value & BigInt(1)) === BigInt(1);\n        };\n        BigInteger.prototype.isPositive = function() {\n          return !this.sign;\n        };\n        SmallInteger.prototype.isPositive = function() {\n          return this.value > 0;\n        };\n        NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\n        BigInteger.prototype.isNegative = function() {\n          return this.sign;\n        };\n        SmallInteger.prototype.isNegative = function() {\n          return this.value < 0;\n        };\n        NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\n        BigInteger.prototype.isUnit = function() {\n          return false;\n        };\n        SmallInteger.prototype.isUnit = function() {\n          return Math.abs(this.value) === 1;\n        };\n        NativeBigInt.prototype.isUnit = function() {\n          return this.abs().value === BigInt(1);\n        };\n        BigInteger.prototype.isZero = function() {\n          return false;\n        };\n        SmallInteger.prototype.isZero = function() {\n          return this.value === 0;\n        };\n        NativeBigInt.prototype.isZero = function() {\n          return this.value === BigInt(0);\n        };\n        BigInteger.prototype.isDivisibleBy = function(v) {\n          var n = parseValue(v);\n          if (n.isZero())\n            return false;\n          if (n.isUnit())\n            return true;\n          if (n.compareAbs(2) === 0)\n            return this.isEven();\n          return this.mod(n).isZero();\n        };\n        NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\n        function isBasicPrime(v) {\n          var n = v.abs();\n          if (n.isUnit())\n            return false;\n          if (n.equals(2) || n.equals(3) || n.equals(5))\n            return true;\n          if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))\n            return false;\n          if (n.lesser(49))\n            return true;\n        }\n        function millerRabinTest(n, a) {\n          var nPrev = n.prev(), b = nPrev, r = 0, d, t, i2, x;\n          while (b.isEven())\n            b = b.divide(2), r++;\n          next:\n            for (i2 = 0; i2 < a.length; i2++) {\n              if (n.lesser(a[i2]))\n                continue;\n              x = bigInt2(a[i2]).modPow(b, n);\n              if (x.isUnit() || x.equals(nPrev))\n                continue;\n              for (d = r - 1; d != 0; d--) {\n                x = x.square().mod(n);\n                if (x.isUnit())\n                  return false;\n                if (x.equals(nPrev))\n                  continue next;\n              }\n              return false;\n            }\n          return true;\n        }\n        BigInteger.prototype.isPrime = function(strict) {\n          var isPrime = isBasicPrime(this);\n          if (isPrime !== undefined2)\n            return isPrime;\n          var n = this.abs();\n          var bits = n.bitLength();\n          if (bits <= 64)\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\n          var logN = Math.log(2) * bits.toJSNumber();\n          var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);\n          for (var a = [], i2 = 0; i2 < t; i2++) {\n            a.push(bigInt2(i2 + 2));\n          }\n          return millerRabinTest(n, a);\n        };\n        NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\n        BigInteger.prototype.isProbablePrime = function(iterations, rng) {\n          var isPrime = isBasicPrime(this);\n          if (isPrime !== undefined2)\n            return isPrime;\n          var n = this.abs();\n          var t = iterations === undefined2 ? 5 : iterations;\n          for (var a = [], i2 = 0; i2 < t; i2++) {\n            a.push(bigInt2.randBetween(2, n.minus(2), rng));\n          }\n          return millerRabinTest(n, a);\n        };\n        NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\n        BigInteger.prototype.modInv = function(n) {\n          var t = bigInt2.zero, newT = bigInt2.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\n          while (!newR.isZero()) {\n            q = r.divide(newR);\n            lastT = t;\n            lastR = r;\n            t = newT;\n            r = newR;\n            newT = lastT.subtract(q.multiply(newT));\n            newR = lastR.subtract(q.multiply(newR));\n          }\n          if (!r.isUnit())\n            throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\n          if (t.compare(0) === -1) {\n            t = t.add(n);\n          }\n          if (this.isNegative()) {\n            return t.negate();\n          }\n          return t;\n        };\n        NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\n        BigInteger.prototype.next = function() {\n          var value = this.value;\n          if (this.sign) {\n            return subtractSmall(value, 1, this.sign);\n          }\n          return new BigInteger(addSmall(value, 1), this.sign);\n        };\n        SmallInteger.prototype.next = function() {\n          var value = this.value;\n          if (value + 1 < MAX_INT)\n            return new SmallInteger(value + 1);\n          return new BigInteger(MAX_INT_ARR, false);\n        };\n        NativeBigInt.prototype.next = function() {\n          return new NativeBigInt(this.value + BigInt(1));\n        };\n        BigInteger.prototype.prev = function() {\n          var value = this.value;\n          if (this.sign) {\n            return new BigInteger(addSmall(value, 1), true);\n          }\n          return subtractSmall(value, 1, this.sign);\n        };\n        SmallInteger.prototype.prev = function() {\n          var value = this.value;\n          if (value - 1 > -MAX_INT)\n            return new SmallInteger(value - 1);\n          return new BigInteger(MAX_INT_ARR, true);\n        };\n        NativeBigInt.prototype.prev = function() {\n          return new NativeBigInt(this.value - BigInt(1));\n        };\n        var powersOfTwo = [1];\n        while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)\n          powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\n        var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\n        function shift_isSmall(n) {\n          return Math.abs(n) <= BASE;\n        }\n        BigInteger.prototype.shiftLeft = function(v) {\n          var n = parseValue(v).toJSNumber();\n          if (!shift_isSmall(n)) {\n            throw new Error(String(n) + \" is too large for shifting.\");\n          }\n          if (n < 0)\n            return this.shiftRight(-n);\n          var result = this;\n          if (result.isZero())\n            return result;\n          while (n >= powers2Length) {\n            result = result.multiply(highestPower2);\n            n -= powers2Length - 1;\n          }\n          return result.multiply(powersOfTwo[n]);\n        };\n        NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\n        BigInteger.prototype.shiftRight = function(v) {\n          var remQuo;\n          var n = parseValue(v).toJSNumber();\n          if (!shift_isSmall(n)) {\n            throw new Error(String(n) + \" is too large for shifting.\");\n          }\n          if (n < 0)\n            return this.shiftLeft(-n);\n          var result = this;\n          while (n >= powers2Length) {\n            if (result.isZero() || result.isNegative() && result.isUnit())\n              return result;\n            remQuo = divModAny(result, highestPower2);\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n            n -= powers2Length - 1;\n          }\n          remQuo = divModAny(result, powersOfTwo[n]);\n          return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n        };\n        NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\n        function bitwise(x, y, fn) {\n          y = parseValue(y);\n          var xSign = x.isNegative(), ySign = y.isNegative();\n          var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;\n          var xDigit = 0, yDigit = 0;\n          var xDivMod = null, yDivMod = null;\n          var result = [];\n          while (!xRem.isZero() || !yRem.isZero()) {\n            xDivMod = divModAny(xRem, highestPower2);\n            xDigit = xDivMod[1].toJSNumber();\n            if (xSign) {\n              xDigit = highestPower2 - 1 - xDigit;\n            }\n            yDivMod = divModAny(yRem, highestPower2);\n            yDigit = yDivMod[1].toJSNumber();\n            if (ySign) {\n              yDigit = highestPower2 - 1 - yDigit;\n            }\n            xRem = xDivMod[0];\n            yRem = yDivMod[0];\n            result.push(fn(xDigit, yDigit));\n          }\n          var sum3 = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);\n          for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {\n            sum3 = sum3.multiply(highestPower2).add(bigInt2(result[i2]));\n          }\n          return sum3;\n        }\n        BigInteger.prototype.not = function() {\n          return this.negate().prev();\n        };\n        NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\n        BigInteger.prototype.and = function(n) {\n          return bitwise(this, n, function(a, b) {\n            return a & b;\n          });\n        };\n        NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\n        BigInteger.prototype.or = function(n) {\n          return bitwise(this, n, function(a, b) {\n            return a | b;\n          });\n        };\n        NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\n        BigInteger.prototype.xor = function(n) {\n          return bitwise(this, n, function(a, b) {\n            return a ^ b;\n          });\n        };\n        NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\n        var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\n        function roughLOB(n) {\n          var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;\n          return x & -x;\n        }\n        function integerLogarithm(value, base) {\n          if (base.compareTo(value) <= 0) {\n            var tmp = integerLogarithm(value, base.square(base));\n            var p = tmp.p;\n            var e = tmp.e;\n            var t = p.multiply(base);\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };\n          }\n          return { p: bigInt2(1), e: 0 };\n        }\n        BigInteger.prototype.bitLength = function() {\n          var n = this;\n          if (n.compareTo(bigInt2(0)) < 0) {\n            n = n.negate().subtract(bigInt2(1));\n          }\n          if (n.compareTo(bigInt2(0)) === 0) {\n            return bigInt2(0);\n          }\n          return bigInt2(integerLogarithm(n, bigInt2(2)).e).add(bigInt2(1));\n        };\n        NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\n        function max3(a, b) {\n          a = parseValue(a);\n          b = parseValue(b);\n          return a.greater(b) ? a : b;\n        }\n        function min5(a, b) {\n          a = parseValue(a);\n          b = parseValue(b);\n          return a.lesser(b) ? a : b;\n        }\n        function gcd(a, b) {\n          a = parseValue(a).abs();\n          b = parseValue(b).abs();\n          if (a.equals(b))\n            return a;\n          if (a.isZero())\n            return b;\n          if (b.isZero())\n            return a;\n          var c = Integer[1], d, t;\n          while (a.isEven() && b.isEven()) {\n            d = min5(roughLOB(a), roughLOB(b));\n            a = a.divide(d);\n            b = b.divide(d);\n            c = c.multiply(d);\n          }\n          while (a.isEven()) {\n            a = a.divide(roughLOB(a));\n          }\n          do {\n            while (b.isEven()) {\n              b = b.divide(roughLOB(b));\n            }\n            if (a.greater(b)) {\n              t = b;\n              b = a;\n              a = t;\n            }\n            b = b.subtract(a);\n          } while (!b.isZero());\n          return c.isUnit() ? a : a.multiply(c);\n        }\n        function lcm(a, b) {\n          a = parseValue(a).abs();\n          b = parseValue(b).abs();\n          return a.divide(gcd(a, b)).multiply(b);\n        }\n        function randBetween(a, b, rng) {\n          a = parseValue(a);\n          b = parseValue(b);\n          var usedRNG = rng || Math.random;\n          var low = min5(a, b), high = max3(a, b);\n          var range3 = high.subtract(low).add(1);\n          if (range3.isSmall)\n            return low.add(Math.floor(usedRNG() * range3));\n          var digits = toBase2(range3, BASE).value;\n          var result = [], restricted = true;\n          for (var i2 = 0; i2 < digits.length; i2++) {\n            var top3 = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;\n            var digit = truncate(usedRNG() * top3);\n            result.push(digit);\n            if (digit < digits[i2])\n              restricted = false;\n          }\n          return low.add(Integer.fromArray(result, BASE, false));\n        }\n        var parseBase = function(text, base, alphabet, caseSensitive) {\n          alphabet = alphabet || DEFAULT_ALPHABET;\n          text = String(text);\n          if (!caseSensitive) {\n            text = text.toLowerCase();\n            alphabet = alphabet.toLowerCase();\n          }\n          var length4 = text.length;\n          var i2;\n          var absBase = Math.abs(base);\n          var alphabetValues = {};\n          for (i2 = 0; i2 < alphabet.length; i2++) {\n            alphabetValues[alphabet[i2]] = i2;\n          }\n          for (i2 = 0; i2 < length4; i2++) {\n            var c = text[i2];\n            if (c === \"-\")\n              continue;\n            if (c in alphabetValues) {\n              if (alphabetValues[c] >= absBase) {\n                if (c === \"1\" && absBase === 1)\n                  continue;\n                throw new Error(c + \" is not a valid digit in base \" + base + \".\");\n              }\n            }\n          }\n          base = parseValue(base);\n          var digits = [];\n          var isNegative = text[0] === \"-\";\n          for (i2 = isNegative ? 1 : 0; i2 < text.length; i2++) {\n            var c = text[i2];\n            if (c in alphabetValues)\n              digits.push(parseValue(alphabetValues[c]));\n            else if (c === \"<\") {\n              var start = i2;\n              do {\n                i2++;\n              } while (text[i2] !== \">\" && i2 < text.length);\n              digits.push(parseValue(text.slice(start + 1, i2)));\n            } else\n              throw new Error(c + \" is not a valid character\");\n          }\n          return parseBaseFromArray(digits, base, isNegative);\n        };\n        function parseBaseFromArray(digits, base, isNegative) {\n          var val = Integer[0], pow4 = Integer[1], i2;\n          for (i2 = digits.length - 1; i2 >= 0; i2--) {\n            val = val.add(digits[i2].times(pow4));\n            pow4 = pow4.times(base);\n          }\n          return isNegative ? val.negate() : val;\n        }\n        function stringify2(digit, alphabet) {\n          alphabet = alphabet || DEFAULT_ALPHABET;\n          if (digit < alphabet.length) {\n            return alphabet[digit];\n          }\n          return \"<\" + digit + \">\";\n        }\n        function toBase2(n, base) {\n          base = bigInt2(base);\n          if (base.isZero()) {\n            if (n.isZero())\n              return { value: [0], isNegative: false };\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\n          }\n          if (base.equals(-1)) {\n            if (n.isZero())\n              return { value: [0], isNegative: false };\n            if (n.isNegative())\n              return {\n                value: [].concat.apply(\n                  [],\n                  Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])\n                ),\n                isNegative: false\n              };\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);\n            arr.unshift([1]);\n            return {\n              value: [].concat.apply([], arr),\n              isNegative: false\n            };\n          }\n          var neg = false;\n          if (n.isNegative() && base.isPositive()) {\n            neg = true;\n            n = n.abs();\n          }\n          if (base.isUnit()) {\n            if (n.isZero())\n              return { value: [0], isNegative: false };\n            return {\n              value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),\n              isNegative: neg\n            };\n          }\n          var out = [];\n          var left = n, divmod;\n          while (left.isNegative() || left.compareAbs(base) >= 0) {\n            divmod = left.divmod(base);\n            left = divmod.quotient;\n            var digit = divmod.remainder;\n            if (digit.isNegative()) {\n              digit = base.minus(digit).abs();\n              left = left.next();\n            }\n            out.push(digit.toJSNumber());\n          }\n          out.push(left.toJSNumber());\n          return { value: out.reverse(), isNegative: neg };\n        }\n        function toBaseString(n, base, alphabet) {\n          var arr = toBase2(n, base);\n          return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function(x) {\n            return stringify2(x, alphabet);\n          }).join(\"\");\n        }\n        BigInteger.prototype.toArray = function(radix) {\n          return toBase2(this, radix);\n        };\n        SmallInteger.prototype.toArray = function(radix) {\n          return toBase2(this, radix);\n        };\n        NativeBigInt.prototype.toArray = function(radix) {\n          return toBase2(this, radix);\n        };\n        BigInteger.prototype.toString = function(radix, alphabet) {\n          if (radix === undefined2)\n            radix = 10;\n          if (radix !== 10 || alphabet)\n            return toBaseString(this, radix, alphabet);\n          var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\n          while (--l >= 0) {\n            digit = String(v[l]);\n            str += zeros.slice(digit.length) + digit;\n          }\n          var sign2 = this.sign ? \"-\" : \"\";\n          return sign2 + str;\n        };\n        SmallInteger.prototype.toString = function(radix, alphabet) {\n          if (radix === undefined2)\n            radix = 10;\n          if (radix != 10 || alphabet)\n            return toBaseString(this, radix, alphabet);\n          return String(this.value);\n        };\n        NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\n        NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {\n          return this.toString();\n        };\n        BigInteger.prototype.valueOf = function() {\n          return parseInt(this.toString(), 10);\n        };\n        BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\n        SmallInteger.prototype.valueOf = function() {\n          return this.value;\n        };\n        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\n        NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {\n          return parseInt(this.toString(), 10);\n        };\n        function parseStringValue(v) {\n          if (isPrecise(+v)) {\n            var x = +v;\n            if (x === truncate(x))\n              return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\n            throw new Error(\"Invalid integer: \" + v);\n          }\n          var sign2 = v[0] === \"-\";\n          if (sign2)\n            v = v.slice(1);\n          var split2 = v.split(/e/i);\n          if (split2.length > 2)\n            throw new Error(\"Invalid integer: \" + split2.join(\"e\"));\n          if (split2.length === 2) {\n            var exp2 = split2[1];\n            if (exp2[0] === \"+\")\n              exp2 = exp2.slice(1);\n            exp2 = +exp2;\n            if (exp2 !== truncate(exp2) || !isPrecise(exp2))\n              throw new Error(\"Invalid integer: \" + exp2 + \" is not a valid exponent.\");\n            var text = split2[0];\n            var decimalPlace = text.indexOf(\".\");\n            if (decimalPlace >= 0) {\n              exp2 -= text.length - decimalPlace - 1;\n              text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\n            }\n            if (exp2 < 0)\n              throw new Error(\"Cannot include negative exponent part for integers\");\n            text += new Array(exp2 + 1).join(\"0\");\n            v = text;\n          }\n          var isValid = /^([0-9][0-9]*)$/.test(v);\n          if (!isValid)\n            throw new Error(\"Invalid integer: \" + v);\n          if (supportsNativeBigInt) {\n            return new NativeBigInt(BigInt(sign2 ? \"-\" + v : v));\n          }\n          var r = [], max4 = v.length, l = LOG_BASE, min6 = max4 - l;\n          while (max4 > 0) {\n            r.push(+v.slice(min6, max4));\n            min6 -= l;\n            if (min6 < 0)\n              min6 = 0;\n            max4 -= l;\n          }\n          trim2(r);\n          return new BigInteger(r, sign2);\n        }\n        function parseNumberValue(v) {\n          if (supportsNativeBigInt) {\n            return new NativeBigInt(BigInt(v));\n          }\n          if (isPrecise(v)) {\n            if (v !== truncate(v))\n              throw new Error(v + \" is not an integer.\");\n            return new SmallInteger(v);\n          }\n          return parseStringValue(v.toString());\n        }\n        function parseValue(v) {\n          if (typeof v === \"number\") {\n            return parseNumberValue(v);\n          }\n          if (typeof v === \"string\") {\n            return parseStringValue(v);\n          }\n          if (typeof v === \"bigint\") {\n            return new NativeBigInt(v);\n          }\n          return v;\n        }\n        for (var i = 0; i < 1e3; i++) {\n          Integer[i] = parseValue(i);\n          if (i > 0)\n            Integer[-i] = parseValue(-i);\n        }\n        Integer.one = Integer[1];\n        Integer.zero = Integer[0];\n        Integer.minusOne = Integer[-1];\n        Integer.max = max3;\n        Integer.min = min5;\n        Integer.gcd = gcd;\n        Integer.lcm = lcm;\n        Integer.isInstance = function(x) {\n          return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;\n        };\n        Integer.randBetween = randBetween;\n        Integer.fromArray = function(digits, base, isNegative) {\n          return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\n        };\n        return Integer;\n      }();\n      if (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\n        module.exports = bigInt2;\n      }\n      if (typeof define === \"function\" && define.amd) {\n        define(function() {\n          return bigInt2;\n        });\n      }\n    }\n  });\n\n  // output/Control.Bind/foreign.js\n  var arrayBind = function(arr) {\n    return function(f2) {\n      var result = [];\n      for (var i = 0, l = arr.length; i < l; i++) {\n        Array.prototype.push.apply(result, f2(arr[i]));\n      }\n      return result;\n    };\n  };\n\n  // output/Control.Apply/foreign.js\n  var arrayApply = function(fs) {\n    return function(xs) {\n      var l = fs.length;\n      var k = xs.length;\n      var result = new Array(l * k);\n      var n = 0;\n      for (var i = 0; i < l; i++) {\n        var f2 = fs[i];\n        for (var j = 0; j < k; j++) {\n          result[n++] = f2(xs[j]);\n        }\n      }\n      return result;\n    };\n  };\n\n  // output/Control.Semigroupoid/index.js\n  var semigroupoidFn = {\n    compose: function(f2) {\n      return function(g) {\n        return function(x) {\n          return f2(g(x));\n        };\n      };\n    }\n  };\n  var compose = function(dict) {\n    return dict.compose;\n  };\n\n  // output/Control.Category/index.js\n  var identity = function(dict) {\n    return dict.identity;\n  };\n  var categoryFn = {\n    identity: function(x) {\n      return x;\n    },\n    Semigroupoid0: function() {\n      return semigroupoidFn;\n    }\n  };\n\n  // output/Data.Boolean/index.js\n  var otherwise = true;\n\n  // output/Data.Function/index.js\n  var on = function(f2) {\n    return function(g) {\n      return function(x) {\n        return function(y) {\n          return f2(g(x))(g(y));\n        };\n      };\n    };\n  };\n  var flip = function(f2) {\n    return function(b) {\n      return function(a) {\n        return f2(a)(b);\n      };\n    };\n  };\n  var $$const = function(a) {\n    return function(v) {\n      return a;\n    };\n  };\n\n  // output/Data.Functor/foreign.js\n  var arrayMap = function(f2) {\n    return function(arr) {\n      var l = arr.length;\n      var result = new Array(l);\n      for (var i = 0; i < l; i++) {\n        result[i] = f2(arr[i]);\n      }\n      return result;\n    };\n  };\n\n  // output/Data.Unit/foreign.js\n  var unit = void 0;\n\n  // output/Type.Proxy/index.js\n  var $$Proxy = /* @__PURE__ */ function() {\n    function $$Proxy2() {\n    }\n    ;\n    $$Proxy2.value = new $$Proxy2();\n    return $$Proxy2;\n  }();\n\n  // output/Data.Functor/index.js\n  var map = function(dict) {\n    return dict.map;\n  };\n  var mapFlipped = function(dictFunctor) {\n    var map12 = map(dictFunctor);\n    return function(fa) {\n      return function(f2) {\n        return map12(f2)(fa);\n      };\n    };\n  };\n  var $$void = function(dictFunctor) {\n    return map(dictFunctor)($$const(unit));\n  };\n  var functorFn = {\n    map: /* @__PURE__ */ compose(semigroupoidFn)\n  };\n  var functorArray = {\n    map: arrayMap\n  };\n  var flap = function(dictFunctor) {\n    var map12 = map(dictFunctor);\n    return function(ff2) {\n      return function(x) {\n        return map12(function(f2) {\n          return f2(x);\n        })(ff2);\n      };\n    };\n  };\n\n  // output/Control.Apply/index.js\n  var applyArray = {\n    apply: arrayApply,\n    Functor0: function() {\n      return functorArray;\n    }\n  };\n  var apply = function(dict) {\n    return dict.apply;\n  };\n\n  // output/Control.Applicative/index.js\n  var pure = function(dict) {\n    return dict.pure;\n  };\n  var when = function(dictApplicative) {\n    var pure1 = pure(dictApplicative);\n    return function(v) {\n      return function(v1) {\n        if (v) {\n          return v1;\n        }\n        ;\n        if (!v) {\n          return pure1(unit);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    };\n  };\n  var liftA1 = function(dictApplicative) {\n    var apply2 = apply(dictApplicative.Apply0());\n    var pure1 = pure(dictApplicative);\n    return function(f2) {\n      return function(a) {\n        return apply2(pure1(f2))(a);\n      };\n    };\n  };\n  var applicativeArray = {\n    pure: function(x) {\n      return [x];\n    },\n    Apply0: function() {\n      return applyArray;\n    }\n  };\n\n  // output/Control.Bind/index.js\n  var bindArray = {\n    bind: arrayBind,\n    Apply0: function() {\n      return applyArray;\n    }\n  };\n  var bind = function(dict) {\n    return dict.bind;\n  };\n  var bindFlipped = function(dictBind) {\n    return flip(bind(dictBind));\n  };\n  var composeKleisliFlipped = function(dictBind) {\n    var bindFlipped1 = bindFlipped(dictBind);\n    return function(f2) {\n      return function(g) {\n        return function(a) {\n          return bindFlipped1(f2)(g(a));\n        };\n      };\n    };\n  };\n\n  // output/Data.Argonaut.Core/foreign.js\n  function stringify(j) {\n    return JSON.stringify(j);\n  }\n  function _caseJson(isNull3, isBool, isNum, isStr, isArr, isObj, j) {\n    if (j == null)\n      return isNull3();\n    else if (typeof j === \"boolean\")\n      return isBool(j);\n    else if (typeof j === \"number\")\n      return isNum(j);\n    else if (typeof j === \"string\")\n      return isStr(j);\n    else if (Object.prototype.toString.call(j) === \"[object Array]\")\n      return isArr(j);\n    else\n      return isObj(j);\n  }\n\n  // output/Data.Eq/foreign.js\n  var refEq = function(r1) {\n    return function(r2) {\n      return r1 === r2;\n    };\n  };\n  var eqIntImpl = refEq;\n  var eqStringImpl = refEq;\n  var eqArrayImpl = function(f2) {\n    return function(xs) {\n      return function(ys) {\n        if (xs.length !== ys.length)\n          return false;\n        for (var i = 0; i < xs.length; i++) {\n          if (!f2(xs[i])(ys[i]))\n            return false;\n        }\n        return true;\n      };\n    };\n  };\n\n  // output/Data.Symbol/index.js\n  var reflectSymbol = function(dict) {\n    return dict.reflectSymbol;\n  };\n\n  // output/Record.Unsafe/foreign.js\n  var unsafeGet = function(label) {\n    return function(rec) {\n      return rec[label];\n    };\n  };\n  var unsafeSet = function(label) {\n    return function(value) {\n      return function(rec) {\n        var copy = {};\n        for (var key in rec) {\n          if ({}.hasOwnProperty.call(rec, key)) {\n            copy[key] = rec[key];\n          }\n        }\n        copy[label] = value;\n        return copy;\n      };\n    };\n  };\n\n  // output/Data.Eq/index.js\n  var eqString = {\n    eq: eqStringImpl\n  };\n  var eqRowNil = {\n    eqRecord: function(v) {\n      return function(v1) {\n        return function(v2) {\n          return true;\n        };\n      };\n    }\n  };\n  var eqRecord = function(dict) {\n    return dict.eqRecord;\n  };\n  var eqRec = function() {\n    return function(dictEqRecord) {\n      return {\n        eq: eqRecord(dictEqRecord)($$Proxy.value)\n      };\n    };\n  };\n  var eqInt = {\n    eq: eqIntImpl\n  };\n  var eq = function(dict) {\n    return dict.eq;\n  };\n  var eqArray = function(dictEq) {\n    return {\n      eq: eqArrayImpl(eq(dictEq))\n    };\n  };\n  var eqRowCons = function(dictEqRecord) {\n    var eqRecord1 = eqRecord(dictEqRecord);\n    return function() {\n      return function(dictIsSymbol) {\n        var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n        return function(dictEq) {\n          var eq32 = eq(dictEq);\n          return {\n            eqRecord: function(v) {\n              return function(ra) {\n                return function(rb) {\n                  var tail2 = eqRecord1($$Proxy.value)(ra)(rb);\n                  var key = reflectSymbol2($$Proxy.value);\n                  var get2 = unsafeGet(key);\n                  return eq32(get2(ra))(get2(rb)) && tail2;\n                };\n              };\n            }\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Semigroup/foreign.js\n  var concatArray = function(xs) {\n    return function(ys) {\n      if (xs.length === 0)\n        return ys;\n      if (ys.length === 0)\n        return xs;\n      return xs.concat(ys);\n    };\n  };\n\n  // output/Data.Semigroup/index.js\n  var semigroupArray = {\n    append: concatArray\n  };\n  var append = function(dict) {\n    return dict.append;\n  };\n\n  // output/Control.Alt/index.js\n  var altArray = {\n    alt: /* @__PURE__ */ append(semigroupArray),\n    Functor0: function() {\n      return functorArray;\n    }\n  };\n\n  // output/Data.Bounded/foreign.js\n  var topInt = 2147483647;\n  var bottomInt = -2147483648;\n  var topChar = String.fromCharCode(65535);\n  var bottomChar = String.fromCharCode(0);\n  var topNumber = Number.POSITIVE_INFINITY;\n  var bottomNumber = Number.NEGATIVE_INFINITY;\n\n  // output/Data.Ord/foreign.js\n  var unsafeCompareImpl = function(lt) {\n    return function(eq4) {\n      return function(gt) {\n        return function(x) {\n          return function(y) {\n            return x < y ? lt : x === y ? eq4 : gt;\n          };\n        };\n      };\n    };\n  };\n  var ordIntImpl = unsafeCompareImpl;\n  var ordStringImpl = unsafeCompareImpl;\n\n  // output/Data.Ordering/index.js\n  var LT = /* @__PURE__ */ function() {\n    function LT2() {\n    }\n    ;\n    LT2.value = new LT2();\n    return LT2;\n  }();\n  var GT = /* @__PURE__ */ function() {\n    function GT2() {\n    }\n    ;\n    GT2.value = new GT2();\n    return GT2;\n  }();\n  var EQ = /* @__PURE__ */ function() {\n    function EQ2() {\n    }\n    ;\n    EQ2.value = new EQ2();\n    return EQ2;\n  }();\n  var eqOrdering = {\n    eq: function(v) {\n      return function(v1) {\n        if (v instanceof LT && v1 instanceof LT) {\n          return true;\n        }\n        ;\n        if (v instanceof GT && v1 instanceof GT) {\n          return true;\n        }\n        ;\n        if (v instanceof EQ && v1 instanceof EQ) {\n          return true;\n        }\n        ;\n        return false;\n      };\n    }\n  };\n\n  // output/Data.Semiring/foreign.js\n  var intAdd = function(x) {\n    return function(y) {\n      return x + y | 0;\n    };\n  };\n  var intMul = function(x) {\n    return function(y) {\n      return x * y | 0;\n    };\n  };\n\n  // output/Data.Semiring/index.js\n  var zero = function(dict) {\n    return dict.zero;\n  };\n  var semiringInt = {\n    add: intAdd,\n    zero: 0,\n    mul: intMul,\n    one: 1\n  };\n  var one = function(dict) {\n    return dict.one;\n  };\n  var mul = function(dict) {\n    return dict.mul;\n  };\n  var add = function(dict) {\n    return dict.add;\n  };\n\n  // output/Data.Ring/index.js\n  var sub = function(dict) {\n    return dict.sub;\n  };\n\n  // output/Data.Ord/index.js\n  var ordString = /* @__PURE__ */ function() {\n    return {\n      compare: ordStringImpl(LT.value)(EQ.value)(GT.value),\n      Eq0: function() {\n        return eqString;\n      }\n    };\n  }();\n  var ordInt = /* @__PURE__ */ function() {\n    return {\n      compare: ordIntImpl(LT.value)(EQ.value)(GT.value),\n      Eq0: function() {\n        return eqInt;\n      }\n    };\n  }();\n  var compare = function(dict) {\n    return dict.compare;\n  };\n  var comparing = function(dictOrd) {\n    var compare32 = compare(dictOrd);\n    return function(f2) {\n      return function(x) {\n        return function(y) {\n          return compare32(f2(x))(f2(y));\n        };\n      };\n    };\n  };\n  var greaterThanOrEq = function(dictOrd) {\n    var compare32 = compare(dictOrd);\n    return function(a1) {\n      return function(a2) {\n        var v = compare32(a1)(a2);\n        if (v instanceof LT) {\n          return false;\n        }\n        ;\n        return true;\n      };\n    };\n  };\n  var min = function(dictOrd) {\n    var compare32 = compare(dictOrd);\n    return function(x) {\n      return function(y) {\n        var v = compare32(x)(y);\n        if (v instanceof LT) {\n          return x;\n        }\n        ;\n        if (v instanceof EQ) {\n          return x;\n        }\n        ;\n        if (v instanceof GT) {\n          return y;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): \" + [v.constructor.name]);\n      };\n    };\n  };\n\n  // output/Data.Bounded/index.js\n  var top = function(dict) {\n    return dict.top;\n  };\n  var boundedInt = {\n    top: topInt,\n    bottom: bottomInt,\n    Ord0: function() {\n      return ordInt;\n    }\n  };\n  var bottom = function(dict) {\n    return dict.bottom;\n  };\n\n  // output/Data.Show/foreign.js\n  var showIntImpl = function(n) {\n    return n.toString();\n  };\n\n  // output/Data.Show/index.js\n  var showInt = {\n    show: showIntImpl\n  };\n  var show = function(dict) {\n    return dict.show;\n  };\n\n  // output/Data.Maybe/index.js\n  var identity2 = /* @__PURE__ */ identity(categoryFn);\n  var Nothing = /* @__PURE__ */ function() {\n    function Nothing2() {\n    }\n    ;\n    Nothing2.value = new Nothing2();\n    return Nothing2;\n  }();\n  var Just = /* @__PURE__ */ function() {\n    function Just2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Just2.create = function(value0) {\n      return new Just2(value0);\n    };\n    return Just2;\n  }();\n  var maybe$prime = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v2 instanceof Nothing) {\n          return v(unit);\n        }\n        ;\n        if (v2 instanceof Just) {\n          return v1(v2.value0);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 250, column 1 - line 250, column 62): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  };\n  var maybe = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v2 instanceof Nothing) {\n          return v;\n        }\n        ;\n        if (v2 instanceof Just) {\n          return v1(v2.value0);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  };\n  var functorMaybe = {\n    map: function(v) {\n      return function(v1) {\n        if (v1 instanceof Just) {\n          return new Just(v(v1.value0));\n        }\n        ;\n        return Nothing.value;\n      };\n    }\n  };\n  var map2 = /* @__PURE__ */ map(functorMaybe);\n  var fromMaybe = function(a) {\n    return maybe(a)(identity2);\n  };\n  var fromJust = function() {\n    return function(v) {\n      if (v instanceof Just) {\n        return v.value0;\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): \" + [v.constructor.name]);\n    };\n  };\n  var applyMaybe = {\n    apply: function(v) {\n      return function(v1) {\n        if (v instanceof Just) {\n          return map2(v.value0)(v1);\n        }\n        ;\n        if (v instanceof Nothing) {\n          return Nothing.value;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    },\n    Functor0: function() {\n      return functorMaybe;\n    }\n  };\n  var bindMaybe = {\n    bind: function(v) {\n      return function(v1) {\n        if (v instanceof Just) {\n          return v1(v.value0);\n        }\n        ;\n        if (v instanceof Nothing) {\n          return Nothing.value;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    },\n    Apply0: function() {\n      return applyMaybe;\n    }\n  };\n\n  // output/Foreign.Object/foreign.js\n  function _lookup(no, yes, k, m) {\n    return k in m ? yes(m[k]) : no;\n  }\n  function toArrayWithKey(f2) {\n    return function(m) {\n      var r = [];\n      for (var k in m) {\n        if (hasOwnProperty.call(m, k)) {\n          r.push(f2(k)(m[k]));\n        }\n      }\n      return r;\n    };\n  }\n  var keys = Object.keys || toArrayWithKey(function(k) {\n    return function() {\n      return k;\n    };\n  });\n\n  // output/Control.Monad.ST.Internal/foreign.js\n  var map_ = function(f2) {\n    return function(a) {\n      return function() {\n        return f2(a());\n      };\n    };\n  };\n  var pure_ = function(a) {\n    return function() {\n      return a;\n    };\n  };\n  var bind_ = function(a) {\n    return function(f2) {\n      return function() {\n        return f2(a())();\n      };\n    };\n  };\n  var foreach = function(as) {\n    return function(f2) {\n      return function() {\n        for (var i = 0, l = as.length; i < l; i++) {\n          f2(as[i])();\n        }\n      };\n    };\n  };\n  function newSTRef(val) {\n    return function() {\n      return { value: val };\n    };\n  }\n  var read = function(ref) {\n    return function() {\n      return ref.value;\n    };\n  };\n  var modifyImpl = function(f2) {\n    return function(ref) {\n      return function() {\n        var t = f2(ref.value);\n        ref.value = t.state;\n        return t.value;\n      };\n    };\n  };\n  var write = function(a) {\n    return function(ref) {\n      return function() {\n        return ref.value = a;\n      };\n    };\n  };\n\n  // output/Control.Monad/index.js\n  var ap = function(dictMonad) {\n    var bind5 = bind(dictMonad.Bind1());\n    var pure3 = pure(dictMonad.Applicative0());\n    return function(f2) {\n      return function(a) {\n        return bind5(f2)(function(f$prime) {\n          return bind5(a)(function(a$prime) {\n            return pure3(f$prime(a$prime));\n          });\n        });\n      };\n    };\n  };\n\n  // output/Data.Either/index.js\n  var Left = /* @__PURE__ */ function() {\n    function Left2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Left2.create = function(value0) {\n      return new Left2(value0);\n    };\n    return Left2;\n  }();\n  var Right = /* @__PURE__ */ function() {\n    function Right2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Right2.create = function(value0) {\n      return new Right2(value0);\n    };\n    return Right2;\n  }();\n  var note = function(a) {\n    return maybe(new Left(a))(Right.create);\n  };\n  var functorEither = {\n    map: function(f2) {\n      return function(m) {\n        if (m instanceof Left) {\n          return new Left(m.value0);\n        }\n        ;\n        if (m instanceof Right) {\n          return new Right(f2(m.value0));\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): \" + [m.constructor.name]);\n      };\n    }\n  };\n  var map3 = /* @__PURE__ */ map(functorEither);\n  var either = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v2 instanceof Left) {\n          return v(v2.value0);\n        }\n        ;\n        if (v2 instanceof Right) {\n          return v1(v2.value0);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  };\n  var applyEither = {\n    apply: function(v) {\n      return function(v1) {\n        if (v instanceof Left) {\n          return new Left(v.value0);\n        }\n        ;\n        if (v instanceof Right) {\n          return map3(v.value0)(v1);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    },\n    Functor0: function() {\n      return functorEither;\n    }\n  };\n  var bindEither = {\n    bind: /* @__PURE__ */ either(function(e) {\n      return function(v) {\n        return new Left(e);\n      };\n    })(function(a) {\n      return function(f2) {\n        return f2(a);\n      };\n    }),\n    Apply0: function() {\n      return applyEither;\n    }\n  };\n  var applicativeEither = /* @__PURE__ */ function() {\n    return {\n      pure: Right.create,\n      Apply0: function() {\n        return applyEither;\n      }\n    };\n  }();\n\n  // output/Data.EuclideanRing/index.js\n  var mod = function(dict) {\n    return dict.mod;\n  };\n  var div = function(dict) {\n    return dict.div;\n  };\n\n  // output/Data.Monoid/index.js\n  var monoidArray = {\n    mempty: [],\n    Semigroup0: function() {\n      return semigroupArray;\n    }\n  };\n  var mempty = function(dict) {\n    return dict.mempty;\n  };\n\n  // output/Effect/foreign.js\n  var pureE = function(a) {\n    return function() {\n      return a;\n    };\n  };\n  var bindE = function(a) {\n    return function(f2) {\n      return function() {\n        return f2(a())();\n      };\n    };\n  };\n\n  // output/Effect/index.js\n  var $runtime_lazy = function(name2, moduleName, init3) {\n    var state2 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state2 === 2)\n        return val;\n      if (state2 === 1)\n        throw new ReferenceError(name2 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state2 = 1;\n      val = init3();\n      state2 = 2;\n      return val;\n    };\n  };\n  var monadEffect = {\n    Applicative0: function() {\n      return applicativeEffect;\n    },\n    Bind1: function() {\n      return bindEffect;\n    }\n  };\n  var bindEffect = {\n    bind: bindE,\n    Apply0: function() {\n      return $lazy_applyEffect(0);\n    }\n  };\n  var applicativeEffect = {\n    pure: pureE,\n    Apply0: function() {\n      return $lazy_applyEffect(0);\n    }\n  };\n  var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy(\"functorEffect\", \"Effect\", function() {\n    return {\n      map: liftA1(applicativeEffect)\n    };\n  });\n  var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy(\"applyEffect\", \"Effect\", function() {\n    return {\n      apply: ap(monadEffect),\n      Functor0: function() {\n        return $lazy_functorEffect(0);\n      }\n    };\n  });\n\n  // output/Control.Monad.ST.Internal/index.js\n  var $runtime_lazy2 = function(name2, moduleName, init3) {\n    var state2 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state2 === 2)\n        return val;\n      if (state2 === 1)\n        throw new ReferenceError(name2 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state2 = 1;\n      val = init3();\n      state2 = 2;\n      return val;\n    };\n  };\n  var modify$prime = modifyImpl;\n  var modify = function(f2) {\n    return modify$prime(function(s) {\n      var s$prime = f2(s);\n      return {\n        state: s$prime,\n        value: s$prime\n      };\n    });\n  };\n  var functorST = {\n    map: map_\n  };\n  var monadST = {\n    Applicative0: function() {\n      return applicativeST;\n    },\n    Bind1: function() {\n      return bindST;\n    }\n  };\n  var bindST = {\n    bind: bind_,\n    Apply0: function() {\n      return $lazy_applyST(0);\n    }\n  };\n  var applicativeST = {\n    pure: pure_,\n    Apply0: function() {\n      return $lazy_applyST(0);\n    }\n  };\n  var $lazy_applyST = /* @__PURE__ */ $runtime_lazy2(\"applyST\", \"Control.Monad.ST.Internal\", function() {\n    return {\n      apply: ap(monadST),\n      Functor0: function() {\n        return functorST;\n      }\n    };\n  });\n\n  // output/Data.Array/foreign.js\n  var rangeImpl = function(start, end) {\n    var step = start > end ? -1 : 1;\n    var result = new Array(step * (end - start) + 1);\n    var i = start, n = 0;\n    while (i !== end) {\n      result[n++] = i;\n      i += step;\n    }\n    result[n] = i;\n    return result;\n  };\n  var replicateFill = function(count, value) {\n    if (count < 1) {\n      return [];\n    }\n    var result = new Array(count);\n    return result.fill(value);\n  };\n  var replicatePolyfill = function(count, value) {\n    var result = [];\n    var n = 0;\n    for (var i = 0; i < count; i++) {\n      result[n++] = value;\n    }\n    return result;\n  };\n  var replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n  var fromFoldableImpl = /* @__PURE__ */ function() {\n    function Cons2(head3, tail2) {\n      this.head = head3;\n      this.tail = tail2;\n    }\n    var emptyList = {};\n    function curryCons(head3) {\n      return function(tail2) {\n        return new Cons2(head3, tail2);\n      };\n    }\n    function listToArray(list) {\n      var result = [];\n      var count = 0;\n      var xs = list;\n      while (xs !== emptyList) {\n        result[count++] = xs.head;\n        xs = xs.tail;\n      }\n      return result;\n    }\n    return function(foldr3, xs) {\n      return listToArray(foldr3(curryCons)(emptyList)(xs));\n    };\n  }();\n  var length = function(xs) {\n    return xs.length;\n  };\n  var unconsImpl = function(empty5, next2, xs) {\n    return xs.length === 0 ? empty5({}) : next2(xs[0])(xs.slice(1));\n  };\n  var indexImpl = function(just, nothing, xs, i) {\n    return i < 0 || i >= xs.length ? nothing : just(xs[i]);\n  };\n  var findIndexImpl = function(just, nothing, f2, xs) {\n    for (var i = 0, l = xs.length; i < l; i++) {\n      if (f2(xs[i]))\n        return just(i);\n    }\n    return nothing;\n  };\n  var _insertAt = function(just, nothing, i, a, l) {\n    if (i < 0 || i > l.length)\n      return nothing;\n    var l1 = l.slice();\n    l1.splice(i, 0, a);\n    return just(l1);\n  };\n  var _deleteAt = function(just, nothing, i, l) {\n    if (i < 0 || i >= l.length)\n      return nothing;\n    var l1 = l.slice();\n    l1.splice(i, 1);\n    return just(l1);\n  };\n  var concat = function(xss) {\n    if (xss.length <= 1e4) {\n      return Array.prototype.concat.apply([], xss);\n    }\n    var result = [];\n    for (var i = 0, l = xss.length; i < l; i++) {\n      var xs = xss[i];\n      for (var j = 0, m = xs.length; j < m; j++) {\n        result.push(xs[j]);\n      }\n    }\n    return result;\n  };\n  var filterImpl = function(f2, xs) {\n    return xs.filter(f2);\n  };\n  var sortByImpl = /* @__PURE__ */ function() {\n    function mergeFromTo(compare5, fromOrdering, xs1, xs2, from2, to) {\n      var mid;\n      var i;\n      var j;\n      var k;\n      var x;\n      var y;\n      var c;\n      mid = from2 + (to - from2 >> 1);\n      if (mid - from2 > 1)\n        mergeFromTo(compare5, fromOrdering, xs2, xs1, from2, mid);\n      if (to - mid > 1)\n        mergeFromTo(compare5, fromOrdering, xs2, xs1, mid, to);\n      i = from2;\n      j = mid;\n      k = from2;\n      while (i < mid && j < to) {\n        x = xs2[i];\n        y = xs2[j];\n        c = fromOrdering(compare5(x)(y));\n        if (c > 0) {\n          xs1[k++] = y;\n          ++j;\n        } else {\n          xs1[k++] = x;\n          ++i;\n        }\n      }\n      while (i < mid) {\n        xs1[k++] = xs2[i++];\n      }\n      while (j < to) {\n        xs1[k++] = xs2[j++];\n      }\n    }\n    return function(compare5, fromOrdering, xs) {\n      var out;\n      if (xs.length < 2)\n        return xs;\n      out = xs.slice(0);\n      mergeFromTo(compare5, fromOrdering, out, xs.slice(0), 0, xs.length);\n      return out;\n    };\n  }();\n  var sliceImpl = function(s, e, l) {\n    return l.slice(s, e);\n  };\n  var zipWithImpl = function(f2, xs, ys) {\n    var l = xs.length < ys.length ? xs.length : ys.length;\n    var result = new Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f2(xs[i])(ys[i]);\n    }\n    return result;\n  };\n  var anyImpl = function(p, xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      if (p(xs[i]))\n        return true;\n    }\n    return false;\n  };\n  var allImpl = function(p, xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      if (!p(xs[i]))\n        return false;\n    }\n    return true;\n  };\n  var unsafeIndexImpl = function(xs, n) {\n    return xs[n];\n  };\n\n  // output/Data.Array.ST/foreign.js\n  function newSTArray() {\n    return [];\n  }\n  function unsafeFreezeThawImpl(xs) {\n    return xs;\n  }\n  var unsafeFreezeImpl = unsafeFreezeThawImpl;\n  var pushImpl = function(a, xs) {\n    return xs.push(a);\n  };\n\n  // output/Control.Monad.ST.Uncurried/foreign.js\n  var runSTFn1 = function runSTFn12(fn) {\n    return function(a) {\n      return function() {\n        return fn(a);\n      };\n    };\n  };\n  var runSTFn2 = function runSTFn22(fn) {\n    return function(a) {\n      return function(b) {\n        return function() {\n          return fn(a, b);\n        };\n      };\n    };\n  };\n\n  // output/Data.Array.ST/index.js\n  var unsafeFreeze = /* @__PURE__ */ runSTFn1(unsafeFreezeImpl);\n  var push = /* @__PURE__ */ runSTFn2(pushImpl);\n\n  // output/Data.HeytingAlgebra/foreign.js\n  var boolConj = function(b1) {\n    return function(b2) {\n      return b1 && b2;\n    };\n  };\n  var boolDisj = function(b1) {\n    return function(b2) {\n      return b1 || b2;\n    };\n  };\n  var boolNot = function(b) {\n    return !b;\n  };\n\n  // output/Data.HeytingAlgebra/index.js\n  var tt = function(dict) {\n    return dict.tt;\n  };\n  var not = function(dict) {\n    return dict.not;\n  };\n  var disj = function(dict) {\n    return dict.disj;\n  };\n  var heytingAlgebraBoolean = {\n    ff: false,\n    tt: true,\n    implies: function(a) {\n      return function(b) {\n        return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);\n      };\n    },\n    conj: boolConj,\n    disj: boolDisj,\n    not: boolNot\n  };\n  var conj = function(dict) {\n    return dict.conj;\n  };\n\n  // output/Data.Array.ST.Iterator/index.js\n  var map4 = /* @__PURE__ */ map(functorST);\n  var not2 = /* @__PURE__ */ not(heytingAlgebraBoolean);\n  var $$void2 = /* @__PURE__ */ $$void(functorST);\n  var Iterator = /* @__PURE__ */ function() {\n    function Iterator2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Iterator2.create = function(value0) {\n      return function(value1) {\n        return new Iterator2(value0, value1);\n      };\n    };\n    return Iterator2;\n  }();\n  var peek = function(v) {\n    return function __do() {\n      var i = read(v.value1)();\n      return v.value0(i);\n    };\n  };\n  var next = function(v) {\n    return function __do() {\n      var i = read(v.value1)();\n      modify(function(v1) {\n        return v1 + 1 | 0;\n      })(v.value1)();\n      return v.value0(i);\n    };\n  };\n  var pushWhile = function(p) {\n    return function(iter) {\n      return function(array) {\n        return function __do() {\n          var $$break = newSTRef(false)();\n          while (map4(not2)(read($$break))()) {\n            (function __do2() {\n              var mx = peek(iter)();\n              if (mx instanceof Just && p(mx.value0)) {\n                push(mx.value0)(array)();\n                return $$void2(next(iter))();\n              }\n              ;\n              return $$void2(write(true)($$break))();\n            })();\n          }\n          ;\n          return {};\n        };\n      };\n    };\n  };\n  var iterator = function(f2) {\n    return map4(Iterator.create(f2))(newSTRef(0));\n  };\n  var iterate = function(iter) {\n    return function(f2) {\n      return function __do() {\n        var $$break = newSTRef(false)();\n        while (map4(not2)(read($$break))()) {\n          (function __do2() {\n            var mx = next(iter)();\n            if (mx instanceof Just) {\n              return f2(mx.value0)();\n            }\n            ;\n            if (mx instanceof Nothing) {\n              return $$void2(write(true)($$break))();\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): \" + [mx.constructor.name]);\n          })();\n        }\n        ;\n        return {};\n      };\n    };\n  };\n\n  // output/Data.Foldable/foreign.js\n  var foldrArray = function(f2) {\n    return function(init3) {\n      return function(xs) {\n        var acc = init3;\n        var len = xs.length;\n        for (var i = len - 1; i >= 0; i--) {\n          acc = f2(xs[i])(acc);\n        }\n        return acc;\n      };\n    };\n  };\n  var foldlArray = function(f2) {\n    return function(init3) {\n      return function(xs) {\n        var acc = init3;\n        var len = xs.length;\n        for (var i = 0; i < len; i++) {\n          acc = f2(acc)(xs[i]);\n        }\n        return acc;\n      };\n    };\n  };\n\n  // output/Control.Plus/index.js\n  var plusArray = {\n    empty: [],\n    Alt0: function() {\n      return altArray;\n    }\n  };\n  var empty = function(dict) {\n    return dict.empty;\n  };\n\n  // output/Data.Tuple/index.js\n  var Tuple = /* @__PURE__ */ function() {\n    function Tuple2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Tuple2.create = function(value0) {\n      return function(value1) {\n        return new Tuple2(value0, value1);\n      };\n    };\n    return Tuple2;\n  }();\n\n  // output/Data.Bifunctor/index.js\n  var identity3 = /* @__PURE__ */ identity(categoryFn);\n  var bimap = function(dict) {\n    return dict.bimap;\n  };\n  var lmap = function(dictBifunctor) {\n    var bimap1 = bimap(dictBifunctor);\n    return function(f2) {\n      return bimap1(f2)(identity3);\n    };\n  };\n  var bifunctorEither = {\n    bimap: function(v) {\n      return function(v1) {\n        return function(v2) {\n          if (v2 instanceof Left) {\n            return new Left(v(v2.value0));\n          }\n          ;\n          if (v2 instanceof Right) {\n            return new Right(v1(v2.value0));\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n        };\n      };\n    }\n  };\n\n  // output/Data.Monoid.Conj/index.js\n  var Conj = function(x) {\n    return x;\n  };\n  var semigroupConj = function(dictHeytingAlgebra) {\n    var conj2 = conj(dictHeytingAlgebra);\n    return {\n      append: function(v) {\n        return function(v1) {\n          return conj2(v)(v1);\n        };\n      }\n    };\n  };\n  var monoidConj = function(dictHeytingAlgebra) {\n    var semigroupConj1 = semigroupConj(dictHeytingAlgebra);\n    return {\n      mempty: tt(dictHeytingAlgebra),\n      Semigroup0: function() {\n        return semigroupConj1;\n      }\n    };\n  };\n\n  // output/Unsafe.Coerce/foreign.js\n  var unsafeCoerce2 = function(x) {\n    return x;\n  };\n\n  // output/Safe.Coerce/index.js\n  var coerce = function() {\n    return unsafeCoerce2;\n  };\n\n  // output/Data.Newtype/index.js\n  var coerce2 = /* @__PURE__ */ coerce();\n  var alaF = function() {\n    return function() {\n      return function() {\n        return function() {\n          return function(v) {\n            return coerce2;\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Foldable/index.js\n  var identity4 = /* @__PURE__ */ identity(categoryFn);\n  var eq12 = /* @__PURE__ */ eq(eqOrdering);\n  var alaF2 = /* @__PURE__ */ alaF()()()();\n  var foldr = function(dict) {\n    return dict.foldr;\n  };\n  var foldl = function(dict) {\n    return dict.foldl;\n  };\n  var maximumBy = function(dictFoldable) {\n    var foldl22 = foldl(dictFoldable);\n    return function(cmp) {\n      var max$prime = function(v) {\n        return function(v1) {\n          if (v instanceof Nothing) {\n            return new Just(v1);\n          }\n          ;\n          if (v instanceof Just) {\n            return new Just(function() {\n              var $303 = eq12(cmp(v.value0)(v1))(GT.value);\n              if ($303) {\n                return v.value0;\n              }\n              ;\n              return v1;\n            }());\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Foldable (line 441, column 3 - line 441, column 27): \" + [v.constructor.name, v1.constructor.name]);\n        };\n      };\n      return foldl22(max$prime)(Nothing.value);\n    };\n  };\n  var maximum = function(dictOrd) {\n    var compare5 = compare(dictOrd);\n    return function(dictFoldable) {\n      return maximumBy(dictFoldable)(compare5);\n    };\n  };\n  var product = function(dictFoldable) {\n    var foldl22 = foldl(dictFoldable);\n    return function(dictSemiring) {\n      return foldl22(mul(dictSemiring))(one(dictSemiring));\n    };\n  };\n  var sum = function(dictFoldable) {\n    var foldl22 = foldl(dictFoldable);\n    return function(dictSemiring) {\n      return foldl22(add(dictSemiring))(zero(dictSemiring));\n    };\n  };\n  var foldableMaybe = {\n    foldr: function(v) {\n      return function(v1) {\n        return function(v2) {\n          if (v2 instanceof Nothing) {\n            return v1;\n          }\n          ;\n          if (v2 instanceof Just) {\n            return v(v2.value0)(v1);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n        };\n      };\n    },\n    foldl: function(v) {\n      return function(v1) {\n        return function(v2) {\n          if (v2 instanceof Nothing) {\n            return v1;\n          }\n          ;\n          if (v2 instanceof Just) {\n            return v(v1)(v2.value0);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n        };\n      };\n    },\n    foldMap: function(dictMonoid) {\n      var mempty2 = mempty(dictMonoid);\n      return function(v) {\n        return function(v1) {\n          if (v1 instanceof Nothing) {\n            return mempty2;\n          }\n          ;\n          if (v1 instanceof Just) {\n            return v(v1.value0);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [v.constructor.name, v1.constructor.name]);\n        };\n      };\n    }\n  };\n  var foldMapDefaultR = function(dictFoldable) {\n    var foldr22 = foldr(dictFoldable);\n    return function(dictMonoid) {\n      var append5 = append(dictMonoid.Semigroup0());\n      var mempty2 = mempty(dictMonoid);\n      return function(f2) {\n        return foldr22(function(x) {\n          return function(acc) {\n            return append5(f2(x))(acc);\n          };\n        })(mempty2);\n      };\n    };\n  };\n  var foldableArray = {\n    foldr: foldrArray,\n    foldl: foldlArray,\n    foldMap: function(dictMonoid) {\n      return foldMapDefaultR(foldableArray)(dictMonoid);\n    }\n  };\n  var foldMap = function(dict) {\n    return dict.foldMap;\n  };\n  var fold = function(dictFoldable) {\n    var foldMap22 = foldMap(dictFoldable);\n    return function(dictMonoid) {\n      return foldMap22(dictMonoid)(identity4);\n    };\n  };\n  var all = function(dictFoldable) {\n    var foldMap22 = foldMap(dictFoldable);\n    return function(dictHeytingAlgebra) {\n      return alaF2(Conj)(foldMap22(monoidConj(dictHeytingAlgebra)));\n    };\n  };\n  var and = function(dictFoldable) {\n    var all1 = all(dictFoldable);\n    return function(dictHeytingAlgebra) {\n      return all1(dictHeytingAlgebra)(identity4);\n    };\n  };\n\n  // output/Data.Function.Uncurried/foreign.js\n  var runFn2 = function(fn) {\n    return function(a) {\n      return function(b) {\n        return fn(a, b);\n      };\n    };\n  };\n  var runFn3 = function(fn) {\n    return function(a) {\n      return function(b) {\n        return function(c) {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n  var runFn4 = function(fn) {\n    return function(a) {\n      return function(b) {\n        return function(c) {\n          return function(d) {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n  var runFn5 = function(fn) {\n    return function(a) {\n      return function(b) {\n        return function(c) {\n          return function(d) {\n            return function(e) {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.FunctorWithIndex/foreign.js\n  var mapWithIndexArray = function(f2) {\n    return function(xs) {\n      var l = xs.length;\n      var result = Array(l);\n      for (var i = 0; i < l; i++) {\n        result[i] = f2(i)(xs[i]);\n      }\n      return result;\n    };\n  };\n\n  // output/Data.Monoid.Additive/index.js\n  var Additive = function(x) {\n    return x;\n  };\n  var semigroupAdditive = function(dictSemiring) {\n    var add4 = add(dictSemiring);\n    return {\n      append: function(v) {\n        return function(v1) {\n          return add4(v)(v1);\n        };\n      }\n    };\n  };\n  var monoidAdditive = function(dictSemiring) {\n    var semigroupAdditive1 = semigroupAdditive(dictSemiring);\n    return {\n      mempty: zero(dictSemiring),\n      Semigroup0: function() {\n        return semigroupAdditive1;\n      }\n    };\n  };\n\n  // output/Data.FunctorWithIndex/index.js\n  var mapWithIndex = function(dict) {\n    return dict.mapWithIndex;\n  };\n  var functorWithIndexArray = {\n    mapWithIndex: mapWithIndexArray,\n    Functor0: function() {\n      return functorArray;\n    }\n  };\n\n  // output/Data.Traversable/foreign.js\n  var traverseArrayImpl = /* @__PURE__ */ function() {\n    function array1(a) {\n      return [a];\n    }\n    function array2(a) {\n      return function(b) {\n        return [a, b];\n      };\n    }\n    function array3(a) {\n      return function(b) {\n        return function(c) {\n          return [a, b, c];\n        };\n      };\n    }\n    function concat2(xs) {\n      return function(ys) {\n        return xs.concat(ys);\n      };\n    }\n    return function(apply2) {\n      return function(map10) {\n        return function(pure3) {\n          return function(f2) {\n            return function(array) {\n              function go(bot, top3) {\n                switch (top3 - bot) {\n                  case 0:\n                    return pure3([]);\n                  case 1:\n                    return map10(array1)(f2(array[bot]));\n                  case 2:\n                    return apply2(map10(array2)(f2(array[bot])))(f2(array[bot + 1]));\n                  case 3:\n                    return apply2(apply2(map10(array3)(f2(array[bot])))(f2(array[bot + 1])))(f2(array[bot + 2]));\n                  default:\n                    var pivot = bot + Math.floor((top3 - bot) / 4) * 2;\n                    return apply2(map10(concat2)(go(bot, pivot)))(go(pivot, top3));\n                }\n              }\n              return go(0, array.length);\n            };\n          };\n        };\n      };\n    };\n  }();\n\n  // output/Data.Traversable/index.js\n  var identity5 = /* @__PURE__ */ identity(categoryFn);\n  var traverse = function(dict) {\n    return dict.traverse;\n  };\n  var sequenceDefault = function(dictTraversable) {\n    var traverse2 = traverse(dictTraversable);\n    return function(dictApplicative) {\n      return traverse2(dictApplicative)(identity5);\n    };\n  };\n  var traversableArray = {\n    traverse: function(dictApplicative) {\n      var Apply0 = dictApplicative.Apply0();\n      return traverseArrayImpl(apply(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));\n    },\n    sequence: function(dictApplicative) {\n      return sequenceDefault(traversableArray)(dictApplicative);\n    },\n    Functor0: function() {\n      return functorArray;\n    },\n    Foldable1: function() {\n      return foldableArray;\n    }\n  };\n  var sequence = function(dict) {\n    return dict.sequence;\n  };\n\n  // output/Data.Semigroup.Foldable/index.js\n  var foldl1 = function(dict) {\n    return dict.foldl1;\n  };\n  var foldMap1DefaultL = function(dictFoldable1) {\n    var foldl11 = foldl1(dictFoldable1);\n    return function(dictFunctor) {\n      var map10 = map(dictFunctor);\n      return function(dictSemigroup) {\n        var append5 = append(dictSemigroup);\n        return function(f2) {\n          var $162 = foldl11(append5);\n          var $163 = map10(f2);\n          return function($164) {\n            return $162($163($164));\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Array/index.js\n  var $$void3 = /* @__PURE__ */ $$void(functorST);\n  var map5 = /* @__PURE__ */ map(functorMaybe);\n  var map22 = /* @__PURE__ */ map(functorST);\n  var fromJust2 = /* @__PURE__ */ fromJust();\n  var when2 = /* @__PURE__ */ when(applicativeST);\n  var eq13 = /* @__PURE__ */ eq(eqOrdering);\n  var foldMap1 = /* @__PURE__ */ foldMap(foldableArray);\n  var append2 = /* @__PURE__ */ append(semigroupArray);\n  var zipWith = /* @__PURE__ */ runFn3(zipWithImpl);\n  var unsafeIndex = function() {\n    return runFn2(unsafeIndexImpl);\n  };\n  var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();\n  var uncons = /* @__PURE__ */ function() {\n    return runFn3(unconsImpl)($$const(Nothing.value))(function(x) {\n      return function(xs) {\n        return new Just({\n          head: x,\n          tail: xs\n        });\n      };\n    });\n  }();\n  var sortBy = function(comp) {\n    return runFn3(sortByImpl)(comp)(function(v) {\n      if (v instanceof GT) {\n        return 1;\n      }\n      ;\n      if (v instanceof EQ) {\n        return 0;\n      }\n      ;\n      if (v instanceof LT) {\n        return -1 | 0;\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Array (line 897, column 38 - line 900, column 11): \" + [v.constructor.name]);\n    });\n  };\n  var slice = /* @__PURE__ */ runFn3(sliceImpl);\n  var take = function(n) {\n    return function(xs) {\n      var $152 = n < 1;\n      if ($152) {\n        return [];\n      }\n      ;\n      return slice(0)(n)(xs);\n    };\n  };\n  var singleton2 = function(a) {\n    return [a];\n  };\n  var replicate = /* @__PURE__ */ runFn2(replicateImpl);\n  var range2 = /* @__PURE__ */ runFn2(rangeImpl);\n  var insertAt = /* @__PURE__ */ function() {\n    return runFn5(_insertAt)(Just.create)(Nothing.value);\n  }();\n  var index = /* @__PURE__ */ function() {\n    return runFn4(indexImpl)(Just.create)(Nothing.value);\n  }();\n  var head = function(xs) {\n    return index(xs)(0);\n  };\n  var groupBy = function(op) {\n    return function(xs) {\n      return function __do() {\n        var result = newSTArray();\n        var iter = iterator(function(v) {\n          return index(xs)(v);\n        })();\n        iterate(iter)(function(x) {\n          return $$void3(function __do2() {\n            var sub1 = newSTArray();\n            push(x)(sub1)();\n            pushWhile(op(x))(iter)(sub1)();\n            var grp = unsafeFreeze(sub1)();\n            return push(grp)(result)();\n          });\n        })();\n        return unsafeFreeze(result)();\n      }();\n    };\n  };\n  var groupAllBy = function(cmp) {\n    var $186 = groupBy(function(x) {\n      return function(y) {\n        return eq13(cmp(x)(y))(EQ.value);\n      };\n    });\n    var $187 = sortBy(cmp);\n    return function($188) {\n      return $186($187($188));\n    };\n  };\n  var group = function(dictEq) {\n    var eq22 = eq(dictEq);\n    return function(xs) {\n      return groupBy(eq22)(xs);\n    };\n  };\n  var fromFoldable = function(dictFoldable) {\n    return runFn2(fromFoldableImpl)(foldr(dictFoldable));\n  };\n  var foldl2 = /* @__PURE__ */ foldl(foldableArray);\n  var foldMap2 = function(dictMonoid) {\n    return foldMap1(dictMonoid);\n  };\n  var findIndex = /* @__PURE__ */ function() {\n    return runFn4(findIndexImpl)(Just.create)(Nothing.value);\n  }();\n  var find2 = function(f2) {\n    return function(xs) {\n      return map5(unsafeIndex1(xs))(findIndex(f2)(xs));\n    };\n  };\n  var filter = /* @__PURE__ */ runFn2(filterImpl);\n  var deleteAt = /* @__PURE__ */ function() {\n    return runFn4(_deleteAt)(Just.create)(Nothing.value);\n  }();\n  var deleteBy = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v2.length === 0) {\n          return [];\n        }\n        ;\n        return maybe(v2)(function(i) {\n          return fromJust2(deleteAt(i)(v2));\n        })(findIndex(v(v1))(v2));\n      };\n    };\n  };\n  var cons = function(x) {\n    return function(xs) {\n      return append2([x])(xs);\n    };\n  };\n  var any2 = /* @__PURE__ */ runFn2(anyImpl);\n  var nubByEq = function(eq22) {\n    return function(xs) {\n      return function __do() {\n        var arr = newSTArray();\n        foreach(xs)(function(x) {\n          return function __do2() {\n            var e = map22(function() {\n              var $194 = any2(function(v) {\n                return eq22(v)(x);\n              });\n              return function($195) {\n                return !$194($195);\n              };\n            }())(unsafeFreeze(arr))();\n            return when2(e)($$void3(push(x)(arr)))();\n          };\n        })();\n        return unsafeFreeze(arr)();\n      }();\n    };\n  };\n  var nubEq = function(dictEq) {\n    return nubByEq(eq(dictEq));\n  };\n  var unionBy = function(eq22) {\n    return function(xs) {\n      return function(ys) {\n        return append2(xs)(foldl2(flip(deleteBy(eq22)))(nubByEq(eq22)(ys))(xs));\n      };\n    };\n  };\n  var all2 = /* @__PURE__ */ runFn2(allImpl);\n\n  // output/Data.FoldableWithIndex/index.js\n  var foldr8 = /* @__PURE__ */ foldr(foldableArray);\n  var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);\n  var foldl8 = /* @__PURE__ */ foldl(foldableArray);\n  var foldrWithIndex = function(dict) {\n    return dict.foldrWithIndex;\n  };\n  var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {\n    var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);\n    return function(dictMonoid) {\n      var append5 = append(dictMonoid.Semigroup0());\n      var mempty2 = mempty(dictMonoid);\n      return function(f2) {\n        return foldrWithIndex1(function(i) {\n          return function(x) {\n            return function(acc) {\n              return append5(f2(i)(x))(acc);\n            };\n          };\n        })(mempty2);\n      };\n    };\n  };\n  var foldableWithIndexArray = {\n    foldrWithIndex: function(f2) {\n      return function(z) {\n        var $291 = foldr8(function(v) {\n          return function(y) {\n            return f2(v.value0)(v.value1)(y);\n          };\n        })(z);\n        var $292 = mapWithIndex2(Tuple.create);\n        return function($293) {\n          return $291($292($293));\n        };\n      };\n    },\n    foldlWithIndex: function(f2) {\n      return function(z) {\n        var $294 = foldl8(function(y) {\n          return function(v) {\n            return f2(v.value0)(y)(v.value1);\n          };\n        })(z);\n        var $295 = mapWithIndex2(Tuple.create);\n        return function($296) {\n          return $294($295($296));\n        };\n      };\n    },\n    foldMapWithIndex: function(dictMonoid) {\n      return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);\n    },\n    Foldable0: function() {\n      return foldableArray;\n    }\n  };\n\n  // output/Data.TraversableWithIndex/index.js\n  var traverseWithIndexDefault = function(dictTraversableWithIndex) {\n    var sequence2 = sequence(dictTraversableWithIndex.Traversable2());\n    var mapWithIndex4 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());\n    return function(dictApplicative) {\n      var sequence12 = sequence2(dictApplicative);\n      return function(f2) {\n        var $174 = mapWithIndex4(f2);\n        return function($175) {\n          return sequence12($174($175));\n        };\n      };\n    };\n  };\n  var traverseWithIndex = function(dict) {\n    return dict.traverseWithIndex;\n  };\n  var traversableWithIndexArray = {\n    traverseWithIndex: function(dictApplicative) {\n      return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);\n    },\n    FunctorWithIndex0: function() {\n      return functorWithIndexArray;\n    },\n    FoldableWithIndex1: function() {\n      return foldableWithIndexArray;\n    },\n    Traversable2: function() {\n      return traversableArray;\n    }\n  };\n\n  // output/Foreign.Object/index.js\n  var lookup = /* @__PURE__ */ function() {\n    return runFn4(_lookup)(Nothing.value)(Just.create);\n  }();\n\n  // output/Data.Argonaut.Core/index.js\n  var verbJsonType = function(def) {\n    return function(f2) {\n      return function(g) {\n        return g(def)(f2);\n      };\n    };\n  };\n  var toJsonType = /* @__PURE__ */ function() {\n    return verbJsonType(Nothing.value)(Just.create);\n  }();\n  var caseJsonString = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), $$const(d), $$const(d), f2, $$const(d), $$const(d), j);\n      };\n    };\n  };\n  var caseJsonObject = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), $$const(d), f2, j);\n      };\n    };\n  };\n  var toObject = /* @__PURE__ */ toJsonType(caseJsonObject);\n  var caseJsonNumber = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), $$const(d), f2, $$const(d), $$const(d), $$const(d), j);\n      };\n    };\n  };\n  var caseJsonArray = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), f2, $$const(d), j);\n      };\n    };\n  };\n  var toArray = /* @__PURE__ */ toJsonType(caseJsonArray);\n\n  // output/Data.Argonaut.Decode.Error/index.js\n  var show1 = /* @__PURE__ */ show(showInt);\n  var TypeMismatch = /* @__PURE__ */ function() {\n    function TypeMismatch2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    TypeMismatch2.create = function(value0) {\n      return new TypeMismatch2(value0);\n    };\n    return TypeMismatch2;\n  }();\n  var UnexpectedValue = /* @__PURE__ */ function() {\n    function UnexpectedValue2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UnexpectedValue2.create = function(value0) {\n      return new UnexpectedValue2(value0);\n    };\n    return UnexpectedValue2;\n  }();\n  var AtIndex = /* @__PURE__ */ function() {\n    function AtIndex2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    AtIndex2.create = function(value0) {\n      return function(value1) {\n        return new AtIndex2(value0, value1);\n      };\n    };\n    return AtIndex2;\n  }();\n  var AtKey = /* @__PURE__ */ function() {\n    function AtKey2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    AtKey2.create = function(value0) {\n      return function(value1) {\n        return new AtKey2(value0, value1);\n      };\n    };\n    return AtKey2;\n  }();\n  var Named = /* @__PURE__ */ function() {\n    function Named2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Named2.create = function(value0) {\n      return function(value1) {\n        return new Named2(value0, value1);\n      };\n    };\n    return Named2;\n  }();\n  var MissingValue = /* @__PURE__ */ function() {\n    function MissingValue2() {\n    }\n    ;\n    MissingValue2.value = new MissingValue2();\n    return MissingValue2;\n  }();\n  var printJsonDecodeError = function(err) {\n    var go = function(v) {\n      if (v instanceof TypeMismatch) {\n        return \"  Expected value of type '\" + (v.value0 + \"'.\");\n      }\n      ;\n      if (v instanceof UnexpectedValue) {\n        return \"  Unexpected value \" + (stringify(v.value0) + \".\");\n      }\n      ;\n      if (v instanceof AtIndex) {\n        return \"  At array index \" + (show1(v.value0) + (\":\\n\" + go(v.value1)));\n      }\n      ;\n      if (v instanceof AtKey) {\n        return \"  At object key '\" + (v.value0 + (\"':\\n\" + go(v.value1)));\n      }\n      ;\n      if (v instanceof Named) {\n        return \"  Under '\" + (v.value0 + (\"':\\n\" + go(v.value1)));\n      }\n      ;\n      if (v instanceof MissingValue) {\n        return \"  No value was found.\";\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Error (line 37, column 8 - line 43, column 44): \" + [v.constructor.name]);\n    };\n    return \"An error occurred while decoding a JSON value:\\n\" + go(err);\n  };\n\n  // output/Data.Array.NonEmpty.Internal/foreign.js\n  var foldr1Impl = function(f2, xs) {\n    var acc = xs[xs.length - 1];\n    for (var i = xs.length - 2; i >= 0; i--) {\n      acc = f2(xs[i])(acc);\n    }\n    return acc;\n  };\n  var foldl1Impl = function(f2, xs) {\n    var acc = xs[0];\n    var len = xs.length;\n    for (var i = 1; i < len; i++) {\n      acc = f2(acc)(xs[i]);\n    }\n    return acc;\n  };\n\n  // output/Data.Array.NonEmpty.Internal/index.js\n  var NonEmptyArray = function(x) {\n    return x;\n  };\n  var traversableNonEmptyArray = traversableArray;\n  var functorNonEmptyArray = functorArray;\n  var foldableNonEmptyArray = foldableArray;\n  var foldable1NonEmptyArray = {\n    foldMap1: function(dictSemigroup) {\n      return foldMap1DefaultL(foldable1NonEmptyArray)(functorNonEmptyArray)(dictSemigroup);\n    },\n    foldr1: /* @__PURE__ */ runFn2(foldr1Impl),\n    foldl1: /* @__PURE__ */ runFn2(foldl1Impl),\n    Foldable0: function() {\n      return foldableNonEmptyArray;\n    }\n  };\n\n  // output/Data.Array.NonEmpty/index.js\n  var unsafeFromArray = NonEmptyArray;\n  var foldl12 = /* @__PURE__ */ foldl1(foldable1NonEmptyArray);\n  var cons$prime = function(x) {\n    return function(xs) {\n      return unsafeFromArray(cons(x)(xs));\n    };\n  };\n\n  // output/Data.Int/foreign.js\n  var fromNumberImpl = function(just) {\n    return function(nothing) {\n      return function(n) {\n        return (n | 0) === n ? just(n) : nothing;\n      };\n    };\n  };\n  var toNumber = function(n) {\n    return n;\n  };\n\n  // output/Data.Number/foreign.js\n  var isFiniteImpl = isFinite;\n  var floor = Math.floor;\n\n  // output/Data.Int/index.js\n  var top2 = /* @__PURE__ */ top(boundedInt);\n  var bottom2 = /* @__PURE__ */ bottom(boundedInt);\n  var fromNumber = /* @__PURE__ */ function() {\n    return fromNumberImpl(Just.create)(Nothing.value);\n  }();\n  var unsafeClamp = function(x) {\n    if (!isFiniteImpl(x)) {\n      return 0;\n    }\n    ;\n    if (x >= toNumber(top2)) {\n      return top2;\n    }\n    ;\n    if (x <= toNumber(bottom2)) {\n      return bottom2;\n    }\n    ;\n    if (otherwise) {\n      return fromMaybe(0)(fromNumber(x));\n    }\n    ;\n    throw new Error(\"Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): \" + [x.constructor.name]);\n  };\n  var floor2 = function($39) {\n    return unsafeClamp(floor($39));\n  };\n\n  // output/Data.List.Types/index.js\n  var Nil = /* @__PURE__ */ function() {\n    function Nil2() {\n    }\n    ;\n    Nil2.value = new Nil2();\n    return Nil2;\n  }();\n  var Cons = /* @__PURE__ */ function() {\n    function Cons2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Cons2.create = function(value0) {\n      return function(value1) {\n        return new Cons2(value0, value1);\n      };\n    };\n    return Cons2;\n  }();\n  var foldableList = {\n    foldr: function(f2) {\n      return function(b) {\n        var rev = function() {\n          var go = function($copy_v) {\n            return function($copy_v1) {\n              var $tco_var_v = $copy_v;\n              var $tco_done = false;\n              var $tco_result;\n              function $tco_loop(v, v1) {\n                if (v1 instanceof Nil) {\n                  $tco_done = true;\n                  return v;\n                }\n                ;\n                if (v1 instanceof Cons) {\n                  $tco_var_v = new Cons(v1.value0, v);\n                  $copy_v1 = v1.value1;\n                  return;\n                }\n                ;\n                throw new Error(\"Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): \" + [v.constructor.name, v1.constructor.name]);\n              }\n              ;\n              while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $copy_v1);\n              }\n              ;\n              return $tco_result;\n            };\n          };\n          return go(Nil.value);\n        }();\n        var $284 = foldl(foldableList)(flip(f2))(b);\n        return function($285) {\n          return $284(rev($285));\n        };\n      };\n    },\n    foldl: function(f2) {\n      var go = function($copy_b) {\n        return function($copy_v) {\n          var $tco_var_b = $copy_b;\n          var $tco_done1 = false;\n          var $tco_result;\n          function $tco_loop(b, v) {\n            if (v instanceof Nil) {\n              $tco_done1 = true;\n              return b;\n            }\n            ;\n            if (v instanceof Cons) {\n              $tco_var_b = f2(b)(v.value0);\n              $copy_v = v.value1;\n              return;\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): \" + [v.constructor.name]);\n          }\n          ;\n          while (!$tco_done1) {\n            $tco_result = $tco_loop($tco_var_b, $copy_v);\n          }\n          ;\n          return $tco_result;\n        };\n      };\n      return go;\n    },\n    foldMap: function(dictMonoid) {\n      var append22 = append(dictMonoid.Semigroup0());\n      var mempty2 = mempty(dictMonoid);\n      return function(f2) {\n        return foldl(foldableList)(function(acc) {\n          var $286 = append22(acc);\n          return function($287) {\n            return $286(f2($287));\n          };\n        })(mempty2);\n      };\n    }\n  };\n\n  // output/Data.List/index.js\n  var singleton5 = function(a) {\n    return new Cons(a, Nil.value);\n  };\n  var head2 = function(v) {\n    if (v instanceof Nil) {\n      return Nothing.value;\n    }\n    ;\n    if (v instanceof Cons) {\n      return new Just(v.value0);\n    }\n    ;\n    throw new Error(\"Failed pattern match at Data.List (line 230, column 1 - line 230, column 22): \" + [v.constructor.name]);\n  };\n\n  // output/Data.String.CodePoints/foreign.js\n  var hasArrayFrom = typeof Array.from === \"function\";\n  var hasStringIterator = typeof Symbol !== \"undefined\" && Symbol != null && typeof Symbol.iterator !== \"undefined\" && typeof String.prototype[Symbol.iterator] === \"function\";\n  var hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\n  var hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\n  // output/Data.Argonaut.Decode.Decoders/index.js\n  var map6 = /* @__PURE__ */ map(functorEither);\n  var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);\n  var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(bindEither);\n  var traverse12 = /* @__PURE__ */ traverse(traversableNonEmptyArray)(applicativeEither);\n  var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeEither);\n  var decodeString = /* @__PURE__ */ function() {\n    return caseJsonString(new Left(new TypeMismatch(\"String\")))(Right.create);\n  }();\n  var decodeNumber = /* @__PURE__ */ function() {\n    return caseJsonNumber(new Left(new TypeMismatch(\"Number\")))(Right.create);\n  }();\n  var decodeJArray = /* @__PURE__ */ function() {\n    var $52 = note(new TypeMismatch(\"Array\"));\n    return function($53) {\n      return $52(toArray($53));\n    };\n  }();\n  var decodeNonEmptyArray = function(decoder) {\n    return composeKleisliFlipped2(function() {\n      var $60 = lmap2(Named.create(\"NonEmptyArray\"));\n      var $61 = traverse12(decoder);\n      return function($62) {\n        return $60($61($62));\n      };\n    }())(composeKleisliFlipped2(function() {\n      var $63 = map6(function(x) {\n        return cons$prime(x.head)(x.tail);\n      });\n      var $64 = note(new TypeMismatch(\"NonEmptyArray\"));\n      return function($65) {\n        return $63($64(uncons($65)));\n      };\n    }())(decodeJArray));\n  };\n  var decodeInt = /* @__PURE__ */ composeKleisliFlipped2(/* @__PURE__ */ function() {\n    var $84 = note(new TypeMismatch(\"Integer\"));\n    return function($85) {\n      return $84(fromNumber($85));\n    };\n  }())(decodeNumber);\n  var decodeArray = function(decoder) {\n    return composeKleisliFlipped2(function() {\n      var $89 = lmap2(Named.create(\"Array\"));\n      var $90 = traverseWithIndex2(function(i) {\n        var $92 = lmap2(AtIndex.create(i));\n        return function($93) {\n          return $92(decoder($93));\n        };\n      });\n      return function($91) {\n        return $89($90($91));\n      };\n    }())(decodeJArray);\n  };\n\n  // output/Record/index.js\n  var insert3 = function(dictIsSymbol) {\n    var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n    return function() {\n      return function() {\n        return function(l) {\n          return function(a) {\n            return function(r) {\n              return unsafeSet(reflectSymbol2(l))(a)(r);\n            };\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Argonaut.Decode.Class/index.js\n  var bind2 = /* @__PURE__ */ bind(bindEither);\n  var lmap3 = /* @__PURE__ */ lmap(bifunctorEither);\n  var map7 = /* @__PURE__ */ map(functorMaybe);\n  var gDecodeJsonNil = {\n    gDecodeJson: function(v) {\n      return function(v1) {\n        return new Right({});\n      };\n    }\n  };\n  var gDecodeJson = function(dict) {\n    return dict.gDecodeJson;\n  };\n  var decodeRecord = function(dictGDecodeJson) {\n    var gDecodeJson1 = gDecodeJson(dictGDecodeJson);\n    return function() {\n      return {\n        decodeJson: function(json) {\n          var v = toObject(json);\n          if (v instanceof Just) {\n            return gDecodeJson1(v.value0)($$Proxy.value);\n          }\n          ;\n          if (v instanceof Nothing) {\n            return new Left(new TypeMismatch(\"Object\"));\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Class (line 103, column 5 - line 105, column 46): \" + [v.constructor.name]);\n        }\n      };\n    };\n  };\n  var decodeJsonString = {\n    decodeJson: decodeString\n  };\n  var decodeJsonInt = {\n    decodeJson: decodeInt\n  };\n  var decodeJsonField = function(dict) {\n    return dict.decodeJsonField;\n  };\n  var gDecodeJsonCons = function(dictDecodeJsonField) {\n    var decodeJsonField1 = decodeJsonField(dictDecodeJsonField);\n    return function(dictGDecodeJson) {\n      var gDecodeJson1 = gDecodeJson(dictGDecodeJson);\n      return function(dictIsSymbol) {\n        var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n        var insert5 = insert3(dictIsSymbol)()();\n        return function() {\n          return function() {\n            return {\n              gDecodeJson: function(object) {\n                return function(v) {\n                  var fieldName = reflectSymbol2($$Proxy.value);\n                  var fieldValue = lookup(fieldName)(object);\n                  var v1 = decodeJsonField1(fieldValue);\n                  if (v1 instanceof Just) {\n                    return bind2(lmap3(AtKey.create(fieldName))(v1.value0))(function(val) {\n                      return bind2(gDecodeJson1(object)($$Proxy.value))(function(rest) {\n                        return new Right(insert5($$Proxy.value)(val)(rest));\n                      });\n                    });\n                  }\n                  ;\n                  if (v1 instanceof Nothing) {\n                    return new Left(new AtKey(fieldName, MissingValue.value));\n                  }\n                  ;\n                  throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Class (line 127, column 5 - line 134, column 44): \" + [v1.constructor.name]);\n                };\n              }\n            };\n          };\n        };\n      };\n    };\n  };\n  var decodeJson = function(dict) {\n    return dict.decodeJson;\n  };\n  var decodeJsonNonEmptyArray = function(dictDecodeJson) {\n    return {\n      decodeJson: decodeNonEmptyArray(decodeJson(dictDecodeJson))\n    };\n  };\n  var decodeFieldId = function(dictDecodeJson) {\n    var decodeJson1 = decodeJson(dictDecodeJson);\n    return {\n      decodeJsonField: function(j) {\n        return map7(decodeJson1)(j);\n      }\n    };\n  };\n  var decodeArray2 = function(dictDecodeJson) {\n    return {\n      decodeJson: decodeArray(decodeJson(dictDecodeJson))\n    };\n  };\n\n  // output/Data.BigInt/foreign.js\n  var import_big_integer = __toESM(require_BigInteger(), 1);\n  function fromInt(n) {\n    return (0, import_big_integer.default)(n);\n  }\n  function toBase(base) {\n    return function(x) {\n      return x.toString(base);\n    };\n  }\n  function toNumber2(x) {\n    return x.toJSNumber();\n  }\n  function biAdd(x) {\n    return function(y) {\n      return x.add(y);\n    };\n  }\n  function biMul(x) {\n    return function(y) {\n      return x.multiply(y);\n    };\n  }\n  function biSub(x) {\n    return function(y) {\n      return x.minus(y);\n    };\n  }\n  function biMod(x) {\n    return function(y) {\n      return x.mod(y);\n    };\n  }\n  function biDiv(x) {\n    return function(y) {\n      return x.divide(y);\n    };\n  }\n  function abs3(x) {\n    return x.abs();\n  }\n\n  // output/Data.BigInt/index.js\n  var toString2 = /* @__PURE__ */ toBase(10);\n  var semiringBigInt = {\n    add: biAdd,\n    zero: /* @__PURE__ */ fromInt(0),\n    mul: biMul,\n    one: /* @__PURE__ */ fromInt(1)\n  };\n  var add2 = /* @__PURE__ */ add(semiringBigInt);\n  var ringBigInt = {\n    sub: biSub,\n    Semiring0: function() {\n      return semiringBigInt;\n    }\n  };\n  var sub2 = /* @__PURE__ */ sub(ringBigInt);\n  var commutativeRingBigInt = {\n    Ring0: function() {\n      return ringBigInt;\n    }\n  };\n  var euclideanRingBigInt = {\n    div: function(x) {\n      return function(y) {\n        return biDiv(sub2(x)(mod(euclideanRingBigInt)(x)(y)))(y);\n      };\n    },\n    mod: function(x) {\n      return function(y) {\n        var yy = abs3(y);\n        return biMod(add2(biMod(x)(yy))(yy))(yy);\n      };\n    },\n    degree: function($13) {\n      return floor2(toNumber2(abs3($13)));\n    },\n    CommutativeRing0: function() {\n      return commutativeRingBigInt;\n    }\n  };\n\n  // output/Effect.Class/index.js\n  var monadEffectEffect = {\n    liftEffect: /* @__PURE__ */ identity(categoryFn),\n    Monad0: function() {\n      return monadEffect;\n    }\n  };\n  var liftEffect = function(dict) {\n    return dict.liftEffect;\n  };\n\n  // output/Effect.Console/foreign.js\n  var error = function(s) {\n    return function() {\n      console.error(s);\n    };\n  };\n\n  // output/Effect.Class.Console/index.js\n  var error2 = function(dictMonadEffect) {\n    var $79 = liftEffect(dictMonadEffect);\n    return function($80) {\n      return $79(error($80));\n    };\n  };\n\n  // output/Foreign/foreign.js\n  var isArray = Array.isArray || function(value) {\n    return Object.prototype.toString.call(value) === \"[object Array]\";\n  };\n\n  // output/Foreign/index.js\n  var unsafeFromForeign = unsafeCoerce2;\n\n  // output/TcgCalculator.Math/index.js\n  var bind3 = /* @__PURE__ */ bind(bindArray);\n  var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorArray);\n  var fold2 = /* @__PURE__ */ fold(foldableMaybe)(monoidArray);\n  var add3 = /* @__PURE__ */ add(semiringBigInt);\n  var append3 = /* @__PURE__ */ append(semigroupArray);\n  var zero2 = /* @__PURE__ */ zero(semiringBigInt);\n  var one2 = /* @__PURE__ */ one(semiringBigInt);\n  var map8 = /* @__PURE__ */ map(functorArray);\n  var bind1 = /* @__PURE__ */ bind(bindMaybe);\n  var product3 = /* @__PURE__ */ product(foldableArray)(semiringBigInt);\n  var min3 = /* @__PURE__ */ min(ordInt);\n  var div2 = /* @__PURE__ */ div(euclideanRingBigInt);\n  var fromFoldable5 = /* @__PURE__ */ fromFoldable(foldableList);\n  var ptCacheSize = 256;\n  var permutations = function(v) {\n    if (v.length === 0) {\n      return [[]];\n    }\n    ;\n    if (v.length === 1) {\n      return [[v[0]]];\n    }\n    ;\n    var v1 = uncons(v);\n    if (v1 instanceof Just) {\n      var r = range2(0)(length(v1.value0.tail));\n      return bind3(permutations(v1.value0.tail))(function(p) {\n        return mapFlipped2(r)(function(i) {\n          return fold2(insertAt(i)(v1.value0.head)(p));\n        });\n      });\n    }\n    ;\n    return [];\n  };\n  var createPascalTriangle = function(size3) {\n    var f2 = function(v) {\n      return function(v1) {\n        if (v1 <= 0) {\n          return [];\n        }\n        ;\n        return cons(v)(f2(zipWith(add3)(append3([zero2])(v))(append3(v)([zero2])))(v1 - 1 | 0));\n      };\n    };\n    return f2([one2])(size3);\n  };\n  var pascalTriangle = /* @__PURE__ */ createPascalTriangle(ptCacheSize);\n  var combinations = function(n) {\n    return function(a) {\n      if (n === 0) {\n        return [[]];\n      }\n      ;\n      if (n === 1) {\n        return map8(singleton2)(a);\n      }\n      ;\n      if (length(a) === n) {\n        return [a];\n      }\n      ;\n      if (length(a) < n) {\n        return [];\n      }\n      ;\n      if (otherwise) {\n        var v = uncons(a);\n        if (v instanceof Just) {\n          return append3(map8(function(v1) {\n            return cons(v.value0.head)(v1);\n          })(combinations(n - 1 | 0)(v.value0.tail)))(combinations(n)(v.value0.tail));\n        }\n        ;\n        return [];\n      }\n      ;\n      throw new Error(\"Failed pattern match at TcgCalculator.Math (line 98, column 1 - line 98, column 58): \" + [n.constructor.name, a.constructor.name]);\n    };\n  };\n  var combinationNumber = function(n) {\n    return function(r) {\n      if (n < r) {\n        return zero2;\n      }\n      ;\n      if (r === 0 || n === r) {\n        return one2;\n      }\n      ;\n      if (r === 1) {\n        return fromInt(n);\n      }\n      ;\n      if (n < ptCacheSize) {\n        return fromMaybe(zero2)(bind1(index(pascalTriangle)(n))(function(v) {\n          return index(v)(r);\n        }));\n      }\n      ;\n      if (otherwise) {\n        var product$prime = function() {\n          var $59 = map8(fromInt);\n          return function($60) {\n            return product3($59($60));\n          };\n        }();\n        var k = min3(r)(n - r | 0);\n        return div2(product$prime(range2((n - k | 0) + 1 | 0)(n)))(product$prime(range2(1)(k)));\n      }\n      ;\n      throw new Error(\"Failed pattern match at TcgCalculator.Math (line 40, column 1 - line 40, column 42): \" + [n.constructor.name, r.constructor.name]);\n    };\n  };\n  var buildPartitionNumbers = function(v) {\n    if (v === 0) {\n      return singleton5([[]]);\n    }\n    ;\n    var $$new2 = function(v1) {\n      return function(v2) {\n        if (v1 instanceof Cons) {\n          return append3($$new2(v1.value1)(v2 + 1 | 0))(map8(function(v3) {\n            return cons(v2)(v3);\n          })(filter(function() {\n            var $61 = fromMaybe(0);\n            return function($62) {\n              return function(v3) {\n                return v3 <= v2;\n              }($61(head($62)));\n            };\n          }())(v1.value0)));\n        }\n        ;\n        return [];\n      };\n    };\n    var prev = buildPartitionNumbers(v - 1 | 0);\n    return new Cons($$new2(prev)(1), prev);\n  };\n  var partitionNumber = function(v) {\n    if (v < 0) {\n      return [];\n    }\n    ;\n    if (v === 0) {\n      return [[]];\n    }\n    ;\n    return fold2(head2(buildPartitionNumbers(v)));\n  };\n  var partitionNumbers = function(v) {\n    if (v < 0) {\n      return [];\n    }\n    ;\n    if (v === 0) {\n      return [[[]]];\n    }\n    ;\n    return fromFoldable5(buildPartitionNumbers(v));\n  };\n\n  // node_modules/uuid/dist/esm-browser/regex.js\n  var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\n  // node_modules/uuid/dist/esm-browser/validate.js\n  function validate(uuid) {\n    return typeof uuid === \"string\" && regex_default.test(uuid);\n  }\n  var validate_default = validate;\n\n  // node_modules/uuid/dist/esm-browser/stringify.js\n  var byteToHex = [];\n  for (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 256).toString(16).slice(1));\n  }\n  function unsafeStringify(arr, offset = 0) {\n    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n  }\n\n  // node_modules/uuid/dist/esm-browser/parse.js\n  function parse(uuid) {\n    if (!validate_default(uuid)) {\n      throw TypeError(\"Invalid UUID\");\n    }\n    let v;\n    const arr = new Uint8Array(16);\n    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n    arr[1] = v >>> 16 & 255;\n    arr[2] = v >>> 8 & 255;\n    arr[3] = v & 255;\n    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n    arr[5] = v & 255;\n    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n    arr[7] = v & 255;\n    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n    arr[9] = v & 255;\n    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;\n    arr[11] = v / 4294967296 & 255;\n    arr[12] = v >>> 24 & 255;\n    arr[13] = v >>> 16 & 255;\n    arr[14] = v >>> 8 & 255;\n    arr[15] = v & 255;\n    return arr;\n  }\n  var parse_default = parse;\n\n  // node_modules/uuid/dist/esm-browser/v35.js\n  function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = [];\n    for (let i = 0; i < str.length; ++i) {\n      bytes.push(str.charCodeAt(i));\n    }\n    return bytes;\n  }\n  var DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n  var URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\n  function v35(name2, version, hashfunc) {\n    function generateUUID(value, namespace, buf, offset) {\n      var _namespace;\n      if (typeof value === \"string\") {\n        value = stringToBytes(value);\n      }\n      if (typeof namespace === \"string\") {\n        namespace = parse_default(namespace);\n      }\n      if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n        throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n      }\n      let bytes = new Uint8Array(16 + value.length);\n      bytes.set(namespace);\n      bytes.set(value, namespace.length);\n      bytes = hashfunc(bytes);\n      bytes[6] = bytes[6] & 15 | version;\n      bytes[8] = bytes[8] & 63 | 128;\n      if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n          buf[offset + i] = bytes[i];\n        }\n        return buf;\n      }\n      return unsafeStringify(bytes);\n    }\n    try {\n      generateUUID.name = name2;\n    } catch (err) {\n    }\n    generateUUID.DNS = DNS;\n    generateUUID.URL = URL;\n    return generateUUID;\n  }\n\n  // node_modules/uuid/dist/esm-browser/sha1.js\n  function f(s, x, y, z) {\n    switch (s) {\n      case 0:\n        return x & y ^ ~x & z;\n      case 1:\n        return x ^ y ^ z;\n      case 2:\n        return x & y ^ x & z ^ y & z;\n      case 3:\n        return x ^ y ^ z;\n    }\n  }\n  function ROTL(x, n) {\n    return x << n | x >>> 32 - n;\n  }\n  function sha1(bytes) {\n    const K = [1518500249, 1859775393, 2400959708, 3395469782];\n    const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n    if (typeof bytes === \"string\") {\n      const msg = unescape(encodeURIComponent(bytes));\n      bytes = [];\n      for (let i = 0; i < msg.length; ++i) {\n        bytes.push(msg.charCodeAt(i));\n      }\n    } else if (!Array.isArray(bytes)) {\n      bytes = Array.prototype.slice.call(bytes);\n    }\n    bytes.push(128);\n    const l = bytes.length / 4 + 2;\n    const N = Math.ceil(l / 16);\n    const M = new Array(N);\n    for (let i = 0; i < N; ++i) {\n      const arr = new Uint32Array(16);\n      for (let j = 0; j < 16; ++j) {\n        arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n      }\n      M[i] = arr;\n    }\n    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n    for (let i = 0; i < N; ++i) {\n      const W = new Uint32Array(80);\n      for (let t = 0; t < 16; ++t) {\n        W[t] = M[i][t];\n      }\n      for (let t = 16; t < 80; ++t) {\n        W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n      }\n      let a = H[0];\n      let b = H[1];\n      let c = H[2];\n      let d = H[3];\n      let e = H[4];\n      for (let t = 0; t < 80; ++t) {\n        const s = Math.floor(t / 20);\n        const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n        e = d;\n        d = c;\n        c = ROTL(b, 30) >>> 0;\n        b = a;\n        a = T;\n      }\n      H[0] = H[0] + a >>> 0;\n      H[1] = H[1] + b >>> 0;\n      H[2] = H[2] + c >>> 0;\n      H[3] = H[3] + d >>> 0;\n      H[4] = H[4] + e >>> 0;\n    }\n    return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];\n  }\n  var sha1_default = sha1;\n\n  // node_modules/uuid/dist/esm-browser/v5.js\n  var v5 = v35(\"v5\", 80, sha1_default);\n  var v5_default = v5;\n\n  // output/Data.UUID/foreign.js\n  var getUUID5Impl = function(str) {\n    return function(namespace) {\n      return v5_default(str, namespace);\n    };\n  };\n  var validateV4UUID = validate_default;\n\n  // output/Data.UUID/index.js\n  var compare2 = /* @__PURE__ */ compare(ordString);\n  var parseUUID = function(str) {\n    var v = validateV4UUID(str);\n    if (v) {\n      return new Just(str);\n    }\n    ;\n    return Nothing.value;\n  };\n  var genv5UUID = function(s) {\n    return function(v) {\n      return getUUID5Impl(s)(v);\n    };\n  };\n  var eqUUID = {\n    eq: function(x) {\n      return function(y) {\n        return x === y;\n      };\n    }\n  };\n  var ordUUID = {\n    compare: function(x) {\n      return function(y) {\n        return compare2(x)(y);\n      };\n    },\n    Eq0: function() {\n      return eqUUID;\n    }\n  };\n  var emptyUUID = \"00000000-0000-0000-0000-000000000000\";\n\n  // output/TcgCalculator.Types/index.js\n  var cardsIsSymbol = {\n    reflectSymbol: function() {\n      return \"cards\";\n    }\n  };\n  var countIsSymbol = {\n    reflectSymbol: function() {\n      return \"count\";\n    }\n  };\n  var modeIsSymbol = {\n    reflectSymbol: function() {\n      return \"mode\";\n    }\n  };\n  var idIsSymbol = {\n    reflectSymbol: function() {\n      return \"id\";\n    }\n  };\n  var nameIsSymbol = {\n    reflectSymbol: function() {\n      return \"name\";\n    }\n  };\n  var eq2 = /* @__PURE__ */ eq(eqUUID);\n  var compare3 = /* @__PURE__ */ compare(ordUUID);\n  var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindEither);\n  var decodeJson2 = /* @__PURE__ */ decodeJson(decodeJsonString);\n  var mapFlipped3 = /* @__PURE__ */ mapFlipped(functorEither);\n  var gDecodeJsonCons2 = /* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonInt));\n  var Id = function(x) {\n    return x;\n  };\n  var AtLeast = /* @__PURE__ */ function() {\n    function AtLeast2() {\n    }\n    ;\n    AtLeast2.value = new AtLeast2();\n    return AtLeast2;\n  }();\n  var JustDraw = /* @__PURE__ */ function() {\n    function JustDraw2() {\n    }\n    ;\n    JustDraw2.value = new JustDraw2();\n    return JustDraw2;\n  }();\n  var Remains = /* @__PURE__ */ function() {\n    function Remains2() {\n    }\n    ;\n    Remains2.value = new Remains2();\n    return Remains2;\n  }();\n  var JustRemains = /* @__PURE__ */ function() {\n    function JustRemains2() {\n    }\n    ;\n    JustRemains2.value = new JustRemains2();\n    return JustRemains2;\n  }();\n  var Choice = /* @__PURE__ */ function() {\n    function Choice2() {\n    }\n    ;\n    Choice2.value = new Choice2();\n    return Choice2;\n  }();\n  var LeftOne = /* @__PURE__ */ function() {\n    function LeftOne2() {\n    }\n    ;\n    LeftOne2.value = new LeftOne2();\n    return LeftOne2;\n  }();\n  var LeftAll = /* @__PURE__ */ function() {\n    function LeftAll2() {\n    }\n    ;\n    LeftAll2.value = new LeftAll2();\n    return LeftAll2;\n  }();\n  var eqId = {\n    eq: function(x) {\n      return function(y) {\n        return eq2(x)(y);\n      };\n    }\n  };\n  var ordId = {\n    compare: function(x) {\n      return function(y) {\n        return compare3(x)(y);\n      };\n    },\n    Eq0: function() {\n      return eqId;\n    }\n  };\n  var readConditionMode = function(v) {\n    if (v === \"AtLeast\") {\n      return new Just(AtLeast.value);\n    }\n    ;\n    if (v === \"JustDraw\") {\n      return new Just(JustDraw.value);\n    }\n    ;\n    if (v === \"Remains\") {\n      return new Just(Remains.value);\n    }\n    ;\n    if (v === \"JustRemains\") {\n      return new Just(JustRemains.value);\n    }\n    ;\n    if (v === \"Choice\") {\n      return new Just(Choice.value);\n    }\n    ;\n    if (v === \"LeftOne\") {\n      return new Just(LeftOne.value);\n    }\n    ;\n    if (v === \"LeftAll\") {\n      return new Just(LeftAll.value);\n    }\n    ;\n    return Nothing.value;\n  };\n  var decodeJsonConditionMode = {\n    decodeJson: function(json) {\n      return bindFlipped2(function() {\n        var $263 = note(new UnexpectedValue(json));\n        return function($264) {\n          return $263(readConditionMode($264));\n        };\n      }())(decodeJson2(json));\n    }\n  };\n  var namespaceTcgCalculator = /* @__PURE__ */ genv5UUID(\"tcg-calculator\")(emptyUUID);\n  var mkId = function(s) {\n    return genv5UUID(s)(namespaceTcgCalculator);\n  };\n  var decodeJsonId = {\n    decodeJson: function(json) {\n      return mapFlipped3(decodeJson2(json))(function(id2) {\n        return maybe$prime(function(v) {\n          return mkId(id2);\n        })(Id)(parseUUID(id2));\n      });\n    }\n  };\n  var decodeJsonCondition = /* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonId))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonString))(gDecodeJsonNil)(nameIsSymbol)()())(idIsSymbol)()())(countIsSymbol)()())())))(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonConditionMode))(gDecodeJsonNil)(modeIsSymbol)()())(countIsSymbol)()())(cardsIsSymbol)()())();\n\n  // output/TcgCalculator/index.js\n  var map9 = /* @__PURE__ */ map(functorMaybe);\n  var eq3 = /* @__PURE__ */ eq(eqId);\n  var compare4 = /* @__PURE__ */ compare(ordInt);\n  var map1 = /* @__PURE__ */ map(functorArray);\n  var and3 = /* @__PURE__ */ and(foldableArray)(heytingAlgebraBoolean);\n  var greaterThanOrEq2 = /* @__PURE__ */ greaterThanOrEq(ordInt);\n  var maximum2 = /* @__PURE__ */ maximum(ordInt)(foldableArray);\n  var flap2 = /* @__PURE__ */ flap(functorFn);\n  var bind4 = /* @__PURE__ */ bind(bindArray);\n  var fold3 = /* @__PURE__ */ fold(foldableMaybe)(monoidArray);\n  var group4 = /* @__PURE__ */ group(eqInt);\n  var pure2 = /* @__PURE__ */ pure(applicativeArray);\n  var nubEq3 = /* @__PURE__ */ nubEq(/* @__PURE__ */ eqArray(eqInt));\n  var mapFlipped4 = /* @__PURE__ */ mapFlipped(functorArray);\n  var min4 = /* @__PURE__ */ min(ordInt);\n  var comparing2 = /* @__PURE__ */ comparing(ordId);\n  var append4 = /* @__PURE__ */ append(semigroupArray);\n  var product4 = /* @__PURE__ */ product(foldableArray)(semiringBigInt);\n  var mul2 = /* @__PURE__ */ mul(semiringBigInt);\n  var map23 = /* @__PURE__ */ map(functorNonEmptyArray);\n  var empty4 = /* @__PURE__ */ empty(plusArray);\n  var eqRec2 = /* @__PURE__ */ eqRec();\n  var eqRowCons2 = /* @__PURE__ */ eqRowCons(eqRowNil)();\n  var nubEq1 = /* @__PURE__ */ nubEq(/* @__PURE__ */ eqArray(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({\n    reflectSymbol: function() {\n      return \"min\";\n    }\n  })(eqInt))()({\n    reflectSymbol: function() {\n      return \"max\";\n    }\n  })(eqInt))()({\n    reflectSymbol: function() {\n      return \"card\";\n    }\n  })(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({\n    reflectSymbol: function() {\n      return \"name\";\n    }\n  })(eqString))()({\n    reflectSymbol: function() {\n      return \"id\";\n    }\n  })(eqId))()({\n    reflectSymbol: function() {\n      return \"count\";\n    }\n  })(eqInt))))));\n  var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindArray);\n  var sum2 = /* @__PURE__ */ sum(foldableArray)(semiringBigInt);\n  var sumBy = /* @__PURE__ */ alaF()()()()(Additive)(/* @__PURE__ */ foldMap2(/* @__PURE__ */ monoidAdditive(semiringInt)));\n  var satisfyCondition = function(dp) {\n    return all2(function(v) {\n      return fromMaybe(false)(map9(function(v1) {\n        return v.min <= v1.draw && v1.draw <= v.max;\n      })(find2(function($171) {\n        return function(v1) {\n          return eq3(v1)(v.card.id);\n        }(function(v1) {\n          return v1.card.id;\n        }($171));\n      })(dp)));\n    });\n  };\n  var mkDrawPattern$prime = function(v) {\n    return function(v1) {\n      if (v1.length === 0) {\n        return [];\n      }\n      ;\n      if (v1.length === 1 && v1[0].length === 0) {\n        return [[]];\n      }\n      ;\n      var cardsLength = length(v);\n      var cardCounts = sortBy(flip(compare4))(map1(function(v2) {\n        return v2.count;\n      })(v));\n      var pattern$prime = filter(function() {\n        var $177 = zipWith(greaterThanOrEq2)(cardCounts);\n        return function($178) {\n          return and3($177($178));\n        };\n      }())(map1(sortBy(flip(compare4)))(filter(function($179) {\n        return function(v2) {\n          return v2 <= cardsLength;\n        }(length($179));\n      })(v1)));\n      var maxPatternLength = fromMaybe(0)(maximum2(map1(length)(pattern$prime)));\n      var cardCombinations = map1(flap2(combinations)(v))(range2(0)(maxPatternLength));\n      return bind4(pattern$prime)(function(p) {\n        var len = length(p);\n        var con = fold3(index(cardCombinations)(len));\n        return bind4(function() {\n          var v2 = length(group4(p));\n          if (v2 === 1) {\n            return pure2;\n          }\n          ;\n          if (v2 === len) {\n            return permutations;\n          }\n          ;\n          return function($180) {\n            return nubEq3(permutations($180));\n          };\n        }()(p))(function(p$prime) {\n          return filter(all2(function(d) {\n            return d.draw <= d.card.count;\n          }))(map1(zipWith(function(v2) {\n            return function(v3) {\n              return {\n                draw: v2,\n                card: v3\n              };\n            };\n          })(p$prime))(con));\n        });\n      });\n    };\n  };\n  var mkDrawPattern = function(cards) {\n    return function(count) {\n      return mkDrawPattern$prime(cards)(partitionNumber(count));\n    };\n  };\n  var mkConditionPattern = function($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n    function $tco_loop(v) {\n      if (v.mode instanceof AtLeast) {\n        $tco_done = true;\n        return map1(function(v1) {\n          return mapFlipped4(v1)(function(p) {\n            return {\n              card: p.card,\n              min: p.draw,\n              max: p.card.count\n            };\n          });\n        })(mkDrawPattern(v.cards)(v.count));\n      }\n      ;\n      if (v.mode instanceof JustDraw) {\n        $tco_done = true;\n        return map1(function(v1) {\n          var cond = mapFlipped4(v1)(function(p) {\n            return {\n              card: p.card,\n              min: p.draw,\n              max: p.draw\n            };\n          });\n          return unionBy(on(eq3)(function(v2) {\n            return v2.card.id;\n          }))(cond)(map1(function(v2) {\n            return {\n              card: v2,\n              min: 0,\n              max: 0\n            };\n          })(v.cards));\n        })(mkDrawPattern(v.cards)(v.count));\n      }\n      ;\n      if (v.mode instanceof Remains) {\n        $tco_done = true;\n        return map1(function(v1) {\n          var cond = mapFlipped4(v1)(function(p) {\n            return {\n              card: p.card,\n              min: 0,\n              max: p.draw\n            };\n          });\n          return unionBy(on(eq3)(function(v2) {\n            return v2.card.id;\n          }))(cond)(map1(function(v2) {\n            return {\n              card: v2,\n              min: 0,\n              max: 0\n            };\n          })(v.cards));\n        })(mkDrawPattern(v.cards)(sumBy(function(v1) {\n          return v1.count;\n        })(v.cards) - v.count | 0));\n      }\n      ;\n      if (v.mode instanceof JustRemains) {\n        $copy_v = {\n          mode: JustDraw.value,\n          count: sumBy(function(v1) {\n            return v1.count;\n          })(v.cards) - v.count | 0,\n          cards: v.cards\n        };\n        return;\n      }\n      ;\n      if (v.mode instanceof Choice) {\n        $tco_done = true;\n        return map1(function(v1) {\n          return mapFlipped4(v1)(function(p) {\n            return {\n              card: p.card,\n              min: 1,\n              max: p.card.count\n            };\n          });\n        })(mkDrawPattern$prime(v.cards)([replicate(v.count)(1)]));\n      }\n      ;\n      if (v.mode instanceof LeftOne) {\n        $tco_done = true;\n        return map1(function(v1) {\n          return mapFlipped4(v1)(function(p) {\n            return {\n              card: p.card,\n              min: 0,\n              max: p.card.count - 1 | 0\n            };\n          });\n        })(mkDrawPattern$prime(v.cards)([replicate(v.count)(1)]));\n      }\n      ;\n      if (v.mode instanceof LeftAll) {\n        $tco_done = true;\n        return map1(function(v1) {\n          return mapFlipped4(v1)(function(p) {\n            return {\n              card: p.card,\n              min: 0,\n              max: 0\n            };\n          });\n        })(mkDrawPattern$prime(v.cards)([replicate(v.count)(0)]));\n      }\n      ;\n      throw new Error(\"Failed pattern match at TcgCalculator (line 88, column 57 - line 117, column 58): \" + [v.mode.constructor.name]);\n    }\n    ;\n    while (!$tco_done) {\n      $tco_result = $tco_loop($copy_v);\n    }\n    ;\n    return $tco_result;\n  };\n  var mergeConditionPattern = function(left) {\n    return function(right) {\n      var merge = function(v) {\n        return function(v1) {\n          return {\n            card: v.card,\n            min: v.min + v1.min | 0,\n            max: min4(v.max)(v1.max)\n          };\n        };\n      };\n      return map1(foldl12(merge))(groupAllBy(comparing2(function(v) {\n        return v.card.id;\n      }))(append4(left)(right)));\n    };\n  };\n  var isValidConditionPattern = /* @__PURE__ */ all2(function(v) {\n    return v.min <= v.max && v.min <= v.card.count;\n  });\n  var generateDrawPatterns = function(v) {\n    var zeroDrawPattern = map1(function(v1) {\n      return {\n        card: v1,\n        draw: 0\n      };\n    })(v.cards);\n    var maxDrawCount = min4(v.hand)(sumBy(function(v1) {\n      return v1.count;\n    })(v.cards));\n    var maxPatternLength = (v.others - (v.hand - maxDrawCount | 0) | 0) + 1 | 0;\n    return map1(function(v1) {\n      return unionBy(on(eq3)(function(v2) {\n        return v2.card.id;\n      }))(v1)(zeroDrawPattern);\n    })(mkDrawPattern$prime(v.cards)(concat(take(maxPatternLength)(partitionNumbers(maxDrawCount)))));\n  };\n  var calculatePatternCount = function(v) {\n    return function(pattern) {\n      var patternCount = product4(mapFlipped4(pattern)(function(v1) {\n        return combinationNumber(v1.card.count)(v1.draw);\n      }));\n      var drawCount = sumBy(function(v1) {\n        return v1.draw;\n      })(pattern);\n      return mul2(patternCount)(combinationNumber(v.others)(v.hand - drawCount | 0));\n    };\n  };\n  var buildConditionPattern = function(conditions) {\n    var patterns = map23(mkConditionPattern)(conditions);\n    return flap2(foldl12)(patterns)(function(left) {\n      return function(right) {\n        return bind4(left)(function(l) {\n          return bind4(right)(function(r) {\n            var merged = mergeConditionPattern(l)(r);\n            var $170 = isValidConditionPattern(merged);\n            if ($170) {\n              return pure2(merged);\n            }\n            ;\n            return empty4;\n          });\n        });\n      };\n    });\n  };\n  var calculate = function(deck) {\n    return function(conditions) {\n      var drawPattern = generateDrawPatterns(deck);\n      var conditionPattern = nubEq1(bindFlipped3(buildConditionPattern)(conditions));\n      var pattern = filter(function(dp) {\n        return any2(satisfyCondition(dp))(conditionPattern);\n      })(drawPattern);\n      return sum2(map1(calculatePatternCount(deck))(pattern));\n    };\n  };\n\n  // output/Web.Worker.GlobalScope/foreign.js\n  function postMessageImpl(data) {\n    return function(tr) {\n      return function() {\n        self.postMessage(data, tr.length > 0 ? tr : void 0);\n      };\n    };\n  }\n  function onMessage(f2) {\n    return function() {\n      self.onmessage = function(ev) {\n        f2(ev)();\n      };\n    };\n  }\n\n  // output/Web.Worker.GlobalScope/index.js\n  var postMessage = function(msg) {\n    return postMessageImpl(msg)([]);\n  };\n\n  // output/Web.Worker.MessageEvent/foreign.js\n  function data_(ev) {\n    return ev.data;\n  }\n\n  // output/Worker.Main/index.js\n  var gDecodeJsonCons3 = /* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonInt));\n  var decodeJson3 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeJsonNonEmptyArray(decodeJsonCondition))))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons3(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonId))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonString))(gDecodeJsonNil)({\n    reflectSymbol: function() {\n      return \"name\";\n    }\n  })()())({\n    reflectSymbol: function() {\n      return \"id\";\n    }\n  })()())({\n    reflectSymbol: function() {\n      return \"count\";\n    }\n  })()())())))(/* @__PURE__ */ gDecodeJsonCons3(/* @__PURE__ */ gDecodeJsonCons3(gDecodeJsonNil)({\n    reflectSymbol: function() {\n      return \"others\";\n    }\n  })()())({\n    reflectSymbol: function() {\n      return \"hand\";\n    }\n  })()())({\n    reflectSymbol: function() {\n      return \"cards\";\n    }\n  })()())()))(gDecodeJsonNil)({\n    reflectSymbol: function() {\n      return \"deck\";\n    }\n  })()())({\n    reflectSymbol: function() {\n      return \"conditions\";\n    }\n  })()())());\n  var error4 = /* @__PURE__ */ error2(monadEffectEffect);\n  var main = /* @__PURE__ */ onMessage(function(event) {\n    var v = decodeJson3(unsafeFromForeign(data_(event)));\n    if (v instanceof Left) {\n      return error4(printJsonDecodeError(v.value0));\n    }\n    ;\n    if (v instanceof Right) {\n      var result = calculate(v.value0.deck)(v.value0.conditions);\n      return postMessage(toString2(result));\n    }\n    ;\n    throw new Error(\"Failed pattern match at Worker.Main (line 21, column 5 - line 25, column 52): \" + [v.constructor.name]);\n  });\n\n  // <stdin>\n  main();\n})();\n//# sourceMappingURL=worker.js.map\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < digits[i]) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define( function () {\r\n        return bigInt;\r\n    });\r\n}\r\n","export const arrayBind = function (arr) {\n  return function (f) {\n    var result = [];\n    for (var i = 0, l = arr.length; i < l; i++) {\n      Array.prototype.push.apply(result, f(arr[i]));\n    }\n    return result;\n  };\n};\n","export const arrayApply = function (fs) {\n  return function (xs) {\n    var l = fs.length;\n    var k = xs.length;\n    var result = new Array(l*k);\n    var n = 0;\n    for (var i = 0; i < l; i++) {\n      var f = fs[i];\n      for (var j = 0; j < k; j++) {\n        result[n++] = f(xs[j]);\n      }\n    }\n    return result;\n  };\n};\n","module Control.Semigroupoid where\n\n-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not\n-- | require an identity element `identity`, just composable morphisms.\n-- |\n-- | `Semigroupoid`s must satisfy the following law:\n-- |\n-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n-- |\n-- | One example of a `Semigroupoid` is the function type constructor `(->)`,\n-- | with `(<<<)` defined as function composition.\nclass Semigroupoid :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a where\n  compose :: forall b c d. a c d -> a b c -> a b d\n\ninstance semigroupoidFn :: Semigroupoid (->) where\n  compose f g x = f (g x)\n\ninfixr 9 compose as <<<\n\n-- | Forwards composition, or `compose` with its arguments reversed.\ncomposeFlipped :: forall a b c d. Semigroupoid a => a b c -> a c d -> a b d\ncomposeFlipped f g = compose g f\n\ninfixr 9 composeFlipped as >>>\n","module Control.Category\n  ( class Category\n  , identity\n  , module Control.Semigroupoid\n  ) where\n\nimport Control.Semigroupoid (class Semigroupoid, compose, (<<<), (>>>))\n\n-- | `Category`s consist of objects and composable morphisms between them, and\n-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\n-- | must have an identity element.\n-- |\n-- | Instances must satisfy the following law in addition to the\n-- | `Semigroupoid` law:\n-- |\n-- | - Identity: `identity <<< p = p <<< identity = p`\nclass Category :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a <= Category a where\n  identity :: forall t. a t t\n\ninstance categoryFn :: Category (->) where\n  identity x = x\n","module Data.Boolean where\n\n-- | An alias for `true`, which can be useful in guard clauses:\n-- |\n-- | ```purescript\n-- | max x y | x >= y    = x\n-- |         | otherwise = y\n-- | ```\notherwise :: Boolean\notherwise = true\n","module Data.Function\n  ( flip\n  , const\n  , apply\n  , ($)\n  , applyFlipped\n  , (#)\n  , applyN\n  , on\n  , module Control.Category\n  ) where\n\nimport Control.Category (identity, compose, (<<<), (>>>))\nimport Data.Boolean (otherwise)\nimport Data.Ord ((<=))\nimport Data.Ring ((-))\n\n-- | Given a function that takes two arguments, applies the arguments\n-- | to the function in a swapped order.\n-- |\n-- | ```purescript\n-- | flip append \"1\" \"2\" == append \"2\" \"1\" == \"21\"\n-- |\n-- | const 1 \"two\" == 1\n-- |\n-- | flip const 1 \"two\" == const \"two\" 1 == \"two\"\n-- | ```\nflip :: forall a b c. (a -> b -> c) -> b -> a -> c\nflip f b a = f a b\n\n-- | Returns its first argument and ignores its second.\n-- |\n-- | ```purescript\n-- | const 1 \"hello\" = 1\n-- | ```\n-- |\n-- | It can also be thought of as creating a function that ignores its argument:\n-- |\n-- | ```purescript\n-- | const 1 = \\_ -> 1\n-- | ```\nconst :: forall a b. a -> b -> a\nconst a _ = a\n\n-- | Applies a function to an argument. This is primarily used as the operator\n-- | `($)` which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a chain of composed functions to a value.\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n\n-- | Applies a function to an argument: the reverse of `(#)`.\n-- |\n-- | ```purescript\n-- | length $ groupBy productCategory $ filter isInStock $ products\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying chain of composed functions to\n-- | a value:\n-- |\n-- | ```purescript\n-- | length <<< groupBy productCategory <<< filter isInStock $ products\n-- | ```\ninfixr 0 apply as $\n\n-- | Applies an argument to a function. This is primarily used as the `(#)`\n-- | operator, which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a value to a chain of composed functions.\napplyFlipped :: forall a b. a -> (a -> b) -> b\napplyFlipped x f = f x\n\n-- | Applies an argument to a function: the reverse of `($)`.\n-- |\n-- | ```purescript\n-- | products # filter isInStock # groupBy productCategory # length\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying a value to a chain of composed\n-- | functions:\n-- |\n-- | ```purescript\n-- | products # filter isInStock >>> groupBy productCategory >>> length\n-- | ```\ninfixl 1 applyFlipped as #\n\n-- | `applyN f n` applies the function `f` to its argument `n` times.\n-- |\n-- | If n is less than or equal to 0, the function is not applied.\n-- |\n-- | ```purescript\n-- | applyN (_ + 1) 10 0 == 10\n-- | ```\napplyN :: forall a. (a -> a) -> Int -> a -> a\napplyN f = go\n  where\n  go n acc\n    | n <= 0 = acc\n    | otherwise = go (n - 1) (f acc)\n\n-- | The `on` function is used to change the domain of a binary operator.\n-- |\n-- | For example, we can create a function which compares two records based on the values of their `x` properties:\n-- |\n-- | ```purescript\n-- | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering\n-- | compareX = compare `on` _.x\n-- | ```\non :: forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c\non f g x y = g x `f` g y\n","export const arrayMap = function (f) {\n  return function (arr) {\n    var l = arr.length;\n    var result = new Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(arr[i]);\n    }\n    return result;\n  };\n};\n","export const unit = undefined;\n","-- | The `Proxy` type and values are for situations where type information is\n-- | required for an input to determine the type of an output, but where it is\n-- | not possible or convenient to provide a _value_ for the input.\n-- |\n-- | A hypothetical example: if you have a class that is used to handle the\n-- | result of an AJAX request, you may want to use this information to set the\n-- | expected content type of the request, so you might have a class something\n-- | like this:\n-- |\n-- | ``` purescript\n-- | class AjaxResponse a where\n-- |   responseType :: a -> ResponseType\n-- |   fromResponse :: Foreign -> a\n-- | ```\n-- |\n-- | The problem here is `responseType` requires a value of type `a`, but we\n-- | won't have a value of that type until the request has been completed. The\n-- | solution is to use a `Proxy` type instead:\n-- |\n-- | ``` purescript\n-- | class AjaxResponse a where\n-- |   responseType :: Proxy a -> ResponseType\n-- |   fromResponse :: Foreign -> a\n-- | ```\n-- |\n-- | We can now call `responseType (Proxy :: Proxy SomeContentType)` to produce\n-- | a `ResponseType` for `SomeContentType` without having to construct some\n-- | empty version of `SomeContentType` first. In situations like this where\n-- | the `Proxy` type can be statically determined, it is recommended to pull\n-- | out the definition to the top level and make a declaration like:\n-- |\n-- | ``` purescript\n-- | _SomeContentType :: Proxy SomeContentType\n-- | _SomeContentType = Proxy\n-- | ```\n-- |\n-- | That way the proxy value can be used as `responseType _SomeContentType`\n-- | for improved readability. However, this is not always possible, sometimes\n-- | the type required will be determined by a type variable. As PureScript has\n-- | scoped type variables, we can do things like this:\n-- |\n-- | ``` purescript\n-- | makeRequest :: URL -> ResponseType -> Aff _ Foreign\n-- | makeRequest = ...\n-- |\n-- | fetchData :: forall a. (AjaxResponse a) => URL -> Aff _ a\n-- | fetchData url = fromResponse <$> makeRequest url (responseType (Proxy :: Proxy a))\n-- | ```\nmodule Type.Proxy where\n\n-- | Proxy type for all `kind`s.\ndata Proxy :: forall k. k -> Type\ndata Proxy a = Proxy\n","module Data.Functor\n  ( class Functor\n  , map\n  , (<$>)\n  , mapFlipped\n  , (<#>)\n  , void\n  , voidRight\n  , (<$)\n  , voidLeft\n  , ($>)\n  , flap\n  , (<@>)\n  ) where\n\nimport Data.Function (const, compose)\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Functor` is a type constructor which supports a mapping operation\n-- | `map`.\n-- |\n-- | `map` can be used to turn functions `a -> b` into functions\n-- | `f a -> f b` whose argument and return types use the type constructor `f`\n-- | to represent some computational context.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Identity: `map identity = identity`\n-- | - Composition: `map (f <<< g) = map f <<< map g`\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n\ninfixl 4 map as <$>\n\n-- | `mapFlipped` is `map` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | [1, 2, 3] <#> \\n -> n * n\n-- | ```\nmapFlipped :: forall f a b. Functor f => f a -> (a -> b) -> f b\nmapFlipped fa f = f <$> fa\n\ninfixl 1 mapFlipped as <#>\n\ninstance functorFn :: Functor ((->) r) where\n  map = compose\n\ninstance functorArray :: Functor Array where\n  map = arrayMap\n\ninstance functorProxy :: Functor Proxy where\n  map _ _ = Proxy\n\nforeign import arrayMap :: forall a b. (a -> b) -> Array a -> Array b\n\n-- | The `void` function is used to ignore the type wrapped by a\n-- | [`Functor`](#functor), replacing it with `Unit` and keeping only the type\n-- | information provided by the type constructor itself.\n-- |\n-- | `void` is often useful when using `do` notation to change the return type\n-- | of a monadic computation:\n-- |\n-- | ```purescript\n-- | main = forE 1 10 \\n -> void do\n-- |   print n\n-- |   print (n * n)\n-- | ```\nvoid :: forall f a. Functor f => f a -> f Unit\nvoid = map (const unit)\n\n-- | Ignore the return value of a computation, using the specified return value\n-- | instead.\nvoidRight :: forall f a b. Functor f => a -> f b -> f a\nvoidRight x = map (const x)\n\ninfixl 4 voidRight as <$\n\n-- | A version of `voidRight` with its arguments flipped.\nvoidLeft :: forall f a b. Functor f => f a -> b -> f b\nvoidLeft f x = const x <$> f\n\ninfixl 4 voidLeft as $>\n\n-- | Apply a value in a computational context to a value in no context.\n-- |\n-- | Generalizes `flip`.\n-- |\n-- | ```purescript\n-- | longEnough :: String -> Bool\n-- | hasSymbol :: String -> Bool\n-- | hasDigit :: String -> Bool\n-- | password :: String\n-- |\n-- | validate :: String -> Array Bool\n-- | validate = flap [longEnough, hasSymbol, hasDigit]\n-- | ```\n-- |\n-- | ```purescript\n-- | flap (-) 3 4 == 1\n-- | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)\n-- | ```\nflap :: forall f a b. Functor f => f (a -> b) -> a -> f b\nflap ff x = map (\\f -> f x) ff\n\ninfixl 4 flap as <@>\n","module Control.Apply\n  ( class Apply\n  , apply\n  , (<*>)\n  , applyFirst\n  , (<*)\n  , applySecond\n  , (*>)\n  , lift2\n  , lift3\n  , lift4\n  , lift5\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Function (const)\nimport Control.Category (identity)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Apply` class provides the `(<*>)` which is used to apply a function\n-- | to an argument under a type constructor.\n-- |\n-- | `Apply` can be used to lift functions of two or more arguments to work on\n-- | values wrapped with the type constructor `f`. It might also be understood\n-- | in terms of the `lift2` function:\n-- |\n-- | ```purescript\n-- | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n-- | lift2 f a b = f <$> a <*> b\n-- | ```\n-- |\n-- | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\n-- | the function application operator `($)` to arguments wrapped with the\n-- | type constructor `f`.\n-- |\n-- | Put differently...\n-- | ```\n-- | foo =\n-- |   functionTakingNArguments <$> computationProducingArg1\n-- |                            <*> computationProducingArg2\n-- |                            <*> ...\n-- |                            <*> computationProducingArgN\n-- | ```\n-- |\n-- | Instances must satisfy the following law in addition to the `Functor`\n-- | laws:\n-- |\n-- | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n-- |\n-- | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\nclass Functor f <= Apply f where\n  apply :: forall a b. f (a -> b) -> f a -> f b\n\ninfixl 4 apply as <*>\n\ninstance applyFn :: Apply ((->) r) where\n  apply f g x = f x (g x)\n\ninstance applyArray :: Apply Array where\n  apply = arrayApply\n\nforeign import arrayApply :: forall a b. Array (a -> b) -> Array a -> Array b\n\ninstance applyProxy :: Apply Proxy where\n  apply _ _ = Proxy\n\n-- | Combine two effectful actions, keeping only the result of the first.\napplyFirst :: forall a b f. Apply f => f a -> f b -> f a\napplyFirst a b = const <$> a <*> b\n\ninfixl 4 applyFirst as <*\n\n-- | Combine two effectful actions, keeping only the result of the second.\napplySecond :: forall a b f. Apply f => f a -> f b -> f b\napplySecond a b = const identity <$> a <*> b\n\ninfixl 4 applySecond as *>\n\n-- | Lift a function of two arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\n-- |\n-- | ```purescript\n-- | lift2 add (Just 1) (Just 2) == Just 3\n-- | lift2 add Nothing (Just 2) == Nothing\n-- |```\n-- |\nlift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n\n-- | Lift a function of three arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift3 :: forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nlift3 f a b c = f <$> a <*> b <*> c\n\n-- | Lift a function of four arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift4 :: forall a b c d e f. Apply f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e\nlift4 f a b c d = f <$> a <*> b <*> c <*> d\n\n-- | Lift a function of five arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift5 :: forall a b c d e f g. Apply f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g\nlift5 f a b c d e = f <$> a <*> b <*> c <*> d <*> e\n","module Control.Applicative\n  ( class Applicative\n  , pure\n  , liftA1\n  , unless\n  , when\n  , module Control.Apply\n  , module Data.Functor\n  ) where\n\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Applicative` type class extends the [`Apply`](#apply) type class\n-- | with a `pure` function, which can be used to create values of type `f a`\n-- | from values of type `a`.\n-- |\n-- | Where [`Apply`](#apply) provides the ability to lift functions of two or\n-- | more arguments to functions whose arguments are wrapped using `f`, and\n-- | [`Functor`](#functor) provides the ability to lift functions of one\n-- | argument, `pure` can be seen as the function which lifts functions of\n-- | _zero_ arguments. That is, `Applicative` functors support a lifting\n-- | operation for any number of function arguments.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Identity: `(pure identity) <*> v = v`\n-- | - Composition: `pure (<<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n-- | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n-- | - Interchange: `u <*> (pure y) = (pure (_ $ y)) <*> u`\nclass Apply f <= Applicative f where\n  pure :: forall a. a -> f a\n\ninstance applicativeFn :: Applicative ((->) r) where\n  pure x _ = x\n\ninstance applicativeArray :: Applicative Array where\n  pure x = [ x ]\n\ninstance applicativeProxy :: Applicative Proxy where\n  pure _ = Proxy\n\n-- | `liftA1` provides a default implementation of `(<$>)` for any\n-- | [`Applicative`](#applicative) functor, without using `(<$>)` as provided\n-- | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\n-- | relationship.\n-- |\n-- | `liftA1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftA1\n-- | ```\nliftA1 :: forall f a b. Applicative f => (a -> b) -> f a -> f b\nliftA1 f a = pure f <*> a\n\n-- | Perform an applicative action when a condition is true.\nwhen :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nwhen true m = m\nwhen false _ = pure unit\n\n-- | Perform an applicative action unless a condition is true.\nunless :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nunless false m = m\nunless true _ = pure unit\n","module Control.Bind\n  ( class Bind\n  , bind\n  , (>>=)\n  , bindFlipped\n  , (=<<)\n  , class Discard\n  , discard\n  , join\n  , composeKleisli\n  , (>=>)\n  , composeKleisliFlipped\n  , (<=<)\n  , ifM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Category (identity)\n\nimport Data.Function (flip)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bind` type class extends the [`Apply`](#apply) type class with a\n-- | \"bind\" operation `(>>=)` which composes computations in sequence, using\n-- | the return value of one computation to determine the next computation.\n-- |\n-- | The `>>=` operator can also be expressed using `do` notation, as follows:\n-- |\n-- | ```purescript\n-- | x >>= f = do y <- x\n-- |              f y\n-- | ```\n-- |\n-- | where the function argument of `f` is given the name `y`.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Associativity: `(x >>= f) >>= g = x >>= (\\k -> f k >>= g)`\n-- | - Apply Superclass: `apply f x = f >>= \\f’ -> map f’ x`\n-- |\n-- | Associativity tells us that we can regroup operations which use `do`\n-- | notation so that we can unambiguously write, for example:\n-- |\n-- | ```purescript\n-- | do x <- m1\n-- |    y <- m2 x\n-- |    m3 x y\n-- | ```\nclass Apply m <= Bind m where\n  bind :: forall a b. m a -> (a -> m b) -> m b\n\ninfixl 1 bind as >>=\n\n-- | `bindFlipped` is `bind` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | print =<< random\n-- | ```\nbindFlipped :: forall m a b. Bind m => (a -> m b) -> m a -> m b\nbindFlipped = flip bind\n\ninfixr 1 bindFlipped as =<<\n\ninstance bindFn :: Bind ((->) r) where\n  bind m f x = f (m x) x\n\n-- | The `bind`/`>>=` function for `Array` works by applying a function to\n-- | each element in the array, and flattening the results into a single,\n-- | new array.\n-- |\n-- | Array's `bind`/`>>=` works like a nested for loop. Each `bind` adds\n-- | another level of nesting in the loop. For example:\n-- | ```\n-- | foo :: Array String\n-- | foo =\n-- |   [\"a\", \"b\"] >>= \\eachElementInArray1 ->\n-- |     [\"c\", \"d\"] >>= \\eachElementInArray2\n-- |       pure (eachElementInArray1 <> eachElementInArray2)\n-- |\n-- | -- In other words...\n-- | foo\n-- | -- ... is the same as...\n-- | [ (\"a\" <> \"c\"), (\"a\" <> \"d\"), (\"b\" <> \"c\"), (\"b\" <> \"d\") ]\n-- | -- which simplifies to...\n-- | [ \"ac\", \"ad\", \"bc\", \"bd\" ]\n-- | ```\ninstance bindArray :: Bind Array where\n  bind = arrayBind\n\nforeign import arrayBind :: forall a b. Array a -> (a -> Array b) -> Array b\n\ninstance bindProxy :: Bind Proxy where\n  bind _ _ = Proxy\n\n-- | A class for types whose values can safely be discarded\n-- | in a `do` notation block.\n-- |\n-- | An example is the `Unit` type, since there is only one\n-- | possible value which can be returned.\nclass Discard a where\n  discard :: forall f b. Bind f => f a -> (a -> f b) -> f b\n\ninstance discardUnit :: Discard Unit where\n  discard = bind\n\ninstance discardProxy :: Discard (Proxy a) where\n  discard = bind\n\n-- | Collapse two applications of a monadic type constructor into one.\njoin :: forall a m. Bind m => m (m a) -> m a\njoin m = m >>= identity\n\n-- | Forwards Kleisli composition.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Data.Array (head, tail)\n-- |\n-- | third = tail >=> tail >=> head\n-- | ```\ncomposeKleisli :: forall a b c m. Bind m => (a -> m b) -> (b -> m c) -> a -> m c\ncomposeKleisli f g a = f a >>= g\n\ninfixr 1 composeKleisli as >=>\n\n-- | Backwards Kleisli composition.\ncomposeKleisliFlipped :: forall a b c m. Bind m => (b -> m c) -> (a -> m b) -> a -> m c\ncomposeKleisliFlipped f g a = f =<< g a\n\ninfixr 1 composeKleisliFlipped as <=<\n\n-- | Execute a monadic action if a condition holds.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = ifM ((< 0.5) <$> random)\n-- |          (trace \"Heads\")\n-- |          (trace \"Tails\")\n-- | ```\nifM :: forall a m. Bind m => m Boolean -> m a -> m a -> m a\nifM cond t f = cond >>= \\cond' -> if cond' then t else f\n","/* eslint-disable no-eq-null, eqeqeq */\nfunction id(x) {\n  return x;\n}\n\nexport {id as fromBoolean};\nexport {id as fromNumber};\nexport {id as fromString};\nexport {id as fromArray};\nexport {id as fromObject};\nexport const jsonNull = null;\n\nexport function stringify(j) {\n  return JSON.stringify(j);\n}\n\nexport function stringifyWithIndent(i) {\n  return function (j) {\n    return JSON.stringify(j, null, i);\n  };\n}\n\nfunction isArray(a) {\n  return Object.prototype.toString.call(a) === \"[object Array]\";\n}\n\nexport function _caseJson(isNull, isBool, isNum, isStr, isArr, isObj, j) {\n  if (j == null) return isNull();\n  else if (typeof j === \"boolean\") return isBool(j);\n  else if (typeof j === \"number\") return isNum(j);\n  else if (typeof j === \"string\") return isStr(j);\n  else if (Object.prototype.toString.call(j) === \"[object Array]\")\n    return isArr(j);\n  else return isObj(j);\n}\n\nexport function _compare(EQ, GT, LT, a, b) {\n  if (a == null) {\n    if (b == null) return EQ;\n    else return LT;\n  } else if (typeof a === \"boolean\") {\n    if (typeof b === \"boolean\") {\n      // boolean / boolean\n      if (a === b) return EQ;\n      else if (a === false) return LT;\n      else return GT;\n    } else if (b == null) return GT;\n    else return LT;\n  } else if (typeof a === \"number\") {\n    if (typeof b === \"number\") {\n      if (a === b) return EQ;\n      else if (a < b) return LT;\n      else return GT;\n    } else if (b == null) return GT;\n    else if (typeof b === \"boolean\") return GT;\n    else return LT;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      if (a === b) return EQ;\n      else if (a < b) return LT;\n      else return GT;\n    } else if (b == null) return GT;\n    else if (typeof b === \"boolean\") return GT;\n    else if (typeof b === \"number\") return GT;\n    else return LT;\n  } else if (isArray(a)) {\n    if (isArray(b)) {\n      for (var i = 0; i < Math.min(a.length, b.length); i++) {\n        var ca = _compare(EQ, GT, LT, a[i], b[i]);\n        if (ca !== EQ) return ca;\n      }\n      if (a.length === b.length) return EQ;\n      else if (a.length < b.length) return LT;\n      else return GT;\n    } else if (b == null) return GT;\n    else if (typeof b === \"boolean\") return GT;\n    else if (typeof b === \"number\") return GT;\n    else if (typeof b === \"string\") return GT;\n    else return LT;\n  } else {\n    if (b == null) return GT;\n    else if (typeof b === \"boolean\") return GT;\n    else if (typeof b === \"number\") return GT;\n    else if (typeof b === \"string\") return GT;\n    else if (isArray(b)) return GT;\n    else {\n      var akeys = Object.keys(a);\n      var bkeys = Object.keys(b);\n      if (akeys.length < bkeys.length) return LT;\n      else if (akeys.length > bkeys.length) return GT;\n      var keys = akeys.concat(bkeys).sort();\n      for (var j = 0; j < keys.length; j++) {\n        var k = keys[j];\n        if (a[k] === undefined) return LT;\n        else if (b[k] === undefined) return GT;\n        var ck = _compare(EQ, GT, LT, a[k], b[k]);\n        if (ck !== EQ) return ck;\n      }\n      return EQ;\n    }\n  }\n}\n","var refEq = function (r1) {\n  return function (r2) {\n    return r1 === r2;\n  };\n};\n\nexport const eqBooleanImpl = refEq;\nexport const eqIntImpl = refEq;\nexport const eqNumberImpl = refEq;\nexport const eqCharImpl = refEq;\nexport const eqStringImpl = refEq;\n\nexport const eqArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      if (xs.length !== ys.length) return false;\n      for (var i = 0; i < xs.length; i++) {\n        if (!f(xs[i])(ys[i])) return false;\n      }\n      return true;\n    };\n  };\n};\n","module Data.Symbol\n  ( class IsSymbol\n  , reflectSymbol\n  , reifySymbol\n  ) where\n\nimport Type.Proxy (Proxy(..))\n\n-- | A class for known symbols\nclass IsSymbol (sym :: Symbol) where\n  reflectSymbol :: Proxy sym -> String\n\n-- local definition for use in `reifySymbol`\nforeign import unsafeCoerce :: forall a b. a -> b\n\nreifySymbol :: forall r. String -> (forall sym. IsSymbol sym => Proxy sym -> r) -> r\nreifySymbol s f = coerce f { reflectSymbol: \\_ -> s } Proxy\n  where\n  coerce\n    :: (forall sym1. IsSymbol sym1 => Proxy sym1 -> r)\n    -> { reflectSymbol :: Proxy \"\" -> String }\n    -> Proxy \"\"\n    -> r\n  coerce = unsafeCoerce\n","export const unsafeHas = function (label) {\n  return function (rec) {\n    return {}.hasOwnProperty.call(rec, label);\n  };\n};\n\nexport const unsafeGet = function (label) {\n  return function (rec) {\n    return rec[label];\n  };\n};\n\nexport const unsafeSet = function (label) {\n  return function (value) {\n    return function (rec) {\n      var copy = {};\n      for (var key in rec) {\n        if ({}.hasOwnProperty.call(rec, key)) {\n          copy[key] = rec[key];\n        }\n      }\n      copy[label] = value;\n      return copy;\n    };\n  };\n};\n\nexport const unsafeDelete = function (label) {\n  return function (rec) {\n    var copy = {};\n    for (var key in rec) {\n      if (key !== label && {}.hasOwnProperty.call(rec, key)) {\n        copy[key] = rec[key];\n      }\n    }\n    return copy;\n  };\n};\n","module Data.Eq\n  ( class Eq\n  , eq\n  , (==)\n  , notEq\n  , (/=)\n  , class Eq1\n  , eq1\n  , notEq1\n  , class EqRecord\n  , eqRecord\n  ) where\n\nimport Data.HeytingAlgebra ((&&))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Eq` type class represents types which support decidable equality.\n-- |\n-- | `Eq` instances should satisfy the following laws:\n-- |\n-- | - Reflexivity: `x == x = true`\n-- | - Symmetry: `x == y = y == x`\n-- | - Transitivity: if `x == y` and `y == z` then `x == z`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,\n-- | computing with `Number` can result in a loss of precision, so sometimes\n-- | values that should be equivalent are not.\nclass Eq a where\n  eq :: a -> a -> Boolean\n\ninfix 4 eq as ==\n\n-- | `notEq` tests whether one value is _not equal_ to another. Shorthand for\n-- | `not (eq x y)`.\nnotEq :: forall a. Eq a => a -> a -> Boolean\nnotEq x y = (x == y) == false\n\ninfix 4 notEq as /=\n\ninstance eqBoolean :: Eq Boolean where\n  eq = eqBooleanImpl\n\ninstance eqInt :: Eq Int where\n  eq = eqIntImpl\n\ninstance eqNumber :: Eq Number where\n  eq = eqNumberImpl\n\ninstance eqChar :: Eq Char where\n  eq = eqCharImpl\n\ninstance eqString :: Eq String where\n  eq = eqStringImpl\n\ninstance eqUnit :: Eq Unit where\n  eq _ _ = true\n\ninstance eqVoid :: Eq Void where\n  eq _ _ = true\n\ninstance eqArray :: Eq a => Eq (Array a) where\n  eq = eqArrayImpl eq\n\ninstance eqRec :: (RL.RowToList row list, EqRecord list row) => Eq (Record row) where\n  eq = eqRecord (Proxy :: Proxy list)\n\ninstance eqProxy :: Eq (Proxy a) where\n  eq _ _ = true\n\nforeign import eqBooleanImpl :: Boolean -> Boolean -> Boolean\nforeign import eqIntImpl :: Int -> Int -> Boolean\nforeign import eqNumberImpl :: Number -> Number -> Boolean\nforeign import eqCharImpl :: Char -> Char -> Boolean\nforeign import eqStringImpl :: String -> String -> Boolean\n\nforeign import eqArrayImpl :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Boolean\n\n-- | The `Eq1` type class represents type constructors with decidable equality.\nclass Eq1 f where\n  eq1 :: forall a. Eq a => f a -> f a -> Boolean\n\ninstance eq1Array :: Eq1 Array where\n  eq1 = eq\n\nnotEq1 :: forall f a. Eq1 f => Eq a => f a -> f a -> Boolean\nnotEq1 x y = (x `eq1` y) == false\n\n-- | A class for records where all fields have `Eq` instances, used to implement\n-- | the `Eq` instance for records.\nclass EqRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row where\n  eqRecord :: Proxy rowlist -> Record row -> Record row -> Boolean\n\ninstance eqRowNil :: EqRecord RL.Nil row where\n  eqRecord _ _ _ = true\n\ninstance eqRowCons ::\n  ( EqRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Eq focus\n  ) =>\n  EqRecord (RL.Cons key focus rowlistTail) row where\n  eqRecord _ ra rb = (get ra == get rb) && tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = eqRecord (Proxy :: Proxy rowlistTail) ra rb\n","export const concatString = function (s1) {\n  return function (s2) {\n    return s1 + s2;\n  };\n};\n\nexport const concatArray = function (xs) {\n  return function (ys) {\n    if (xs.length === 0) return ys;\n    if (ys.length === 0) return xs;\n    return xs.concat(ys);\n  };\n};\n","module Data.Semigroup\n  ( class Semigroup\n  , append\n  , (<>)\n  , class SemigroupRecord\n  , appendRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semigroup` type class identifies an associative operation on a type.\n-- |\n-- | Instances are required to satisfy the following law:\n-- |\n-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`\n-- |\n-- | One example of a `Semigroup` is `String`, with `(<>)` defined as string\n-- | concatenation. Another example is `List a`, with `(<>)` defined as\n-- | list concatenation.\n-- |\n-- | ### Newtypes for Semigroup\n-- |\n-- | There are two other ways to implement an instance for this type class\n-- | regardless of which type is used. These instances can be used by\n-- | wrapping the values in one of the two newtypes below:\n-- | 1. `First` - Use the first argument every time: `append first _ = first`.\n-- | 2. `Last` - Use the last argument every time: `append _ last = last`.\nclass Semigroup a where\n  append :: a -> a -> a\n\ninfixr 5 append as <>\n\ninstance semigroupString :: Semigroup String where\n  append = concatString\n\ninstance semigroupUnit :: Semigroup Unit where\n  append _ _ = unit\n\ninstance semigroupVoid :: Semigroup Void where\n  append _ = absurd\n\ninstance semigroupFn :: Semigroup s' => Semigroup (s -> s') where\n  append f g x = f x <> g x\n\ninstance semigroupArray :: Semigroup (Array a) where\n  append = concatArray\n\ninstance semigroupProxy :: Semigroup (Proxy a) where\n  append _ _ = Proxy\n\ninstance semigroupRecord :: (RL.RowToList row list, SemigroupRecord list row row) => Semigroup (Record row) where\n  append = appendRecord (Proxy :: Proxy list)\n\nforeign import concatString :: String -> String -> String\nforeign import concatArray :: forall a. Array a -> Array a -> Array a\n\n-- | A class for records where all fields have `Semigroup` instances, used to\n-- | implement the `Semigroup` instance for records.\nclass SemigroupRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow | rowlist -> subrow where\n  appendRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance semigroupRecordNil :: SemigroupRecord RL.Nil row () where\n  appendRecord _ _ _ = {}\n\ninstance semigroupRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemigroupRecord rowlistTail row subrowTail\n  , Semigroup focus\n  ) =>\n  SemigroupRecord (RL.Cons key focus rowlistTail) row subrow where\n  appendRecord _ ra rb = insert (get ra <> get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = appendRecord (Proxy :: Proxy rowlistTail) ra rb\n","module Control.Alt\n  ( class Alt, alt, (<|>)\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (append)\n\n-- | The `Alt` type class identifies an associative operation on a type\n-- | constructor.  It is similar to `Semigroup`, except that it applies to\n-- | types of kind `* -> *`, like `Array` or `List`, rather than concrete types\n-- | `String` or `Number`.\n-- |\n-- | `Alt` instances are required to satisfy the following laws:\n-- |\n-- | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`\n-- | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`\n-- |\n-- | For example, the `Array` (`[]`) type is an instance of `Alt`, where\n-- | `(<|>)` is defined to be concatenation.\n-- |\n-- | A common use case is to select the first \"valid\" item, or, if all items\n-- | are \"invalid\", the last \"invalid\" item.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Control.Alt ((<|>))\n-- | import Data.Maybe (Maybe(..)\n-- | import Data.Either (Either(..))\n-- |\n-- | Nothing <|> Just 1 <|> Just 2 == Just 1\n-- | Left \"err\" <|> Right 1 <|> Right 2 == Right 1\n-- | Left \"err 1\" <|> Left \"err 2\" <|> Left \"err 3\" == Left \"err 3\"\n-- | ```\nclass Functor f <= Alt f where\n  alt :: forall a. f a -> f a -> f a\n\ninfixr 3 alt as <|>\n\ninstance altArray :: Alt Array where\n  alt = append\n","export const topInt = 2147483647;\nexport const bottomInt = -2147483648;\n\nexport const topChar = String.fromCharCode(65535);\nexport const bottomChar = String.fromCharCode(0);\n\nexport const topNumber = Number.POSITIVE_INFINITY;\nexport const bottomNumber = Number.NEGATIVE_INFINITY;\n","var unsafeCompareImpl = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (x) {\n        return function (y) {\n          return x < y ? lt : x === y ? eq : gt;\n        };\n      };\n    };\n  };\n};\n\nexport const ordBooleanImpl = unsafeCompareImpl;\nexport const ordIntImpl = unsafeCompareImpl;\nexport const ordNumberImpl = unsafeCompareImpl;\nexport const ordStringImpl = unsafeCompareImpl;\nexport const ordCharImpl = unsafeCompareImpl;\n\nexport const ordArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var i = 0;\n      var xlen = xs.length;\n      var ylen = ys.length;\n      while (i < xlen && i < ylen) {\n        var x = xs[i];\n        var y = ys[i];\n        var o = f(x)(y);\n        if (o !== 0) {\n          return o;\n        }\n        i++;\n      }\n      if (xlen === ylen) {\n        return 0;\n      } else if (xlen > ylen) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n  };\n};\n","module Data.Ordering (Ordering(..), invert) where\n\nimport Data.Eq (class Eq)\nimport Data.Semigroup (class Semigroup)\nimport Data.Show (class Show)\n\n-- | The `Ordering` data type represents the three possible outcomes of\n-- | comparing two values:\n-- |\n-- | `LT` - The first value is _less than_ the second.\n-- | `GT` - The first value is _greater than_ the second.\n-- | `EQ` - The first value is _equal to_ the second.\ndata Ordering = LT | GT | EQ\n\ninstance eqOrdering :: Eq Ordering where\n  eq LT LT = true\n  eq GT GT = true\n  eq EQ EQ = true\n  eq _ _ = false\n\ninstance semigroupOrdering :: Semigroup Ordering where\n  append LT _ = LT\n  append GT _ = GT\n  append EQ y = y\n\ninstance showOrdering :: Show Ordering where\n  show LT = \"LT\"\n  show GT = \"GT\"\n  show EQ = \"EQ\"\n\n-- | Reverses an `Ordering` value, flipping greater than for less than while\n-- | preserving equality.\ninvert :: Ordering -> Ordering\ninvert GT = LT\ninvert EQ = EQ\ninvert LT = GT\n","export const intAdd = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x + y | 0;\n  };\n};\n\nexport const intMul = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x * y | 0;\n  };\n};\n\nexport const numAdd = function (n1) {\n  return function (n2) {\n    return n1 + n2;\n  };\n};\n\nexport const numMul = function (n1) {\n  return function (n2) {\n    return n1 * n2;\n  };\n};\n","module Data.Semiring\n  ( class Semiring\n  , add\n  , (+)\n  , zero\n  , mul\n  , (*)\n  , one\n  , class SemiringRecord\n  , addRecord\n  , mulRecord\n  , oneRecord\n  , zeroRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semiring` class is for types that support an addition and\n-- | multiplication operation.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Commutative monoid under addition:\n-- |   - Associativity: `(a + b) + c = a + (b + c)`\n-- |   - Identity: `zero + a = a + zero = a`\n-- |   - Commutative: `a + b = b + a`\n-- | - Monoid under multiplication:\n-- |   - Associativity: `(a * b) * c = a * (b * c)`\n-- |   - Identity: `one * a = a * one = a`\n-- | - Multiplication distributes over addition:\n-- |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n-- |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n-- | - Annihilation: `zero * a = a * zero = zero`\n-- |\n-- | **Note:** The `Number` and `Int` types are not fully law abiding\n-- | members of this class hierarchy due to the potential for arithmetic\n-- | overflows, and in the case of `Number`, the presence of `NaN` and\n-- | `Infinity` values. The behaviour is unspecified in these cases.\nclass Semiring a where\n  add :: a -> a -> a\n  zero :: a\n  mul :: a -> a -> a\n  one :: a\n\ninfixl 6 add as +\ninfixl 7 mul as *\n\ninstance semiringInt :: Semiring Int where\n  add = intAdd\n  zero = 0\n  mul = intMul\n  one = 1\n\ninstance semiringNumber :: Semiring Number where\n  add = numAdd\n  zero = 0.0\n  mul = numMul\n  one = 1.0\n\ninstance semiringFn :: Semiring b => Semiring (a -> b) where\n  add f g x = f x + g x\n  zero = \\_ -> zero\n  mul f g x = f x * g x\n  one = \\_ -> one\n\ninstance semiringUnit :: Semiring Unit where\n  add _ _ = unit\n  zero = unit\n  mul _ _ = unit\n  one = unit\n\ninstance semiringProxy :: Semiring (Proxy a) where\n  add _ _ = Proxy\n  mul _ _ = Proxy\n  one = Proxy\n  zero = Proxy\n\ninstance semiringRecord :: (RL.RowToList row list, SemiringRecord list row row) => Semiring (Record row) where\n  add = addRecord (Proxy :: Proxy list)\n  mul = mulRecord (Proxy :: Proxy list)\n  one = oneRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  zero = zeroRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n\nforeign import intAdd :: Int -> Int -> Int\nforeign import intMul :: Int -> Int -> Int\nforeign import numAdd :: Number -> Number -> Number\nforeign import numMul :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Semiring` instances, used to\n-- | implement the `Semiring` instance for records.\nclass SemiringRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow | rowlist -> subrow where\n  addRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  mulRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  oneRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  zeroRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance semiringRecordNil :: SemiringRecord RL.Nil row () where\n  addRecord _ _ _ = {}\n  mulRecord _ _ _ = {}\n  oneRecord _ _ = {}\n  zeroRecord _ _ = {}\n\ninstance semiringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemiringRecord rowlistTail row subrowTail\n  , Semiring focus\n  ) =>\n  SemiringRecord (RL.Cons key focus rowlistTail) row subrow where\n  addRecord _ ra rb = insert (get ra + get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = addRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  mulRecord _ ra rb = insert (get ra * get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = mulRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  oneRecord _ _ = insert one tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = oneRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  zeroRecord _ _ = insert zero tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = zeroRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n","module Data.Ring\n  ( class Ring\n  , sub\n  , negate\n  , (-)\n  , module Data.Semiring\n  , class RingRecord\n  , subRecord\n  ) where\n\nimport Data.Semiring (class Semiring, class SemiringRecord, add, mul, one, zero, (*), (+))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ring` class is for types that support addition, multiplication,\n-- | and subtraction operations.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Semiring`\n-- | laws:\n-- |\n-- | - Additive inverse: `a - a = zero`\n-- | - Compatibility of `sub` and `negate`: `a - b = a + (zero - b)`\nclass Semiring a <= Ring a where\n  sub :: a -> a -> a\n\ninfixl 6 sub as -\n\ninstance ringInt :: Ring Int where\n  sub = intSub\n\ninstance ringNumber :: Ring Number where\n  sub = numSub\n\ninstance ringUnit :: Ring Unit where\n  sub _ _ = unit\n\ninstance ringFn :: Ring b => Ring (a -> b) where\n  sub f g x = f x - g x\n\ninstance ringProxy :: Ring (Proxy a) where\n  sub _ _ = Proxy\n\ninstance ringRecord :: (RL.RowToList row list, RingRecord list row row) => Ring (Record row) where\n  sub = subRecord (Proxy :: Proxy list)\n\n-- | `negate x` can be used as a shorthand for `zero - x`.\nnegate :: forall a. Ring a => a -> a\nnegate a = zero - a\n\nforeign import intSub :: Int -> Int -> Int\nforeign import numSub :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Ring` instances, used to\n-- | implement the `Ring` instance for records.\nclass RingRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow <= RingRecord rowlist row subrow | rowlist -> subrow where\n  subRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance ringRecordNil :: RingRecord RL.Nil row () where\n  subRecord _ _ _ = {}\n\ninstance ringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , RingRecord rowlistTail row subrowTail\n  , Ring focus\n  ) =>\n  RingRecord (RL.Cons key focus rowlistTail) row subrow where\n  subRecord _ ra rb = insert (get ra - get rb) tail\n    where\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = subRecord (Proxy :: Proxy rowlistTail) ra rb\n","module Data.Ord\n  ( class Ord\n  , compare\n  , class Ord1\n  , compare1\n  , lessThan\n  , (<)\n  , lessThanOrEq\n  , (<=)\n  , greaterThan\n  , (>)\n  , greaterThanOrEq\n  , (>=)\n  , comparing\n  , min\n  , max\n  , clamp\n  , between\n  , abs\n  , signum\n  , module Data.Ordering\n  , class OrdRecord\n  , compareRecord\n  ) where\n\nimport Data.Eq (class Eq, class Eq1, class EqRecord, (/=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Ordering (Ordering(..))\nimport Data.Ring (class Ring, zero, one, negate)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ord` type class represents types which support comparisons with a\n-- | _total order_.\n-- |\n-- | `Ord` instances should satisfy the laws of total orderings:\n-- |\n-- | - Reflexivity: `a <= a`\n-- | - Antisymmetry: if `a <= b` and `b <= a` then `a == b`\n-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN <= NaN` evaluates to `false`\nclass Eq a <= Ord a where\n  compare :: a -> a -> Ordering\n\ninstance ordBoolean :: Ord Boolean where\n  compare = ordBooleanImpl LT EQ GT\n\ninstance ordInt :: Ord Int where\n  compare = ordIntImpl LT EQ GT\n\ninstance ordNumber :: Ord Number where\n  compare = ordNumberImpl LT EQ GT\n\ninstance ordString :: Ord String where\n  compare = ordStringImpl LT EQ GT\n\ninstance ordChar :: Ord Char where\n  compare = ordCharImpl LT EQ GT\n\ninstance ordUnit :: Ord Unit where\n  compare _ _ = EQ\n\ninstance ordVoid :: Ord Void where\n  compare _ _ = EQ\n\ninstance ordProxy :: Ord (Proxy a) where\n  compare _ _ = EQ\n\ninstance ordArray :: Ord a => Ord (Array a) where\n  compare = \\xs ys -> compare 0 (ordArrayImpl toDelta xs ys)\n    where\n    toDelta x y =\n      case compare x y of\n        EQ -> 0\n        LT -> 1\n        GT -> -1\n\nforeign import ordBooleanImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Boolean\n  -> Boolean\n  -> Ordering\n\nforeign import ordIntImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Int\n  -> Int\n  -> Ordering\n\nforeign import ordNumberImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Number\n  -> Number\n  -> Ordering\n\nforeign import ordStringImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\nforeign import ordCharImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Char\n  -> Char\n  -> Ordering\n\nforeign import ordArrayImpl :: forall a. (a -> a -> Int) -> Array a -> Array a -> Int\n\ninstance ordOrdering :: Ord Ordering where\n  compare LT LT = EQ\n  compare EQ EQ = EQ\n  compare GT GT = EQ\n  compare LT _ = LT\n  compare EQ LT = GT\n  compare EQ GT = LT\n  compare GT _ = GT\n\n-- | Test whether one value is _strictly less than_ another.\nlessThan :: forall a. Ord a => a -> a -> Boolean\nlessThan a1 a2 = case a1 `compare` a2 of\n  LT -> true\n  _ -> false\n\n-- | Test whether one value is _strictly greater than_ another.\ngreaterThan :: forall a. Ord a => a -> a -> Boolean\ngreaterThan a1 a2 = case a1 `compare` a2 of\n  GT -> true\n  _ -> false\n\n-- | Test whether one value is _non-strictly less than_ another.\nlessThanOrEq :: forall a. Ord a => a -> a -> Boolean\nlessThanOrEq a1 a2 = case a1 `compare` a2 of\n  GT -> false\n  _ -> true\n\n-- | Test whether one value is _non-strictly greater than_ another.\ngreaterThanOrEq :: forall a. Ord a => a -> a -> Boolean\ngreaterThanOrEq a1 a2 = case a1 `compare` a2 of\n  LT -> false\n  _ -> true\n\ninfixl 4 lessThan as <\ninfixl 4 lessThanOrEq as <=\ninfixl 4 greaterThan as >\ninfixl 4 greaterThanOrEq as >=\n\n-- | Compares two values by mapping them to a type with an `Ord` instance.\ncomparing :: forall a b. Ord b => (a -> b) -> (a -> a -> Ordering)\ncomparing f x y = compare (f x) (f y)\n\n-- | Take the minimum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmin :: forall a. Ord a => a -> a -> a\nmin x y =\n  case compare x y of\n    LT -> x\n    EQ -> x\n    GT -> y\n\n-- | Take the maximum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmax :: forall a. Ord a => a -> a -> a\nmax x y =\n  case compare x y of\n    LT -> y\n    EQ -> x\n    GT -> x\n\n-- | Clamp a value between a minimum and a maximum. For example:\n-- |\n-- | ``` purescript\n-- | let f = clamp 0 10\n-- | f (-5) == 0\n-- | f 5    == 5\n-- | f 15   == 10\n-- | ```\nclamp :: forall a. Ord a => a -> a -> a -> a\nclamp low hi x = min hi (max low x)\n\n-- | Test whether a value is between a minimum and a maximum (inclusive).\n-- | For example:\n-- |\n-- | ``` purescript\n-- | let f = between 0 10\n-- | f 0    == true\n-- | f (-5) == false\n-- | f 5    == true\n-- | f 10   == true\n-- | f 15   == false\n-- | ```\nbetween :: forall a. Ord a => a -> a -> a -> Boolean\nbetween low hi x\n  | x < low = false\n  | x > hi = false\n  | true = true\n\n-- | The absolute value function. `abs x` is defined as `if x >= zero then x\n-- | else negate x`.\nabs :: forall a. Ord a => Ring a => a -> a\nabs x = if x >= zero then x else negate x\n\n-- | The sign function; returns `one` if the argument is positive,\n-- | `negate one` if the argument is negative, or `zero` if the argument is `zero`.\n-- | For floating point numbers with signed zeroes, when called with a zero,\n-- | this function returns the argument in order to preserve the sign.\n-- | For any `x`, we should have `signum x * abs x == x`.\nsignum :: forall a. Ord a => Ring a => a -> a\nsignum x =\n  if x < zero then negate one\n  else if x > zero then one\n  else x\n\n-- | The `Ord1` type class represents totally ordered type constructors.\nclass Eq1 f <= Ord1 f where\n  compare1 :: forall a. Ord a => f a -> f a -> Ordering\n\ninstance ord1Array :: Ord1 Array where\n  compare1 = compare\n\nclass OrdRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row <= OrdRecord rowlist row where\n  compareRecord :: Proxy rowlist -> Record row -> Record row -> Ordering\n\ninstance ordRecordNil :: OrdRecord RL.Nil row where\n  compareRecord _ _ _ = EQ\n\ninstance ordRecordCons ::\n  ( OrdRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Ord focus\n  ) =>\n  OrdRecord (RL.Cons key focus rowlistTail) row where\n  compareRecord _ ra rb =\n    if left /= EQ then left\n    else compareRecord (Proxy :: Proxy rowlistTail) ra rb\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    unsafeGet' = unsafeGet :: String -> Record row -> focus\n    left = unsafeGet' key ra `compare` unsafeGet' key rb\n\ninstance ordRecord ::\n  ( RL.RowToList row list\n  , OrdRecord list row\n  ) =>\n  Ord (Record row) where\n  compare = compareRecord (Proxy :: Proxy list)\n","module Data.Bounded\n  ( class Bounded\n  , bottom\n  , top\n  , module Data.Ord\n  , class BoundedRecord\n  , bottomRecord\n  , topRecord\n  ) where\n\nimport Data.Ord (class Ord, class OrdRecord, Ordering(..), compare, (<), (<=), (>), (>=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bounded` type class represents totally ordered types that have an\n-- | upper and lower boundary.\n-- |\n-- | Instances should satisfy the following law in addition to the `Ord` laws:\n-- |\n-- | - Bounded: `bottom <= a <= top`\nclass Ord a <= Bounded a where\n  top :: a\n  bottom :: a\n\ninstance boundedBoolean :: Bounded Boolean where\n  top = true\n  bottom = false\n\n-- | The `Bounded` `Int` instance has `top :: Int` equal to 2^31 - 1,\n-- | and `bottom :: Int` equal to -2^31, since these are the largest and smallest\n-- | integers representable by twos-complement 32-bit integers, respectively.\ninstance boundedInt :: Bounded Int where\n  top = topInt\n  bottom = bottomInt\n\nforeign import topInt :: Int\nforeign import bottomInt :: Int\n\n-- | Characters fall within the Unicode range.\ninstance boundedChar :: Bounded Char where\n  top = topChar\n  bottom = bottomChar\n\nforeign import topChar :: Char\nforeign import bottomChar :: Char\n\ninstance boundedOrdering :: Bounded Ordering where\n  top = GT\n  bottom = LT\n\ninstance boundedUnit :: Bounded Unit where\n  top = unit\n  bottom = unit\n\nforeign import topNumber :: Number\nforeign import bottomNumber :: Number\n\ninstance boundedNumber :: Bounded Number where\n  top = topNumber\n  bottom = bottomNumber\n\ninstance boundedProxy :: Bounded (Proxy a) where\n  bottom = Proxy\n  top = Proxy\n\nclass BoundedRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass OrdRecord rowlist row <= BoundedRecord rowlist row subrow | rowlist -> subrow where\n  topRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  bottomRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance boundedRecordNil :: BoundedRecord RL.Nil row () where\n  topRecord _ _ = {}\n  bottomRecord _ _ = {}\n\ninstance boundedRecordCons ::\n  ( IsSymbol key\n  , Bounded focus\n  , Row.Cons key focus rowTail row\n  , Row.Cons key focus subrowTail subrow\n  , BoundedRecord rowlistTail row subrowTail\n  ) =>\n  BoundedRecord (RL.Cons key focus rowlistTail) row subrow where\n  topRecord _ rowProxy = insert top tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = topRecord (Proxy :: Proxy rowlistTail) rowProxy\n\n  bottomRecord _ rowProxy = insert bottom tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = bottomRecord (Proxy :: Proxy rowlistTail) rowProxy\n\ninstance boundedRecord ::\n  ( RL.RowToList row list\n  , BoundedRecord list row row\n  ) =>\n  Bounded (Record row) where\n  top = topRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  bottom = bottomRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n","export const showIntImpl = function (n) {\n  return n.toString();\n};\n\nexport const showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexport const showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexport const showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexport const showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n","module Data.Show\n  ( class Show\n  , show\n  , class ShowRecordFields\n  , showRecordFields\n  ) where\n\nimport Data.Semigroup ((<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row (class Nub)\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Show` type class represents those types which can be converted into\n-- | a human-readable `String` representation.\n-- |\n-- | While not required, it is recommended that for any expression `x`, the\n-- | string `show x` be executable PureScript code which evaluates to the same\n-- | value as the expression `x`.\nclass Show a where\n  show :: a -> String\n\ninstance showUnit :: Show Unit where\n  show _ = \"unit\"\n\ninstance showBoolean :: Show Boolean where\n  show true = \"true\"\n  show false = \"false\"\n\ninstance showInt :: Show Int where\n  show = showIntImpl\n\ninstance showNumber :: Show Number where\n  show = showNumberImpl\n\ninstance showChar :: Show Char where\n  show = showCharImpl\n\ninstance showString :: Show String where\n  show = showStringImpl\n\ninstance showArray :: Show a => Show (Array a) where\n  show = showArrayImpl show\n\ninstance showProxy :: Show (Proxy a) where\n  show _ = \"Proxy\"\n\ninstance showVoid :: Show Void where\n  show = absurd\n\ninstance showRecord ::\n  ( Nub rs rs\n  , RL.RowToList rs ls\n  , ShowRecordFields ls rs\n  ) =>\n  Show (Record rs) where\n  show record = \"{\" <> showRecordFields (Proxy :: Proxy ls) record <> \"}\"\n\n-- | A class for records where all fields have `Show` instances, used to\n-- | implement the `Show` instance for records.\nclass ShowRecordFields :: RL.RowList Type -> Row Type -> Constraint\nclass ShowRecordFields rowlist row where\n  showRecordFields :: Proxy rowlist -> Record row -> String\n\ninstance showRecordFieldsNil :: ShowRecordFields RL.Nil row where\n  showRecordFields _ _ = \"\"\nelse\ninstance showRecordFieldsConsNil ::\n  ( IsSymbol key\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus RL.Nil) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \" \"\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\nelse\ninstance showRecordFieldsCons ::\n  ( IsSymbol key\n  , ShowRecordFields rowlistTail row\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus rowlistTail) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \",\" <> tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\n    tail = showRecordFields (Proxy :: Proxy rowlistTail) record\n\nforeign import showIntImpl :: Int -> String\nforeign import showNumberImpl :: Number -> String\nforeign import showCharImpl :: Char -> String\nforeign import showStringImpl :: String -> String\nforeign import showArrayImpl :: forall a. (a -> String) -> Array a -> String\n","module Data.Maybe where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Ord (class Ord1)\n\n-- | The `Maybe` type is used to represent optional values and can be seen as\n-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`\n-- | is the non-null value `x`.\ndata Maybe a = Nothing | Just a\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Just` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing == Nothing\n-- | ```\ninstance functorMaybe :: Functor Maybe where\n  map fn (Just x) = Just (fn x)\n  map _  _        = Nothing\n\n-- | The `Apply` instance allows functions contained within a `Just` to\n-- | transform a value contained within a `Just` using the `apply` operator:\n-- |\n-- | ``` purescript\n-- | Just f <*> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Just f <*> Nothing == Nothing\n-- | Nothing <*> Just x == Nothing\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a\n-- | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Maybe a -> Maybe b -> Maybe c`:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> Just y == Just (f x y)\n-- | ```\n-- |\n-- | The `Nothing`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Nothing`\n-- | means the whole result becomes `Nothing` also:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing <*> Just y == Nothing\n-- | f <$> Just x <*> Nothing == Nothing\n-- | f <$> Nothing <*> Nothing == Nothing\n-- | ```\ninstance applyMaybe :: Apply Maybe where\n  apply (Just fn) x = fn <$> x\n  apply Nothing   _ = Nothing\n\n-- | The `Applicative` instance enables lifting of values into `Maybe` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Maybe _ == Just x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Maybe` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> pure y == Just (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Just` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Just` with a new constructor.\ninstance applicativeMaybe :: Applicative Maybe where\n  pure = Just\n\n-- | The `Alt` instance allows for a choice to be made between two `Maybe`\n-- | values with the `<|>` operator, where the first `Just` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Just x <|> Just y == Just x\n-- | Nothing <|> Just y == Just y\n-- | Nothing <|> Nothing == Nothing\n-- | ```\ninstance altMaybe :: Alt Maybe where\n  alt Nothing r = r\n  alt l       _ = l\n\n-- | The `Plus` instance provides a default `Maybe` value:\n-- |\n-- | ``` purescript\n-- | empty :: Maybe _ == Nothing\n-- | ```\ninstance plusMaybe :: Plus Maybe where\n  empty = Nothing\n\n-- | The `Alternative` instance guarantees that there are both `Applicative` and\n-- | `Plus` instances for `Maybe`.\ninstance alternativeMaybe :: Alternative Maybe\n\n-- | The `Bind` instance allows sequencing of `Maybe` values and functions that\n-- | return a `Maybe` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Just x >>= f = f x\n-- | Nothing >>= f = Nothing\n-- | ```\ninstance bindMaybe :: Bind Maybe where\n  bind (Just x) k = k x\n  bind Nothing  _ = Nothing\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | case x of\n-- |   Nothing -> Nothing\n-- |   Just x' -> case y of\n-- |     Nothing -> Nothing\n-- |     Just y' -> Just (f x' y')\n-- | ```\ninstance monadMaybe :: Monad Maybe\n\n-- | The `Extend` instance allows sequencing of `Maybe` values and functions\n-- | that accept a `Maybe a` and return a non-`Maybe` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Nothing = Nothing\n-- | f <<= x = Just (f x)\n-- | ```\ninstance extendMaybe :: Extend Maybe where\n  extend _ Nothing  = Nothing\n  extend f x        = Just (f x)\n\ninstance invariantMaybe :: Invariant Maybe where\n  imap = imapF\n\n-- | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values\n-- | whenever there is a `Semigroup` instance for the type the `Maybe` contains.\n-- | The exact behaviour of `<>` depends on the \"inner\" `Semigroup` instance,\n-- | but generally captures the notion of appending or combining things.\n-- |\n-- | ``` purescript\n-- | Just x <> Just y = Just (x <> y)\n-- | Just x <> Nothing = Just x\n-- | Nothing <> Just y = Just y\n-- | Nothing <> Nothing = Nothing\n-- | ```\ninstance semigroupMaybe :: Semigroup a => Semigroup (Maybe a) where\n  append Nothing y = y\n  append x Nothing = x\n  append (Just x) (Just y) = Just (x <> y)\n\ninstance monoidMaybe :: Semigroup a => Monoid (Maybe a) where\n  mempty = Nothing\n\ninstance semiringMaybe :: Semiring a => Semiring (Maybe a) where\n  zero = Nothing\n  one = Just one\n\n  add Nothing y = y\n  add x Nothing = x\n  add (Just x) (Just y) = Just (add x y)\n\n  mul x y = mul <$> x <*> y\n\n-- | The `Eq` instance allows `Maybe` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for the\n-- | type the `Maybe` contains.\nderive instance eqMaybe :: Eq a => Eq (Maybe a)\n\ninstance eq1Maybe :: Eq1 Maybe where eq1 = eq\n\n-- | The `Ord` instance allows `Maybe` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | the type the `Maybe` contains.\n-- |\n-- | `Nothing` is considered to be less than any `Just` value.\nderive instance ordMaybe :: Ord a => Ord (Maybe a)\n\ninstance ord1Maybe :: Ord1 Maybe where compare1 = compare\n\ninstance boundedMaybe :: Bounded a => Bounded (Maybe a) where\n  top = Just top\n  bottom = Nothing\n\n-- | The `Show` instance allows `Maybe` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for the type the `Maybe`\n-- | contains.\ninstance showMaybe :: Show a => Show (Maybe a) where\n  show (Just x) = \"(Just \" <> show x <> \")\"\n  show Nothing  = \"Nothing\"\n\nderive instance genericMaybe :: Generic (Maybe a) _\n\n-- | Takes a default value, a function, and a `Maybe` value. If the `Maybe`\n-- | value is `Nothing` the default value is returned, otherwise the function\n-- | is applied to the value inside the `Just` and the result is returned.\n-- |\n-- | ``` purescript\n-- | maybe x f Nothing == x\n-- | maybe x f (Just y) == f y\n-- | ```\nmaybe :: forall a b. b -> (a -> b) -> Maybe a -> b\nmaybe b _ Nothing = b\nmaybe _ f (Just a) = f a\n\n-- | Similar to `maybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `maybe` has\n-- | to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | maybe' (\\_ -> x) f Nothing == x\n-- | maybe' (\\_ -> x) f (Just y) == f y\n-- | ```\nmaybe' :: forall a b. (Unit -> b) -> (a -> b) -> Maybe a -> b\nmaybe' g _ Nothing = g unit\nmaybe' _ f (Just a) = f a\n\n-- | Takes a default value, and a `Maybe` value. If the `Maybe` value is\n-- | `Nothing` the default value is returned, otherwise the value inside the\n-- | `Just` is returned.\n-- |\n-- | ``` purescript\n-- | fromMaybe x Nothing == x\n-- | fromMaybe x (Just y) == y\n-- | ```\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe a = maybe a identity\n\n-- | Similar to `fromMaybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`\n-- | has to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | fromMaybe' (\\_ -> x) Nothing == x\n-- | fromMaybe' (\\_ -> x) (Just y) == y\n-- | ```\nfromMaybe' :: forall a. (Unit -> a) -> Maybe a -> a\nfromMaybe' a = maybe' a identity\n\n-- | Returns `true` when the `Maybe` value was constructed with `Just`.\nisJust :: forall a. Maybe a -> Boolean\nisJust = maybe false (const true)\n\n-- | Returns `true` when the `Maybe` value is `Nothing`.\nisNothing :: forall a. Maybe a -> Boolean\nisNothing = maybe true (const false)\n\n-- | A partial function that extracts the value from the `Just` data\n-- | constructor. Passing `Nothing` to `fromJust` will throw an error at\n-- | runtime.\nfromJust :: forall a. Partial => Maybe a -> a\nfromJust (Just x) = x\n\n-- | One or none.\n-- |\n-- | ```purescript\n-- | optional empty = pure Nothing\n-- | ```\n-- |\n-- | The behaviour of `optional (pure x)` depends on whether the `Alt` instance\n-- | satisfy the left catch law (`pure a <|> b = pure a`).\n-- |\n-- | `Either e` does:\n-- |\n-- | ```purescript\n-- | optional (Right x) = Right (Just x)\n-- | ```\n-- |\n-- | But `Array` does not:\n-- |\n-- | ```purescript\n-- | optional [x] = [Just x, Nothing]\n-- | ```\noptional :: forall f a. Alt f => Applicative f => f a -> f (Maybe a)\noptional a = map Just a <|> pure Nothing\n","export function _copyST(m) {\n  return function () {\n    var r = {};\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r[k] = m[k];\n      }\n    }\n    return r;\n  };\n}\n\nexport const empty = {};\n\nexport function runST(f) {\n  return f();\n}\n\nexport function _fmapObject(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _mapWithKey(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(k)(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _foldM(bind) {\n  return function (f) {\n    return function (mz) {\n      return function (m) {\n        var acc = mz;\n        function g(k) {\n          return function (z) {\n            return f(z)(k)(m[k]);\n          };\n        }\n        for (var k in m) {\n          if (hasOwnProperty.call(m, k)) {\n            acc = bind(acc)(g(k));\n          }\n        }\n        return acc;\n      };\n    };\n  };\n}\n\nexport function _foldSCObject(m, z, f, fromMaybe) {\n  var acc = z;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      var maybeR = f(acc)(k)(m[k]);\n      var r = fromMaybe(null)(maybeR);\n      if (r === null) return acc;\n      else acc = r;\n    }\n  }\n  return acc;\n}\n\nexport function all(f) {\n  return function (m) {\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k) && !f(k)(m[k])) return false;\n    }\n    return true;\n  };\n}\n\nexport function size(m) {\n  var s = 0;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      ++s;\n    }\n  }\n  return s;\n}\n\nexport function _lookup(no, yes, k, m) {\n  return k in m ? yes(m[k]) : no;\n}\n\nexport function _lookupST(no, yes, k, m) {\n  return function () {\n    return k in m ? yes(m[k]) : no;\n  };\n}\n\nexport function toArrayWithKey(f) {\n  return function (m) {\n    var r = [];\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r.push(f(k)(m[k]));\n      }\n    }\n    return r;\n  };\n}\n\nexport const keys = Object.keys || toArrayWithKey(function (k) {\n  return function () { return k; };\n});\n","export const map_ = function (f) {\n  return function (a) {\n    return function () {\n      return f(a());\n    };\n  };\n};\n\nexport const pure_ = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bind_ = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const run = function (f) {\n  return f();\n};\n\nfunction whileST(f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n}\nexport { whileST as while };\n\nfunction forST(lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n}\nexport { forST as for };\n\nexport const foreach = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n\nfunction newSTRef(val) {\n  return function () {\n    return { value: val };\n  };\n}\nexport { newSTRef as new };\n\nexport const read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexport const modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexport const write = function (a) {\n  return function (ref) {\n    return function () {\n      return ref.value = a; // eslint-disable-line no-return-assign\n    };\n  };\n};\n","module Control.Monad\n  ( class Monad\n  , liftM1\n  , whenM\n  , unlessM\n  , ap\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  , module Control.Bind\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy)\n\n-- | The `Monad` type class combines the operations of the `Bind` and\n-- | `Applicative` type classes. Therefore, `Monad` instances represent type\n-- | constructors which support sequential composition, and also lifting of\n-- | functions of arbitrary arity.\n-- |\n-- | Instances must satisfy the following laws in addition to the\n-- | `Applicative` and `Bind` laws:\n-- |\n-- | - Left Identity: `pure x >>= f = f x`\n-- | - Right Identity: `x >>= pure = x`\nclass (Applicative m, Bind m) <= Monad m\n\ninstance monadFn :: Monad ((->) r)\n\ninstance monadArray :: Monad Array\n\ninstance monadProxy :: Monad Proxy\n\n-- | `liftM1` provides a default implementation of `(<$>)` for any\n-- | [`Monad`](#monad), without using `(<$>)` as provided by the\n-- | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n-- |\n-- | `liftM1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftM1\n-- | ```\nliftM1 :: forall m a b. Monad m => (a -> b) -> m a -> m b\nliftM1 f a = do\n  a' <- a\n  pure (f a')\n\n-- | Perform a monadic action when a condition is true, where the conditional\n-- | value is also in a monadic context.\nwhenM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nwhenM mb m = do\n  b <- mb\n  when b m\n\n-- | Perform a monadic action unless a condition is true, where the conditional\n-- | value is also in a monadic context.\nunlessM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nunlessM mb m = do\n  b <- mb\n  unless b m\n\n-- | `ap` provides a default implementation of `(<*>)` for any `Monad`, without\n-- | using `(<*>)` as provided by the `Apply`-`Monad` superclass relationship.\n-- |\n-- | `ap` can therefore be used to write `Apply` instances as follows:\n-- |\n-- | ```purescript\n-- | instance applyF :: Apply F where\n-- |   apply = ap\n-- | ```\n-- Note: Only a `Bind` constraint is needed, but this can\n-- produce loops when used with other default implementations\n-- (i.e. `liftA1`).\n-- See https://github.com/purescript/purescript-prelude/issues/232\nap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\nap f a = do\n  f' <- f\n  a' <- a\n  pure (f' a')\n","module Data.Either where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Extend (class Extend)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..), maybe, maybe')\nimport Data.Ord (class Ord1)\n\n-- | The `Either` type is used to represent a choice between two types of value.\n-- |\n-- | A common use case for `Either` is error handling, where `Left` is used to\n-- | carry an error value and `Right` is used to carry a success value.\ndata Either a b = Left a | Right b\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Right` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Left y == Left y\n-- | ```\nderive instance functorEither :: Functor (Either a)\n\nderive instance genericEither :: Generic (Either a b) _\n\ninstance invariantEither :: Invariant (Either a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions contained within a `Right` to\n-- | transform a value contained within a `Right` using the `(<*>)` operator:\n-- |\n-- | ``` purescript\n-- | Right f <*> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Left f <*> Right x == Left f\n-- | Right f <*> Left y == Left y\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a\n-- | pure function to take `Either`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Either l a -> Either l b -> Either l c`:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> Right y == Right (f x y)\n-- | ```\n-- |\n-- | The `Left`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Left`\n-- | means the whole result becomes `Left` also, taking the first `Left` value\n-- | found:\n-- |\n-- | ``` purescript\n-- | f <$> Left x <*> Right y == Left x\n-- | f <$> Right x <*> Left y == Left y\n-- | f <$> Left x <*> Left y == Left x\n-- | ```\ninstance applyEither :: Apply (Either e) where\n  apply (Left e) _ = Left e\n  apply (Right f) r = f <$> r\n\n-- | The `Applicative` instance enables lifting of values into `Either` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Either _ _ == Right x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Either` and non-`Either` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Either` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> pure y == Right (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Right` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Right` with a new constructor.\ninstance applicativeEither :: Applicative (Either e) where\n  pure = Right\n\n-- | The `Alt` instance allows for a choice to be made between two `Either`\n-- | values with the `<|>` operator, where the first `Right` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Right x <|> Right y == Right x\n-- | Left x <|> Right y == Right y\n-- | Left x <|> Left y == Left y\n-- | ```\ninstance altEither :: Alt (Either e) where\n  alt (Left _) r = r\n  alt l        _ = l\n\n-- | The `Bind` instance allows sequencing of `Either` values and functions that\n-- | return an `Either` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Left x >>= f = Left x\n-- | Right x >>= f = f x\n-- | ```\n-- |\n-- | `Either`'s \"do notation\" can be understood to work like this:\n-- | ``` purescript\n-- | x :: forall e a. Either e a\n-- | x = --\n-- |\n-- | y :: forall e b. Either e b\n-- | y = --\n-- |\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | ...which is equivalent to...\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | ...and is the same as writing...\n-- |\n-- | ```\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = case x of\n-- |   Left e ->\n-- |     Left e\n-- |   Right x -> case y of\n-- |     Left e ->\n-- |       Left e\n-- |     Right y ->\n-- |       Right (f x y)\n-- | ```\ninstance bindEither :: Bind (Either e) where\n  bind = either (\\e _ -> Left e) (\\a f -> f a)\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Either`.\ninstance monadEither :: Monad (Either e)\n\n-- | The `Extend` instance allows sequencing of `Either` values and functions\n-- | that accept an `Either` and return a non-`Either` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Left x = Left x\n-- | f <<= Right x = Right (f (Right x))\n-- | ```\ninstance extendEither :: Extend (Either e) where\n  extend _ (Left y)  = Left y\n  extend f x         = Right (f x)\n\n-- | The `Show` instance allows `Either` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for both type the `Either` can\n-- | contain.\ninstance showEither :: (Show a, Show b) => Show (Either a b) where\n  show (Left x) = \"(Left \" <> show x <> \")\"\n  show (Right y) = \"(Right \" <> show y <> \")\"\n\n-- | The `Eq` instance allows `Either` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for both\n-- | types the `Either` can contain.\nderive instance eqEither :: (Eq a, Eq b) => Eq (Either a b)\n\nderive instance eq1Either :: Eq a => Eq1 (Either a)\n\n-- | The `Ord` instance allows `Either` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | both types the `Either` can contain.\n-- |\n-- | Any `Left` value is considered to be less than a `Right` value.\nderive instance ordEither :: (Ord a, Ord b) => Ord (Either a b)\n\nderive instance ord1Either :: Ord a => Ord1 (Either a)\n\ninstance boundedEither :: (Bounded a, Bounded b) => Bounded (Either a b) where\n  top = Right top\n  bottom = Left bottom\n\ninstance semigroupEither :: (Semigroup b) => Semigroup (Either a b) where\n  append x y = append <$> x <*> y\n\n-- | Takes two functions and an `Either` value, if the value is a `Left` the\n-- | inner value is applied to the first function, if the value is a `Right`\n-- | the inner value is applied to the second function.\n-- |\n-- | ``` purescript\n-- | either f g (Left x) == f x\n-- | either f g (Right y) == g y\n-- | ```\neither :: forall a b c. (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n-- | Combine two alternatives.\nchoose :: forall m a b. Alt m => m a -> m b -> m (Either a b)\nchoose a b = Left <$> a <|> Right <$> b\n\n-- | Returns `true` when the `Either` value was constructed with `Left`.\nisLeft :: forall a b. Either a b -> Boolean\nisLeft = either (const true) (const false)\n\n-- | Returns `true` when the `Either` value was constructed with `Right`.\nisRight :: forall a b. Either a b -> Boolean\nisRight = either (const false) (const true)\n\n-- | A function that extracts the value from the `Left` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Right` is passed to `fromLeft`.\nfromLeft :: forall a b. a -> Either a b -> a\nfromLeft _ (Left a) = a\nfromLeft default _ = default\n\n-- | Similar to `fromLeft` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromLeft`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Right`.\nfromLeft' :: forall a b. (Unit -> a) -> Either a b -> a\nfromLeft' _ (Left a) = a\nfromLeft' default _ = default unit\n\n-- | A function that extracts the value from the `Right` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Left` is passed to `fromRight`.\nfromRight :: forall a b. b -> Either a b -> b\nfromRight _ (Right b) = b\nfromRight default _ = default\n\n-- | Similar to `fromRight` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromRight`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Left`.\nfromRight' :: forall a b. (Unit -> b) -> Either a b -> b\nfromRight' _ (Right b) = b\nfromRight' default _ = default unit\n\n-- | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into\n-- | a `Right`, if the value is a `Nothing` use the provided default as a `Left`\n-- |\n-- | ```purescript\n-- | note \"default\" Nothing = Left \"default\"\n-- | note \"default\" (Just 1) = Right 1\n-- | ```\nnote :: forall a b. a -> Maybe b -> Either a b\nnote a = maybe (Left a) Right\n\n-- | Similar to `note`, but for use in cases where the default value may be\n-- | expensive to compute.\n-- |\n-- | ```purescript\n-- | note' (\\_ -> \"default\") Nothing = Left \"default\"\n-- | note' (\\_ -> \"default\") (Just 1) = Right 1\n-- | ```\nnote' :: forall a b. (Unit -> a) -> Maybe b -> Either a b\nnote' f = maybe' (Left <<< f) Right\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Left` values away and converting\n-- | them into `Nothing`. `Right` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | hush (Left \"ParseError\") = Nothing\n-- | hush (Right 42) = Just 42\n-- | ```\nhush :: forall a b. Either a b -> Maybe b\nhush = either (const Nothing) Just\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Right` values away and converting\n-- | them into `Nothing`. `Left` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | blush (Left \"ParseError\") = Just \"Parse Error\"\n-- | blush (Right 42) = Nothing\n-- | ```\nblush :: forall a b. Either a b -> Maybe a\nblush = either Just (const Nothing)\n","module Data.EuclideanRing\n  ( class EuclideanRing\n  , degree\n  , div\n  , mod\n  , (/)\n  , gcd\n  , lcm\n  , module Data.CommutativeRing\n  , module Data.Ring\n  , module Data.Semiring\n  ) where\n\nimport Data.BooleanAlgebra ((||))\nimport Data.CommutativeRing (class CommutativeRing)\nimport Data.Eq (class Eq, (==))\nimport Data.Ring (class Ring, sub, (-))\nimport Data.Semiring (class Semiring, add, mul, one, zero, (*), (+))\n\n-- | The `EuclideanRing` class is for commutative rings that support division.\n-- | The mathematical structure this class is based on is sometimes also called\n-- | a *Euclidean domain*.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Ring`\n-- | laws:\n-- |\n-- | - Integral domain: `one /= zero`, and if `a` and `b` are both nonzero then\n-- |   so is their product `a * b`\n-- | - Euclidean function `degree`:\n-- |   - Nonnegativity: For all nonzero `a`, `degree a >= 0`\n-- |   - Quotient/remainder: For all `a` and `b`, where `b` is nonzero,\n-- |     let `q = a / b` and ``r = a `mod` b``; then `a = q*b + r`, and also\n-- |     either `r = zero` or `degree r < degree b`\n-- | - Submultiplicative euclidean function:\n-- |   - For all nonzero `a` and `b`, `degree a <= degree (a * b)`\n-- |\n-- | The behaviour of division by `zero` is unconstrained by these laws,\n-- | meaning that individual instances are free to choose how to behave in this\n-- | case. Similarly, there are no restrictions on what the result of\n-- | `degree zero` is; it doesn't make sense to ask for `degree zero` in the\n-- | same way that it doesn't make sense to divide by `zero`, so again,\n-- | individual instances may choose how to handle this case.\n-- |\n-- | For any `EuclideanRing` which is also a `Field`, one valid choice\n-- | for `degree` is simply `const 1`. In fact, unless there's a specific\n-- | reason not to, `Field` types should normally use this definition of\n-- | `degree`.\n-- |\n-- | The `EuclideanRing Int` instance is one of the most commonly used\n-- | `EuclideanRing` instances and deserves a little more discussion. In\n-- | particular, there are a few different sensible law-abiding implementations\n-- | to choose from, with slightly different behaviour in the presence of\n-- | negative dividends or divisors. The most common definitions are \"truncating\"\n-- | division, where the result of `a / b` is rounded towards 0, and \"Knuthian\"\n-- | or \"flooring\" division, where the result of `a / b` is rounded towards\n-- | negative infinity. A slightly less common, but arguably more useful, option\n-- | is \"Euclidean\" division, which is defined so as to ensure that ``a `mod` b``\n-- | is always nonnegative. With Euclidean division, `a / b` rounds towards\n-- | negative infinity if the divisor is positive, and towards positive infinity\n-- | if the divisor is negative. Note that all three definitions are identical if\n-- | we restrict our attention to nonnegative dividends and divisors.\n-- |\n-- | In versions 1.x, 2.x, and 3.x of the Prelude, the `EuclideanRing Int`\n-- | instance used truncating division. As of 4.x, the `EuclideanRing Int`\n-- | instance uses Euclidean division. Additional functions `quot` and `rem` are\n-- | supplied if truncating division is desired.\nclass CommutativeRing a <= EuclideanRing a where\n  degree :: a -> Int\n  div :: a -> a -> a\n  mod :: a -> a -> a\n\ninfixl 7 div as /\n\ninstance euclideanRingInt :: EuclideanRing Int where\n  degree = intDegree\n  div = intDiv\n  mod = intMod\n\ninstance euclideanRingNumber :: EuclideanRing Number where\n  degree _ = 1\n  div = numDiv\n  mod _ _ = 0.0\n\nforeign import intDegree :: Int -> Int\nforeign import intDiv :: Int -> Int -> Int\nforeign import intMod :: Int -> Int -> Int\n\nforeign import numDiv :: Number -> Number -> Number\n\n-- | The *greatest common divisor* of two values.\ngcd :: forall a. Eq a => EuclideanRing a => a -> a -> a\ngcd a b =\n  if b == zero then a\n  else gcd b (a `mod` b)\n\n-- | The *least common multiple* of two values.\nlcm :: forall a. Eq a => EuclideanRing a => a -> a -> a\nlcm a b =\n  if a == zero || b == zero then zero\n  else a * b / gcd a b\n","module Data.Monoid\n  ( class Monoid\n  , mempty\n  , power\n  , guard\n  , module Data.Semigroup\n  , class MonoidRecord\n  , memptyRecord\n  ) where\n\nimport Data.Boolean (otherwise)\nimport Data.Eq ((==))\nimport Data.EuclideanRing (mod, (/))\nimport Data.Ord ((<=))\nimport Data.Ordering (Ordering(..))\nimport Data.Semigroup (class Semigroup, class SemigroupRecord, (<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a\n-- | left and right unit for the associative operation `<>`:\n-- |\n-- | - Left unit: `(mempty <> x) = x`\n-- | - Right unit: `(x <> mempty) = x`\n-- |\n-- | `Monoid`s are commonly used as the result of fold operations, where\n-- | `<>` is used to combine individual results, and `mempty` gives the result\n-- | of folding an empty collection of elements.\n-- |\n-- | ### Newtypes for Monoid\n-- |\n-- | Some types (e.g. `Int`, `Boolean`) can implement multiple law-abiding\n-- | instances for `Monoid`. Let's use `Int` as an example\n-- | 1. `<>` could be `+` and `mempty` could be `0`\n-- | 2. `<>` could be `*` and `mempty` could be `1`.\n-- |\n-- | To clarify these ambiguous situations, one should use the newtypes\n-- | defined in `Data.Monoid.<NewtypeName>` modules.\n-- |\n-- | In the above ambiguous situation, we could use `Additive`\n-- | for the first situation or `Multiplicative` for the second one.\nclass Semigroup m <= Monoid m where\n  mempty :: m\n\ninstance monoidUnit :: Monoid Unit where\n  mempty = unit\n\ninstance monoidOrdering :: Monoid Ordering where\n  mempty = EQ\n\ninstance monoidFn :: Monoid b => Monoid (a -> b) where\n  mempty _ = mempty\n\ninstance monoidString :: Monoid String where\n  mempty = \"\"\n\ninstance monoidArray :: Monoid (Array a) where\n  mempty = []\n\ninstance monoidRecord :: (RL.RowToList row list, MonoidRecord list row row) => Monoid (Record row) where\n  mempty = memptyRecord (Proxy :: Proxy list)\n\n-- | Append a value to itself a certain number of times. For the\n-- | `Multiplicative` type, and for a non-negative power, this is the same as\n-- | normal number exponentiation.\n-- |\n-- | If the second argument is negative this function will return `mempty`\n-- | (*unlike* normal number exponentiation). The `Monoid` constraint alone\n-- | is not enough to write a `power` function with the property that `power x\n-- | n` cancels with `power x (-n)`, i.e. `power x n <> power x (-n) = mempty`.\n-- | For that, we would additionally need the ability to invert elements, i.e.\n-- | a Group.\n-- |\n-- | ```purescript\n-- | power [1,2] 3    == [1,2,1,2,1,2]\n-- | power [1,2] 1    == [1,2]\n-- | power [1,2] 0    == []\n-- | power [1,2] (-3) == []\n-- | ```\n-- |\npower :: forall m. Monoid m => m -> Int -> m\npower x = go\n  where\n  go :: Int -> m\n  go p\n    | p <= 0 = mempty\n    | p == 1 = x\n    | p `mod` 2 == 0 = let x' = go (p / 2) in x' <> x'\n    | otherwise = let x' = go (p / 2) in x' <> x' <> x\n\n-- | Allow or \"truncate\" a Monoid to its `mempty` value based on a condition.\nguard :: forall m. Monoid m => Boolean -> m -> m\nguard true a = a\nguard false _ = mempty\n\n-- | A class for records where all fields have `Monoid` instances, used to\n-- | implement the `Monoid` instance for records.\nclass MonoidRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow <= MonoidRecord rowlist row subrow | rowlist -> row subrow where\n  memptyRecord :: Proxy rowlist -> Record subrow\n\ninstance monoidRecordNil :: MonoidRecord RL.Nil row () where\n  memptyRecord _ = {}\n\ninstance monoidRecordCons ::\n  ( IsSymbol key\n  , Monoid focus\n  , Row.Cons key focus subrowTail subrow\n  , MonoidRecord rowlistTail row subrowTail\n  ) =>\n  MonoidRecord (RL.Cons key focus rowlistTail) row subrow where\n  memptyRecord _ = insert mempty tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = memptyRecord (Proxy :: Proxy rowlistTail)\n","export const pureE = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bindE = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const untilE = function (f) {\n  return function () {\n    while (!f());\n  };\n};\n\nexport const whileE = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexport const forE = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexport const foreachE = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n","-- | This module provides the `Effect` type, which is used to represent\n-- | _native_ effects. The `Effect` type provides a typed API for effectful\n-- | computations, while at the same time generating efficient JavaScript.\nmodule Effect\n  ( Effect\n  , untilE, whileE, forE, foreachE\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\n\n-- | A native effect. The type parameter denotes the return type of running the\n-- | effect, that is, an `Effect Int` is a possibly-effectful computation which\n-- | eventually produces a value of the type `Int` when it finishes.\nforeign import data Effect :: Type -> Type\n\ntype role Effect representational\n\ninstance functorEffect :: Functor Effect where\n  map = liftA1\n\ninstance applyEffect :: Apply Effect where\n  apply = ap\n\ninstance applicativeEffect :: Applicative Effect where\n  pure = pureE\n\nforeign import pureE :: forall a. a -> Effect a\n\ninstance bindEffect :: Bind Effect where\n  bind = bindE\n\nforeign import bindE :: forall a b. Effect a -> (a -> Effect b) -> Effect b\n\ninstance monadEffect :: Monad Effect\n\n-- | The `Semigroup` instance for effects allows you to run two effects, one\n-- | after the other, and then combine their results using the result type's\n-- | `Semigroup` instance.\ninstance semigroupEffect :: Semigroup a => Semigroup (Effect a) where\n  append = lift2 append\n\n-- | If you have a `Monoid a` instance, then `mempty :: Effect a` is defined as\n-- | `pure mempty`.\ninstance monoidEffect :: Monoid a => Monoid (Effect a) where\n  mempty = pureE mempty\n\n-- | Loop until a condition becomes `true`.\n-- |\n-- | `untilE b` is an effectful computation which repeatedly runs the effectful\n-- | computation `b`, until its return value is `true`.\nforeign import untilE :: Effect Boolean -> Effect Unit\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `whileE b m` is effectful computation which runs the effectful computation\n-- | `b`. If its result is `true`, it runs the effectful computation `m` and\n-- | loops. If not, the computation ends.\nforeign import whileE :: forall a. Effect Boolean -> Effect a -> Effect Unit\n\n-- | Loop over a consecutive collection of numbers.\n-- |\n-- | `forE lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import forE :: Int -> Int -> (Int -> Effect Unit) -> Effect Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `foreachE xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreachE :: forall a. Array a -> (a -> Effect Unit) -> Effect Unit\n","module Control.Monad.ST.Internal\n  ( Region\n  , ST\n  , run\n  , while\n  , for\n  , foreach\n  , STRef\n  , new\n  , read\n  , modify'\n  , modify\n  , write\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..))\nimport Partial.Unsafe (unsafePartial)\n\n-- | `ST` is concerned with _restricted_ mutation. Mutation is restricted to a\n-- | _region_ of mutable references. This kind is inhabited by phantom types\n-- | which represent regions in the type system.\nforeign import data Region :: Type\n\n-- | The `ST` type constructor allows _local mutation_, i.e. mutation which\n-- | does not \"escape\" into the surrounding computation.\n-- |\n-- | An `ST` computation is parameterized by a phantom type which is used to\n-- | restrict the set of reference cells it is allowed to access.\n-- |\n-- | The `run` function can be used to run a computation in the `ST` monad.\nforeign import data ST :: Region -> Type -> Type\n\ntype role ST nominal representational\n\nforeign import map_ :: forall r a b. (a -> b) -> ST r a -> ST r b\n\nforeign import pure_ :: forall r a. a -> ST r a\n\nforeign import bind_ :: forall r a b. ST r a -> (a -> ST r b) -> ST r b\n\ninstance functorST :: Functor (ST r) where\n  map = map_\n\ninstance applyST :: Apply (ST r) where\n  apply = ap\n\ninstance applicativeST :: Applicative (ST r) where\n  pure = pure_\n\ninstance bindST :: Bind (ST r) where\n  bind = bind_\n\ninstance monadST :: Monad (ST r)\n\ninstance monadRecST :: MonadRec (ST r) where\n  tailRecM f a = do\n    r <- new =<< f a\n    while (isLooping <$> read r) do\n      read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          void (write e r)\n        Done _ -> pure unit\n    fromDone <$> read r\n    where\n      fromDone :: forall a b. Step a b -> b\n      fromDone = unsafePartial \\(Done b) -> b\n\n      isLooping = case _ of\n        Loop _ -> true\n        _ -> false\n\ninstance semigroupST :: Semigroup a => Semigroup (ST r a) where\n  append = lift2 append\n\ninstance monoidST :: Monoid a => Monoid (ST r a) where\n  mempty = pure mempty\n\n-- | Run an `ST` computation.\n-- |\n-- | Note: the type of `run` uses a rank-2 type to constrain the phantom\n-- | type `r`, such that the computation must not leak any mutable references\n-- | to the surrounding computation. It may cause problems to apply this\n-- | function using the `$` operator. The recommended approach is to use\n-- | parentheses instead.\nforeign import run :: forall a. (forall r. ST r a) -> a\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `while b m` is ST computation which runs the ST computation `b`. If its\n-- | result is `true`, it runs the ST computation `m` and loops. If not, the\n-- | computation ends.\nforeign import while :: forall r a. ST r Boolean -> ST r a -> ST r Unit\n\n-- | Loop over a consecutive collection of numbers\n-- |\n-- | `ST.for lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import for :: forall r a. Int -> Int -> (Int -> ST r a) -> ST r Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `ST.foreach xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreach :: forall r a. Array a -> (a -> ST r Unit) -> ST r Unit\n\n-- | The type `STRef r a` represents a mutable reference holding a value of\n-- | type `a`, which can be used with the `ST r` effect.\nforeign import data STRef :: Region -> Type -> Type\n\ntype role STRef nominal representational\n\n-- | Create a new mutable reference.\nforeign import new :: forall a r. a -> ST r (STRef r a)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall a r. STRef r a -> ST r a\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value, computing a new state value for the reference and\n-- | a return value.\nmodify' :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\nmodify' = modifyImpl\n\nforeign import modifyImpl :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\n\n-- | Modify the value of a mutable reference by applying a function to the\n-- | current value. The modified value is returned.\nmodify :: forall r a. (a -> a) -> STRef r a -> ST r a\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | Set the value of a mutable reference.\nforeign import write :: forall a r. a -> STRef r a -> ST r a\n","//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const rangeImpl = function (start, end) {\n  var step = start > end ? -1 : 1;\n  var result = new Array(step * (end - start) + 1);\n  var i = start, n = 0;\n  while (i !== end) {\n    result[n++] = i;\n    i += step;\n  }\n  result[n] = i;\n  return result;\n};\n\nvar replicateFill = function (count, value) {\n  if (count < 1) {\n    return [];\n  }\n  var result = new Array(count);\n  return result.fill(value);\n};\n\nvar replicatePolyfill = function (count, value) {\n  var result = [];\n  var n = 0;\n  for (var i = 0; i < count; i++) {\n    result[n++] = value;\n  }\n  return result;\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexport const replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexport const fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr, xs) {\n    return listToArray(foldr(curryCons)(emptyList)(xs));\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unconsImpl = function (empty, next, xs) {\n  return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const indexImpl = function (just, nothing, xs, i) {\n  return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n};\n\nexport const findMapImpl = function (nothing, isJust, f, xs) {\n  for (var i = 0; i < xs.length; i++) {\n    var result = f(xs[i]);\n    if (isJust(result)) return result;\n  }\n  return nothing;\n};\n\nexport const findIndexImpl = function (just, nothing, f, xs) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const findLastIndexImpl = function (just, nothing, f, xs) {\n  for (var i = xs.length - 1; i >= 0; i--) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const _insertAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i > l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 0, a);\n  return just(l1);\n};\n\nexport const _deleteAt = function (just, nothing, i, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 1);\n  return just(l1);\n};\n\nexport const _updateAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1[i] = a;\n  return just(l1);\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexport const concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexport const filterImpl = function (f, xs) {\n  return xs.filter(f);\n};\n\nexport const partitionImpl = function (f, xs) {\n  var yes = [];\n  var no  = [];\n  for (var i = 0; i < xs.length; i++) {\n    var x = xs[i];\n    if (f(x))\n      yes.push(x);\n    else\n      no.push(x);\n  }\n  return { yes: yes, no: no };\n};\n\nexport const scanlImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    acc = f(acc)(xs[i]);\n    out[i] = acc;\n  }\n  return out;\n};\n\nexport const scanrImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = len - 1; i >= 0; i--) {\n    acc = f(xs[i])(acc);\n    out[i] = acc;\n  }\n  return out;\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    var out;\n\n    if (xs.length < 2) return xs;\n\n    out = xs.slice(0);\n    mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);\n\n    return out;\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sliceImpl = function (s, e, l) {\n  return l.slice(s, e);\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const zipWithImpl = function (f, xs, ys) {\n  var l = xs.length < ys.length ? xs.length : ys.length;\n  var result = new Array(l);\n  for (var i = 0; i < l; i++) {\n    result[i] = f(xs[i])(ys[i]);\n  }\n  return result;\n};\n\n//------------------------------------------------------------------------------\n// Folding ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const anyImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (p(xs[i])) return true;\n  }\n  return false;\n};\n\nexport const allImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (!p(xs[i])) return false;\n  }\n  return true;\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unsafeIndexImpl = function (xs, n) {\n  return xs[n];\n};\n","function newSTArray() {\n  return [];\n}\nexport { newSTArray as new };\n\nexport const peekImpl = function (just, nothing, i, xs) {\n  return i >= 0 && i < xs.length ? just(xs[i]) : nothing;\n};\n\nexport const pokeImpl = function (i, a, xs) {\n  var ret = i >= 0 && i < xs.length;\n  if (ret) xs[i] = a;\n  return ret;\n};\n\nexport const lengthImpl = function (xs) {\n  return xs.length;\n};\n\nexport const popImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.pop()) : nothing;\n};\n\nexport const pushAllImpl = function (as, xs) {\n  return xs.push.apply(xs, as);\n};\n\nexport const shiftImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.shift()) : nothing;\n};\n\nexport const unshiftAllImpl = function (as, xs) {\n  return xs.unshift.apply(xs, as);\n};\n\nexport const spliceImpl = function (i, howMany, bs, xs) {\n  return xs.splice.apply(xs, [i, howMany].concat(bs));\n};\n\nfunction unsafeFreezeThawImpl(xs) {\n  return xs;\n}\n\nexport const unsafeFreezeImpl = unsafeFreezeThawImpl;\n\nexport const unsafeThawImpl = unsafeFreezeThawImpl;\n\nfunction copyImpl(xs) {\n  return xs.slice();\n}\n\nexport const freezeImpl = copyImpl;\n\nexport const thawImpl = copyImpl;\n\nexport const cloneImpl = copyImpl;\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      } else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    if (xs.length < 2) return xs;\n\n    mergeFromTo(compare, fromOrdering, xs, xs.slice(0), 0, xs.length);\n\n    return xs;\n  };\n})();\n\nexport const toAssocArrayImpl = function (xs) {\n  var n = xs.length;\n  var as = new Array(n);\n  for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };\n  return as;\n};\n\nexport const pushImpl = function (a, xs) {\n  return xs.push(a);\n};\n","export const mkSTFn1 = function mkSTFn1(fn) {\n  return function(x) {\n    return fn(x)();\n  };\n};\n  \nexport const mkSTFn2 = function mkSTFn2(fn) {\n  return function(a, b) {\n    return fn(a)(b)();\n  };\n};\n  \nexport const mkSTFn3 = function mkSTFn3(fn) {\n  return function(a, b, c) {\n    return fn(a)(b)(c)();\n  };\n};\n  \nexport const mkSTFn4 = function mkSTFn4(fn) {\n  return function(a, b, c, d) {\n    return fn(a)(b)(c)(d)();\n  };\n};\n  \nexport const mkSTFn5 = function mkSTFn5(fn) {\n  return function(a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e)();\n  };\n};\n  \nexport const mkSTFn6 = function mkSTFn6(fn) {\n  return function(a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f)();\n  };\n};\n  \nexport const mkSTFn7 = function mkSTFn7(fn) {\n  return function(a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g)();\n  };\n};\n  \nexport const mkSTFn8 = function mkSTFn8(fn) {\n  return function(a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)();\n  };\n};\n  \nexport const mkSTFn9 = function mkSTFn9(fn) {\n  return function(a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)();\n  };\n};\n  \nexport const mkSTFn10 = function mkSTFn10(fn) {\n  return function(a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)();\n  };\n};\n  \nexport const runSTFn1 = function runSTFn1(fn) {\n  return function(a) {\n    return function() {\n      return fn(a);\n    };\n  };\n};\n  \nexport const runSTFn2 = function runSTFn2(fn) {\n  return function(a) {\n    return function(b) {\n      return function() {\n        return fn(a, b);\n      };\n    };\n  };\n};\n  \nexport const runSTFn3 = function runSTFn3(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function() {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn4 = function runSTFn4(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function() {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn5 = function runSTFn5(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function() {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn6 = function runSTFn6(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function() {\n                return fn(a, b, c, d, e, f);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn7 = function runSTFn7(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function() {\n                  return fn(a, b, c, d, e, f, g);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn8 = function runSTFn8(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function() {\n                    return fn(a, b, c, d, e, f, g, h);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn9 = function runSTFn9(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function() {\n                      return fn(a, b, c, d, e, f, g, h, i);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn10 = function runSTFn10(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function(j) {\n                      return function() {\n                        return fn(a, b, c, d, e, f, g, h, i, j);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};","-- | Helper functions for working with mutable arrays using the `ST` effect.\n-- |\n-- | This module can be used when performance is important and mutation is a local effect.\n\nmodule Data.Array.ST\n  ( STArray(..)\n  , Assoc\n  , run\n  , withArray\n  , new\n  , peek\n  , poke\n  , modify\n  , length\n  , pop\n  , push\n  , pushAll\n  , shift\n  , unshift\n  , unshiftAll\n  , splice\n  , sort\n  , sortBy\n  , sortWith\n  , freeze\n  , thaw\n  , clone\n  , unsafeFreeze\n  , unsafeThaw\n  , toAssocArray\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST, Region)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Uncurried (STFn1, STFn2, STFn3, STFn4, runSTFn1, runSTFn2, runSTFn3, runSTFn4)\nimport Data.Maybe (Maybe(..))\n\n-- | A reference to a mutable array.\n-- |\n-- | The first type parameter represents the memory region which the array belongs to.\n-- | The second type parameter defines the type of elements of the mutable array.\n-- |\n-- | The runtime representation of a value of type `STArray h a` is the same as that of `Array a`,\n-- | except that mutation is allowed.\nforeign import data STArray :: Region -> Type -> Type\n\ntype role STArray nominal representational\n\n-- | An element and its index.\ntype Assoc a = { value :: a, index :: Int }\n\n-- | A safe way to create and work with a mutable array before returning an\n-- | immutable array for later perusal. This function avoids copying the array\n-- | before returning it - it uses unsafeFreeze internally, but this wrapper is\n-- | a safe interface to that function.\nrun :: forall a. (forall h. ST h (STArray h a)) -> Array a\nrun st = ST.run (st >>= unsafeFreeze)\n\n-- | Perform an effect requiring a mutable array on a copy of an immutable array,\n-- | safely returning the result as an immutable array.\nwithArray\n  :: forall h a b\n   . (STArray h a -> ST h b)\n  -> Array a\n  -> ST h (Array a)\nwithArray f xs = do\n  result <- thaw xs\n  _ <- f result\n  unsafeFreeze result\n\n-- | O(1). Convert a mutable array to an immutable array, without copying. The mutable\n-- | array must not be mutated afterwards.\nunsafeFreeze :: forall h a. STArray h a -> ST h (Array a)\nunsafeFreeze = runSTFn1 unsafeFreezeImpl\n\nforeign import unsafeFreezeImpl :: forall h a. STFn1 (STArray h a) h (Array a)\n\n-- | O(1) Convert an immutable array to a mutable array, without copying. The input\n-- | array must not be used afterward.\nunsafeThaw :: forall h a. Array a -> ST h (STArray h a)\nunsafeThaw = runSTFn1 unsafeThawImpl\n\nforeign import unsafeThawImpl :: forall h a. STFn1 (Array a) h (STArray h a)\n\n-- | Create a new, empty mutable array.\nforeign import new :: forall h a. ST h (STArray h a)\n\nthaw\n  :: forall h a\n   . Array a\n  -> ST h (STArray h a)\nthaw = runSTFn1 thawImpl\n\n-- | Create a mutable copy of an immutable array.\nforeign import thawImpl :: forall h a. STFn1 (Array a) h (STArray h a)\n\n-- | Make a mutable copy of a mutable array.\nclone\n  :: forall h a\n   . STArray h a\n  -> ST h (STArray h a)\nclone = runSTFn1 cloneImpl\n\nforeign import cloneImpl :: forall h a. STFn1 (STArray h a) h (STArray h a)\n\n-- | Sort a mutable array in place. Sorting is stable: the order of equal\n-- | elements is preserved.\nsort :: forall a h. Ord a => STArray h a -> ST h (STArray h a)\nsort = sortBy compare\n\n-- | Remove the first element from an array and return that element.\nshift :: forall h a. STArray h a -> ST h (Maybe a)\nshift = runSTFn3 shiftImpl Just Nothing\n\nforeign import shiftImpl\n  :: forall h a\n   . STFn3 (forall b. b -> Maybe b) (forall b. Maybe b) (STArray h a) h (Maybe a)\n\n-- | Sort a mutable array in place using a comparison function. Sorting is\n-- | stable: the order of elements is preserved if they are equal according to\n-- | the comparison function.\nsortBy\n  :: forall a h\n   . (a -> a -> Ordering)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortBy comp = runSTFn3 sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\nforeign import sortByImpl\n  :: forall a h\n   . STFn3 (a -> a -> Ordering) (Ordering -> Int) (STArray h a) h (STArray h a)\n\n-- | Sort a mutable array in place based on a projection. Sorting is stable: the\n-- | order of elements is preserved if they are equal according to the projection.\nsortWith\n  :: forall a b h\n   . Ord b\n  => (a -> b)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortWith f = sortBy (comparing f)\n\n-- | Create an immutable copy of a mutable array.\nfreeze\n  :: forall h a\n   . STArray h a\n  -> ST h (Array a)\nfreeze = runSTFn1 freezeImpl\n\nforeign import freezeImpl :: forall h a. STFn1 (STArray h a) h (Array a)\n\n-- | Read the value at the specified index in a mutable array.\npeek\n  :: forall h a\n   . Int\n  -> STArray h a\n  -> ST h (Maybe a)\npeek = runSTFn4 peekImpl Just Nothing\n\nforeign import peekImpl :: forall h a r. STFn4 (a -> r) r Int (STArray h a) h r\n\npoke\n  :: forall h a\n   . Int\n  -> a\n  -> STArray h a\n  -> ST h Boolean\npoke = runSTFn3 pokeImpl\n\n-- | Change the value at the specified index in a mutable array.\nforeign import pokeImpl :: forall h a. STFn3 Int a (STArray h a) h Boolean\n\nforeign import lengthImpl :: forall h a. STFn1 (STArray h a) h Int\n\n-- | Get the number of elements in a mutable array.\nlength :: forall h a. STArray h a -> ST h Int\nlength = runSTFn1 lengthImpl\n\n-- | Remove the last element from an array and return that element.\npop :: forall h a. STArray h a -> ST h (Maybe a)\npop = runSTFn3 popImpl Just Nothing\n\nforeign import popImpl\n  :: forall h a\n   . STFn3 (forall b. b -> Maybe b) (forall b. Maybe b) (STArray h a) h (Maybe a)\n\n-- | Append an element to the end of a mutable array. Returns the new length of\n-- | the array.\npush :: forall h a. a -> (STArray h a) -> ST h Int\npush = runSTFn2 pushImpl\n\nforeign import pushImpl :: forall h a. STFn2 a (STArray h a) h Int\n\n-- | Append the values in an immutable array to the end of a mutable array.\n-- | Returns the new length of the mutable array.\npushAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\npushAll = runSTFn2 pushAllImpl\n\nforeign import pushAllImpl\n  :: forall h a\n   . STFn2 (Array a) (STArray h a) h Int\n\n-- | Append an element to the front of a mutable array. Returns the new length of\n-- | the array.\nunshift :: forall h a. a -> STArray h a -> ST h Int\nunshift a = runSTFn2 unshiftAllImpl [ a ]\n\n-- | Append the values in an immutable array to the front of a mutable array.\n-- | Returns the new length of the mutable array.\nunshiftAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\nunshiftAll = runSTFn2 unshiftAllImpl\n\nforeign import unshiftAllImpl\n  :: forall h a\n   . STFn2 (Array a) (STArray h a) h Int\n\n-- | Mutate the element at the specified index using the supplied function.\nmodify :: forall h a. Int -> (a -> a) -> STArray h a -> ST h Boolean\nmodify i f xs = do\n  entry <- peek i xs\n  case entry of\n    Just x -> poke i (f x) xs\n    Nothing -> pure false\n\n-- | Remove and/or insert elements from/into a mutable array at the specified index.\nsplice\n  :: forall h a\n   . Int\n  -> Int\n  -> Array a\n  -> STArray h a\n  -> ST h (Array a)\nsplice = runSTFn4 spliceImpl\n\nforeign import spliceImpl\n  :: forall h a\n   . STFn4 Int Int (Array a) (STArray h a) h (Array a)\n\n-- | Create an immutable copy of a mutable array, where each element\n-- | is labelled with its index in the original array.\ntoAssocArray\n  :: forall h a\n   . STArray h a\n  -> ST h (Array (Assoc a))\ntoAssocArray = runSTFn1 toAssocArrayImpl\n\nforeign import toAssocArrayImpl\n  :: forall h a\n   . STFn1 (STArray h a) h (Array (Assoc a))\n","export const boolConj = function (b1) {\n  return function (b2) {\n    return b1 && b2;\n  };\n};\n\nexport const boolDisj = function (b1) {\n  return function (b2) {\n    return b1 || b2;\n  };\n};\n\nexport const boolNot = function (b) {\n  return !b;\n};\n","module Data.HeytingAlgebra\n  ( class HeytingAlgebra\n  , tt\n  , ff\n  , implies\n  , conj\n  , disj\n  , not\n  , (&&)\n  , (||)\n  , class HeytingAlgebraRecord\n  , ffRecord\n  , ttRecord\n  , impliesRecord\n  , conjRecord\n  , disjRecord\n  , notRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `HeytingAlgebra` type class represents types that are bounded lattices with\n-- | an implication operator such that the following laws hold:\n-- |\n-- | - Associativity:\n-- |   - `a || (b || c) = (a || b) || c`\n-- |   - `a && (b && c) = (a && b) && c`\n-- | - Commutativity:\n-- |   - `a || b = b || a`\n-- |   - `a && b = b && a`\n-- | - Absorption:\n-- |   - `a || (a && b) = a`\n-- |   - `a && (a || b) = a`\n-- | - Idempotent:\n-- |   - `a || a = a`\n-- |   - `a && a = a`\n-- | - Identity:\n-- |   - `a || ff = a`\n-- |   - `a && tt = a`\n-- | - Implication:\n-- |   - ``a `implies` a = tt``\n-- |   - ``a && (a `implies` b) = a && b``\n-- |   - ``b && (a `implies` b) = b``\n-- |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``\n-- | - Complemented:\n-- |   - ``not a = a `implies` ff``\nclass HeytingAlgebra a where\n  ff :: a\n  tt :: a\n  implies :: a -> a -> a\n  conj :: a -> a -> a\n  disj :: a -> a -> a\n  not :: a -> a\n\ninfixr 3 conj as &&\ninfixr 2 disj as ||\n\ninstance heytingAlgebraBoolean :: HeytingAlgebra Boolean where\n  ff = false\n  tt = true\n  implies a b = not a || b\n  conj = boolConj\n  disj = boolDisj\n  not = boolNot\n\ninstance heytingAlgebraUnit :: HeytingAlgebra Unit where\n  ff = unit\n  tt = unit\n  implies _ _ = unit\n  conj _ _ = unit\n  disj _ _ = unit\n  not _ = unit\n\ninstance heytingAlgebraFunction :: HeytingAlgebra b => HeytingAlgebra (a -> b) where\n  ff _ = ff\n  tt _ = tt\n  implies f g a = f a `implies` g a\n  conj f g a = f a && g a\n  disj f g a = f a || g a\n  not f a = not (f a)\n\ninstance heytingAlgebraProxy :: HeytingAlgebra (Proxy a) where\n  conj _ _ = Proxy\n  disj _ _ = Proxy\n  implies _ _ = Proxy\n  ff = Proxy\n  not _ = Proxy\n  tt = Proxy\n\ninstance heytingAlgebraRecord :: (RL.RowToList row list, HeytingAlgebraRecord list row row) => HeytingAlgebra (Record row) where\n  ff = ffRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  tt = ttRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  conj = conjRecord (Proxy :: Proxy list)\n  disj = disjRecord (Proxy :: Proxy list)\n  implies = impliesRecord (Proxy :: Proxy list)\n  not = notRecord (Proxy :: Proxy list)\n\nforeign import boolConj :: Boolean -> Boolean -> Boolean\nforeign import boolDisj :: Boolean -> Boolean -> Boolean\nforeign import boolNot :: Boolean -> Boolean\n\n-- | A class for records where all fields have `HeytingAlgebra` instances, used\n-- | to implement the `HeytingAlgebra` instance for records.\nclass HeytingAlgebraRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass HeytingAlgebraRecord rowlist row subrow | rowlist -> subrow where\n  ffRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  ttRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  impliesRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  disjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  conjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  notRecord :: Proxy rowlist -> Record row -> Record subrow\n\ninstance heytingAlgebraRecordNil :: HeytingAlgebraRecord RL.Nil row () where\n  conjRecord _ _ _ = {}\n  disjRecord _ _ _ = {}\n  ffRecord _ _ = {}\n  impliesRecord _ _ _ = {}\n  notRecord _ _ = {}\n  ttRecord _ _ = {}\n\ninstance heytingAlgebraRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , HeytingAlgebraRecord rowlistTail row subrowTail\n  , HeytingAlgebra focus\n  ) =>\n  HeytingAlgebraRecord (RL.Cons key focus rowlistTail) row subrow where\n  conjRecord _ ra rb = insert (conj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = conjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  disjRecord _ ra rb = insert (disj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = disjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  impliesRecord _ ra rb = insert (implies (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = impliesRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  ffRecord _ row = insert ff tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ffRecord (Proxy :: Proxy rowlistTail) row\n\n  notRecord _ row = insert (not (get row)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = notRecord (Proxy :: Proxy rowlistTail) row\n\n  ttRecord _ row = insert tt tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ttRecord (Proxy :: Proxy rowlistTail) row\n","module Data.Array.ST.Iterator\n  ( Iterator\n  , iterator\n  , iterate\n  , next\n  , peek\n  , exhausted\n  , pushWhile\n  , pushAll\n  ) where\n\nimport Prelude\nimport Control.Monad.ST (ST)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Ref (STRef)\nimport Control.Monad.ST.Ref as STRef\nimport Data.Array.ST (STArray)\nimport Data.Array.ST as STA\n\nimport Data.Maybe (Maybe(..), isNothing)\n\n-- | This type provides a slightly easier way of iterating over an array's\n-- | elements in an STArray computation, without having to keep track of\n-- | indices.\ndata Iterator r a = Iterator (Int -> Maybe a) (STRef r Int)\n\n-- | Make an Iterator given an indexing function into an array (or anything\n-- | else). If `xs :: Array a`, the standard way to create an iterator over\n-- | `xs` is to use `iterator (xs !! _)`, where `(!!)` comes from `Data.Array`.\niterator :: forall r a. (Int -> Maybe a) -> ST r (Iterator r a)\niterator f =\n  Iterator f <$> STRef.new 0\n\n-- | Perform an action once for each item left in an iterator. If the action\n-- | itself also advances the same iterator, `iterate` will miss those items\n-- | out.\niterate :: forall r a. Iterator r a -> (a -> ST r Unit) -> ST r Unit\niterate iter f = do\n  break <- STRef.new false\n  ST.while (not <$> STRef.read break) do\n    mx <- next iter\n    case mx of\n      Just x -> f x\n      Nothing -> void $ STRef.write true break\n\n-- | Get the next item out of an iterator, advancing it. Returns Nothing if the\n-- | Iterator is exhausted.\nnext :: forall r a. Iterator r a -> ST r (Maybe a)\nnext (Iterator f currentIndex) = do\n  i <- STRef.read currentIndex\n  _ <- STRef.modify (_ + 1) currentIndex\n  pure (f i)\n\n-- | Get the next item out of an iterator without advancing it.\npeek :: forall r a. Iterator r a -> ST r (Maybe a)\npeek (Iterator f currentIndex) = do\n  i <- STRef.read currentIndex\n  pure (f i)\n\n-- | Check whether an iterator has been exhausted.\nexhausted :: forall r a. Iterator r a -> ST r Boolean\nexhausted = map isNothing <<< peek\n\n-- | Extract elements from an iterator and push them on to an STArray for as\n-- | long as those elements satisfy a given predicate.\npushWhile :: forall r a. (a -> Boolean) -> Iterator r a -> STArray r a -> ST r Unit\npushWhile p iter array = do\n  break <- STRef.new false\n  ST.while (not <$> STRef.read break) do\n    mx <- peek iter\n    case mx of\n      Just x | p x -> do\n        _ <- STA.push x array\n        void $ next iter\n      _ ->\n        void $ STRef.write true break\n\n-- | Push the entire remaining contents of an iterator onto an STArray.\npushAll :: forall r a. Iterator r a -> STArray r a -> ST r Unit\npushAll = pushWhile (const true)\n","export const foldrArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n      }\n      return acc;\n    };\n  };\n};\n\nexport const foldlArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n      }\n      return acc;\n    };\n  };\n};\n","module Control.Plus\n  ( class Plus, empty\n  , module Control.Alt\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Plus` type class extends the `Alt` type class with a value that\n-- | should be the left and right identity for `(<|>)`.\n-- |\n-- | It is similar to `Monoid`, except that it applies to types of\n-- | kind `* -> *`, like `Array` or `List`, rather than concrete types like\n-- | `String` or `Number`.\n-- |\n-- | `Plus` instances should satisfy the following laws:\n-- |\n-- | - Left identity: `empty <|> x == x`\n-- | - Right identity: `x <|> empty == x`\n-- | - Annihilation: `f <$> empty == empty`\nclass Alt f <= Plus f where\n  empty :: forall a. f a\n\ninstance plusArray :: Plus Array where\n  empty = []\n","-- | A data type and functions for working with ordered pairs.\nmodule Data.Tuple where\n\nimport Prelude\n\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy, defer)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.HeytingAlgebra (implies, ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | A simple product type for wrapping a pair of component values.\ndata Tuple a b = Tuple a b\n\n-- | Allows `Tuple`s to be rendered as a string with `show` whenever there are\n-- | `Show` instances for both component types.\ninstance showTuple :: (Show a, Show b) => Show (Tuple a b) where\n  show (Tuple a b) = \"(Tuple \" <> show a <> \" \" <> show b <> \")\"\n\n-- | Allows `Tuple`s to be checked for equality with `==` and `/=` whenever\n-- | there are `Eq` instances for both component types.\nderive instance eqTuple :: (Eq a, Eq b) => Eq (Tuple a b)\n\nderive instance eq1Tuple :: Eq a => Eq1 (Tuple a)\n\n-- | Allows `Tuple`s to be compared with `compare`, `>`, `>=`, `<` and `<=`\n-- | whenever there are `Ord` instances for both component types. To obtain\n-- | the result, the `fst`s are `compare`d, and if they are `EQ`ual, the\n-- | `snd`s are `compare`d.\nderive instance ordTuple :: (Ord a, Ord b) => Ord (Tuple a b)\n\nderive instance ord1Tuple :: Ord a => Ord1 (Tuple a)\n\ninstance boundedTuple :: (Bounded a, Bounded b) => Bounded (Tuple a b) where\n  top = Tuple top top\n  bottom = Tuple bottom bottom\n\ninstance semigroupoidTuple :: Semigroupoid Tuple where\n  compose (Tuple _ c) (Tuple a _) = Tuple a c\n\n-- | The `Semigroup` instance enables use of the associative operator `<>` on\n-- | `Tuple`s whenever there are `Semigroup` instances for the component\n-- | types. The `<>` operator is applied pairwise, so:\n-- | ```purescript\n-- | (Tuple a1 b1) <> (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n-- | ```\ninstance semigroupTuple :: (Semigroup a, Semigroup b) => Semigroup (Tuple a b) where\n  append (Tuple a1 b1) (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n\ninstance monoidTuple :: (Monoid a, Monoid b) => Monoid (Tuple a b) where\n  mempty = Tuple mempty mempty\n\ninstance semiringTuple :: (Semiring a, Semiring b) => Semiring (Tuple a b) where\n  add (Tuple x1 y1) (Tuple x2 y2) = Tuple (add x1 x2) (add y1 y2)\n  one = Tuple one one\n  mul (Tuple x1 y1) (Tuple x2 y2) = Tuple (mul x1 x2) (mul y1 y2)\n  zero = Tuple zero zero\n\ninstance ringTuple :: (Ring a, Ring b) => Ring (Tuple a b) where\n  sub (Tuple x1 y1) (Tuple x2 y2) = Tuple (sub x1 x2) (sub y1 y2)\n\ninstance commutativeRingTuple :: (CommutativeRing a, CommutativeRing b) => CommutativeRing (Tuple a b)\n\ninstance heytingAlgebraTuple :: (HeytingAlgebra a, HeytingAlgebra b) => HeytingAlgebra (Tuple a b) where\n  tt = Tuple tt tt\n  ff = Tuple ff ff\n  implies (Tuple x1 y1) (Tuple x2 y2) = Tuple (x1 `implies` x2) (y1 `implies` y2)\n  conj (Tuple x1 y1) (Tuple x2 y2) = Tuple (conj x1 x2) (conj y1 y2)\n  disj (Tuple x1 y1) (Tuple x2 y2) = Tuple (disj x1 x2) (disj y1 y2)\n  not (Tuple x y) = Tuple (not x) (not y)\n\ninstance booleanAlgebraTuple :: (BooleanAlgebra a, BooleanAlgebra b) => BooleanAlgebra (Tuple a b)\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<$>` operator, applying the function to the second\n-- | component, so:\n-- | ```purescript\n-- | f <$> (Tuple x y) = Tuple x (f y)\n-- | ````\nderive instance functorTuple :: Functor (Tuple a)\n\nderive instance genericTuple :: Generic (Tuple a b) _\n\ninstance invariantTuple :: Invariant (Tuple a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<*>` operator whenever there is a `Semigroup` instance\n-- | for the `fst` component, so:\n-- | ```purescript\n-- | (Tuple a1 f) <*> (Tuple a2 x) == Tuple (a1 <> a2) (f x)\n-- | ```\ninstance applyTuple :: (Semigroup a) => Apply (Tuple a) where\n  apply (Tuple a1 f) (Tuple a2 x) = Tuple (a1 <> a2) (f x)\n\ninstance applicativeTuple :: (Monoid a) => Applicative (Tuple a) where\n  pure = Tuple mempty\n\ninstance bindTuple :: (Semigroup a) => Bind (Tuple a) where\n  bind (Tuple a1 b) f = case f b of\n    Tuple a2 c -> Tuple (a1 <> a2) c\n\ninstance monadTuple :: (Monoid a) => Monad (Tuple a)\n\ninstance extendTuple :: Extend (Tuple a) where\n  extend f t@(Tuple a _) = Tuple a (f t)\n\ninstance comonadTuple :: Comonad (Tuple a) where\n  extract = snd\n\ninstance lazyTuple :: (Lazy a, Lazy b) => Lazy (Tuple a b) where\n  defer f = Tuple (defer $ \\_ -> fst (f unit)) (defer $ \\_ -> snd (f unit))\n\n-- | Returns the first component of a tuple.\nfst :: forall a b. Tuple a b -> a\nfst (Tuple a _) = a\n\n-- | Returns the second component of a tuple.\nsnd :: forall a b. Tuple a b -> b\nsnd (Tuple _ b) = b\n\n-- | Turn a function that expects a tuple into a function of two arguments.\ncurry :: forall a b c. (Tuple a b -> c) -> a -> b -> c\ncurry f a b = f (Tuple a b)\n\n-- | Turn a function of two arguments into a function that expects a tuple.\nuncurry :: forall a b c. (a -> b -> c) -> Tuple a b -> c\nuncurry f (Tuple a b) = f a b\n\n-- | Exchange the first and second components of a tuple.\nswap :: forall a b. Tuple a b -> Tuple b a\nswap (Tuple a b) = Tuple b a\n","module Data.Bifunctor where\n\nimport Control.Category (identity)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Tuple (Tuple(..))\n\n-- | A `Bifunctor` is a `Functor` from the pair category `(Type, Type)` to `Type`.\n-- |\n-- | A type constructor with two type arguments can be made into a `Bifunctor` if\n-- | both of its type arguments are covariant.\n-- |\n-- | The `bimap` function maps a pair of functions over the two type arguments\n-- | of the bifunctor.\n-- |\n-- | Laws:\n-- |\n-- | - Identity: `bimap identity identity == identity`\n-- | - Composition: `bimap f1 g1 <<< bimap f2 g2 == bimap (f1 <<< f2) (g1 <<< g2)`\n-- |\nclass Bifunctor f where\n  bimap :: forall a b c d. (a -> b) -> (c -> d) -> f a c -> f b d\n\n-- | Map a function over the first type argument of a `Bifunctor`.\nlmap :: forall f a b c. Bifunctor f => (a -> b) -> f a c -> f b c\nlmap f = bimap f identity\n\n-- | Map a function over the second type arguments of a `Bifunctor`.\nrmap :: forall f a b c. Bifunctor f => (b -> c) -> f a b -> f a c\nrmap = bimap identity\n\ninstance bifunctorEither :: Bifunctor Either where\n  bimap f _ (Left l) = Left (f l)\n  bimap _ g (Right r) = Right (g r)\n\ninstance bifunctorTuple :: Bifunctor Tuple where\n  bimap f g (Tuple x y) = Tuple (f x) (g y)\n\ninstance bifunctorConst :: Bifunctor Const where\n  bimap f _ (Const a) = Const (f a)\n","module Data.Monoid.Conj where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.HeytingAlgebra (ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup for conjunction.\n-- |\n-- | ``` purescript\n-- | Conj x <> Conj y == Conj (x && y)\n-- | (mempty :: Conj _) == Conj tt\n-- | ```\nnewtype Conj a = Conj a\n\nderive newtype instance eqConj :: Eq a => Eq (Conj a)\nderive instance eq1Conj :: Eq1 Conj\n\nderive newtype instance ordConj :: Ord a => Ord (Conj a)\nderive instance ord1Conj :: Ord1 Conj\n\nderive newtype instance boundedConj :: Bounded a => Bounded (Conj a)\n\ninstance showConj :: (Show a) => Show (Conj a) where\n  show (Conj a) = \"(Conj \" <> show a <> \")\"\n\nderive instance functorConj :: Functor Conj\n\ninstance applyConj :: Apply Conj where\n  apply (Conj f) (Conj x) = Conj (f x)\n\ninstance applicativeConj :: Applicative Conj where\n  pure = Conj\n\ninstance bindConj :: Bind Conj where\n  bind (Conj x) f = f x\n\ninstance monadConj :: Monad Conj\n\ninstance semigroupConj :: HeytingAlgebra a => Semigroup (Conj a) where\n  append (Conj a) (Conj b) = Conj (conj a b)\n\ninstance monoidConj :: HeytingAlgebra a => Monoid (Conj a) where\n  mempty = Conj tt\n\ninstance semiringConj :: HeytingAlgebra a => Semiring (Conj a) where\n  zero = Conj tt\n  one = Conj ff\n  add (Conj a) (Conj b) = Conj (conj a b)\n  mul (Conj a) (Conj b) = Conj (disj a b)\n","// module Unsafe.Coerce\n\nexport const unsafeCoerce = function (x) {\n  return x;\n};\n","module Safe.Coerce\n  ( module Prim.Coerce\n  , coerce\n  ) where\n\nimport Prim.Coerce (class Coercible)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Coerce a value of one type to a value of some other type, without changing\n-- | its runtime representation. This function behaves identically to\n-- | `unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n-- | `Coercible` constraint prevents any use of this function from compiling\n-- | unless the compiler can prove that the two types have the same runtime\n-- | representation.\n-- |\n-- | One application for this function is to avoid doing work that you know is a\n-- | no-op because of newtypes. For example, if you have an `Array (Conj a)` and you\n-- | want an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\n-- | this performs an unnecessary traversal of the array, with O(n) cost.\n-- | `coerce` accomplishes the same with only O(1) cost:\n-- |\n-- | ```purescript\n-- | mapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\n-- | mapConjToDisj = coerce\n-- | ```\ncoerce :: forall a b. Coercible a b => a -> b\ncoerce = unsafeCoerce\n","module Data.Newtype where\n\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Semigroup.First (First(..))\nimport Data.Semigroup.Last (Last(..))\nimport Safe.Coerce (class Coercible, coerce)\n\n-- | A type class for `newtype`s to enable convenient wrapping and unwrapping,\n-- | and the use of the other functions in this module.\n-- |\n-- | The compiler can derive instances of `Newtype` automatically:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- |\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- | ```\n-- |\n-- | Note that deriving for `Newtype` instances requires that the type be\n-- | defined as `newtype` rather than `data` declaration (even if the `data`\n-- | structurally fits the rules of a `newtype`), and the use of a wildcard for\n-- | the wrapped type.\nclass Newtype :: Type -> Type -> Constraint\nclass Coercible t a <= Newtype t a | t -> a\n\nwrap :: forall t a. Newtype t a => a -> t\nwrap = coerce\n\nunwrap :: forall t a. Newtype t a => t -> a\nunwrap = coerce\n\ninstance newtypeAdditive :: Newtype (Additive a) a\n\ninstance newtypeMultiplicative :: Newtype (Multiplicative a) a\n\ninstance newtypeConj :: Newtype (Conj a) a\n\ninstance newtypeDisj :: Newtype (Disj a) a\n\ninstance newtypeDual :: Newtype (Dual a) a\n\ninstance newtypeEndo :: Newtype (Endo c a) (c a a)\n\ninstance newtypeFirst :: Newtype (First a) a\n\ninstance newtypeLast :: Newtype (Last a) a\n\n-- | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`\n-- | function.\nun :: forall t a. Newtype t a => (a -> t) -> t -> a\nun _ = unwrap\n\n-- | This combinator unwraps the newtype, applies a monomorphic function to the \n-- | contained value and wraps the result back in the newtype\nmodify :: forall t a. Newtype t a => (a -> a) -> t -> t\nmodify fn t = wrap (fn (unwrap t))\n\n-- | This combinator is for when you have a higher order function that you want\n-- | to use in the context of some newtype - `foldMap` being a common example:\n-- |\n-- | ``` purescript\n-- | ala Additive foldMap [1,2,3,4] -- 10\n-- | ala Multiplicative foldMap [1,2,3,4] -- 24\n-- | ala Conj foldMap [true, false] -- false\n-- | ala Disj foldMap [true, false] -- true\n-- | ```\nala\n  :: forall f t a s b\n   . Coercible (f t) (f a)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> ((b -> s) -> f t)\n  -> f a\nala _ f = coerce (f wrap)\n\n-- | Similar to `ala` but useful for cases where you want to use an additional\n-- | projection with the higher order function:\n-- |\n-- | ``` purescript\n-- | alaF Additive foldMap String.length [\"hello\", \"world\"] -- 10\n-- | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0\n-- | ```\n-- |\n-- | The type admits other possibilities due to the polymorphic `Functor`\n-- | constraints, but the case described above works because ((->) a) is a\n-- | `Functor`.\nalaF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nalaF _ = coerce\n\n-- | Lifts a function operate over newtypes. This can be used to lift a\n-- | function to manipulate the contents of a single newtype, somewhat like\n-- | `map` does for a `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype Label = Label String\n-- | derive instance newtypeLabel :: Newtype Label _\n-- |\n-- | toUpperLabel :: Label -> Label\n-- | toUpperLabel = over Label String.toUpper\n-- | ```\n-- |\n-- | But the result newtype is polymorphic, meaning the result can be returned\n-- | as an alternative newtype:\n-- |\n-- | ``` purescript\n-- | newtype UppercaseLabel = UppercaseLabel String\n-- | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _\n-- |\n-- | toUpperLabel' :: Label -> UppercaseLabel\n-- | toUpperLabel' = over Label String.toUpper\n-- | ```\nover\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> b)\n  -> t\n  -> s\nover _ = coerce\n\n-- | Much like `over`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | findLabel :: String -> Array Label -> Maybe Label\n-- | findLabel s = overF Label (Foldable.find (_ == s))\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\noverF\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> g b)\n  -> f t\n  -> g s\noverF _ = coerce\n\n-- | The opposite of `over`: lowers a function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\n-- |\n-- | ``` purescript\n-- | newtype Degrees = Degrees Number\n-- | derive instance newtypeDegrees :: Newtype Degrees _\n-- |\n-- | newtype NormalDegrees = NormalDegrees Number\n-- | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _\n-- |\n-- | normaliseDegrees :: Degrees -> NormalDegrees\n-- | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)\n-- |\n-- | asNormalDegrees :: Number -> Number\n-- | asNormalDegrees = under Degrees normaliseDegrees\n-- | ```\n-- |\n-- | As with `over` the `Newtype` is polymorphic, as illustrated in the example\n-- | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,\n-- | so even though `normaliseDegrees` changes the result type we can still put\n-- | a `Number` in and get a `Number` out via `under`.\nunder\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> s)\n  -> a\n  -> b\nunder _ = coerce\n\n-- | Much like `under`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- |\n-- | isValid :: EmailAddress -> Boolean\n-- | isValid x = false -- imagine a slightly less strict predicate here\n-- |\n-- | findValidEmailString :: Array String -> Maybe String\n-- | findValidEmailString = underF EmailAddress (Foldable.find isValid)\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\nunderF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nunderF _ = coerce\n\n-- | Lifts a binary function to operate over newtypes.\n-- |\n-- | ``` purescript\n-- | newtype Meter = Meter Int\n-- | derive newtype instance newtypeMeter :: Newtype Meter _\n-- | newtype SquareMeter = SquareMeter Int\n-- | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _\n-- |\n-- | area :: Meter -> Meter -> SquareMeter\n-- | area = over2 Meter (*)\n-- | ```\n-- |\n-- | The above example also demonstrates that the return type is polymorphic\n-- | here too.\nover2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> a -> b)\n  -> t\n  -> t\n  -> s\nover2 _ = coerce\n\n-- | Much like `over2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\noverF2\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> f a -> g b)\n  -> f t\n  -> f t\n  -> g s\noverF2 _ = coerce\n\n-- | The opposite of `over2`: lowers a binary function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\nunder2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> t -> s)\n  -> a\n  -> a\n  -> b\nunder2 _ = coerce\n\n-- | Much like `under2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\nunderF2\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> f t -> g s)\n  -> f a\n  -> f a\n  -> g b\nunderF2 _ = coerce\n\n-- | Similar to the function from the `Traversable` class, but operating within\n-- | a newtype instead.\ntraverse\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (a -> f a)\n  -> t\n  -> f t\ntraverse _ = coerce\n\n-- | Similar to the function from the `Distributive` class, but operating within\n-- | a newtype instead.\ncollect\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (f a -> a)\n  -> f t\n  -> t\ncollect _ = coerce\n","module Data.Foldable\n  ( class Foldable, foldr, foldl, foldMap\n  , foldrDefault, foldlDefault, foldMapDefaultL, foldMapDefaultR\n  , fold\n  , foldM\n  , traverse_\n  , for_\n  , sequence_\n  , oneOf\n  , oneOfMap\n  , intercalate\n  , surroundMap\n  , surround\n  , and\n  , or\n  , all\n  , any\n  , sum\n  , product\n  , elem\n  , notElem\n  , indexl\n  , indexr\n  , find\n  , findMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  , null\n  , length\n  , lookup\n  ) where\n\nimport Prelude\n\nimport Control.Plus (class Plus, alt, empty)\nimport Data.Const (Const)\nimport Data.Either (Either(..))\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct, coproduct)\nimport Data.Functor.Product (Product(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (alaF, unwrap)\nimport Data.Tuple (Tuple(..))\n\n-- | `Foldable` represents data structures which can be _folded_.\n-- |\n-- | - `foldr` folds a structure from the right\n-- | - `foldl` folds a structure from the left\n-- | - `foldMap` folds a structure by accumulating values in a `Monoid`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrDefault`\n-- | - `foldlDefault`\n-- | - `foldMapDefaultR`\n-- | - `foldMapDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f where\n  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n\n-- | A default implementation of `foldr` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultR`.\nfoldrDefault\n  :: forall f a b\n   . Foldable f\n  => (a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrDefault c u xs = unwrap (foldMap (Endo <<< c) xs) u\n\n-- | A default implementation of `foldl` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultL`.\nfoldlDefault\n  :: forall f a b\n   . Foldable f\n  => (b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlDefault c u xs = unwrap (unwrap (foldMap (Dual <<< Endo <<< flip c) xs)) u\n\n-- | A default implementation of `foldMap` using `foldr`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldrDefault`.\nfoldMapDefaultR\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultR f = foldr (\\x acc -> f x <> acc) mempty\n\n-- | A default implementation of `foldMap` using `foldl`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldlDefault`.\nfoldMapDefaultL\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultL f = foldl (\\acc x -> acc <> f x) mempty\n\ninstance foldableArray :: Foldable Array where\n  foldr = foldrArray\n  foldl = foldlArray\n  foldMap = foldMapDefaultR\n\nforeign import foldrArray :: forall a b. (a -> b -> b) -> b -> Array a -> b\nforeign import foldlArray :: forall a b. (b -> a -> b) -> b -> Array a -> b\n\ninstance foldableMaybe :: Foldable Maybe where\n  foldr _ z Nothing  = z\n  foldr f z (Just x) = x `f` z\n  foldl _ z Nothing  = z\n  foldl f z (Just x) = z `f` x\n  foldMap _ Nothing  = mempty\n  foldMap f (Just x) = f x\n\ninstance foldableFirst :: Foldable First where\n  foldr f z (First x) = foldr f z x\n  foldl f z (First x) = foldl f z x\n  foldMap f (First x) = foldMap f x\n\ninstance foldableLast :: Foldable Last where\n  foldr f z (Last x) = foldr f z x\n  foldl f z (Last x) = foldl f z x\n  foldMap f (Last x) = foldMap f x\n\ninstance foldableAdditive :: Foldable Additive where\n  foldr f z (Additive x) = x `f` z\n  foldl f z (Additive x) = z `f` x\n  foldMap f (Additive x) = f x\n\ninstance foldableDual :: Foldable Dual where\n  foldr f z (Dual x) = x `f` z\n  foldl f z (Dual x) = z `f` x\n  foldMap f (Dual x) = f x\n\ninstance foldableDisj :: Foldable Disj where\n  foldr f z (Disj x) = f x z\n  foldl f z (Disj x) = f z x\n  foldMap f (Disj x) = f x\n\ninstance foldableConj :: Foldable Conj where\n  foldr f z (Conj x) = f x z\n  foldl f z (Conj x) = f z x\n  foldMap f (Conj x) = f x\n\ninstance foldableMultiplicative :: Foldable Multiplicative where\n  foldr f z (Multiplicative x) = x `f` z\n  foldl f z (Multiplicative x) = z `f` x\n  foldMap f (Multiplicative x) = f x\n\ninstance foldableEither :: Foldable (Either a) where\n  foldr _ z (Left _)  = z\n  foldr f z (Right x) = f x z\n  foldl _ z (Left _)  = z\n  foldl f z (Right x) = f z x\n  foldMap _ (Left _)  = mempty\n  foldMap f (Right x) = f x\n\ninstance foldableTuple :: Foldable (Tuple a) where\n  foldr f z (Tuple _ x) = f x z\n  foldl f z (Tuple _ x) = f z x\n  foldMap f (Tuple _ x) = f x\n\ninstance foldableIdentity :: Foldable Identity where\n  foldr f z (Identity x) = f x z\n  foldl f z (Identity x) = f z x\n  foldMap f (Identity x) = f x\n\ninstance foldableConst :: Foldable (Const a) where\n  foldr _ z _ = z\n  foldl _ z _ = z\n  foldMap _ _ = mempty\n\ninstance foldableProduct :: (Foldable f, Foldable g) => Foldable (Product f g) where\n  foldr f z (Product (Tuple fa ga)) = foldr f (foldr f z ga) fa\n  foldl f z (Product (Tuple fa ga)) = foldl f (foldl f z fa) ga\n  foldMap f (Product (Tuple fa ga)) = foldMap f fa <> foldMap f ga\n\ninstance foldableCoproduct :: (Foldable f, Foldable g) => Foldable (Coproduct f g) where\n  foldr f z = coproduct (foldr f z) (foldr f z)\n  foldl f z = coproduct (foldl f z) (foldl f z)\n  foldMap f = coproduct (foldMap f) (foldMap f)\n\ninstance foldableCompose :: (Foldable f, Foldable g) => Foldable (Compose f g) where\n  foldr f i (Compose fga) = foldr (flip (foldr f)) i fga\n  foldl f i (Compose fga) = foldl (foldl f) i fga\n  foldMap f (Compose fga) = foldMap (foldMap f) fga\n\ninstance foldableApp :: Foldable f => Foldable (App f) where\n  foldr f i (App x) = foldr f i x\n  foldl f i (App x) = foldl f i x\n  foldMap f (App x) = foldMap f x\n\n-- | Fold a data structure, accumulating values in some `Monoid`.\nfold :: forall f m. Foldable f => Monoid m => f m -> m\nfold = foldMap identity\n\n-- | Similar to 'foldl', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldM :: forall f m a b. Foldable f => Monad m => (b -> a -> m b) -> b -> f a -> m b\nfoldM f b0 = foldl (\\b a -> b >>= flip f a) (pure b0)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Applicative` functor at each value, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | traverse_ print [1, 2, 3]\n-- | ```\ntraverse_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => (a -> m b)\n  -> f a\n  -> m Unit\ntraverse_ f = foldr ((*>) <<< f) (pure unit)\n\n-- | A version of `traverse_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for_ [1, 2, 3] \\n -> do\n-- |   print n\n-- |   trace \"squared is\"\n-- |   print (n * n)\n-- | ```\nfor_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => f a\n  -> (a -> m b)\n  -> m Unit\nfor_ = flip traverse_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable` instance, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | sequence_ [ trace \"Hello, \", trace \" world!\" ]\n-- | ```\nsequence_ :: forall a f m. Applicative m => Foldable f => f (m a) -> m Unit\nsequence_ = traverse_ identity\n\n-- | Combines a collection of elements using the `Alt` operation.\noneOf :: forall f g a. Foldable f => Plus g => f (g a) -> g a\noneOf = foldr alt empty\n\n-- | Folds a structure into some `Plus`.\noneOfMap :: forall f g a b. Foldable f => Plus g => (a -> g b) -> f a -> g b\noneOfMap f = foldr (alt <<< f) empty\n\n-- | Fold a data structure, accumulating values in some `Monoid`,\n-- | combining adjacent elements using the specified separator.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > intercalate \", \" [\"Lorem\", \"ipsum\", \"dolor\"]\n-- | = \"Lorem, ipsum, dolor\"\n-- |\n-- | > intercalate \"*\" [\"a\", \"b\", \"c\"]\n-- | = \"a*b*c\"\n-- |\n-- | > intercalate [1] [[2, 3], [4, 5], [6, 7]]\n-- | = [2, 3, 1, 4, 5, 1, 6, 7]\n-- | ```\nintercalate :: forall f m. Foldable f => Monoid m => m -> f m -> m\nintercalate sep xs = (foldl go { init: true, acc: mempty } xs).acc\n  where\n  go { init: true } x = { init: false, acc: x }\n  go { acc: acc }   x = { init: false, acc: acc <> sep <> x }\n\n-- | `foldMap` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMap \"*\" show []\n-- | = \"*\"\n-- |\n-- | > surroundMap \"*\" show [1]\n-- | = \"*1*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2]\n-- | = \"*1*2*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2, 3]\n-- | = \"*1*2*3*\"\n-- | ```\nsurroundMap :: forall f a m. Foldable f => Semigroup m => m -> (a -> m) -> f a -> m\nsurroundMap d t f = unwrap (foldMap joined f) d\n  where joined a = Endo \\m -> d <> t a <> m\n\n-- | `fold` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surround \"*\" []\n-- | = \"*\"\n-- |\n-- | > surround \"*\" [\"1\"]\n-- | = \"*1*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\"]\n-- | = \"*1*2*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\", \"3\"]\n-- | = \"*1*2*3*\"\n-- | ```\nsurround :: forall f m. Foldable f => Semigroup m => m -> f m -> m\nsurround d = surroundMap d identity\n\n-- | The conjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether all of the values in a data\n-- | structure are `true`.\nand :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nand = all identity\n\n-- | The disjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether any of the values in a data\n-- | structure is `true`.\nor :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nor = any identity\n\n-- | `all f` is the same as `and <<< map f`; map a function over the structure,\n-- | and then get the conjunction of the results.\nall :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nall  = alaF Conj foldMap\n\n-- | `any f` is the same as `or <<< map f`; map a function over the structure,\n-- | and then get the disjunction of the results.\nany :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nany = alaF Disj foldMap\n\n-- | Find the sum of the numeric values in a data structure.\nsum :: forall a f. Foldable f => Semiring a => f a -> a\nsum = foldl (+) zero\n\n-- | Find the product of the numeric values in a data structure.\nproduct :: forall a f. Foldable f => Semiring a => f a -> a\nproduct = foldl (*) one\n\n-- | Test whether a value is an element of a data structure.\nelem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nelem = any <<< (==)\n\n-- | Test whether a value is not an element of a data structure.\nnotElem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nnotElem x = not <<< elem x\n\n-- | Try to get nth element from the left in a data structure\nindexl :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexl idx = _.elem <<< foldl go { elem: Nothing, pos: 0 }\n  where\n  go cursor a =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to get nth element from the right in a data structure\nindexr :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexr idx = _.elem <<< foldr go { elem: Nothing, pos: 0 }\n  where\n  go a cursor =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to find an element in a data structure which satisfies a predicate.\nfind :: forall a f. Foldable f => (a -> Boolean) -> f a -> Maybe a\nfind p = foldl go Nothing\n  where\n  go Nothing x | p x = Just x\n  go r _ = r\n\n-- | Try to find an element in a data structure which satisfies a predicate mapping.\nfindMap :: forall a b f. Foldable f => (a -> Maybe b) -> f a -> Maybe b\nfindMap p = foldl go Nothing\n  where\n  go Nothing x = p x\n  go r _ = r\n\n-- | Find the largest element of a structure, according to its `Ord` instance.\nmaximum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nmaximum = maximumBy compare\n\n-- | Find the largest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nmaximumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nmaximumBy cmp = foldl max' Nothing\n  where\n  max' Nothing x  = Just x\n  max' (Just x) y = Just (if cmp x y == GT then x else y)\n\n-- | Find the smallest element of a structure, according to its `Ord` instance.\nminimum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nminimum = minimumBy compare\n\n-- | Find the smallest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nminimumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nminimumBy cmp = foldl min' Nothing\n  where\n  min' Nothing x  = Just x\n  min' (Just x) y = Just (if cmp x y == LT then x else y)\n\n-- | Test whether the structure is empty.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nnull :: forall a f. Foldable f => f a -> Boolean\nnull = foldr (\\_ _ -> false) true\n\n-- | Returns the size/length of a finite structure.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nlength :: forall a b f. Foldable f => Semiring b => f a -> b\nlength = foldl (\\c _ -> add one c) zero\n\n-- | Lookup a value in a data structure of `Tuple`s, generalizing association lists.\nlookup :: forall a b f. Foldable f => Eq a => a -> f (Tuple a b) -> Maybe b\nlookup a = unwrap <<< foldMap \\(Tuple a' b) -> First (if a == a' then Just b else Nothing)\n","// module Data.Function.Uncurried\n\nexport const mkFn0 = function (fn) {\n  return function () {\n    return fn();\n  };\n};\n\nexport const mkFn2 = function (fn) {\n  /* jshint maxparams: 2 */\n  return function (a, b) {\n    return fn(a)(b);\n  };\n};\n\nexport const mkFn3 = function (fn) {\n  /* jshint maxparams: 3 */\n  return function (a, b, c) {\n    return fn(a)(b)(c);\n  };\n};\n\nexport const mkFn4 = function (fn) {\n  /* jshint maxparams: 4 */\n  return function (a, b, c, d) {\n    return fn(a)(b)(c)(d);\n  };\n};\n\nexport const mkFn5 = function (fn) {\n  /* jshint maxparams: 5 */\n  return function (a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e);\n  };\n};\n\nexport const mkFn6 = function (fn) {\n  /* jshint maxparams: 6 */\n  return function (a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f);\n  };\n};\n\nexport const mkFn7 = function (fn) {\n  /* jshint maxparams: 7 */\n  return function (a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g);\n  };\n};\n\nexport const mkFn8 = function (fn) {\n  /* jshint maxparams: 8 */\n  return function (a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h);\n  };\n};\n\nexport const mkFn9 = function (fn) {\n  /* jshint maxparams: 9 */\n  return function (a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i);\n  };\n};\n\nexport const mkFn10 = function (fn) {\n  /* jshint maxparams: 10 */\n  return function (a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j);\n  };\n};\n\nexport const runFn0 = function (fn) {\n  return fn();\n};\n\nexport const runFn2 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return fn(a, b);\n    };\n  };\n};\n\nexport const runFn3 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return fn(a, b, c);\n      };\n    };\n  };\n};\n\nexport const runFn4 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return fn(a, b, c, d);\n        };\n      };\n    };\n  };\n};\n\nexport const runFn5 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return fn(a, b, c, d, e);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn6 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return fn(a, b, c, d, e, f);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn7 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return fn(a, b, c, d, e, f, g);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn8 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return fn(a, b, c, d, e, f, g, h);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn9 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return fn(a, b, c, d, e, f, g, h, i);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn10 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return function (j) {\n                      return fn(a, b, c, d, e, f, g, h, i, j);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n","export const mapWithIndexArray = function (f) {\n  return function (xs) {\n    var l = xs.length;\n    var result = Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(i)(xs[i]);\n    }\n    return result;\n  };\n};\n","module Data.Monoid.Additive where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup for semirings under addition.\n-- |\n-- | ``` purescript\n-- | Additive x <> Additive y == Additive (x + y)\n-- | (mempty :: Additive _) == Additive zero\n-- | ```\nnewtype Additive a = Additive a\n\nderive newtype instance eqAdditive :: Eq a => Eq (Additive a)\nderive instance eq1Additive :: Eq1 Additive\n\nderive newtype instance ordAdditive :: Ord a => Ord (Additive a)\nderive instance ord1Additive :: Ord1 Additive\n\nderive newtype instance boundedAdditive :: Bounded a => Bounded (Additive a)\n\ninstance showAdditive :: Show a => Show (Additive a) where\n  show (Additive a) = \"(Additive \" <> show a <> \")\"\n\nderive instance functorAdditive :: Functor Additive\n\ninstance applyAdditive :: Apply Additive where\n  apply (Additive f) (Additive x) = Additive (f x)\n\ninstance applicativeAdditive :: Applicative Additive where\n  pure = Additive\n\ninstance bindAdditive :: Bind Additive where\n  bind (Additive x) f = f x\n\ninstance monadAdditive :: Monad Additive\n\ninstance semigroupAdditive :: Semiring a => Semigroup (Additive a) where\n  append (Additive a) (Additive b) = Additive (a + b)\n\ninstance monoidAdditive :: Semiring a => Monoid (Additive a) where\n  mempty = Additive zero\n","module Data.FunctorWithIndex\n  ( class FunctorWithIndex, mapWithIndex, mapDefault\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (bimap)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..))\nimport Data.Functor.Product (Product(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe)\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj)\nimport Data.Monoid.Disj (Disj)\nimport Data.Monoid.Dual (Dual)\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Tuple (Tuple, curry)\n\n-- | A `Functor` with an additional index.\n-- | Instances must satisfy a modified form of the `Functor` laws\n-- | ```purescript\n-- | mapWithIndex (\\_ a -> a) = identity\n-- | mapWithIndex f . mapWithIndex g = mapWithIndex (\\i -> f i <<< g i)\n-- | ```\n-- | and be compatible with the `Functor` instance\n-- | ```purescript\n-- | map f = mapWithIndex (const f)\n-- | ```\nclass Functor f <= FunctorWithIndex i f | f -> i where\n  mapWithIndex :: forall a b. (i -> a -> b) -> f a -> f b\n\nforeign import mapWithIndexArray :: forall a b. (Int -> a -> b) -> Array a -> Array b\n\ninstance functorWithIndexArray :: FunctorWithIndex Int Array where\n  mapWithIndex = mapWithIndexArray\n\ninstance functorWithIndexMaybe :: FunctorWithIndex Unit Maybe where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexFirst :: FunctorWithIndex Unit First where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexLast :: FunctorWithIndex Unit Last where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexAdditive :: FunctorWithIndex Unit Additive where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexDual :: FunctorWithIndex Unit Dual where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexConj :: FunctorWithIndex Unit Conj where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexDisj :: FunctorWithIndex Unit Disj where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexMultiplicative :: FunctorWithIndex Unit Multiplicative where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexEither :: FunctorWithIndex Unit (Either a) where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexTuple :: FunctorWithIndex Unit (Tuple a) where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexIdentity :: FunctorWithIndex Unit Identity where\n  mapWithIndex f (Identity a) = Identity (f unit a)\n\ninstance functorWithIndexConst :: FunctorWithIndex Void (Const a) where\n  mapWithIndex _ (Const x) = Const x\n\ninstance functorWithIndexProduct :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Either a b) (Product f g) where\n  mapWithIndex f (Product fga) = Product (bimap (mapWithIndex (f <<< Left)) (mapWithIndex (f <<< Right)) fga)\n\ninstance functorWithIndexCoproduct :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Either a b) (Coproduct f g) where\n  mapWithIndex f (Coproduct e) = Coproduct (bimap (mapWithIndex (f <<< Left)) (mapWithIndex (f <<< Right)) e)\n\ninstance functorWithIndexCompose :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Tuple a b) (Compose f g) where\n  mapWithIndex f (Compose fga) = Compose $ mapWithIndex (mapWithIndex <<< curry f) fga\n\ninstance functorWithIndexApp :: FunctorWithIndex a f => FunctorWithIndex a (App f) where\n  mapWithIndex f (App x) = App $ mapWithIndex f x\n\n-- | A default implementation of Functor's `map` in terms of `mapWithIndex`\nmapDefault :: forall i f a b. FunctorWithIndex i f => (a -> b) -> f a -> f b\nmapDefault f = mapWithIndex (const f)\n","// jshint maxparams: 3\n\nexport const traverseArrayImpl = (function () {\n  function array1(a) {\n    return [a];\n  }\n\n  function array2(a) {\n    return function (b) {\n      return [a, b];\n    };\n  }\n\n  function array3(a) {\n    return function (b) {\n      return function (c) {\n        return [a, b, c];\n      };\n    };\n  }\n\n  function concat2(xs) {\n    return function (ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (pure) {\n        return function (f) {\n          return function (array) {\n            function go(bot, top) {\n              switch (top - bot) {\n              case 0: return pure([]);\n              case 1: return map(array1)(f(array[bot]));\n              case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));\n              case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));\n              default:\n                // This slightly tricky pivot selection aims to produce two\n                // even-length partitions where possible.\n                var pivot = bot + Math.floor((top - bot) / 4) * 2;\n                return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));\n              }\n            }\n            return go(0, array.length);\n          };\n        };\n      };\n    };\n  };\n})();\n","module Data.Traversable\n  ( class Traversable, traverse, sequence\n  , traverseDefault, sequenceDefault\n  , for\n  , scanl\n  , scanr\n  , mapAccumL\n  , mapAccumR\n  , module Data.Foldable\n  , module Data.Traversable.Accum\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Foldable (class Foldable, all, and, any, elem, find, fold, foldMap, foldMapDefaultL, foldMapDefaultR, foldl, foldlDefault, foldr, foldrDefault, for_, intercalate, maximum, maximumBy, minimum, minimumBy, notElem, oneOf, or, sequence_, sum, traverse_)\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..), coproduct)\nimport Data.Functor.Product (Product(..), product)\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Traversable.Accum (Accum)\nimport Data.Traversable.Accum.Internal (StateL(..), StateR(..), stateL, stateR)\nimport Data.Tuple (Tuple(..))\n\n-- | `Traversable` represents data structures which can be _traversed_,\n-- | accumulating results and effects in some `Applicative` functor.\n-- |\n-- | - `traverse` runs an action for every element in a data structure,\n-- |   and accumulates the results.\n-- | - `sequence` runs the actions _contained_ in a data structure,\n-- |   and accumulates the results.\n-- |\n-- | ```purescript\n-- | import Data.Traversable\n-- | import Data.Maybe\n-- | import Data.Int (fromNumber)\n-- |\n-- | sequence [Just 1, Just 2, Just 3] == Just [1,2,3]\n-- | sequence [Nothing, Just 2, Just 3] == Nothing\n-- |\n-- | traverse fromNumber [1.0, 2.0, 3.0] == Just [1,2,3]\n-- | traverse fromNumber [1.5, 2.0, 3.0] == Nothing\n-- |\n-- | traverse logShow [1,2,3]\n-- | -- prints:\n-- |    1\n-- |    2\n-- |    3\n-- |\n-- | traverse (\\x -> [x, 0]) [1,2,3] == [[1,2,3],[1,2,0],[1,0,3],[1,0,0],[0,2,3],[0,2,0],[0,0,3],[0,0,0]]\n-- | ```\n-- |\n-- | The `traverse` and `sequence` functions should be compatible in the\n-- | following sense:\n-- |\n-- | - `traverse f xs = sequence (f <$> xs)`\n-- | - `sequence = traverse identity`\n-- |\n-- | `Traversable` instances should also be compatible with the corresponding\n-- | `Foldable` instances, in the following sense:\n-- |\n-- | - `foldMap f = runConst <<< traverse (Const <<< f)`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `traverseDefault`\n-- | - `sequenceDefault`\nclass (Functor t, Foldable t) <= Traversable t where\n  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n\n-- | A default implementation of `traverse` using `sequence` and `map`.\ntraverseDefault\n  :: forall t a b m\n   . Traversable t\n  => Applicative m\n  => (a -> m b)\n  -> t a\n  -> m (t b)\ntraverseDefault f ta = sequence (f <$> ta)\n\n-- | A default implementation of `sequence` using `traverse`.\nsequenceDefault\n  :: forall t a m\n   . Traversable t\n  => Applicative m\n  => t (m a)\n  -> m (t a)\nsequenceDefault = traverse identity\n\ninstance traversableArray :: Traversable Array where\n  traverse = traverseArrayImpl apply map pure\n  sequence = sequenceDefault\n\nforeign import traverseArrayImpl\n  :: forall m a b\n   . (forall x y. m (x -> y) -> m x -> m y)\n  -> (forall x y. (x -> y) -> m x -> m y)\n  -> (forall x. x -> m x)\n  -> (a -> m b)\n  -> Array a\n  -> m (Array b)\n\ninstance traversableMaybe :: Traversable Maybe where\n  traverse _ Nothing  = pure Nothing\n  traverse f (Just x) = Just <$> f x\n  sequence Nothing  = pure Nothing\n  sequence (Just x) = Just <$> x\n\ninstance traversableFirst :: Traversable First where\n  traverse f (First x) = First <$> traverse f x\n  sequence (First x) = First <$> sequence x\n\ninstance traversableLast :: Traversable Last where\n  traverse f (Last x) = Last <$> traverse f x\n  sequence (Last x) = Last <$> sequence x\n\ninstance traversableAdditive :: Traversable Additive where\n  traverse f (Additive x) = Additive <$> f x\n  sequence (Additive x) = Additive <$> x\n\ninstance traversableDual :: Traversable Dual where\n  traverse f (Dual x) = Dual <$> f x\n  sequence (Dual x) = Dual <$> x\n\ninstance traversableConj :: Traversable Conj where\n  traverse f (Conj x) = Conj <$> f x\n  sequence (Conj x) = Conj <$> x\n\ninstance traversableDisj :: Traversable Disj where\n  traverse f (Disj x) = Disj <$> f x\n  sequence (Disj x) = Disj <$> x\n\ninstance traversableMultiplicative :: Traversable Multiplicative where\n  traverse f (Multiplicative x) = Multiplicative <$> f x\n  sequence (Multiplicative x) = Multiplicative <$> x\n\ninstance traversableEither :: Traversable (Either a) where\n  traverse _ (Left x)  = pure (Left x)\n  traverse f (Right x) = Right <$> f x\n  sequence (Left x) = pure (Left x)\n  sequence (Right x)  = Right <$> x\n\ninstance traversableTuple :: Traversable (Tuple a) where\n  traverse f (Tuple x y) = Tuple x <$> f y\n  sequence (Tuple x y) = Tuple x <$> y\n\ninstance traversableIdentity :: Traversable Identity where\n  traverse f (Identity x) = Identity <$> f x\n  sequence (Identity x) = Identity <$> x\n\ninstance traversableConst :: Traversable (Const a) where\n  traverse _ (Const x) = pure (Const x)\n  sequence (Const x) = pure (Const x)\n\ninstance traversableProduct :: (Traversable f, Traversable g) => Traversable (Product f g) where\n  traverse f (Product (Tuple fa ga)) = lift2 product (traverse f fa) (traverse f ga)\n  sequence (Product (Tuple fa ga)) = lift2 product (sequence fa) (sequence ga)\n\ninstance traversableCoproduct :: (Traversable f, Traversable g) => Traversable (Coproduct f g) where\n  traverse f = coproduct\n    (map (Coproduct <<< Left) <<< traverse f)\n    (map (Coproduct <<< Right) <<< traverse f)\n  sequence = coproduct\n    (map (Coproduct <<< Left) <<< sequence)\n    (map (Coproduct <<< Right) <<< sequence)\n\ninstance traversableCompose :: (Traversable f, Traversable g) => Traversable (Compose f g) where\n  traverse f (Compose fga) = map Compose $ traverse (traverse f) fga\n  sequence = traverse identity\n\ninstance traversableApp :: Traversable f => Traversable (App f) where\n  traverse f (App x) = App <$> traverse f x\n  sequence (App x) = App <$> sequence x\n\n-- | A version of `traverse` with its arguments flipped.\n-- |\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for [1, 2, 3] \\n -> do\n-- |   print n\n-- |   return (n * n)\n-- | ```\nfor\n  :: forall a b m t\n   . Applicative m\n  => Traversable t\n  => t a\n  -> (a -> m b)\n  -> m (t b)\nfor x f = traverse f x\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```purescript\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b f. Traversable f => (b -> a -> b) -> b -> f a -> f b\nscanl f b0 xs = (mapAccumL (\\b a -> let b' = f b a in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanl`, `mapAccumL` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumL\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumL f s0 xs = stateL (traverse (\\a -> StateL \\s -> f s a) xs) s0\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```purescript\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b f. Traversable f => (a -> b -> b) -> b -> f a -> f b\nscanr f b0 xs = (mapAccumR (\\b a -> let b' = f a b in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanr`, `mapAccumR` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumR\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumR f s0 xs = stateR (traverse (\\a -> StateR \\s -> f s a) xs) s0\n","module Data.Semigroup.Foldable\n  ( class Foldable1\n  , foldMap1\n  , fold1\n  , foldr1\n  , foldl1\n  , traverse1_\n  , for1_\n  , sequence1_\n  , foldr1Default\n  , foldl1Default\n  , foldMap1DefaultR\n  , foldMap1DefaultL\n  , intercalate\n  , intercalateMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable)\nimport Data.Identity (Identity(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (ala, alaF)\nimport Data.Ord.Max (Max(..))\nimport Data.Ord.Min (Min(..))\nimport Data.Tuple (Tuple(..))\n\n-- | `Foldable1` represents data structures with a minimum of one element that can be _folded_.\n-- |\n-- | - `foldr1` folds a structure from the right\n-- | - `foldl1` folds a structure from the left\n-- | - `foldMap1` folds a structure by accumulating values in a `Semigroup`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldr1Default`\n-- | - `foldl1Default`\n-- | - `foldMap1DefaultR`\n-- | - `foldMap1DefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable t <= Foldable1 t where\n  foldr1 :: forall a. (a -> a -> a) -> t a -> a\n  foldl1 :: forall a. (a -> a -> a) -> t a -> a\n  foldMap1 :: forall a m. Semigroup m => (a -> m) -> t a -> m\n\n-- | A default implementation of `foldr1` using `foldMap1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldMap1DefaultR`.\nfoldr1Default :: forall t a. Foldable1 t => (a -> a -> a) -> t a -> a\nfoldr1Default = flip (runFoldRight1 <<< foldMap1 mkFoldRight1)\n\n-- | A default implementation of `foldl1` using `foldMap1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldMap1DefaultL`.\nfoldl1Default :: forall t a. Foldable1 t => (a -> a -> a) -> t a -> a\nfoldl1Default = flip (runFoldRight1 <<< alaF Dual foldMap1 mkFoldRight1) <<< flip\n\n-- | A default implementation of `foldMap1` using `foldr1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldr1Default`.\nfoldMap1DefaultR :: forall t m a. Foldable1 t => Functor t => Semigroup m => (a -> m) -> t a -> m\nfoldMap1DefaultR f = map f >>> foldr1 (<>)\n\n-- | A default implementation of `foldMap1` using `foldl1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldl1Default`.\nfoldMap1DefaultL :: forall t m a. Foldable1 t => Functor t => Semigroup m => (a -> m) -> t a -> m\nfoldMap1DefaultL f = map f >>> foldl1 (<>)\n\ninstance foldableDual :: Foldable1 Dual where\n  foldr1 _ (Dual x) = x\n  foldl1 _ (Dual x) = x\n  foldMap1 f (Dual x) = f x\n\ninstance foldableMultiplicative :: Foldable1 Multiplicative where\n  foldr1 _ (Multiplicative x) = x\n  foldl1 _ (Multiplicative x) = x\n  foldMap1 f (Multiplicative x) = f x\n\ninstance foldableTuple :: Foldable1 (Tuple a) where\n  foldMap1 f (Tuple _ x) = f x\n  foldr1 _ (Tuple _ x) = x\n  foldl1 _ (Tuple _ x) = x\n\ninstance foldableIdentity :: Foldable1 Identity where\n  foldMap1 f (Identity x) = f x\n  foldl1 _ (Identity x) = x\n  foldr1 _ (Identity x) = x\n\n-- | Fold a data structure, accumulating values in some `Semigroup`.\nfold1 :: forall t m. Foldable1 t => Semigroup m => t m -> m\nfold1 = foldMap1 identity\n\nnewtype Act :: forall k. (k -> Type) -> k -> Type\nnewtype Act f a = Act (f a)\n\ngetAct :: forall f a. Act f a -> f a\ngetAct (Act f) = f\n\ninstance semigroupAct :: Apply f => Semigroup (Act f a) where\n  append (Act a) (Act b) = Act (a *> b)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Apply` instance at each value, ignoring the final result.\ntraverse1_ :: forall t f a b. Foldable1 t => Apply f => (a -> f b) -> t a -> f Unit\ntraverse1_ f t = unit <$ getAct (foldMap1 (Act <<< f) t)\n\n-- | A version of `traverse1_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\nfor1_ :: forall t f a b. Foldable1 t => Apply f => t a -> (a -> f b) -> f Unit\nfor1_ = flip traverse1_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable1` instance, ignoring the final result.\nsequence1_ :: forall t f a. Foldable1 t => Apply f => t (f a) -> f Unit\nsequence1_ = traverse1_ identity\n\nmaximum :: forall f a. Ord a => Foldable1 f => f a -> a\nmaximum = ala Max foldMap1\n\nmaximumBy :: forall f a. Foldable1 f => (a -> a -> Ordering) -> f a -> a\nmaximumBy cmp = foldl1 \\x y -> if cmp x y == GT then x else y\n\nminimum :: forall f a. Ord a => Foldable1 f => f a -> a\nminimum = ala Min foldMap1\n\nminimumBy :: forall f a. Foldable1 f => (a -> a -> Ordering) -> f a -> a\nminimumBy cmp = foldl1 \\x y -> if cmp x y == LT then x else y\n\n-- | Internal. Used by intercalation functions.\nnewtype JoinWith a = JoinWith (a -> a)\n\njoinee :: forall a. JoinWith a -> a -> a\njoinee (JoinWith x) = x\n\ninstance semigroupJoinWith :: Semigroup a => Semigroup (JoinWith a) where\n  append (JoinWith a) (JoinWith b) = JoinWith $ \\j -> a j <> j <> b j\n\n-- | Fold a data structure using a `Semigroup` instance,\n-- | combining adjacent elements using the specified separator.\nintercalate :: forall f m. Foldable1 f => Semigroup m => m -> f m -> m\nintercalate = flip intercalateMap identity\n\n-- | Fold a data structure, accumulating values in some `Semigroup`,\n-- | combining adjacent elements using the specified separator.\nintercalateMap\n  :: forall f m a\n   . Foldable1 f\n  => Semigroup m\n  => m -> (a -> m) -> f a -> m\nintercalateMap j f foldable =\n  joinee (foldMap1 (JoinWith <<< const <<< f) foldable) j\n\n-- | Internal. Used by foldr1Default and foldl1Default.\ndata FoldRight1 a = FoldRight1 (a -> (a -> a -> a) -> a) a\n\ninstance foldRight1Semigroup :: Semigroup (FoldRight1 a) where\n  append (FoldRight1 lf lr) (FoldRight1 rf rr) = FoldRight1 (\\a f -> lf (f lr (rf a f)) f) rr\n\nmkFoldRight1 :: forall a. a -> FoldRight1 a\nmkFoldRight1 = FoldRight1 const\n\nrunFoldRight1 :: forall a. FoldRight1 a -> (a -> a -> a) -> a\nrunFoldRight1 (FoldRight1 f a) = f a\n","-- | Helper functions for working with immutable Javascript arrays.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use `Data.List` or\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is useful when integrating with JavaScript libraries\n-- | which use arrays, but immutable arrays are not a practical data structure\n-- | for many use cases due to their poor asymptotics.\n-- |\n-- | In addition to the functions in this module, Arrays have a number of\n-- | useful instances:\n-- |\n-- | * `Functor`, which provides `map :: forall a b. (a -> b) -> Array a ->\n-- |   Array b`\n-- | * `Apply`, which provides `(<*>) :: forall a b. Array (a -> b) -> Array a\n-- |   -> Array b`. This function works a bit like a Cartesian product; the\n-- |   result array is constructed by applying each function in the first\n-- |   array to each value in the second, so that the result array ends up with\n-- |   a length equal to the product of the two arguments' lengths.\n-- | * `Bind`, which provides `(>>=) :: forall a b. (a -> Array b) -> Array a\n-- |   -> Array b` (this is the same as `concatMap`).\n-- | * `Semigroup`, which provides `(<>) :: forall a. Array a -> Array a ->\n-- |   Array a`, for concatenating arrays.\n-- | * `Foldable`, which provides a slew of functions for *folding* (also known\n-- |   as *reducing*) arrays down to one value. For example,\n-- |   `Data.Foldable.or` tests whether an array of `Boolean` values contains\n-- |   at least one `true` value.\n-- | * `Traversable`, which provides the PureScript version of a for-loop,\n-- |   allowing you to STAI.iterate over an array and accumulate effects.\n-- |\nmodule Data.Array\n  ( fromFoldable\n  , toUnfoldable\n  , singleton\n  , (..)\n  , range\n  , replicate\n  , some\n  , many\n\n  , null\n  , length\n\n  , (:)\n  , cons\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!)\n  , index\n  , elem\n  , notElem\n  , elemIndex\n  , elemLastIndex\n  , find\n  , findMap\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , intersperse\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , splitAt\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n  , foldl\n  , foldr\n  , foldMap\n  , fold\n  , intercalate\n  , transpose\n  , scanl\n  , scanr\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n\n  , nub\n  , nubEq\n  , nubBy\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n\n  , (\\\\)\n  , difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , any\n  , all\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM2)\nimport Control.Monad.ST as ST\nimport Data.Array.NonEmpty.Internal (NonEmptyArray(..))\nimport Data.Array.ST as STA\nimport Data.Array.ST.Iterator as STAI\nimport Data.Foldable (class Foldable, traverse_)\nimport Data.Foldable as F\nimport Data.Function.Uncurried (Fn2, Fn3, Fn4, Fn5, runFn2, runFn3, runFn4, runFn5)\nimport Data.FunctorWithIndex as FWI\nimport Data.Maybe (Maybe(..), maybe, isJust, fromJust, isNothing)\nimport Data.Traversable (sequence, traverse)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafePartial)\n\n-- | Convert an `Array` into an `Unfoldable` structure.\ntoUnfoldable :: forall f. Unfoldable f => Array ~> f\ntoUnfoldable xs = unfoldr f 0\n  where\n  len = length xs\n  f i\n    | i < len = Just (Tuple (unsafePartial (unsafeIndex xs i)) (i + 1))\n    | otherwise = Nothing\n\n-- | Convert a `Foldable` structure into an `Array`.\n-- |\n-- | ```purescript\n-- | fromFoldable (Just 1) = [1]\n-- | fromFoldable (Nothing) = []\n-- | ```\n-- |\nfromFoldable :: forall f. Foldable f => f ~> Array\nfromFoldable = runFn2 fromFoldableImpl F.foldr\n\nforeign import fromFoldableImpl\n  :: forall f a\n   . Fn2 (forall b. (a -> b -> b) -> b -> f a -> b) (f a) (Array a)\n\n-- | Create an array of one element\n-- | ```purescript\n-- | singleton 2 = [2]\n-- | ```\nsingleton :: forall a. a -> Array a\nsingleton a = [ a ]\n\n-- | Create an array containing a range of integers, including both endpoints.\n-- | ```purescript\n-- | range 2 5 = [2, 3, 4, 5]\n-- | ```\nrange :: Int -> Int -> Array Int\nrange = runFn2 rangeImpl\n\nforeign import rangeImpl :: Fn2 Int Int (Array Int)\n\n-- | Create an array containing a value repeated the specified number of times.\n-- | ```purescript\n-- | replicate 2 \"Hi\" = [\"Hi\", \"Hi\"]\n-- | ```\nreplicate :: forall a. Int -> a -> Array a\nreplicate = runFn2 replicateImpl\n\nforeign import replicateImpl :: forall a. Fn2 Int a (Array a)\n\n-- | An infix synonym for `range`.\n-- | ```purescript\n-- | 2 .. 5 = [2, 3, 4, 5]\n-- | ```\ninfix 8 range as ..\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nsome v = (:) <$> v <*> defer (\\_ -> many v)\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nmany v = some v <|> pure []\n\n--------------------------------------------------------------------------------\n-- Array size ------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether an array is empty.\n-- | ```purescript\n-- | null [] = true\n-- | null [1, 2] = false\n-- | ```\nnull :: forall a. Array a -> Boolean\nnull xs = length xs == 0\n\n-- | Get the number of elements in an array.\n-- | ```purescript\n-- | length [\"Hello\", \"World\"] = 2\n-- | ```\nforeign import length :: forall a. Array a -> Int\n\n--------------------------------------------------------------------------------\n-- Extending arrays ------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Attaches an element to the front of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | cons 1 [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ncons :: forall a. a -> Array a -> Array a\ncons x xs = [ x ] <> xs\n\n-- | An infix alias for `cons`.\n-- |\n-- | ```purescript\n-- | 1 : [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ninfixr 6 cons as :\n\n-- | Append an element to the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | snoc [1, 2, 3] 4 = [1, 2, 3, 4]\n-- | ```\n-- |\nsnoc :: forall a. Array a -> a -> Array a\nsnoc xs x = ST.run (STA.withArray (STA.push x) xs)\n\n-- | Insert an element into a sorted array.\n-- |\n-- | ```purescript\n-- | insert 10 [1, 2, 20, 21] = [1, 2, 10, 20, 21]\n-- | ```\n-- |\ninsert :: forall a. Ord a => a -> Array a -> Array a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted array, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | ```purescript\n-- | invertCompare a b = invert $ compare a b\n-- |\n-- | insertBy invertCompare 10 [21, 20, 2, 1] = [21, 20, 10, 2, 1]\n-- | ```\n-- |\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> Array a -> Array a\ninsertBy cmp x ys =\n  let\n    i = maybe 0 (_ + 1) (findLastIndex (\\y -> cmp x y == GT) ys)\n  in\n    unsafePartial (fromJust (insertAt i x ys))\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | head [1, 2] = Just 1\n-- | head [] = Nothing\n-- | ```\n-- |\nhead :: forall a. Array a -> Maybe a\nhead xs = xs !! 0\n\n-- | Get the last element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | last [1, 2] = Just 2\n-- | last [] = Nothing\n-- | ```\n-- |\nlast :: forall a. Array a -> Maybe a\nlast xs = xs !! (length xs - 1)\n\n-- | Get all but the first element of an array, creating a new array, or\n-- | `Nothing` if the array is empty\n-- |\n-- | ```purescript\n-- | tail [1, 2, 3, 4] = Just [2, 3, 4]\n-- | tail [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ntail :: forall a. Array a -> Maybe (Array a)\ntail = runFn3 unconsImpl (const Nothing) (\\_ xs -> Just xs)\n\n-- | Get all but the last element of an array, creating a new array, or\n-- | `Nothing` if the array is empty.\n-- |\n-- | ```purescript\n-- | init [1, 2, 3, 4] = Just [1, 2, 3]\n-- | init [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ninit :: forall a. Array a -> Maybe (Array a)\ninit xs\n  | null xs = Nothing\n  | otherwise = Just (slice zero (length xs - one) xs)\n\n-- | Break an array into its first element and remaining elements.\n-- |\n-- | Using `uncons` provides a way of writing code that would use cons patterns\n-- | in Haskell or pre-PureScript 0.7:\n-- | ``` purescript\n-- | f (x : xs) = something\n-- | f [] = somethingElse\n-- | ```\n-- | Becomes:\n-- | ``` purescript\n-- | f arr = case uncons arr of\n-- |   Just { head: x, tail: xs } -> something\n-- |   Nothing -> somethingElse\n-- | ```\nuncons :: forall a. Array a -> Maybe { head :: a, tail :: Array a }\nuncons = runFn3 unconsImpl (const Nothing) \\x xs -> Just { head: x, tail: xs }\n\nforeign import unconsImpl\n  :: forall a b\n   . Fn3 (Unit -> b) (a -> Array a -> b) (Array a) b\n\n-- | Break an array into its last element and all preceding elements.\n-- |\n-- | ```purescript\n-- | unsnoc [1, 2, 3] = Just {init: [1, 2], last: 3}\n-- | unsnoc [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\nunsnoc :: forall a. Array a -> Maybe { init :: Array a, last :: a }\nunsnoc xs = { init: _, last: _ } <$> init xs <*> last xs\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | This function provides a safe way to read a value at a particular index\n-- | from an array.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | index sentence 0 = Just \"Hello\"\n-- | index sentence 7 = Nothing\n-- | ```\n-- |\nindex :: forall a. Array a -> Int -> Maybe a\nindex = runFn4 indexImpl Just Nothing\n\nforeign import indexImpl\n  :: forall a\n   . Fn4 (forall r. r -> Maybe r) (forall r. Maybe r) (Array a) Int (Maybe a)\n\n-- | An infix version of `index`.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | sentence !! 0 = Just \"Hello\"\n-- | sentence !! 7 = Nothing\n-- | ```\n-- |\ninfixl 8 index as !!\n\n-- | Returns true if the array has the given element.\nelem :: forall a. Eq a => a -> Array a -> Boolean\nelem a arr = isJust $ elemIndex a arr\n\n-- | Returns true if the array does not have the given element.\nnotElem :: forall a. Eq a => a -> Array a -> Boolean\nnotElem a arr = isNothing $ elemIndex a arr\n\n-- | Find the index of the first element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 0\n-- | elemIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemLastIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 2\n-- | elemLastIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemLastIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first element for which a predicate holds.\n-- |\n-- | ```purescript\n-- | find (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just \"bb\"\n-- | find (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\nfind :: forall a. (a -> Boolean) -> Array a -> Maybe a\nfind f xs = unsafePartial (unsafeIndex xs) <$> findIndex f xs\n\n-- | Find the first element in a data structure which satisfies\n-- | a predicate mapping.\nfindMap :: forall a b. (a -> Maybe b) -> Array a -> Maybe b\nfindMap = runFn4 findMapImpl Nothing isJust\n\nforeign import findMapImpl\n  :: forall a b\n   . Fn4\n       (forall c. Maybe c)\n       (forall c. Maybe c -> Boolean)\n       (a -> Maybe b)\n       (Array a)\n       (Maybe b)\n\n-- | Find the first index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 1\n-- | findIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindIndex = runFn4 findIndexImpl Just Nothing\n\nforeign import findIndexImpl\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       (a -> Boolean)\n       (Array a)\n       (Maybe Int)\n\n-- | Find the last index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findLastIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 2\n-- | findLastIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindLastIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindLastIndex = runFn4 findLastIndexImpl Just Nothing\n\nforeign import findLastIndexImpl\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       (a -> Boolean)\n       (Array a)\n       (Maybe Int)\n\n-- | Insert an element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | insertAt 2 \"!\" [\"Hello\", \"World\"] = Just [\"Hello\", \"World\", \"!\"]\n-- | insertAt 10 \"!\" [\"Hello\"] = Nothing\n-- | ```\n-- |\ninsertAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\ninsertAt = runFn5 _insertAt Just Nothing\n\nforeign import _insertAt\n  :: forall a\n   . Fn5\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       a\n       (Array a)\n       (Maybe (Array a))\n\n-- | Delete the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | deleteAt 0 [\"Hello\", \"World\"] = Just [\"World\"]\n-- | deleteAt 10 [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\ndeleteAt :: forall a. Int -> Array a -> Maybe (Array a)\ndeleteAt = runFn4 _deleteAt Just Nothing\n\nforeign import _deleteAt\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       (Array a)\n       (Maybe (Array a))\n\n-- | Change the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | updateAt 1 \"World\" [\"Hello\", \"Earth\"] = Just [\"Hello\", \"World\"]\n-- | updateAt 10 \"World\" [\"Hello\", \"Earth\"] = Nothing\n-- | ```\n-- |\nupdateAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\nupdateAt = runFn5 _updateAt Just Nothing\n\nforeign import _updateAt\n  :: forall a\n   . Fn5\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       a\n       (Array a)\n       (Maybe (Array a))\n\n-- | Apply a function to the element at the specified index, creating a new\n-- | array, or returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | modifyAt 1 toUpper [\"Hello\", \"World\"] = Just [\"Hello\", \"WORLD\"]\n-- | modifyAt 10 toUpper [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\nmodifyAt :: forall a. Int -> (a -> a) -> Array a -> Maybe (Array a)\nmodifyAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = updateAt i (f x) xs\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new array or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | ```purescript\n-- | alterAt 1 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\", \"World\"]\n-- |\n-- | alterAt 1 (stripSuffix $ Pattern \"!!!!!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\"]\n-- |\n-- | alterAt 10 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"] = Nothing\n-- | ```\n-- |\nalterAt :: forall a. Int -> (a -> Maybe a) -> Array a -> Maybe (Array a)\nalterAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = case f x of\n    Nothing -> deleteAt i xs\n    Just x' -> updateAt i x' xs\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Inserts the given element in between each element in the array. The array\n-- | must have two or more elements for this operation to take effect.\n-- |\n-- | ```purescript\n-- | intersperse \" \" [ \"a\", \"b\" ] == [ \"a\", \" \", \"b\" ]\n-- | intersperse 0 [ 1, 2, 3, 4, 5 ] == [ 1, 0, 2, 0, 3, 0, 4, 0, 5 ]\n-- | ```\n-- |\n-- | If the array has less than two elements, the input array is returned.\n-- | ```purescript\n-- | intersperse \" \" [] == []\n-- | intersperse \" \" [\"a\"] == [\"a\"]\n-- | ```\nintersperse :: forall a. a -> Array a -> Array a\nintersperse a arr = case length arr of\n  len\n    | len < 2 -> arr\n    | otherwise -> STA.run do\n        let unsafeGetElem idx = unsafePartial (unsafeIndex arr idx)\n        out <- STA.new\n        _ <- STA.push (unsafeGetElem 0) out\n        ST.for 1 len \\idx -> do\n          _ <- STA.push a out\n          void (STA.push (unsafeGetElem idx) out)\n        pure out\n\n-- | Reverse an array, creating a new array.\n-- |\n-- | ```purescript\n-- | reverse [] = []\n-- | reverse [1, 2, 3] = [3, 2, 1]\n-- | ```\n-- |\nforeign import reverse :: forall a. Array a -> Array a\n\n-- | Flatten an array of arrays, creating a new array.\n-- |\n-- | ```purescript\n-- | concat [[1, 2, 3], [], [4, 5, 6]] = [1, 2, 3, 4, 5, 6]\n-- | ```\n-- |\nforeign import concat :: forall a. Array (Array a) -> Array a\n\n-- | Apply a function to each element in an array, and flatten the results\n-- | into a single, new array.\n-- |\n-- | ```purescript\n-- | concatMap (split $ Pattern \" \") [\"Hello World\", \"other thing\"]\n-- |    = [\"Hello\", \"World\", \"other\", \"thing\"]\n-- | ```\n-- |\nconcatMap :: forall a b. (a -> Array b) -> Array a -> Array b\nconcatMap = flip bind\n\n-- | Filter an array, keeping the elements which satisfy a predicate function,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | filter (_ > 0) [-1, 4, -5, 7] = [4, 7]\n-- | ```\n-- |\nfilter :: forall a. (a -> Boolean) -> Array a -> Array a\nfilter = runFn2 filterImpl\n\nforeign import filterImpl\n  :: forall a\n   . Fn2 (a -> Boolean) (Array a) (Array a)\n\n-- | Partition an array using a predicate function, creating a set of\n-- | new arrays. One for the values satisfying the predicate function\n-- | and one for values that don't.\n-- |\n-- | ```purescript\n-- | partition (_ > 0) [-1, 4, -5, 7] = { yes: [4, 7], no: [-1, -5] }\n-- | ```\n-- |\npartition\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { yes :: Array a, no :: Array a }\npartition = runFn2 partitionImpl\n\nforeign import partitionImpl\n  :: forall a\n   . Fn2 (a -> Boolean) (Array a) { yes :: Array a, no :: Array a }\n\n-- | Splits an array into two subarrays, where `before` contains the elements\n-- | up to (but not including) the given index, and `after` contains the rest\n-- | of the elements, from that index on.\n-- |\n-- | ```purescript\n-- | >>> splitAt 3 [1, 2, 3, 4, 5]\n-- | { before: [1, 2, 3], after: [4, 5] }\n-- | ```\n-- |\n-- | Thus, the length of `(splitAt i arr).before` will equal either `i` or\n-- | `length arr`, if that is shorter. (Or if `i` is negative the length will\n-- | be 0.)\n-- |\n-- | ```purescript\n-- | splitAt 2 ([] :: Array Int) == { before: [], after: [] }\n-- | splitAt 3 [1, 2, 3, 4, 5] == { before: [1, 2, 3], after: [4, 5] }\n-- | ```\nsplitAt :: forall a. Int -> Array a -> { before :: Array a, after :: Array a }\nsplitAt i xs | i <= 0 = { before: [], after: xs }\nsplitAt i xs = { before: slice 0 i xs, after: slice i (length xs) xs }\n\n-- | Filter where the predicate returns a `Boolean` in some `Applicative`.\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. Array a -> Array (Array a)\n-- | powerSet = filterA (const [true, false])\n-- | ```\nfilterA :: forall a f. Applicative f => (a -> f Boolean) -> Array a -> f (Array a)\nfilterA p =\n  traverse (\\x -> Tuple x <$> p x)\n    >>> map (mapMaybe (\\(Tuple x b) -> if b then Just x else Nothing))\n\n-- | Apply a function to each element in an array, keeping only the results\n-- | which contain a value, creating a new array.\n-- |\n-- | ```purescript\n-- | parseEmail :: String -> Maybe Email\n-- | parseEmail = ...\n-- |\n-- | mapMaybe parseEmail [\"a.com\", \"hello@example.com\", \"--\"]\n-- |    = [Email {user: \"hello\", domain: \"example.com\"}]\n-- | ```\n-- |\nmapMaybe :: forall a b. (a -> Maybe b) -> Array a -> Array b\nmapMaybe f = concatMap (maybe [] singleton <<< f)\n\n-- | Filter an array of optional values, keeping only the elements which contain\n-- | a value, creating a new array.\n-- |\n-- | ```purescript\n-- | catMaybes [Nothing, Just 2, Nothing, Just 4] = [2, 4]\n-- | ```\n-- |\ncatMaybes :: forall a. Array (Maybe a) -> Array a\ncatMaybes = mapMaybe identity\n\n-- | Apply a function to each element in an array, supplying a generated\n-- | zero-based index integer along with the element, creating an array\n-- | with the new elements.\n-- |\n-- | ```purescript\n-- | prefixIndex index element = show index <> element\n-- |\n-- | mapWithIndex prefixIndex [\"Hello\", \"World\"] = [\"0Hello\", \"1World\"]\n-- | ```\n-- |\nmapWithIndex :: forall a b. (Int -> a -> b) -> Array a -> Array b\nmapWithIndex = FWI.mapWithIndex\n\n-- | Change the elements at the specified indices in index/value pairs.\n-- | Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | updates = [Tuple 0 \"Hi\", Tuple 2 \".\" , Tuple 10 \"foobar\"]\n-- |\n-- | updateAtIndices updates [\"Hello\", \"World\", \"!\"] = [\"Hi\", \"World\", \".\"]\n-- | ```\n-- |\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> Array a -> Array a\nupdateAtIndices us xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\(Tuple i a) -> STA.poke i a res) us) xs)\n\n-- | Apply a function to the element at the specified indices,\n-- | creating a new array. Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | indices = [1, 3]\n-- | modifyAtIndices indices toUpper [\"Hello\", \"World\", \"and\", \"others\"]\n-- |    = [\"Hello\", \"WORLD\", \"and\", \"OTHERS\"]\n-- | ```\n-- |\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> Array a -> Array a\nmodifyAtIndices is f xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\i -> STA.modify i f res) is) xs)\n\nfoldl :: forall a b. (b -> a -> b) -> b -> Array a -> b\nfoldl = F.foldl\n\nfoldr :: forall a b. (a -> b -> b) -> b -> Array a -> b\nfoldr = F.foldr\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> Array a -> m\nfoldMap = F.foldMap\n\nfold :: forall m. Monoid m => Array m -> m\nfold = F.fold\n\nintercalate :: forall a. Monoid a => a -> Array a -> a\nintercalate = F.intercalate\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [1, 2, 3]\n-- |   , [4, 5, 6]\n-- |   ] == \n-- |   [ [1, 4]\n-- |   , [2, 5]\n-- |   , [3, 6]\n-- |   ]\n-- | ```\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [10, 11]\n-- |   , [20]\n-- |   , [30, 31, 32]\n-- |   ] == \n-- |   [ [10, 20, 30]\n-- |   , [11, 31]\n-- |   , [32]\n-- |   ]\n-- | ```\ntranspose :: forall a. Array (Array a) -> Array (Array a)\ntranspose xs = go 0 []\n  where\n  go :: Int -> Array (Array a) -> Array (Array a)\n  go idx allArrays = case buildNext idx of\n    Nothing -> allArrays\n    Just next -> go (idx + 1) (snoc allArrays next)\n\n  buildNext :: Int -> Maybe (Array a)\n  buildNext idx = do\n    xs # flip foldl Nothing \\acc nextArr -> do\n      maybe acc (\\el -> Just $ maybe [ el ] (flip snoc el) acc) $ index nextArr idx\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b. (b -> a -> b) -> b -> Array a -> Array b\nscanl = runFn3 scanlImpl\n\nforeign import scanlImpl :: forall a b. Fn3 (b -> a -> b) b (Array a) (Array b)\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b. (a -> b -> b) -> b -> Array a -> Array b\nscanr = runFn3 scanrImpl\n\nforeign import scanrImpl :: forall a b. Fn3 (a -> b -> b) b (Array a) (Array b)\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an array in increasing order, creating a new array.\n-- | Sorting is stable: the order of equal elements is preserved.\n-- |\n-- | ```purescript\n-- | sort [2, -3, 1] = [-3, 1, 2]\n-- | ```\n-- |\nsort :: forall a. Ord a => Array a -> Array a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | compared using the specified partial ordering, creating a new array.\n-- | Sorting is stable: the order of elements is preserved if they are equal\n-- | according to the specified partial ordering.\n-- |\n-- | ```purescript\n-- | compareLength a b = compare (length a) (length b)\n-- | sortBy compareLength [[1, 2, 3], [7, 9], [-2]] = [[-2],[7,9],[1,2,3]]\n-- | ```\n-- |\nsortBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nsortBy comp = runFn3 sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | sorted based on a projection. Sorting is stable: the order of elements is\n-- | preserved if they are equal according to the projection.\n-- |\n-- | ```purescript\n-- | sortWith (_.age) [{name: \"Alice\", age: 42}, {name: \"Bob\", age: 21}]\n-- |    = [{name: \"Bob\", age: 21}, {name: \"Alice\", age: 42}]\n-- | ```\n-- |\nsortWith :: forall a b. Ord b => (a -> b) -> Array a -> Array a\nsortWith f = sortBy (comparing f)\n\nforeign import sortByImpl :: forall a. Fn3 (a -> a -> Ordering) (Ordering -> Int) (Array a) (Array a)\n\n--------------------------------------------------------------------------------\n-- Subarrays -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Extract a subarray by a start and end index.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- | slice 1 3 letters = [\"b\", \"c\"]\n-- | slice 5 7 letters = []\n-- | slice 4 1 letters = []\n-- | ```\n-- |\nslice :: forall a. Int -> Int -> Array a -> Array a\nslice = runFn3 sliceImpl\n\nforeign import sliceImpl :: forall a. Fn3 Int Int (Array a) (Array a)\n\n-- | Keep only a number of elements from the start of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | take 2 letters = [\"a\", \"b\"]\n-- | take 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntake :: forall a. Int -> Array a -> Array a\ntake n xs = if n < 1 then [] else slice 0 n xs\n\n-- | Keep only a number of elements from the end of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | takeEnd 2 letters = [\"b\", \"c\"]\n-- | takeEnd 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntakeEnd :: forall a. Int -> Array a -> Array a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Calculate the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | takeWhile (_ > 0) [4, 1, 0, -4, 5] = [4, 1]\n-- | takeWhile (_ > 0) [-1, 4] = []\n-- | ```\n-- |\ntakeWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ntakeWhile p xs = (span p xs).init\n\n-- | Drop a number of elements from the start of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | drop 2 letters = [\"c\", \"d\"]\n-- | drop 10 letters = []\n-- | ```\n-- |\ndrop :: forall a. Int -> Array a -> Array a\ndrop n xs = if n < 1 then xs else slice n (length xs) xs\n\n-- | Drop a number of elements from the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | dropEnd 2 letters = [\"a\", \"b\"]\n-- | dropEnd 10 letters = []\n-- | ```\n-- |\ndropEnd :: forall a. Int -> Array a -> Array a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Remove the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | dropWhile (_ < 0) [-3, -1, 0, 4, -6] = [0, 4, -6]\n-- | ```\n-- |\ndropWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ndropWhile p xs = (span p xs).rest\n\n-- | Split an array into two parts:\n-- |\n-- | 1. the longest initial subarray for which all elements satisfy the\n-- |    specified predicate\n-- | 2. the remaining elements\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) [1,3,2,4,5] == { init: [1,3], rest: [2,4,5] }\n-- | ```\n-- |\n-- | Running time: `O(n)`.\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { init :: Array a, rest :: Array a }\nspan p arr =\n  case breakIndex of\n    Just 0 ->\n      { init: [], rest: arr }\n    Just i ->\n      { init: slice 0 i arr, rest: slice i (length arr) arr }\n    Nothing ->\n      { init: arr, rest: [] }\n  where\n  breakIndex = go 0\n  go i =\n    -- This looks like a good opportunity to use the Monad Maybe instance,\n    -- but it's important to write out an explicit case expression here in\n    -- order to ensure that TCO is triggered.\n    case index arr i of\n      Just x -> if p x then go (i + 1) else Just i\n      Nothing -> Nothing\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1], NonEmptyArray [2, 2], NonEmptyArray [1]]\n-- | ```\ngroup :: forall a. Eq a => Array a -> Array (NonEmptyArray a)\ngroup xs = groupBy eq xs\n\n-- | Group equal elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | groupAll [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1, 1], NonEmptyArray [2, 2]]\n-- | ```\ngroupAll :: forall a. Ord a => Array a -> Array (NonEmptyArray a)\ngroupAll = groupAllBy compare\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to determine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [1, 3], NonEmptyArray [2], NonEmptyArray [4], NonEmptyArray [3, 3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> Array a -> Array (NonEmptyArray a)\ngroupBy op xs =\n  ST.run do\n    result <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\x -> void do\n      sub <- STA.new\n      _ <- STA.push x sub\n      STAI.pushWhile (op x) iter sub\n      grp <- STA.unsafeFreeze sub\n      STA.push (NonEmptyArray grp) result\n    STA.unsafeFreeze result\n\n-- | Group equal elements of an array into arrays, using the specified\n-- | comparison function to determine equality.\n-- |\n-- | ```purescript\n-- | groupAllBy (comparing Down) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [4], NonEmptyArray [3, 3, 3], NonEmptyArray [2], NonEmptyArray [1]]\n-- | ```\n-- |\ngroupAllBy :: forall a. (a -> a -> Ordering) -> Array a -> Array (NonEmptyArray a)\ngroupAllBy cmp = groupBy (\\x y -> cmp x y == EQ) <<< sortBy cmp\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | ```purescript\n-- | nub [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnub :: forall a. Ord a => Array a -> Array a\nnub = nubBy compare\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnubEq :: forall a. Eq a => Array a -> Array a\nnubEq = nubByEq eq\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified ordering, creating a new array.\n-- |\n-- | ```purescript\n-- | nubBy compare [1, 3, 4, 2, 2, 1] == [1, 3, 4, 2]\n-- | ```\n-- |\nnubBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nnubBy comp xs = case head indexedAndSorted of\n  Nothing -> []\n  Just x -> map snd $ sortWith fst $ ST.run do\n    -- TODO: use NonEmptyArrays here to avoid partial functions\n    result <- STA.unsafeThaw $ singleton x\n    ST.foreach indexedAndSorted \\pair@(Tuple _ x') -> do\n      lst <- snd <<< unsafePartial (fromJust <<< last) <$> STA.unsafeFreeze result\n      when (comp lst x' /= EQ) $ void $ STA.push pair result\n    STA.unsafeFreeze result\n  where\n  indexedAndSorted :: Array (Tuple Int a)\n  indexedAndSorted = sortBy (\\x y -> comp (snd x) (snd y))\n    (mapWithIndex Tuple xs)\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified equivalence relation, creating a new array.\n-- |\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | relation.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | nubByEq mod3eq [1, 3, 4, 5, 6] = [1, 3, 5]\n-- | ```\n-- |\nnubByEq :: forall a. (a -> a -> Boolean) -> Array a -> Array a\nnubByEq eq xs = ST.run do\n  arr <- STA.new\n  ST.foreach xs \\x -> do\n    e <- not <<< any (_ `eq` x) <$> (STA.unsafeFreeze arr)\n    when e $ void $ STA.push x arr\n  STA.unsafeFreeze arr\n\n-- | Calculate the union of two arrays. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | Running time: `O(n^2)`\n-- |\n-- | ```purescript\n-- | union [1, 2, 1, 1] [3, 3, 3, 4] = [1, 2, 1, 1, 3, 4]\n-- | ```\n-- |\nunion :: forall a. Eq a => Array a -> Array a -> Array a\nunion = unionBy (==)\n\n-- | Calculate the union of two arrays, using the specified function to\n-- | determine equality of elements. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | unionBy mod3eq [1, 5, 1, 2] [3, 4, 3, 3] = [1, 5, 1, 2, 3]\n-- | ```\n-- |\nunionBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first element of an array which is equal to the specified value,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | delete 7 [1, 7, 3, 7] = [1, 3, 7]\n-- | delete 7 [1, 2, 3] = [1, 2, 3]\n-- | ```\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> Array a -> Array a\ndelete = deleteBy eq\n\n-- | Delete the first element of an array which matches the specified value,\n-- | under the equivalence relation provided in the first argument, creating a\n-- | new array.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | deleteBy mod3eq 6 [1, 3, 4, 3] = [1, 4, 3]\n-- | ```\n-- |\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> Array a -> Array a\ndeleteBy _ _ [] = []\ndeleteBy eq x ys = maybe ys (\\i -> unsafePartial $ fromJust (deleteAt i ys)) (findIndex (eq x) ys)\n\n-- | Delete the first occurrence of each element in the second array from the\n-- | first array, creating a new array.\n-- |\n-- | ```purescript\n-- | difference [2, 1] [2, 3] = [1]\n-- | ```\n-- |\n-- | Running time: `O(n*m)`, where n is the length of the first array, and m is\n-- | the length of the second.\ndifference :: forall a. Eq a => Array a -> Array a -> Array a\ndifference = foldr delete\n\ninfix 5 difference as \\\\\n\n-- | Calculate the intersection of two arrays, creating a new array. Note that\n-- | duplicates in the first array are preserved while duplicates in the second\n-- | array are removed.\n-- |\n-- | ```purescript\n-- | intersect [1, 1, 2] [2, 2, 1] = [1, 1, 2]\n-- | ```\n-- |\nintersect :: forall a. Eq a => Array a -> Array a -> Array a\nintersect = intersectBy eq\n\n-- | Calculate the intersection of two arrays, using the specified equivalence\n-- | relation to compare elements, creating a new array. Note that duplicates\n-- | in the first array are preserved while duplicates in the second array are\n-- | removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | intersectBy mod3eq [1, 2, 3] [4, 6, 7] = [1, 3]\n-- | ```\n-- |\nintersectBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nintersectBy eq xs ys = filter (\\x -> isJust (findIndex (eq x) ys)) xs\n\n-- | Apply a function to pairs of elements at the same index in two arrays,\n-- | collecting the results in a new array.\n-- |\n-- | If one array is longer, elements will be discarded from the longer array.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) [1, 2, 3] [4, 5, 6, 7] == [4, 10, 18]\n-- | ```\nzipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> Array a\n  -> Array b\n  -> Array c\nzipWith = runFn3 zipWithImpl\n\nforeign import zipWithImpl\n  :: forall a b c\n   . Fn3\n       (a -> b -> c)\n       (Array a)\n       (Array b)\n       (Array c)\n\n-- | A generalization of `zipWith` which accumulates results in some\n-- | `Applicative` functor.\n-- |\n-- | ```purescript\n-- | sndChars = zipWithA (\\a b -> charAt 2 (a <> b))\n-- | sndChars [\"a\", \"b\"] [\"A\", \"B\"] = Nothing -- since \"aA\" has no 3rd char\n-- | sndChars [\"aa\", \"b\"] [\"AA\", \"BBB\"] = Just ['A', 'B']\n-- | ```\n-- |\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> Array a\n  -> Array b\n  -> m (Array c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Takes two arrays and returns an array of corresponding pairs.\n-- | If one input array is short, excess elements of the longer array are\n-- | discarded.\n-- |\n-- | ```purescript\n-- | zip [1, 2, 3] [\"a\", \"b\"] = [Tuple 1 \"a\", Tuple 2 \"b\"]\n-- | ```\n-- |\nzip :: forall a b. Array a -> Array b -> Array (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms an array of pairs into an array of first components and an\n-- | array of second components.\n-- |\n-- | ```purescript\n-- | unzip [Tuple 1 \"a\", Tuple 2 \"b\"] = Tuple [1, 2] [\"a\", \"b\"]\n-- | ```\n-- |\nunzip :: forall a b. Array (Tuple a b) -> Tuple (Array a) (Array b)\nunzip xs =\n  ST.run do\n    fsts <- STA.new\n    snds <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\(Tuple fst snd) -> do\n      void $ STA.push fst fsts\n      void $ STA.push snd snds\n    fsts' <- STA.unsafeFreeze fsts\n    snds' <- STA.unsafeFreeze snds\n    pure $ Tuple fsts' snds'\n\n-- | Returns true if at least one array element satisfies the given predicate,\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields true.\n-- |\n-- | ```purescript\n-- | any (_ > 0) [] = False\n-- | any (_ > 0) [-1, 0, 1] = True\n-- | any (_ > 0) [-1, -2, -3] = False\n-- | ```\nany :: forall a. (a -> Boolean) -> Array a -> Boolean\nany = runFn2 anyImpl\n\nforeign import anyImpl :: forall a. Fn2 (a -> Boolean) (Array a) Boolean\n\n-- | Returns true if all the array elements satisfy the given predicate.\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields false.\n-- |\n-- | ```purescript\n-- | all (_ > 0) [] = True\n-- | all (_ > 0) [1, 2, 3] = True\n-- | all (_ > 0) [-1, -2, -3] = False\n-- | ```\nall :: forall a. (a -> Boolean) -> Array a -> Boolean\nall = runFn2 allImpl\n\nforeign import allImpl :: forall a. Fn2 (a -> Boolean) (Array a) Boolean\n\n-- | Perform a fold using a monadic step function.\n-- |\n-- | ```purescript\n-- | foldM (\\x y -> Just (x + y)) 0 [1, 4] = Just 5\n-- | ```\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> Array a -> m b\nfoldM f b = runFn3 unconsImpl (\\_ -> pure b) (\\a as -> f b a >>= \\b' -> foldM f b' as)\n\nfoldRecM :: forall m a b. MonadRec m => (b -> a -> m b) -> b -> Array a -> m b\nfoldRecM f b array = tailRecM2 go b 0\n  where\n  go res i\n    | i >= length array = pure (Done res)\n    | otherwise = do\n        res' <- f res (unsafePartial (unsafeIndex array i))\n        pure (Loop { a: res', b: i + 1 })\n\n-- | Find the element of an array at the specified index.\n-- |\n-- | ```purescript\n-- | unsafePartial $ unsafeIndex [\"a\", \"b\", \"c\"] 1 = \"b\"\n-- | ```\n-- |\n-- | Using `unsafeIndex` with an out-of-range index will not immediately raise a runtime error.\n-- | Instead, the result will be undefined. Most attempts to subsequently use the result will\n-- | cause a runtime error, of course, but this is not guaranteed, and is dependent on the backend;\n-- | some programs will continue to run as if nothing is wrong. For example, in the JavaScript backend,\n-- | the expression `unsafePartial (unsafeIndex [true] 1)` has type `Boolean`;\n-- | since this expression evaluates to `undefined`, attempting to use it in an `if` statement will cause\n-- | the else branch to be taken.\nunsafeIndex :: forall a. Partial => Array a -> Int -> a\nunsafeIndex = runFn2 unsafeIndexImpl\n\nforeign import unsafeIndexImpl :: forall a. Fn2 (Array a) Int a\n","module Data.FoldableWithIndex\n  ( class FoldableWithIndex, foldrWithIndex, foldlWithIndex, foldMapWithIndex\n  , foldrWithIndexDefault\n  , foldlWithIndexDefault\n  , foldMapWithIndexDefaultR\n  , foldMapWithIndexDefaultL\n  , foldWithIndexM\n  , traverseWithIndex_\n  , forWithIndex_\n  , surroundMapWithIndex\n  , allWithIndex\n  , anyWithIndex\n  , findWithIndex\n  , findMapWithIndex\n  , foldrDefault\n  , foldlDefault\n  , foldMapDefault\n  ) where\n\nimport Prelude\n\nimport Data.Const (Const)\nimport Data.Either (Either(..))\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct, coproduct)\nimport Data.Functor.Product (Product(..))\nimport Data.FunctorWithIndex (mapWithIndex)\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Newtype (unwrap)\nimport Data.Tuple (Tuple(..), curry)\n\n-- | A `Foldable` with an additional index.\n-- | A `FoldableWithIndex` instance must be compatible with its `Foldable`\n-- | instance\n-- | ```purescript\n-- | foldr f = foldrWithIndex (const f)\n-- | foldl f = foldlWithIndex (const f)\n-- | foldMap f = foldMapWithIndex (const f)\n-- | ```\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrWithIndexDefault`\n-- | - `foldlWithIndexDefault`\n-- | - `foldMapWithIndexDefaultR`\n-- | - `foldMapWithIndexDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f <= FoldableWithIndex i f | f -> i where\n  foldrWithIndex :: forall a b. (i -> a -> b -> b) -> b -> f a -> b\n  foldlWithIndex :: forall a b. (i -> b -> a -> b) -> b -> f a -> b\n  foldMapWithIndex :: forall a m. Monoid m => (i -> a -> m) -> f a -> m\n\n-- | A default implementation of `foldrWithIndex` using `foldMapWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldMapWithIndexDefaultR`.\nfoldrWithIndexDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (i -> a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrWithIndexDefault c u xs = unwrap (foldMapWithIndex (\\i -> Endo <<< c i) xs) u\n\n-- | A default implementation of `foldlWithIndex` using `foldMapWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldMapWithIndexDefaultL`.\nfoldlWithIndexDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (i -> b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlWithIndexDefault c u xs = unwrap (unwrap (foldMapWithIndex (\\i -> Dual <<< Endo <<< flip (c i)) xs)) u\n\n-- | A default implementation of `foldMapWithIndex` using `foldrWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldrWithIndexDefault`.\nfoldMapWithIndexDefaultR\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (i -> a -> m)\n  -> f a\n  -> m\nfoldMapWithIndexDefaultR f = foldrWithIndex (\\i x acc -> f i x <> acc) mempty\n\n-- | A default implementation of `foldMapWithIndex` using `foldlWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldlWithIndexDefault`.\nfoldMapWithIndexDefaultL\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (i -> a -> m)\n  -> f a\n  -> m\nfoldMapWithIndexDefaultL f = foldlWithIndex (\\i acc x -> acc <> f i x) mempty\n\ninstance foldableWithIndexArray :: FoldableWithIndex Int Array where\n  foldrWithIndex f z = foldr (\\(Tuple i x) y -> f i x y) z <<< mapWithIndex Tuple\n  foldlWithIndex f z = foldl (\\y (Tuple i x) -> f i y x) z <<< mapWithIndex Tuple\n  foldMapWithIndex = foldMapWithIndexDefaultR\n\ninstance foldableWithIndexMaybe :: FoldableWithIndex Unit Maybe where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexFirst :: FoldableWithIndex Unit First where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexLast :: FoldableWithIndex Unit Last where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexAdditive :: FoldableWithIndex Unit Additive where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexDual :: FoldableWithIndex Unit Dual where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexDisj :: FoldableWithIndex Unit Disj where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexConj :: FoldableWithIndex Unit Conj where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexMultiplicative :: FoldableWithIndex Unit Multiplicative where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexEither :: FoldableWithIndex Unit (Either a) where\n  foldrWithIndex _ z (Left _)  = z\n  foldrWithIndex f z (Right x) = f unit x z\n  foldlWithIndex _ z (Left _)  = z\n  foldlWithIndex f z (Right x) = f unit z x\n  foldMapWithIndex _ (Left _)  = mempty\n  foldMapWithIndex f (Right x) = f unit x\n\ninstance foldableWithIndexTuple :: FoldableWithIndex Unit (Tuple a) where\n  foldrWithIndex f z (Tuple _ x) = f unit x z\n  foldlWithIndex f z (Tuple _ x) = f unit z x\n  foldMapWithIndex f (Tuple _ x) = f unit x\n\ninstance foldableWithIndexIdentity :: FoldableWithIndex Unit Identity where\n  foldrWithIndex f z (Identity x) = f unit x z\n  foldlWithIndex f z (Identity x) = f unit z x\n  foldMapWithIndex f (Identity x) = f unit x\n\ninstance foldableWithIndexConst :: FoldableWithIndex Void (Const a) where\n  foldrWithIndex _ z _ = z\n  foldlWithIndex _ z _ = z\n  foldMapWithIndex _ _ = mempty\n\ninstance foldableWithIndexProduct :: (FoldableWithIndex a f, FoldableWithIndex b g) => FoldableWithIndex (Either a b) (Product f g) where\n  foldrWithIndex f z (Product (Tuple fa ga)) = foldrWithIndex (f <<< Left) (foldrWithIndex (f <<< Right) z ga) fa\n  foldlWithIndex f z (Product (Tuple fa ga)) = foldlWithIndex (f <<< Right) (foldlWithIndex (f <<< Left) z fa) ga\n  foldMapWithIndex f (Product (Tuple fa ga)) = foldMapWithIndex (f <<< Left) fa <> foldMapWithIndex (f <<< Right) ga\n\ninstance foldableWithIndexCoproduct :: (FoldableWithIndex a f, FoldableWithIndex b g) => FoldableWithIndex (Either a b) (Coproduct f g) where\n  foldrWithIndex f z = coproduct (foldrWithIndex (f <<< Left) z) (foldrWithIndex (f <<< Right) z)\n  foldlWithIndex f z = coproduct (foldlWithIndex (f <<< Left) z) (foldlWithIndex (f <<< Right) z)\n  foldMapWithIndex f = coproduct (foldMapWithIndex (f <<< Left)) (foldMapWithIndex (f <<< Right))\n\ninstance foldableWithIndexCompose :: (FoldableWithIndex a f, FoldableWithIndex b g) => FoldableWithIndex (Tuple a b) (Compose f g) where\n  foldrWithIndex f i (Compose fga) = foldrWithIndex (\\a -> flip (foldrWithIndex (curry f a))) i fga\n  foldlWithIndex f i (Compose fga) = foldlWithIndex (foldlWithIndex <<< curry f) i fga\n  foldMapWithIndex f (Compose fga) = foldMapWithIndex (foldMapWithIndex <<< curry f) fga\n\ninstance foldableWithIndexApp :: FoldableWithIndex a f => FoldableWithIndex a (App f) where\n  foldrWithIndex f z (App x) = foldrWithIndex f z x\n  foldlWithIndex f z (App x) = foldlWithIndex f z x\n  foldMapWithIndex f (App x) = foldMapWithIndex f x\n\n\n-- | Similar to 'foldlWithIndex', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldWithIndexM\n  :: forall i f m a b\n   . FoldableWithIndex i f\n  => Monad m\n  => (i -> a -> b -> m a)\n  -> a\n  -> f b\n  -> m a\nfoldWithIndexM f a0 = foldlWithIndex (\\i ma b -> ma >>= flip (f i) b) (pure a0)\n\n-- | Traverse a data structure with access to the index, performing some\n-- | effects encoded by an `Applicative` functor at each value, ignoring the\n-- | final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > traverseWithIndex_ (curry logShow) [\"a\", \"b\", \"c\"]\n-- | (Tuple 0 \"a\")\n-- | (Tuple 1 \"b\")\n-- | (Tuple 2 \"c\")\n-- | ```\ntraverseWithIndex_\n  :: forall i a b f m\n   . Applicative m\n  => FoldableWithIndex i f\n  => (i -> a -> m b)\n  -> f a\n  -> m Unit\ntraverseWithIndex_ f = foldrWithIndex (\\i -> (*>) <<< f i) (pure unit)\n\n-- | A version of `traverseWithIndex_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | forWithIndex_ [\"a\", \"b\", \"c\"] \\i x -> do\n-- |   logShow i\n-- |   log x\n-- | ```\nforWithIndex_\n  :: forall i a b f m\n   . Applicative m\n  => FoldableWithIndex i f\n  => f a\n  -> (i -> a -> m b)\n  -> m Unit\nforWithIndex_ = flip traverseWithIndex_\n\n-- | `foldMapWithIndex` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) []\n-- | = \"*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\"]\n-- | = \"*0a*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\", \"b\"]\n-- | = \"*0a*1b*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\", \"b\", \"c\"]\n-- | = \"*0a*1b*2c*\"\n-- | ```\nsurroundMapWithIndex\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Semigroup m\n  => m\n  -> (i -> a -> m)\n  -> f a\n  -> m\nsurroundMapWithIndex d t f = unwrap (foldMapWithIndex joined f) d\n  where joined i a = Endo \\m -> d <> t i a <> m\n\n-- | `allWithIndex f` is the same as `and <<< mapWithIndex f`; map a function over the\n-- | structure, and then get the conjunction of the results.\nallWithIndex\n  :: forall i a b f\n   . FoldableWithIndex i f\n  => HeytingAlgebra b\n  => (i -> a -> b)\n  -> f a\n  -> b\nallWithIndex t = unwrap <<< foldMapWithIndex (\\i -> Conj <<< t i)\n\n-- | `anyWithIndex f` is the same as `or <<< mapWithIndex f`; map a function over the\n-- | structure, and then get the disjunction of the results.\nanyWithIndex\n  :: forall i a b f\n   . FoldableWithIndex i f\n  => HeytingAlgebra b\n  => (i -> a -> b)\n  -> f a\n  -> b\nanyWithIndex t = unwrap <<< foldMapWithIndex (\\i -> Disj <<< t i)\n\n-- | Try to find an element in a data structure which satisfies a predicate\n-- | with access to the index.\nfindWithIndex\n  :: forall i a f\n   . FoldableWithIndex i f\n  => (i -> a -> Boolean)\n  -> f a\n  -> Maybe { index :: i, value :: a }\nfindWithIndex p = foldlWithIndex go Nothing\n  where\n    go\n      :: i\n      -> Maybe { index :: i, value :: a }\n      -> a\n      -> Maybe { index :: i, value :: a }\n    go i Nothing x | p i x = Just { index: i, value: x }\n    go _ r _ = r\n\n-- | Try to find an element in a data structure which satisfies a predicate mapping\n-- | with access to the index.\nfindMapWithIndex\n  :: forall i a b f\n   . FoldableWithIndex i f\n  => (i -> a -> Maybe b)\n  -> f a\n  -> Maybe b\nfindMapWithIndex f = foldlWithIndex go Nothing\n  where\n    go\n      :: i\n      -> Maybe b\n      -> a\n      -> Maybe b\n    go i Nothing x = f i x\n    go _ r _ = r\n\n-- | A default implementation of `foldr` using `foldrWithIndex`\nfoldrDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (a -> b -> b) -> b -> f a -> b\nfoldrDefault f = foldrWithIndex (const f)\n\n-- | A default implementation of `foldl` using `foldlWithIndex`\nfoldlDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (b -> a -> b) -> b -> f a -> b\nfoldlDefault f = foldlWithIndex (const f)\n\n-- | A default implementation of `foldMap` using `foldMapWithIndex`\nfoldMapDefault\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (a -> m) -> f a -> m\nfoldMapDefault f = foldMapWithIndex (const f)\n","module Data.TraversableWithIndex \n  ( class TraversableWithIndex, traverseWithIndex\n  , traverseWithIndexDefault\n  , forWithIndex\n  , scanlWithIndex\n  , mapAccumLWithIndex\n  , scanrWithIndex\n  , mapAccumRWithIndex\n  , traverseDefault\n  , module Data.Traversable.Accum\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.FoldableWithIndex (class FoldableWithIndex)\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..), coproduct)\nimport Data.Functor.Product (Product(..), product)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe)\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj)\nimport Data.Monoid.Disj (Disj)\nimport Data.Monoid.Dual (Dual)\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Traversable (class Traversable, sequence, traverse)\nimport Data.Traversable.Accum (Accum)\nimport Data.Traversable.Accum.Internal (StateL(..), StateR(..), stateL, stateR)\nimport Data.Tuple (Tuple(..), curry)\n\n\n-- | A `Traversable` with an additional index.  \n-- | A `TraversableWithIndex` instance must be compatible with its\n-- | `Traversable` instance\n-- | ```purescript\n-- | traverse f = traverseWithIndex (const f)\n-- | ```\n-- | with its `FoldableWithIndex` instance\n-- | ```\n-- | foldMapWithIndex f = unwrap <<< traverseWithIndex (\\i -> Const <<< f i)\n-- | ```\n-- | and with its `FunctorWithIndex` instance\n-- | ```\n-- | mapWithIndex f = unwrap <<< traverseWithIndex (\\i -> Identity <<< f i)\n-- | ```\n-- |\n-- | A default implementation is provided by `traverseWithIndexDefault`.\nclass (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) <= TraversableWithIndex i t | t -> i where\n  traverseWithIndex :: forall a b m. Applicative m => (i -> a -> m b) -> t a -> m (t b)\n\n-- | A default implementation of `traverseWithIndex` using `sequence` and `mapWithIndex`.\ntraverseWithIndexDefault\n  :: forall i t a b m\n   . TraversableWithIndex i t\n  => Applicative m\n  => (i -> a -> m b)\n  -> t a\n  -> m (t b)\ntraverseWithIndexDefault f = sequence <<< mapWithIndex f\n\ninstance traversableWithIndexArray :: TraversableWithIndex Int Array where\n  traverseWithIndex = traverseWithIndexDefault\n\ninstance traversableWithIndexMaybe :: TraversableWithIndex Unit Maybe where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexFirst :: TraversableWithIndex Unit First where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexLast :: TraversableWithIndex Unit Last where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexAdditive :: TraversableWithIndex Unit Additive where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexDual :: TraversableWithIndex Unit Dual where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexConj :: TraversableWithIndex Unit Conj where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexDisj :: TraversableWithIndex Unit Disj where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexMultiplicative :: TraversableWithIndex Unit Multiplicative where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexEither :: TraversableWithIndex Unit (Either a) where\n  traverseWithIndex _ (Left x)  = pure (Left x)\n  traverseWithIndex f (Right x) = Right <$> f unit x\n\ninstance traversableWithIndexTuple :: TraversableWithIndex Unit (Tuple a) where\n  traverseWithIndex f (Tuple x y) = Tuple x <$> f unit y\n\ninstance traversableWithIndexIdentity :: TraversableWithIndex Unit Identity where\n  traverseWithIndex f (Identity x) = Identity <$> f unit x\n\ninstance traversableWithIndexConst :: TraversableWithIndex Void (Const a) where\n  traverseWithIndex _ (Const x) = pure (Const x)\n\ninstance traversableWithIndexProduct :: (TraversableWithIndex a f, TraversableWithIndex b g) => TraversableWithIndex (Either a b) (Product f g) where\n  traverseWithIndex f (Product (Tuple fa ga)) = lift2 product (traverseWithIndex (f <<< Left) fa) (traverseWithIndex (f <<< Right) ga)\n\ninstance traversableWithIndexCoproduct :: (TraversableWithIndex a f, TraversableWithIndex b g) => TraversableWithIndex (Either a b) (Coproduct f g) where\n  traverseWithIndex f = coproduct\n    (map (Coproduct <<< Left) <<< traverseWithIndex (f <<< Left))\n    (map (Coproduct <<< Right) <<< traverseWithIndex (f <<< Right))\n\ninstance traversableWithIndexCompose :: (TraversableWithIndex a f, TraversableWithIndex b g) => TraversableWithIndex (Tuple a b) (Compose f g) where\n  traverseWithIndex f (Compose fga) = map Compose $ traverseWithIndex (traverseWithIndex <<< curry f) fga\n\ninstance traversableWithIndexApp :: TraversableWithIndex a f => TraversableWithIndex a (App f) where\n  traverseWithIndex f (App x) = App <$> traverseWithIndex f x\n\n-- | A version of `traverseWithIndex` with its arguments flipped.\n-- |\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for [1, 2, 3] \\i x -> do\n-- |   logShow i\n-- |   pure (x * x)\n-- | ```\nforWithIndex\n  :: forall i a b m t\n   . Applicative m\n  => TraversableWithIndex i t\n  => t a\n  -> (i -> a -> m b)\n  -> m (t b)\nforWithIndex = flip traverseWithIndex\n\n-- | Fold a data structure from the left with access to the indices, keeping\n-- | all intermediate results instead of only the final result. Note that the\n-- | initial value does not appear in the result (unlike Haskell's\n-- | `Prelude.scanl`).\n-- |\n-- | ```purescript\n-- | scanlWithIndex (\\i y x -> i + y + x) 0 [1, 2, 3] = [1, 4, 9]\n-- | ```\nscanlWithIndex\n  :: forall i a b f\n   . TraversableWithIndex i f\n  => (i -> b -> a -> b)\n  -> b\n  -> f a\n  -> f b\nscanlWithIndex f b0 xs =\n  (mapAccumLWithIndex (\\i b a -> let b' = f i b a in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the left with access to the indices, keeping\n-- | all intermediate results instead of only the final result.\n-- |\n-- | Unlike `scanlWithIndex`, `mapAccumLWithIndex` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumLWithIndex\n  :: forall i a b s f\n   . TraversableWithIndex i f\n  => (i -> s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumLWithIndex f s0 xs = stateL (traverseWithIndex (\\i a -> StateL \\s -> f i s a) xs) s0\n\n-- | Fold a data structure from the right with access to the indices, keeping\n-- | all intermediate results instead of only the final result. Note that the\n-- | initial value does not appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```purescript\n-- | scanrWithIndex (\\i x y -> i + x + y) 0 [1, 2, 3] = [9, 8, 5]\n-- | ```\nscanrWithIndex\n  :: forall i a b f\n   . TraversableWithIndex i f\n  => (i -> a -> b -> b)\n  -> b\n  -> f a\n  -> f b\nscanrWithIndex f b0 xs =\n  (mapAccumRWithIndex (\\i b a -> let b' = f i a b in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the right with access to the indices, keeping\n-- | all intermediate results instead of only the final result.\n-- |\n-- | Unlike `scanrWithIndex`, `imapAccumRWithIndex` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumRWithIndex\n  :: forall i a b s f\n   . TraversableWithIndex i f\n  => (i -> s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumRWithIndex f s0 xs = stateR (traverseWithIndex (\\i a -> StateR \\s -> f i s a) xs) s0\n\n-- | A default implementation of `traverse` in terms of `traverseWithIndex`\ntraverseDefault\n  :: forall i t a b m\n   . TraversableWithIndex i t\n  => Applicative m\n  => (a -> m b) -> t a -> m (t b)\ntraverseDefault f = traverseWithIndex (const f)\n","-- | This module defines a type of native homogeneous Javascript Objects.\n-- |\n-- | To maximize performance, Javascript objects are not wrapped,\n-- | and some native code is used even when it's not necessary.\n\nmodule Foreign.Object\n  ( Object\n  , empty\n  , isEmpty\n  , size\n  , singleton\n  , insert\n  , lookup\n  , toUnfoldable\n  , toAscUnfoldable\n  , fromFoldable\n  , fromFoldableWith\n  , fromFoldableWithIndex\n  , fromHomogeneous\n  , delete\n  , pop\n  , member\n  , alter\n  , update\n  , mapWithKey\n  , filterWithKey\n  , filterKeys\n  , filter\n  , keys\n  , values\n  , union\n  , unionWith\n  , unions\n  , isSubmap\n  , fold\n  , foldMap\n  , foldM\n  , foldMaybe\n  , all\n  , thawST\n  , freezeST\n  , runST\n  , toArrayWithKey\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST)\nimport Control.Monad.ST as ST\nimport Data.Array as A\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, for_)\nimport Data.FoldableWithIndex (class FoldableWithIndex, forWithIndex_)\nimport Data.Function.Uncurried (Fn2, runFn2, Fn4, runFn4)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.Maybe (Maybe(..), maybe, fromMaybe)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), fst, uncurry)\nimport Data.Unfoldable (class Unfoldable)\nimport Foreign.Object.ST (STObject)\nimport Foreign.Object.ST as OST\nimport Type.Row.Homogeneous (class Homogeneous)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | `Object a` represents a homogeneous JS Object with values of type `a`.\nforeign import data Object :: Type -> Type\n\ntype role Object representational\n\nforeign import _copyST :: forall a b r. a -> ST r b\n\n-- | Convert an immutable Object into a mutable Object\nthawST :: forall a r. Object a -> ST r (STObject r a)\nthawST = _copyST\n\n-- | Convert a mutable Object into an immutable Object\nfreezeST :: forall a r. STObject r a -> ST r (Object a)\nfreezeST = _copyST\n\n-- | Freeze a mutable Object, creating an immutable Object. Use this function as you would use\n-- | `Control.Monad.ST.run` (from the `purescript-st` package) to freeze a mutable reference.\n-- |\n-- | The rank-2 type prevents the Object from escaping the scope of `runST`.\nforeign import runST :: forall a. (forall r. ST r (STObject r a)) -> Object a\n\nmutate :: forall a b. (forall r. STObject r a -> ST r b) -> Object a -> Object a\nmutate f m = runST do\n  s <- thawST m\n  _ <- f s\n  pure s\n\nforeign import _fmapObject :: forall a b. Fn2 (Object a) (a -> b) (Object b)\n\ninstance functorObject :: Functor Object where\n  map f m = runFn2 _fmapObject m f\n\ninstance functorWithIndexObject :: FunctorWithIndex String Object where\n  mapWithIndex = mapWithKey\n\nforeign import _foldM :: forall a m z. (m -> (z -> m) -> m) -> (z -> String -> a -> m) -> m -> Object a -> m\n\n-- | Fold the keys and values of an object\nfold :: forall a z. (z -> String -> a -> z) -> z -> Object a -> z\nfold = _foldM ((#))\n\n-- | Fold the keys and values of an object, accumulating values using some\n-- | `Monoid`.\nfoldMap :: forall a m. Monoid m => (String -> a -> m) -> Object a -> m\nfoldMap f = fold (\\acc k v -> acc <> f k v) mempty\n\n-- | Fold the keys and values of an object, accumulating values and effects in\n-- | some `Monad`.\nfoldM :: forall a m z. Monad m => (z -> String -> a -> m z) -> z -> Object a -> m z\nfoldM f z = _foldM bind f (pure z)\n\ninstance foldableObject :: Foldable Object where\n  foldl f = fold (\\z _ -> f z)\n  foldr f z m = foldr f z (values m)\n  foldMap f = foldMap (const f)\n\ninstance foldableWithIndexObject :: FoldableWithIndex String Object where\n  foldlWithIndex f = fold (flip f)\n  foldrWithIndex f z m = foldr (uncurry f) z (toArrayWithKey Tuple m)\n  foldMapWithIndex = foldMap\n\ninstance traversableObject :: Traversable Object where\n  traverse = traverseWithIndex <<< const\n  sequence = traverse identity\n\ninstance traversableWithIndexObject :: TraversableWithIndex String Object where\n  traverseWithIndex f ms =\n    fold (\\acc k v -> flip (insert k) <$> acc <*> f k v) (pure empty) ms\n\n-- Unfortunately the above are not short-circuitable (consider using purescript-machines)\n-- so we need special cases:\n\nforeign import _foldSCObject :: forall a z. Fn4 (Object a) z (z -> String -> a -> Maybe z) (forall b. b -> Maybe b -> b) z\n\n-- | Fold the keys and values of a map.\n-- |\n-- | This function allows the folding function to terminate the fold early,\n-- | using `Maybe`.\nfoldMaybe :: forall a z. (z -> String -> a -> Maybe z) -> z -> Object a -> z\nfoldMaybe f z m = runFn4 _foldSCObject m z f fromMaybe\n\n-- | Test whether all key/value pairs in a `Object` satisfy a predicate.\nforeign import all :: forall a. (String -> a -> Boolean) -> Object a -> Boolean\n\ninstance eqObject :: Eq a => Eq (Object a) where\n  eq m1 m2 = (isSubmap m1 m2) && (isSubmap m2 m1)\n\ninstance eq1Object :: Eq1 Object where\n  eq1 = eq\n\n-- Internal use\ntoAscArray :: forall v. Object v -> Array (Tuple String v)\ntoAscArray = toAscUnfoldable\n\ninstance ordObject :: Ord a => Ord (Object a) where\n  compare m1 m2 = compare (toAscArray m1) (toAscArray m2)\n\ninstance showObject :: Show a => Show (Object a) where\n  show m = \"(fromFoldable \" <> show (toArray m) <> \")\"\n\n-- | An empty map\nforeign import empty :: forall a. Object a\n\n-- | Test whether one map contains all of the keys and values contained in another map\nisSubmap :: forall a. Eq a => Object a -> Object a -> Boolean\nisSubmap m1 m2 = all f m1 where\n  f k v = runFn4 _lookup false ((==) v) k m2\n\n-- | Test whether a map is empty\nisEmpty :: forall a. Object a -> Boolean\nisEmpty = all (\\_ _ -> false)\n\n-- | Calculate the number of key/value pairs in a map\nforeign import size :: forall a. Object a -> Int\n\n-- | Create an `Object a` with one key/value pair\nsingleton :: forall a. String -> a -> Object a\nsingleton k v = runST (OST.poke k v =<< OST.new)\n\nforeign import _lookup :: forall a z. Fn4 z (a -> z) String (Object a) z\n\n-- | Lookup the value for a key in a map\nlookup :: forall a. String -> Object a -> Maybe a\nlookup = runFn4 _lookup Nothing Just\n\n-- | Test whether a `String` appears as a key in a map\nmember :: forall a. String -> Object a -> Boolean\nmember = runFn4 _lookup false (const true)\n\n-- | Insert or replace a key/value pair in a map\ninsert :: forall a. String -> a -> Object a -> Object a\ninsert k v = mutate (OST.poke k v)\n\n-- | Delete a key and value from a map\ndelete :: forall a. String -> Object a -> Object a\ndelete k = mutate (OST.delete k)\n\n-- | Delete a key and value from a map, returning the value\n-- | as well as the subsequent map\npop :: forall a. String -> Object a -> Maybe (Tuple a (Object a))\npop k m = lookup k m <#> \\a -> Tuple a (delete k m)\n\n-- | Insert, remove or update a value for a key in a map\nalter :: forall a. (Maybe a -> Maybe a) -> String -> Object a -> Object a\nalter f k m = case f (k `lookup` m) of\n  Nothing -> delete k m\n  Just v -> insert k v m\n\n-- | Remove or update a value for a key in a map\nupdate :: forall a. (a -> Maybe a) -> String -> Object a -> Object a\nupdate f k m = alter (maybe Nothing f) k m\n\n-- | Create an `Object a` from a foldable collection of key/value pairs\nfromFoldable :: forall f a. Foldable f => f (Tuple String a) -> Object a\nfromFoldable l = runST do\n  s <- OST.new\n  ST.foreach (A.fromFoldable l) \\(Tuple k v) -> void $ OST.poke k v s\n  pure s\n\n-- | Create an `Object a` from a `String`-indexed foldable collection\nfromFoldableWithIndex :: forall f a. FoldableWithIndex String f => f a -> Object a\nfromFoldableWithIndex l = runST do\n  s <- OST.new\n  forWithIndex_ l \\k v -> OST.poke k v s\n  pure s\n\nforeign import _lookupST :: forall a r z. Fn4 z (a -> z) String (STObject r a) (ST r z)\n\n-- | Create an `Object a` from a foldable collection of key/value pairs, using the\n-- | specified function to combine values for duplicate keys.\nfromFoldableWith :: forall f a. Foldable f => (a -> a -> a) -> f (Tuple String a) -> Object a\nfromFoldableWith f l = runST (do\n  s <- OST.new\n  for_ l (\\(Tuple k v) -> runFn4 _lookupST v (f v) k s >>= \\v' -> OST.poke k v' s)\n  pure s)\n\n-- | Create an `Object a` from a homogeneous record, i.e. all of the record\n-- | fields are of the same type.\nfromHomogeneous :: forall r a. Homogeneous r a => { | r } -> Object a\nfromHomogeneous = unsafeCoerce\n\nforeign import toArrayWithKey :: forall a b . (String -> a -> b) -> Object a -> Array b\n\n-- | Unfolds a map into a list of key/value pairs\ntoUnfoldable :: forall f a. Unfoldable f => Object a -> f (Tuple String a)\ntoUnfoldable = A.toUnfoldable <<< toArrayWithKey Tuple\n\n-- | Unfolds a map into a list of key/value pairs which is guaranteed to be\n-- | sorted by key\ntoAscUnfoldable :: forall f a. Unfoldable f => Object a -> f (Tuple String a)\ntoAscUnfoldable = A.toUnfoldable <<< A.sortWith fst <<< toArrayWithKey Tuple\n\n-- Internal\ntoArray :: forall a. Object a -> Array (Tuple String a)\ntoArray = toArrayWithKey Tuple\n\n-- | Get an array of the keys in a map\nforeign import keys :: forall a. Object a -> Array String\n\n-- | Get a list of the values in a map\nvalues :: forall a. Object a -> Array a\nvalues = toArrayWithKey (\\_ v -> v)\n\n-- | Compute the union of two maps, preferring the first map in the case of\n-- | duplicate keys.\nunion :: forall a. Object a -> Object a -> Object a\nunion m = mutate (\\s -> foldM (\\s' k v -> OST.poke k v s') s m)\n\n-- | Compute the union of two maps, using the specified function\n-- | to combine values for duplicate keys.\nunionWith :: forall a. (a -> a -> a) -> Object a -> Object a -> Object a\nunionWith f m1 m2 =\n  mutate (\\s1 -> foldM (\\s2 k v1 -> OST.poke k (runFn4 _lookup v1 (\\v2 -> f v1 v2) k m2) s2) s1 m1) m2\n\n-- | Compute the union of a collection of maps\nunions :: forall f a. Foldable f => f (Object a) -> Object a\nunions = foldl union empty\n\nforeign import _mapWithKey :: forall a b. Fn2 (Object a) (String -> a -> b) (Object b)\n\n-- | Apply a function of two arguments to each key/value pair, producing a new map\nmapWithKey :: forall a b. (String -> a -> b) -> Object a -> Object b\nmapWithKey f m = runFn2 _mapWithKey m f\n\ninstance semigroupObject :: (Semigroup a) => Semigroup (Object a) where\n  append = unionWith (<>)\n\ninstance monoidObject :: (Semigroup a) => Monoid (Object a) where\n  mempty = empty\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | fails to hold.\nfilterWithKey :: forall a. (String -> a -> Boolean) -> Object a -> Object a\nfilterWithKey predicate m = runST go\n  where\n  go :: forall r. ST r (STObject r a)\n  go = do\n    m' <- OST.new\n    foldM step m' m\n    where\n      step acc k v = if predicate k v then OST.poke k v acc else pure acc\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the key fails to hold.\nfilterKeys :: (String -> Boolean) -> Object ~> Object\nfilterKeys predicate = filterWithKey $ const <<< predicate\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the value fails to hold.\nfilter :: forall a. (a -> Boolean) -> Object a -> Object a\nfilter predicate = filterWithKey $ const predicate\n","-- | This module defines a data type and various functions for creating and\n-- | manipulating JSON values. The README contains additional documentation\n-- | for this module.\nmodule Data.Argonaut.Core\n  ( Json\n  , caseJson\n  , caseJsonNull\n  , caseJsonBoolean\n  , caseJsonNumber\n  , caseJsonString\n  , caseJsonArray\n  , caseJsonObject\n  , isNull\n  , isBoolean\n  , isNumber\n  , isString\n  , isArray\n  , isObject\n  , fromBoolean\n  , fromNumber\n  , fromString\n  , fromArray\n  , fromObject\n  , toNull\n  , toBoolean\n  , toNumber\n  , toString\n  , toArray\n  , toObject\n  , jsonNull\n  , jsonTrue\n  , jsonFalse\n  , jsonZero\n  , jsonEmptyString\n  , jsonEmptyArray\n  , jsonSingletonArray\n  , jsonEmptyObject\n  , jsonSingletonObject\n  , stringify\n  , stringifyWithIndent\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried (Fn5, runFn5, Fn7, runFn7)\nimport Data.Maybe (Maybe(..))\nimport Foreign.Object (Object)\nimport Foreign.Object as Obj\n\n-- | The type of JSON data. The underlying representation is the same as what\n-- | would be returned from JavaScript's `JSON.parse` function; that is,\n-- | ordinary JavaScript booleans, strings, arrays, objects, etc.\nforeign import data Json :: Type\n\ninstance eqJson :: Eq Json where\n  eq j1 j2 = compare j1 j2 == EQ\n\ninstance ordJson :: Ord Json where\n  compare a b = runFn5 _compare EQ GT LT a b\n\n-- | The type of null values inside JSON data. There is exactly one value of\n-- | this type: in JavaScript, it is written `null`. This module exports this\n-- | value as `jsonNull`.\nforeign import data JNull :: Type\n\ninstance eqJNull :: Eq JNull where\n  eq _ _ = true\n\ninstance ordJNull :: Ord JNull where\n  compare _ _ = EQ\n\n-- | Case analysis for `Json` values. See the README for more information.\ncaseJson\n  :: forall a\n   . (Unit -> a)\n  -> (Boolean -> a)\n  -> (Number -> a)\n  -> (String -> a)\n  -> (Array Json -> a)\n  -> (Object Json -> a)\n  -> Json\n  -> a\ncaseJson a b c d e f json = runFn7 _caseJson a b c d e f json\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was null, and a default value for all other cases.\ncaseJsonNull :: forall a. a -> (Unit -> a) -> Json -> a\ncaseJsonNull d f j = runFn7 _caseJson f (const d) (const d) (const d) (const d) (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was a `Boolean`, and a default value for all other cases.\ncaseJsonBoolean :: forall a. a -> (Boolean -> a) -> Json -> a\ncaseJsonBoolean d f j = runFn7 _caseJson (const d) f (const d) (const d) (const d) (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was a `Number`, and a default value for all other cases.\ncaseJsonNumber :: forall a. a -> (Number -> a) -> Json -> a\ncaseJsonNumber d f j = runFn7 _caseJson (const d) (const d) f (const d) (const d) (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was a `String`, and a default value for all other cases.\ncaseJsonString :: forall a. a -> (String -> a) -> Json -> a\ncaseJsonString d f j = runFn7 _caseJson (const d) (const d) (const d) f (const d) (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was a `Array Json`, and a default value for all other cases.\ncaseJsonArray :: forall a. a -> (Array Json -> a) -> Json -> a\ncaseJsonArray d f j = runFn7 _caseJson (const d) (const d) (const d) (const d) f (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was an `Object`, and a default value for all other cases.\ncaseJsonObject :: forall a. a -> (Object Json -> a) -> Json -> a\ncaseJsonObject d f j = runFn7 _caseJson (const d) (const d) (const d) (const d) (const d) f j\n\nverbJsonType :: forall a b. b -> (a -> b) -> (b -> (a -> b) -> Json -> b) -> Json -> b\nverbJsonType def f g = g def f\n\n-- Tests\n\nisJsonType :: forall a. (Boolean -> (a -> Boolean) -> Json -> Boolean) -> Json -> Boolean\nisJsonType = verbJsonType false (const true)\n\n-- | Check if the provided `Json` is the `null` value\nisNull :: Json -> Boolean\nisNull = isJsonType caseJsonNull\n\n-- | Check if the provided `Json` is a `Boolean`\nisBoolean :: Json -> Boolean\nisBoolean = isJsonType caseJsonBoolean\n\n-- | Check if the provided `Json` is a `Number`\nisNumber :: Json -> Boolean\nisNumber = isJsonType caseJsonNumber\n\n-- | Check if the provided `Json` is a `String`\nisString :: Json -> Boolean\nisString = isJsonType caseJsonString\n\n-- | Check if the provided `Json` is an `Array`\nisArray :: Json -> Boolean\nisArray = isJsonType caseJsonArray\n\n-- | Check if the provided `Json` is an `Object`\nisObject :: Json -> Boolean\nisObject = isJsonType caseJsonObject\n\n-- Decoding\n\ntoJsonType\n  :: forall a\n   . (Maybe a -> (a -> Maybe a) -> Json -> Maybe a)\n  -> Json\n  -> Maybe a\ntoJsonType = verbJsonType Nothing Just\n\n-- | Convert `Json` to the `Unit` value if the `Json` is the null value\ntoNull :: Json -> Maybe Unit\ntoNull = toJsonType caseJsonNull\n\n-- | Convert `Json` to a `Boolean` value, if the `Json` is a boolean.\ntoBoolean :: Json -> Maybe Boolean\ntoBoolean = toJsonType caseJsonBoolean\n\n-- | Convert `Json` to a `Number` value, if the `Json` is a number.\ntoNumber :: Json -> Maybe Number\ntoNumber = toJsonType caseJsonNumber\n\n-- | Convert `Json` to a `String` value, if the `Json` is a string. To write a\n-- | `Json` value to a JSON string, see `stringify`.\ntoString :: Json -> Maybe String\ntoString = toJsonType caseJsonString\n\n-- | Convert `Json` to an `Array` of `Json` values, if the `Json` is an array.\ntoArray :: Json -> Maybe (Array Json)\ntoArray = toJsonType caseJsonArray\n\n-- | Convert `Json` to an `Object` of `Json` values, if the `Json` is an object.\ntoObject :: Json -> Maybe (Object Json)\ntoObject = toJsonType caseJsonObject\n\n-- Encoding\n\n-- | Construct `Json` from a `Boolean` value\nforeign import fromBoolean :: Boolean -> Json\n\n-- | Construct `Json` from a `Number` value\nforeign import fromNumber :: Number -> Json\n\n-- | Construct the `Json` representation of a `String` value.\n-- | Note that this function only produces `Json` containing a single piece of `String`\n-- | data (similar to `fromBoolean`, `fromNumber`, etc.).\n-- | This function does NOT convert the `String` encoding of a JSON value to `Json` - For that\n-- | purpose, you'll need to use `jsonParser`.\nforeign import fromString :: String -> Json\n\n-- | Construct `Json` from an array of `Json` values\nforeign import fromArray :: Array Json -> Json\n\n-- | Construct `Json` from an object with `Json` values\nforeign import fromObject :: Object Json -> Json\n\n-- Defaults\n\n-- | The JSON null value represented as `Json`\nforeign import jsonNull :: Json\n\n-- | The true boolean value represented as `Json`\njsonTrue :: Json\njsonTrue = fromBoolean true\n\n-- | The false boolean value represented as `Json`\njsonFalse :: Json\njsonFalse = fromBoolean false\n\n-- | The number zero represented as `Json`\njsonZero :: Json\njsonZero = fromNumber 0.0\n\n-- | An empty string represented as `Json`\njsonEmptyString :: Json\njsonEmptyString = fromString \"\"\n\n-- | An empty array represented as `Json`\njsonEmptyArray :: Json\njsonEmptyArray = fromArray []\n\n-- | An empty object represented as `Json`\njsonEmptyObject :: Json\njsonEmptyObject = fromObject Obj.empty\n\n-- | Constructs a `Json` array value containing only the provided value\njsonSingletonArray :: Json -> Json\njsonSingletonArray j = fromArray [ j ]\n\n-- | Constructs a `Json` object value containing only the provided key and value\njsonSingletonObject :: String -> Json -> Json\njsonSingletonObject key val = fromObject (Obj.singleton key val)\n\n-- | Converts a `Json` value to a JSON string. To retrieve a string from a `Json`\n-- | string value, see `fromString`.\nforeign import stringify :: Json -> String\n\n-- | Converts a `Json` value to a JSON string.\n-- | The first `Int` argument specifies the amount of white space characters to use as indentation.\n-- | This number is capped at 10 (if it is greater, the value is just 10). Values less than 1 indicate that no space should be used.\nforeign import stringifyWithIndent :: Int -> Json -> String\n\nforeign import _caseJson\n  :: forall z\n   . Fn7\n       (Unit -> z)\n       (Boolean -> z)\n       (Number -> z)\n       (String -> z)\n       (Array Json -> z)\n       (Object Json -> z)\n       Json\n       z\n\nforeign import _compare :: Fn5 Ordering Ordering Ordering Json Json Ordering\n","-- | Originally implemented in:\n-- | https://github.com/garyb/purescript-codec-argonaut\nmodule Data.Argonaut.Decode.Error where\n\nimport Prelude\n\nimport Data.Argonaut.Core (Json, stringify)\nimport Data.Generic.Rep (class Generic)\n\n-- | Error type for failures while decoding.\ndata JsonDecodeError\n  = TypeMismatch String\n  | UnexpectedValue Json\n  | AtIndex Int JsonDecodeError\n  | AtKey String JsonDecodeError\n  | Named String JsonDecodeError\n  | MissingValue\n\nderive instance eqJsonDecodeError :: Eq JsonDecodeError\nderive instance ordJsonDecodeError :: Ord JsonDecodeError\nderive instance genericJsonDecodeError :: Generic JsonDecodeError _\n\ninstance showJsonDecodeError :: Show JsonDecodeError where\n  show = case _ of\n    TypeMismatch s -> \"(TypeMismatch \" <> show s <> \")\"\n    UnexpectedValue j -> \"(UnexpectedValue \" <> stringify j <> \")\"\n    AtIndex i e -> \"(AtIndex \" <> show i <> \" \" <> show e <> \")\"\n    AtKey k e -> \"(AtKey \" <> show k <> \" \" <> show e <> \")\"\n    Named s e -> \"(Named \" <> show s <> \" \" <> show e <> \")\"\n    MissingValue -> \"MissingValue\"\n\n-- | Prints a `JsonDecodeError` as a readable error message.\nprintJsonDecodeError :: JsonDecodeError -> String\nprintJsonDecodeError err =\n  \"An error occurred while decoding a JSON value:\\n\" <> go err\n  where\n  go = case _ of\n    TypeMismatch ty -> \"  Expected value of type '\" <> ty <> \"'.\"\n    UnexpectedValue val -> \"  Unexpected value \" <> stringify val <> \".\"\n    AtIndex ix inner -> \"  At array index \" <> show ix <> \":\\n\" <> go inner\n    AtKey key inner -> \"  At object key \\'\" <> key <> \"\\':\\n\" <> go inner\n    Named name inner -> \"  Under '\" <> name <> \"':\\n\" <> go inner\n    MissingValue -> \"  No value was found.\"\n","export const foldr1Impl = function (f, xs) {\n  var acc = xs[xs.length - 1];\n  for (var i = xs.length - 2; i >= 0; i--) {\n    acc = f(xs[i])(acc);\n  }\n  return acc;\n};\n\nexport const foldl1Impl = function (f, xs) {\n  var acc = xs[0];\n  var len = xs.length;\n  for (var i = 1; i < len; i++) {\n    acc = f(acc)(xs[i]);\n  }\n  return acc;\n};\n\nexport const traverse1Impl = function () {\n  function Cont(fn) {\n    this.fn = fn;\n  }\n\n  var emptyList = {};\n\n  var ConsCell = function (head, tail) {\n    this.head = head;\n    this.tail = tail;\n  };\n\n  function finalCell(head) {\n    return new ConsCell(head, emptyList);\n  }\n\n  function consList(x) {\n    return function (xs) {\n      return new ConsCell(x, xs);\n    };\n  }\n\n  function listToArray(list) {\n    var arr = [];\n    var xs = list;\n    while (xs !== emptyList) {\n      arr.push(xs.head);\n      xs = xs.tail;\n    }\n    return arr;\n  }\n\n  return function (apply, map, f) {\n    var buildFrom = function (x, ys) {\n      return apply(map(consList)(f(x)))(ys);\n    };\n\n    var go = function (acc, currentLen, xs) {\n      if (currentLen === 0) {\n        return acc;\n      } else {\n        var last = xs[currentLen - 1];\n        return new Cont(function () {\n          var built = go(buildFrom(last, acc), currentLen - 1, xs);\n          return built;\n        });\n      }\n    };\n\n    return function (array) {\n      var acc = map(finalCell)(f(array[array.length - 1]));\n      var result = go(acc, array.length - 1, array);\n      while (result instanceof Cont) {\n        result = result.fn();\n      }\n\n      return map(listToArray)(result);\n    };\n  };\n}();\n","-- | This module exports the `NonEmptyArray` constructor.\n-- |\n-- | It is **NOT** intended for public use and is **NOT** versioned.\n-- |\n-- | Its content may change **in any way**, **at any time** and\n-- | **without notice**.\n\nmodule Data.Array.NonEmpty.Internal (NonEmptyArray(..)) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable)\nimport Data.FoldableWithIndex (class FoldableWithIndex)\nimport Data.Function.Uncurried (Fn2, Fn3, runFn2, runFn3)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.Ord (class Ord1)\nimport Data.Semigroup.Foldable (class Foldable1, foldMap1DefaultL)\nimport Data.Semigroup.Traversable (class Traversable1, sequence1Default)\nimport Data.Traversable (class Traversable)\nimport Data.TraversableWithIndex (class TraversableWithIndex)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | An array that is known not to be empty.\n-- |\n-- | You can use the constructor to create a `NonEmptyArray` that isn't\n-- | non-empty, breaking the guarantee behind this newtype. It is\n-- | provided as an escape hatch mainly for the `Data.Array.NonEmpty`\n-- | and `Data.Array` modules. Use this at your own risk when you know\n-- | what you are doing.\nnewtype NonEmptyArray a = NonEmptyArray (Array a)\n\ninstance showNonEmptyArray :: Show a => Show (NonEmptyArray a) where\n  show (NonEmptyArray xs) = \"(NonEmptyArray \" <> show xs <> \")\"\n\nderive newtype instance eqNonEmptyArray :: Eq a => Eq (NonEmptyArray a)\nderive newtype instance eq1NonEmptyArray :: Eq1 NonEmptyArray\n\nderive newtype instance ordNonEmptyArray :: Ord a => Ord (NonEmptyArray a)\nderive newtype instance ord1NonEmptyArray :: Ord1 NonEmptyArray\n\nderive newtype instance semigroupNonEmptyArray :: Semigroup (NonEmptyArray a)\n\nderive newtype instance functorNonEmptyArray :: Functor NonEmptyArray\nderive newtype instance functorWithIndexNonEmptyArray :: FunctorWithIndex Int NonEmptyArray\n\nderive newtype instance foldableNonEmptyArray :: Foldable NonEmptyArray\nderive newtype instance foldableWithIndexNonEmptyArray :: FoldableWithIndex Int NonEmptyArray\n\ninstance foldable1NonEmptyArray :: Foldable1 NonEmptyArray where\n  foldMap1 = foldMap1DefaultL\n  foldr1 = runFn2 foldr1Impl\n  foldl1 = runFn2 foldl1Impl\n\nderive newtype instance unfoldable1NonEmptyArray :: Unfoldable1 NonEmptyArray\nderive newtype instance traversableNonEmptyArray :: Traversable NonEmptyArray\nderive newtype instance traversableWithIndexNonEmptyArray :: TraversableWithIndex Int NonEmptyArray\n\ninstance traversable1NonEmptyArray :: Traversable1 NonEmptyArray where\n  traverse1 f = runFn3 traverse1Impl apply map f\n  sequence1 = sequence1Default\n\nderive newtype instance applyNonEmptyArray :: Apply NonEmptyArray\n\nderive newtype instance applicativeNonEmptyArray :: Applicative NonEmptyArray\n\nderive newtype instance bindNonEmptyArray :: Bind NonEmptyArray\n\nderive newtype instance monadNonEmptyArray :: Monad NonEmptyArray\n\nderive newtype instance altNonEmptyArray :: Alt NonEmptyArray\n\n-- we use FFI here to avoid the unncessary copy created by `tail`\nforeign import foldr1Impl :: forall a. Fn2 (a -> a -> a) (NonEmptyArray a) a\nforeign import foldl1Impl :: forall a. Fn2 (a -> a -> a) (NonEmptyArray a) a\n\nforeign import traverse1Impl\n  :: forall m a b\n   . Fn3\n       (forall a' b'. (m (a' -> b') -> m a' -> m b'))\n       (forall a' b'. (a' -> b') -> m a' -> m b')\n       (a -> m b)\n       (NonEmptyArray a -> m (NonEmptyArray b))\n","module Data.Array.NonEmpty\n  ( module Internal\n  , fromArray\n  , fromNonEmpty\n  , toArray\n  , toNonEmpty\n\n  , fromFoldable\n  , fromFoldable1\n  , toUnfoldable\n  , toUnfoldable1\n  , singleton\n  , (..), range\n  , replicate\n  , some\n\n  , length\n\n  , (:), cons\n  , cons'\n  , snoc\n  , snoc'\n  , appendArray\n  , prependArray\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elem\n  , notElem\n  , elemIndex\n  , elemLastIndex\n  , find\n  , findMap\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , intersperse\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , splitAt\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n  , foldl1\n  , foldr1\n  , foldMap1\n  , fold1\n  , intercalate\n  , transpose\n  , transpose'\n  , scanl\n  , scanr\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , union'\n  , unionBy\n  , unionBy'\n  , delete\n  , deleteBy\n\n  , (\\\\), difference\n  , difference'\n  , intersect\n  , intersect'\n  , intersectBy\n  , intersectBy'\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , any\n  , all\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Rec.Class (class MonadRec)\nimport Data.Array as A\nimport Data.Array.NonEmpty.Internal (NonEmptyArray(..))\nimport Data.Array.NonEmpty.Internal (NonEmptyArray) as Internal\nimport Data.Bifunctor (bimap)\nimport Data.Foldable (class Foldable)\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Foldable as F\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1, unfoldr1)\nimport Partial.Unsafe (unsafePartial)\nimport Safe.Coerce (coerce)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Internal - adapt an Array transform to NonEmptyArray\n--\n-- Note that this is unsafe: if the transform returns an empty array, this can\n-- explode at runtime.\nunsafeAdapt :: forall a b. (Array a -> Array b) -> NonEmptyArray a -> NonEmptyArray b\nunsafeAdapt f = unsafeFromArray <<< adaptAny f\n\n-- | Internal - adapt an Array transform to NonEmptyArray,\n--   with polymorphic result.\n--\n-- Note that this is unsafe: if the transform returns an empty array, this can\n-- explode at runtime.\nadaptAny :: forall a b. (Array a -> b) -> NonEmptyArray a -> b\nadaptAny f = f <<< toArray\n\n-- | Internal - adapt Array functions returning Maybes to NonEmptyArray\nadaptMaybe :: forall a b. (Array a -> Maybe b) -> NonEmptyArray a -> b\nadaptMaybe f = unsafePartial $ fromJust <<< f <<< toArray\n\nfromArray :: forall a. Array a -> Maybe (NonEmptyArray a)\nfromArray xs\n  | A.length xs > 0 = Just (unsafeFromArray xs)\n  | otherwise = Nothing\n\n-- | INTERNAL\nunsafeFromArray :: forall a. Array a -> NonEmptyArray a\nunsafeFromArray = NonEmptyArray\n\nunsafeFromArrayF :: forall f a. f (Array a) -> f (NonEmptyArray a)\nunsafeFromArrayF = unsafeCoerce\n\nfromNonEmpty :: forall a. NonEmpty Array a -> NonEmptyArray a\nfromNonEmpty (x :| xs) = cons' x xs\n\ntoArray :: forall a. NonEmptyArray a -> Array a\ntoArray (NonEmptyArray xs) = xs\n\ntoNonEmpty :: forall a. NonEmptyArray a -> NonEmpty Array a\ntoNonEmpty = uncons >>> \\{head: x, tail: xs} -> x :| xs\n\nfromFoldable :: forall f a. Foldable f => f a -> Maybe (NonEmptyArray a)\nfromFoldable = fromArray <<< A.fromFoldable\n\nfromFoldable1 :: forall f a. Foldable1 f => f a -> NonEmptyArray a\nfromFoldable1 = unsafeFromArray <<< A.fromFoldable\n\ntoUnfoldable :: forall f a. Unfoldable f => NonEmptyArray a -> f a\ntoUnfoldable = adaptAny A.toUnfoldable\n\ntoUnfoldable1 :: forall f a. Unfoldable1 f => NonEmptyArray a -> f a\ntoUnfoldable1 xs = unfoldr1 f 0\n  where\n  len = length xs\n  f i = Tuple (unsafePartial unsafeIndex xs i) $\n          if i < (len - 1) then Just (i + 1) else Nothing\n\nsingleton :: forall a. a -> NonEmptyArray a\nsingleton = unsafeFromArray <<< A.singleton\n\nrange :: Int -> Int -> NonEmptyArray Int\nrange x y = unsafeFromArray $ A.range x y\n\ninfix 8 range as ..\n\n-- | Replicate an item at least once\nreplicate :: forall a. Int -> a -> NonEmptyArray a\nreplicate i x = unsafeFromArray $ A.replicate (max 1 i) x\n\nsome\n  :: forall f a\n   . Alternative f\n  => Lazy (f (Array a))\n  => f a -> f (NonEmptyArray a)\nsome = unsafeFromArrayF <<< A.some\n\nlength :: forall a. NonEmptyArray a -> Int\nlength = adaptAny A.length\n\ncons :: forall a. a -> NonEmptyArray a -> NonEmptyArray a\ncons x = unsafeAdapt $ A.cons x\n\ninfixr 6 cons as :\n\ncons' :: forall a. a -> Array a -> NonEmptyArray a\ncons' x xs = unsafeFromArray $ A.cons x xs\n\nsnoc :: forall a. NonEmptyArray a -> a -> NonEmptyArray a\nsnoc xs x = unsafeFromArray $ A.snoc (toArray xs) x\n\nsnoc' :: forall a. Array a -> a -> NonEmptyArray a\nsnoc' xs x = unsafeFromArray $ A.snoc xs x\n\nappendArray :: forall a. NonEmptyArray a -> Array a -> NonEmptyArray a\nappendArray xs ys = unsafeFromArray $ toArray xs <> ys\n\nprependArray :: forall a. Array a -> NonEmptyArray a -> NonEmptyArray a\nprependArray xs ys = unsafeFromArray $ xs <> toArray ys\n\ninsert :: forall a. Ord a => a -> NonEmptyArray a -> NonEmptyArray a\ninsert x = unsafeAdapt $ A.insert x\n\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> NonEmptyArray a -> NonEmptyArray a\ninsertBy f x = unsafeAdapt $ A.insertBy f x\n\nhead :: forall a. NonEmptyArray a -> a\nhead = adaptMaybe A.head\n\nlast :: forall a. NonEmptyArray a -> a\nlast = adaptMaybe A.last\n\ntail :: forall a. NonEmptyArray a -> Array a\ntail = adaptMaybe A.tail\n\ninit :: forall a. NonEmptyArray a -> Array a\ninit = adaptMaybe A.init\n\nuncons :: forall a. NonEmptyArray a -> { head :: a, tail :: Array a }\nuncons = adaptMaybe A.uncons\n\nunsnoc :: forall a. NonEmptyArray a -> { init :: Array a, last :: a }\nunsnoc = adaptMaybe A.unsnoc\n\nindex :: forall a. NonEmptyArray a -> Int -> Maybe a\nindex = adaptAny A.index\n\ninfixl 8 index as !!\n\nelem :: forall a. Eq a => a -> NonEmptyArray a -> Boolean\nelem x = adaptAny $ A.elem x\n\nnotElem :: forall a. Eq a => a -> NonEmptyArray a -> Boolean\nnotElem x = adaptAny $ A.notElem x\n\nelemIndex :: forall a. Eq a => a -> NonEmptyArray a -> Maybe Int\nelemIndex x = adaptAny $ A.elemIndex x\n\nelemLastIndex :: forall a. Eq a => a -> NonEmptyArray a -> Maybe Int\nelemLastIndex x = adaptAny $ A.elemLastIndex x\n\nfind :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe a\nfind p = adaptAny $ A.find p\n\nfindMap :: forall a b. (a -> Maybe b) -> NonEmptyArray a -> Maybe b\nfindMap p = adaptAny $ A.findMap p\n\nfindIndex :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe Int\nfindIndex p = adaptAny $ A.findIndex p\n\nfindLastIndex :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe Int\nfindLastIndex x = adaptAny $ A.findLastIndex x\n\ninsertAt :: forall a. Int -> a -> NonEmptyArray a -> Maybe (NonEmptyArray a)\ninsertAt i x = unsafeFromArrayF <<< A.insertAt i x <<< toArray\n\ndeleteAt :: forall a. Int -> NonEmptyArray a -> Maybe (Array a)\ndeleteAt i = adaptAny $ A.deleteAt i\n\nupdateAt :: forall a. Int -> a -> NonEmptyArray a -> Maybe (NonEmptyArray a)\nupdateAt i x = unsafeFromArrayF <<< A.updateAt i x <<< toArray\n\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> NonEmptyArray a -> NonEmptyArray a\nupdateAtIndices pairs = unsafeAdapt $ A.updateAtIndices pairs\n\nmodifyAt :: forall a. Int -> (a -> a) -> NonEmptyArray a -> Maybe (NonEmptyArray a)\nmodifyAt i f = unsafeFromArrayF <<< A.modifyAt i f <<< toArray\n\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> NonEmptyArray a -> NonEmptyArray a\nmodifyAtIndices is f = unsafeAdapt $ A.modifyAtIndices is f\n\nalterAt :: forall a. Int -> (a -> Maybe a) -> NonEmptyArray a -> Maybe (Array a)\nalterAt i f = A.alterAt i f <<< toArray\n\nintersperse :: forall a. a -> NonEmptyArray a -> NonEmptyArray a\nintersperse x = unsafeAdapt $ A.intersperse x\n\nreverse :: forall a. NonEmptyArray a -> NonEmptyArray a\nreverse = unsafeAdapt A.reverse\n\nconcat :: forall a. NonEmptyArray (NonEmptyArray a) -> NonEmptyArray a\nconcat = unsafeFromArray <<< A.concat <<< toArray <<< map toArray\n\nconcatMap :: forall a b. (a -> NonEmptyArray b) -> NonEmptyArray a -> NonEmptyArray b\nconcatMap = flip bind\n\nfilter :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\nfilter f = adaptAny $ A.filter f\n\npartition\n  :: forall a\n   . (a -> Boolean)\n  -> NonEmptyArray a\n  -> { yes :: Array a, no :: Array a}\npartition f = adaptAny $ A.partition f\n\nfilterA\n  :: forall a f\n   . Applicative f\n  => (a -> f Boolean)\n  -> NonEmptyArray a\n  -> f (Array a)\nfilterA f = adaptAny $ A.filterA f\n\nsplitAt :: forall a. Int -> NonEmptyArray a -> { before :: Array a, after :: Array a }\nsplitAt i xs = A.splitAt i $ toArray xs\n\nmapMaybe :: forall a b. (a -> Maybe b) -> NonEmptyArray a -> Array b\nmapMaybe f = adaptAny $ A.mapMaybe f\n\ncatMaybes :: forall a. NonEmptyArray (Maybe a) -> Array a\ncatMaybes = adaptAny A.catMaybes\n\nmapWithIndex :: forall a b. (Int -> a -> b) -> NonEmptyArray a -> NonEmptyArray b\nmapWithIndex f = unsafeAdapt $ A.mapWithIndex f\n\nfoldl1 :: forall a. (a -> a -> a) -> NonEmptyArray a -> a\nfoldl1 = F.foldl1\n\nfoldr1 :: forall a. (a -> a -> a) -> NonEmptyArray a -> a\nfoldr1 = F.foldr1\n\nfoldMap1 :: forall a m. Semigroup m => (a -> m) -> NonEmptyArray a -> m\nfoldMap1 = F.foldMap1\n\nfold1 :: forall m. Semigroup m => NonEmptyArray m -> m\nfold1 = F.fold1\n\nintercalate :: forall a. Semigroup a => a -> NonEmptyArray a -> a\nintercalate = F.intercalate\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- | ```purescript\n-- | transpose \n-- |   (NonEmptyArray [ NonEmptyArray [1, 2, 3]\n-- |                  , NonEmptyArray [4, 5, 6]\n-- |                  ]) == \n-- |   (NonEmptyArray [ NonEmptyArray [1, 4]\n-- |                  , NonEmptyArray [2, 5]\n-- |                  , NonEmptyArray [3, 6]\n-- |                  ])\n-- | ```\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- | ```purescript\n-- | transpose \n-- |   (NonEmptyArray [ NonEmptyArray [10, 11]\n-- |                  , NonEmptyArray [20]\n-- |                  , NonEmptyArray [30, 31, 32]\n-- |                  ]) == \n-- |   (NomEmptyArray [ NonEmptyArray [10, 20, 30]\n-- |                  , NonEmptyArray [11, 31]\n-- |                  , NonEmptyArray [32]\n-- |                  ])\n-- | ```\ntranspose :: forall a. NonEmptyArray (NonEmptyArray a) -> NonEmptyArray (NonEmptyArray a)\ntranspose = \n  (coerce :: (Array (Array a)) -> (NonEmptyArray (NonEmptyArray a))) \n    <<< A.transpose <<< coerce\n\n-- | `transpose`' is identical to `transpose` other than that the inner arrays are each\n-- | a standard `Array` and not a `NonEmptyArray`. However, the result is wrapped in a \n-- | `Maybe` to cater for the case where the inner `Array` is empty and must return `Nothing`.\ntranspose' :: forall a. NonEmptyArray (Array a) -> Maybe (NonEmptyArray (Array a))\ntranspose' = fromArray <<< A.transpose <<< coerce\n\nscanl :: forall a b. (b -> a -> b) -> b -> NonEmptyArray a -> NonEmptyArray b\nscanl f x = unsafeAdapt $ A.scanl f x\n\nscanr :: forall a b. (a -> b -> b) -> b -> NonEmptyArray a -> NonEmptyArray b\nscanr f x = unsafeAdapt $ A.scanr f x\n\nsort :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray a\nsort = unsafeAdapt A.sort\n\nsortBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray a\nsortBy f = unsafeAdapt $ A.sortBy f\n\nsortWith :: forall a b. Ord b => (a -> b) -> NonEmptyArray a -> NonEmptyArray a\nsortWith f = unsafeAdapt $ A.sortWith f\n\nslice :: forall a. Int -> Int -> NonEmptyArray a -> Array a\nslice start end = adaptAny $ A.slice start end\n\ntake :: forall a. Int -> NonEmptyArray a -> Array a\ntake i = adaptAny $ A.take i\n\ntakeEnd :: forall a. Int -> NonEmptyArray a -> Array a\ntakeEnd i = adaptAny $ A.takeEnd i\n\ntakeWhile :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\ntakeWhile f = adaptAny $ A.takeWhile f\n\ndrop :: forall a. Int -> NonEmptyArray a -> Array a\ndrop i = adaptAny $ A.drop i\n\ndropEnd :: forall a. Int -> NonEmptyArray a -> Array a\ndropEnd i = adaptAny $ A.dropEnd i\n\ndropWhile :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\ndropWhile f = adaptAny $ A.dropWhile f\n\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> NonEmptyArray a\n  -> { init :: Array a, rest :: Array a }\nspan f = adaptAny $ A.span f\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group (NonEmptyArray [1, 1, 2, 2, 1]) ==\n-- |   NonEmptyArray [NonEmptyArray [1, 1], NonEmptyArray [2, 2], NonEmptyArray [1]]\n-- | ```\ngroup :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroup = unsafeAdapt $ A.group\n\n-- | Group equal elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | groupAll (NonEmptyArray [1, 1, 2, 2, 1]) ==\n-- |   NonEmptyArray [NonEmptyArray [1, 1, 1], NonEmptyArray [2, 2]]\n-- | `\ngroupAll :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupAll = groupAllBy compare\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to determine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) (NonEmptyArray [1, 3, 2, 4, 3, 3])\n-- |    = NonEmptyArray [NonEmptyArray [1, 3], NonEmptyArray [2], NonEmptyArray [4], NonEmptyArray [3, 3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupBy op = unsafeAdapt $ A.groupBy op\n\n-- | Group equal elements of an array into arrays, using the specified\n-- | comparison function to determine equality.\n-- |\n-- | ```purescript\n-- | groupAllBy (comparing Down) (NonEmptyArray [1, 3, 2, 4, 3, 3])\n-- |    = NonEmptyArray [NonEmptyArray [4], NonEmptyArray [3, 3, 3], NonEmptyArray [2], NonEmptyArray [1]]\n-- | ```\ngroupAllBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupAllBy op = unsafeAdapt $ A.groupAllBy op\n\nnub :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray a\nnub = unsafeAdapt A.nub\n\nnubEq :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a\nnubEq = unsafeAdapt A.nubEq\n\nnubBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray a\nnubBy f = unsafeAdapt $ A.nubBy f\n\nnubByEq :: forall a. (a -> a -> Boolean) -> NonEmptyArray a -> NonEmptyArray a\nnubByEq f = unsafeAdapt $ A.nubByEq f\n\nunion :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a -> NonEmptyArray a\nunion = unionBy (==)\n\nunion' :: forall a. Eq a => NonEmptyArray a -> Array a -> NonEmptyArray a\nunion' = unionBy' (==)\n\nunionBy\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> NonEmptyArray a\n  -> NonEmptyArray a\nunionBy eq xs = unionBy' eq xs <<< toArray\n\nunionBy'\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> Array a\n  -> NonEmptyArray a\nunionBy' eq xs = unsafeFromArray <<< A.unionBy eq (toArray xs)\n\ndelete :: forall a. Eq a => a -> NonEmptyArray a -> Array a\ndelete x = adaptAny $ A.delete x\n\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> NonEmptyArray a -> Array a\ndeleteBy f x = adaptAny $ A.deleteBy f x\n\ndifference :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a -> Array a\ndifference xs = adaptAny $ difference' xs\n\ndifference' :: forall a. Eq a => NonEmptyArray a -> Array a -> Array a\ndifference' xs = A.difference $ toArray xs\n\nintersect :: forall a . Eq a => NonEmptyArray a -> NonEmptyArray a -> Array a\nintersect = intersectBy eq\n\nintersect' :: forall a . Eq a => NonEmptyArray a -> Array a -> Array a\nintersect' = intersectBy' eq\n\nintersectBy\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> NonEmptyArray a\n  -> Array a\nintersectBy eq xs = intersectBy' eq xs <<< toArray\n\nintersectBy'\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> Array a\n  -> Array a\nintersectBy' eq xs = A.intersectBy eq (toArray xs)\n\ninfix 5 difference as \\\\\n\nzipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> NonEmptyArray a\n  -> NonEmptyArray b\n  -> NonEmptyArray c\nzipWith f xs ys = unsafeFromArray $ A.zipWith f (toArray xs) (toArray ys)\n\n\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> NonEmptyArray a\n  -> NonEmptyArray b\n  -> m (NonEmptyArray c)\nzipWithA f xs ys = unsafeFromArrayF $ A.zipWithA f (toArray xs) (toArray ys)\n\nzip :: forall a b. NonEmptyArray a -> NonEmptyArray b -> NonEmptyArray (Tuple a b)\nzip xs ys = unsafeFromArray $ toArray xs `A.zip` toArray ys\n\nunzip :: forall a b. NonEmptyArray (Tuple a b) -> Tuple (NonEmptyArray a) (NonEmptyArray b)\nunzip = bimap unsafeFromArray unsafeFromArray <<< A.unzip <<< toArray\n\nany :: forall a. (a -> Boolean) -> NonEmptyArray a -> Boolean\nany p = adaptAny $ A.any p\n\nall :: forall a. (a -> Boolean) -> NonEmptyArray a -> Boolean\nall p = adaptAny $ A.all p\n\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> NonEmptyArray a -> m b\nfoldM f acc = adaptAny $ A.foldM f acc\n\nfoldRecM :: forall m a b. MonadRec m => (b -> a -> m b) -> b -> NonEmptyArray a -> m b\nfoldRecM f acc = adaptAny $ A.foldRecM f acc\n\nunsafeIndex :: forall a. Partial => NonEmptyArray a -> Int -> a\nunsafeIndex = adaptAny A.unsafeIndex\n","export const fromNumberImpl = function (just) {\n  return function (nothing) {\n    return function (n) {\n      /* jshint bitwise: false */\n      return (n | 0) === n ? just(n) : nothing;\n    };\n  };\n};\n\nexport const toNumber = function (n) {\n  return n;\n};\n\nexport const fromStringAsImpl = function (just) {\n  return function (nothing) {\n    return function (radix) {\n      var digits;\n      if (radix < 11) {\n        digits = \"[0-\" + (radix - 1).toString() + \"]\";\n      } else if (radix === 11) {\n        digits = \"[0-9a]\";\n      } else {\n        digits = \"[0-9a-\" + String.fromCharCode(86 + radix) + \"]\";\n      }\n      var pattern = new RegExp(\"^[\\\\+\\\\-]?\" + digits + \"+$\", \"i\");\n\n      return function (s) {\n        /* jshint bitwise: false */\n        if (pattern.test(s)) {\n          var i = parseInt(s, radix);\n          return (i | 0) === i ? just(i) : nothing;\n        } else {\n          return nothing;\n        }\n      };\n    };\n  };\n};\n\nexport const toStringAs = function (radix) {\n  return function (i) {\n    return i.toString(radix);\n  };\n};\n\n\nexport const quot = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x / y | 0;\n  };\n};\n\nexport const rem = function (x) {\n  return function (y) {\n    return x % y;\n  };\n};\n\nexport const pow = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return Math.pow(x,y) | 0;\n  };\n};\n","/* globals exports */\nexport const nan = NaN;\nconst isNaNImpl = isNaN;\nexport { isNaNImpl as isNaN };\nexport const infinity = Infinity;\nconst isFiniteImpl = isFinite;\nexport { isFiniteImpl as isFinite };\n\nexport function fromStringImpl(str, isFinite, just, nothing) {\n  var num = parseFloat(str);\n  if (isFinite(num)) {\n    return just(num);\n  } else {\n    return nothing;\n  }\n}\n\nexport const abs = Math.abs;\n\nexport const acos = Math.acos;\n\nexport const asin = Math.asin;\n\nexport const atan = Math.atan;\n\nexport const atan2 = function (y) {\n  return function (x) {\n    return Math.atan2(y, x);\n  };\n};\n\nexport const ceil = Math.ceil;\n\nexport const cos = Math.cos;\n\nexport const exp = Math.exp;\n\nexport const floor = Math.floor;\n\nexport const log = Math.log;\n\nexport const max = function (n1) {\n  return function (n2) {\n    return Math.max(n1, n2);\n  };\n};\n\nexport const min = function (n1) {\n  return function (n2) {\n    return Math.min(n1, n2);\n  };\n};\n\nexport const pow = function (n) {\n  return function (p) {\n    return Math.pow(n, p);\n  };\n};\n\nexport const remainder = function (n) {\n  return function (m) {\n    return n % m;\n  };\n};\n\nexport const round = Math.round;\n\nexport const sign = Math.sign ? Math.sign : function(x) {\n  return x === 0 || x !== x ? x : (x < 0 ? -1 : 1);\n};\n\nexport const sin = Math.sin;\n\nexport const sqrt = Math.sqrt;\n\nexport const tan = Math.tan;\n\nexport const trunc = Math.trunc ? Math.trunc : function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n","module Data.Int\n  ( fromNumber\n  , ceil\n  , floor\n  , trunc\n  , round\n  , toNumber\n  , fromString\n  , Radix\n  , radix\n  , binary\n  , octal\n  , decimal\n  , hexadecimal\n  , base36\n  , fromStringAs\n  , toStringAs\n  , Parity(..)\n  , parity\n  , even\n  , odd\n  , quot\n  , rem\n  , pow\n  ) where\n\nimport Prelude\n\nimport Data.Int.Bits ((.&.))\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Number (isFinite)\nimport Data.Number as Number\n\n-- | Creates an `Int` from a `Number` value. The number must already be an\n-- | integer and fall within the valid range of values for the `Int` type\n-- | otherwise `Nothing` is returned.\nfromNumber :: Number -> Maybe Int\nfromNumber = fromNumberImpl Just Nothing\n\nforeign import fromNumberImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Number\n  -> Maybe Int\n\n-- | Convert a `Number` to an `Int`, by taking the closest integer equal to or\n-- | less than the argument. Values outside the `Int` range are clamped, `NaN`\n-- | and `Infinity` values return 0.\nfloor :: Number -> Int\nfloor = unsafeClamp <<< Number.floor\n\n-- | Convert a `Number` to an `Int`, by taking the closest integer equal to or\n-- | greater than the argument. Values outside the `Int` range are clamped,\n-- | `NaN` and `Infinity` values return 0.\nceil :: Number -> Int\nceil = unsafeClamp <<< Number.ceil\n\n-- | Convert a `Number` to an `Int`, by dropping the decimal.\n-- | Values outside the `Int` range are clamped, `NaN` and `Infinity`\n-- | values return 0.\ntrunc :: Number -> Int\ntrunc = unsafeClamp <<< Number.trunc\n\n-- | Convert a `Number` to an `Int`, by taking the nearest integer to the\n-- | argument. Values outside the `Int` range are clamped, `NaN` and `Infinity`\n-- | values return 0.\nround :: Number -> Int\nround = unsafeClamp <<< Number.round\n\n-- | Convert an integral `Number` to an `Int`, by clamping to the `Int` range.\n-- | This function will return 0 if the input is `NaN` or an `Infinity`.\nunsafeClamp :: Number -> Int\nunsafeClamp x\n  | not (isFinite x) = 0\n  | x >= toNumber top = top\n  | x <= toNumber bottom = bottom\n  | otherwise = fromMaybe 0 (fromNumber x)\n\n-- | Converts an `Int` value back into a `Number`. Any `Int` is a valid `Number`\n-- | so there is no loss of precision with this function.\nforeign import toNumber :: Int -> Number\n\n-- | Reads an `Int` from a `String` value. The number must parse as an integer\n-- | and fall within the valid range of values for the `Int` type, otherwise\n-- | `Nothing` is returned.\nfromString :: String -> Maybe Int\nfromString = fromStringAs (Radix 10)\n\n-- | A type for describing whether an integer is even or odd.\n-- |\n-- | The `Ord` instance considers `Even` to be less than `Odd`.\n-- |\n-- | The `Semiring` instance allows you to ask about the parity of the results\n-- | of arithmetical operations, given only the parities of the inputs. For\n-- | example, the sum of an odd number and an even number is odd, so\n-- | `Odd + Even == Odd`. This also works for multiplication, eg. the product\n-- | of two odd numbers is odd, and therefore `Odd * Odd == Odd`.\n-- |\n-- | More generally, we have that\n-- |\n-- | ```purescript\n-- | parity x + parity y == parity (x + y)\n-- | parity x * parity y == parity (x * y)\n-- | ```\n-- |\n-- | for any integers `x`, `y`. (A mathematician would say that `parity` is a\n-- | *ring homomorphism*.)\n-- |\n-- | After defining addition and multiplication on `Parity` in this way, the\n-- | `Semiring` laws now force us to choose `zero = Even` and `one = Odd`.\n-- | This `Semiring` instance actually turns out to be a `Field`.\ndata Parity = Even | Odd\n\nderive instance eqParity :: Eq Parity\nderive instance ordParity :: Ord Parity\n\ninstance showParity :: Show Parity where\n  show Even = \"Even\"\n  show Odd = \"Odd\"\n\ninstance boundedParity :: Bounded Parity where\n  bottom = Even\n  top = Odd\n\ninstance semiringParity :: Semiring Parity where\n  zero = Even\n  add x y = if x == y then Even else Odd\n  one = Odd\n  mul Odd Odd = Odd\n  mul _ _ = Even\n\ninstance ringParity :: Ring Parity where\n  sub = add\n\ninstance commutativeRingParity :: CommutativeRing Parity\n\ninstance euclideanRingParity :: EuclideanRing Parity where\n  degree Even = 0\n  degree Odd = 1\n  div x _ = x\n  mod _ _ = Even\n\ninstance divisionRingParity :: DivisionRing Parity where\n  recip = identity\n\n-- | Returns whether an `Int` is `Even` or `Odd`.\n-- |\n-- | ``` purescript\n-- | parity 0 == Even\n-- | parity 1 == Odd\n-- | ```\nparity :: Int -> Parity\nparity n = if even n then Even else Odd\n\n-- | Returns whether an `Int` is an even number.\n-- |\n-- | ``` purescript\n-- | even 0 == true\n-- | even 1 == false\n-- | ```\neven :: Int -> Boolean\neven x = x .&. 1 == 0\n\n-- | The negation of `even`.\n-- |\n-- | ``` purescript\n-- | odd 0 == false\n-- | odd 1 == true\n-- | ```\nodd :: Int -> Boolean\nodd x = x .&. 1 /= 0\n\n-- | The number of unique digits (including zero) used to represent integers in\n-- | a specific base.\nnewtype Radix = Radix Int\n\n-- | The base-2 system.\nbinary :: Radix\nbinary = Radix 2\n\n-- | The base-8 system.\noctal :: Radix\noctal = Radix 8\n\n-- | The base-10 system.\ndecimal :: Radix\ndecimal = Radix 10\n\n-- | The base-16 system.\nhexadecimal :: Radix\nhexadecimal = Radix 16\n\n-- | The base-36 system.\nbase36 :: Radix\nbase36 = Radix 36\n\n-- | Create a `Radix` from a number between 2 and 36.\nradix :: Int -> Maybe Radix\nradix n | n >= 2 && n <= 36 = Just (Radix n)\n        | otherwise         = Nothing\n\n-- | Like `fromString`, but the integer can be specified in a different base.\n-- |\n-- | Example:\n-- | ``` purs\n-- | fromStringAs binary      \"100\" == Just 4\n-- | fromStringAs hexadecimal \"ff\"  == Just 255\n-- | ```\nfromStringAs :: Radix -> String -> Maybe Int\nfromStringAs = fromStringAsImpl Just Nothing\n\n-- | The `quot` function provides _truncating_ integer division (see the\n-- | documentation for the `EuclideanRing` class). It is identical to `div` in\n-- | the `EuclideanRing Int` instance if the dividend is positive, but will be\n-- | slightly different if the dividend is negative. For example:\n-- |\n-- | ```purescript\n-- | div 2 3 == 0\n-- | quot 2 3 == 0\n-- |\n-- | div (-2) 3 == (-1)\n-- | quot (-2) 3 == 0\n-- |\n-- | div 2 (-3) == 0\n-- | quot 2 (-3) == 0\n-- | ```\nforeign import quot :: Int -> Int -> Int\n\n-- | The `rem` function provides the remainder after _truncating_ integer\n-- | division (see the documentation for the `EuclideanRing` class). It is\n-- | identical to `mod` in the `EuclideanRing Int` instance if the dividend is\n-- | positive, but will be slightly different if the dividend is negative. For\n-- | example:\n-- |\n-- | ```purescript\n-- | mod 2 3 == 2\n-- | rem 2 3 == 2\n-- |\n-- | mod (-2) 3 == 1\n-- | rem (-2) 3 == (-2)\n-- |\n-- | mod 2 (-3) == 2\n-- | rem 2 (-3) == 2\n-- | ```\nforeign import rem :: Int -> Int -> Int\n\n-- | Raise an Int to the power of another Int.\nforeign import pow :: Int -> Int -> Int\n\nforeign import fromStringAsImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Radix\n  -> String\n  -> Maybe Int\n\nforeign import toStringAs :: Radix -> Int -> String\n","module Data.List.Types\n  ( List(..)\n  , (:)\n  , NonEmptyList(..)\n  , toList\n  , nelCons\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, intercalate)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex, foldMapWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.NonEmpty as NE\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Traversable (class Traversable1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), snd)\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\ndata List a = Nil | Cons a (List a)\n\ninfixr 6 Cons as :\n\ninstance showList :: Show a => Show (List a) where\n  show Nil = \"Nil\"\n  show xs = \"(\" <> intercalate \" : \" (show <$> xs) <> \" : Nil)\"\n\ninstance eqList :: Eq a => Eq (List a) where\n  eq = eq1\n\ninstance eq1List :: Eq1 List where\n  eq1 xs ys = go xs ys true\n    where\n      go _ _ false = false\n      go Nil Nil acc = acc\n      go (x : xs') (y : ys') acc = go xs' ys' $ acc && (y == x)\n      go _ _ _ = false\n\ninstance ordList :: Ord a => Ord (List a) where\n  compare = compare1\n\ninstance ord1List :: Ord1 List where\n  compare1 xs ys = go xs ys\n    where\n    go Nil Nil = EQ\n    go Nil _ = LT\n    go _ Nil = GT\n    go (x : xs') (y : ys') =\n      case compare x y of\n        EQ -> go xs' ys'\n        other -> other\n\ninstance semigroupList :: Semigroup (List a) where\n  append xs ys = foldr (:) ys xs\n\ninstance monoidList :: Monoid (List a) where\n  mempty = Nil\n\ninstance functorList :: Functor List where\n  map = listMap\n\n-- chunked list Functor inspired by OCaml\n-- https://discuss.ocaml.org/t/a-new-list-map-that-is-both-stack-safe-and-fast/865\n-- chunk sizes determined through experimentation\nlistMap :: forall a b. (a -> b) -> List a -> List b\nlistMap f = chunkedRevMap Nil\n  where\n  chunkedRevMap :: List (List a) -> List a -> List b\n  chunkedRevMap chunksAcc chunk@(_ : _ : _ : xs) =\n    chunkedRevMap (chunk : chunksAcc) xs\n  chunkedRevMap chunksAcc xs =\n    reverseUnrolledMap chunksAcc $ unrolledMap xs\n    where\n    unrolledMap :: List a -> List b\n    unrolledMap (x1 : x2 : Nil) = f x1 : f x2 : Nil\n    unrolledMap (x1 : Nil) = f x1 : Nil\n    unrolledMap _ = Nil\n\n    reverseUnrolledMap :: List (List a) -> List b -> List b\n    reverseUnrolledMap ((x1 : x2 : x3 : _) : cs) acc =\n      reverseUnrolledMap cs (f x1 : f x2 : f x3 : acc)\n    reverseUnrolledMap _ acc = acc\n\ninstance functorWithIndexList :: FunctorWithIndex Int List where\n  mapWithIndex f = foldrWithIndex (\\i x acc -> f i x : acc) Nil\n\ninstance foldableList :: Foldable List where\n  foldr f b = foldl (flip f) b <<< rev\n    where\n    rev = go Nil\n      where\n      go acc Nil = acc\n      go acc (x : xs) = go (x : acc) xs\n  foldl f = go\n    where\n    go b = case _ of\n      Nil -> b\n      a : as -> go (f b a) as\n  foldMap f = foldl (\\acc -> append acc <<< f) mempty\n\ninstance foldableWithIndexList :: FoldableWithIndex Int List where\n  foldrWithIndex f b xs =\n    -- as we climb the reversed list, we decrement the index\n    snd $ foldl\n            (\\(Tuple i b') a -> Tuple (i - 1) (f (i - 1) a b'))\n            (Tuple len b)\n            revList\n    where\n    Tuple len revList = rev (Tuple 0 Nil) xs\n      where\n      -- As we create our reversed list, we count elements.\n      rev = foldl (\\(Tuple i acc) a -> Tuple (i + 1) (a : acc))\n  foldlWithIndex f acc =\n    snd <<< foldl (\\(Tuple i b) a -> Tuple (i + 1) (f i b a)) (Tuple 0 acc)\n  foldMapWithIndex f = foldlWithIndex (\\i acc -> append acc <<< f i) mempty\n\ninstance unfoldable1List :: Unfoldable1 List where\n  unfoldr1 f b = go b Nil\n    where\n    go source memo = case f source of\n      Tuple one (Just rest) -> go rest (one : memo)\n      Tuple one Nothing -> foldl (flip (:)) Nil (one : memo)\n\ninstance unfoldableList :: Unfoldable List where\n  unfoldr f b = go b Nil\n    where\n    go source memo = case f source of\n      Nothing -> (foldl (flip (:)) Nil memo)\n      Just (Tuple one rest) -> go rest (one : memo)\n\ninstance traversableList :: Traversable List where\n  traverse f = map (foldl (flip (:)) Nil) <<< foldl (\\acc -> lift2 (flip (:)) acc <<< f) (pure Nil)\n  sequence = traverse identity\n\ninstance traversableWithIndexList :: TraversableWithIndex Int List where\n  traverseWithIndex f =\n    map rev\n    <<< foldlWithIndex (\\i acc -> lift2 (flip (:)) acc <<< f i) (pure Nil)\n    where\n    rev = foldl (flip Cons) Nil\n\ninstance applyList :: Apply List where\n  apply Nil _ = Nil\n  apply (f : fs) xs = (f <$> xs) <> (fs <*> xs)\n\ninstance applicativeList :: Applicative List where\n  pure a = a : Nil\n\ninstance bindList :: Bind List where\n  bind Nil _ = Nil\n  bind (x : xs) f = f x <> bind xs f\n\ninstance monadList :: Monad List\n\ninstance altList :: Alt List where\n  alt = append\n\ninstance plusList :: Plus List where\n  empty = Nil\n\ninstance alternativeList :: Alternative List\n\ninstance monadPlusList :: MonadPlus List\n\ninstance extendList :: Extend List where\n  extend _ Nil = Nil\n  extend f l@(_ : as) =\n    f l : (foldr go { val: Nil, acc: Nil } as).val\n    where\n    go a' { val, acc } =\n      let acc' = a' : acc\n      in { val: f acc' : val, acc: acc' }\n\nnewtype NonEmptyList a = NonEmptyList (NonEmpty List a)\n\ntoList :: NonEmptyList ~> List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nnelCons :: forall a. a -> NonEmptyList a -> NonEmptyList a\nnelCons a (NonEmptyList (b :| bs)) = NonEmptyList (a :| b : bs)\n\nderive instance newtypeNonEmptyList :: Newtype (NonEmptyList a) _\n\nderive newtype instance eqNonEmptyList :: Eq a => Eq (NonEmptyList a)\nderive newtype instance ordNonEmptyList :: Ord a => Ord (NonEmptyList a)\n\nderive newtype instance eq1NonEmptyList :: Eq1 NonEmptyList\nderive newtype instance ord1NonEmptyList :: Ord1 NonEmptyList\n\ninstance showNonEmptyList :: Show a => Show (NonEmptyList a) where\n  show (NonEmptyList nel) = \"(NonEmptyList \" <> show nel <> \")\"\n\nderive newtype instance functorNonEmptyList :: Functor NonEmptyList\n\ninstance applyNonEmptyList :: Apply NonEmptyList where\n  apply (NonEmptyList (f :| fs)) (NonEmptyList (a :| as)) =\n    NonEmptyList (f a :| (fs <*> a : Nil) <> ((f : fs) <*> as))\n\ninstance applicativeNonEmptyList :: Applicative NonEmptyList where\n  pure = NonEmptyList <<< NE.singleton\n\ninstance bindNonEmptyList :: Bind NonEmptyList where\n  bind (NonEmptyList (a :| as)) f =\n    case f a of\n      NonEmptyList (b :| bs) ->\n        NonEmptyList (b :| bs <> bind as (toList <<< f))\n\ninstance monadNonEmptyList :: Monad NonEmptyList\n\ninstance altNonEmptyList :: Alt NonEmptyList where\n  alt = append\n\ninstance extendNonEmptyList :: Extend NonEmptyList where\n  extend f w@(NonEmptyList (_ :| as)) =\n    NonEmptyList (f w :| (foldr go { val: Nil, acc: Nil } as).val)\n    where\n    go a { val, acc } = { val: f (NonEmptyList (a :| acc)) : val, acc: a : acc }\n\ninstance comonadNonEmptyList :: Comonad NonEmptyList where\n  extract (NonEmptyList (a :| _)) = a\n\ninstance semigroupNonEmptyList :: Semigroup (NonEmptyList a) where\n  append (NonEmptyList (a :| as)) as' =\n    NonEmptyList (a :| as <> toList as')\n\nderive newtype instance foldableNonEmptyList :: Foldable NonEmptyList\n\nderive newtype instance traversableNonEmptyList :: Traversable NonEmptyList\n\nderive newtype instance foldable1NonEmptyList :: Foldable1 NonEmptyList\n\nderive newtype instance unfoldable1NonEmptyList :: Unfoldable1 NonEmptyList\n\ninstance functorWithIndexNonEmptyList :: FunctorWithIndex Int NonEmptyList where\n  mapWithIndex fn (NonEmptyList ne) = NonEmptyList $ mapWithIndex (fn <<< maybe 0 (add 1)) ne\n\ninstance foldableWithIndexNonEmptyList :: FoldableWithIndex Int NonEmptyList where\n  foldMapWithIndex f (NonEmptyList ne) = foldMapWithIndex (f <<< maybe 0 (add 1)) ne\n  foldlWithIndex f b (NonEmptyList ne) = foldlWithIndex (f <<< maybe 0 (add 1)) b ne\n  foldrWithIndex f b (NonEmptyList ne) = foldrWithIndex (f <<< maybe 0 (add 1)) b ne\n\ninstance traversableWithIndexNonEmptyList :: TraversableWithIndex Int NonEmptyList where\n  traverseWithIndex f (NonEmptyList ne) = NonEmptyList <$> traverseWithIndex (f <<< maybe 0 (add 1)) ne\n\ninstance traversable1NonEmptyList :: Traversable1 NonEmptyList where\n  traverse1 f (NonEmptyList (a :| as)) =\n    foldl (\\acc -> lift2 (flip nelCons) acc <<< f) (pure <$> f a) as\n      <#> case _ of NonEmptyList (x :| xs) → foldl (flip nelCons) (pure x) xs\n  sequence1 = traverse1 identity\n","-- | This module defines a type of _strict_ linked lists, and associated helper\n-- | functions and type class instances.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is an improvement over `Data.Array` when working with\n-- | immutable lists of data in a purely-functional setting, but does not have\n-- | good random-access performance.\n\nmodule Data.List\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n\n  , singleton\n  , (..), range\n  , some\n  , someRec\n  , many\n  , manyRec\n\n  , null\n  , length\n\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , modifyAt\n  , alterAt\n\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n\n  , sort\n  , sortBy\n\n  , Pattern(..)\n  , stripPrefix\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n  , (\\\\), difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , transpose\n\n  , foldM\n\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM, tailRecM2)\nimport Data.Bifunctor (bimap)\nimport Data.Foldable (class Foldable, foldr, any, foldl)\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.List.Internal (emptySet, insertAndLookupBy)\nimport Data.List.Types (List(..), (:))\nimport Data.List.Types (NonEmptyList(..)) as NEL\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty ((:|))\nimport Data.Traversable (scanl, scanr) as Exports\nimport Data.Traversable (sequence)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, unfoldr)\n\n-- | Convert a list into any unfoldable structure.\n-- |\n-- | Running time: `O(n)`\ntoUnfoldable :: forall f. Unfoldable f => List ~> f\ntoUnfoldable = unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> uncons xs)\n\n-- | Construct a list from a foldable structure.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> List\nfromFoldable = foldr Cons Nil\n\n--------------------------------------------------------------------------------\n-- List creation ---------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Create a list with a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> List a\nsingleton a = a : Nil\n\n-- | An infix synonym for `range`.\ninfix 8 range as ..\n\n-- | Create a list containing a range of integers, including both endpoints.\nrange :: Int -> Int -> List Int\nrange start end | start == end = singleton start\n                | otherwise = go end start (if start > end then 1 else -1) Nil\n  where\n  go s e step rest | s == e = s : rest\n                   | otherwise = go (s + step) e step (s : rest)\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nsome v = Cons <$> v <*> defer (\\_ -> many v)\n\n-- | A stack-safe version of `some`, at the cost of a `MonadRec` constraint.\nsomeRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nsomeRec v = Cons <$> v <*> manyRec v\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nmany v = some v <|> pure Nil\n\n-- | A stack-safe version of `many`, at the cost of a `MonadRec` constraint.\nmanyRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nmanyRec p = tailRecM go Nil\n  where\n  go :: List a -> f (Step (List a) (List a))\n  go acc = do\n    aa <- (Loop <$> p) <|> pure (Done unit)\n    pure $ bimap (_ : acc) (\\_ -> reverse acc) aa\n\n--------------------------------------------------------------------------------\n-- List size -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether a list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. List a -> Boolean\nnull Nil = true\nnull _ = false\n\n-- | Get the length of a list\n-- |\n-- | Running time: `O(n)`\nlength :: forall a. List a -> Int\nlength = foldl (\\acc _ -> acc + 1) 0\n\n--------------------------------------------------------------------------------\n-- Extending lists -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Append an element to the end of a list, creating a new list.\n-- |\n-- | Running time: `O(n)`\nsnoc :: forall a. List a -> a -> List a\nsnoc xs x = foldr (:) (x : Nil) xs\n\n-- | Insert an element into a sorted list.\n-- |\n-- | Running time: `O(n)`\ninsert :: forall a. Ord a => a -> List a -> List a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted list, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | Running time: `O(n)`\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> List a -> List a\ninsertBy _ x Nil = singleton x\ninsertBy cmp x ys@(y : ys') =\n  case cmp x y of\n    GT -> y : (insertBy cmp x ys')\n    _  -> x : ys\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`.\nhead :: List ~> Maybe\nhead Nil = Nothing\nhead (x : _) = Just x\n\n-- | Get the last element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`.\nlast :: List ~> Maybe\nlast (x : Nil) = Just x\nlast (_ : xs)  = last xs\nlast _         = Nothing\n\n-- | Get all but the first element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\ntail :: forall a. List a -> Maybe (List a)\ntail Nil = Nothing\ntail (_ : xs) = Just xs\n\n-- | Get all but the last element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\ninit :: forall a. List a -> Maybe (List a)\ninit lst = _.init <$> unsnoc lst\n\n-- | Break a list into its first element, and the remaining elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\nuncons :: forall a. List a -> Maybe { head :: a, tail :: List a }\nuncons Nil = Nothing\nuncons (x : xs) = Just { head: x, tail: xs }\n\n-- | Break a list into its last element, and the preceding elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\nunsnoc :: forall a. List a -> Maybe { init :: List a, last :: a }\nunsnoc lst = (\\h -> { init: reverse h.revInit, last: h.last }) <$> go lst Nil\n  where\n  go Nil _ = Nothing\n  go (x : Nil) acc = Just { revInit: acc, last: x }\n  go (x : xs) acc = go xs (x : acc)\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the element at the specified index, or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)` where `n` is the required index.\nindex :: forall a. List a -> Int -> Maybe a\nindex Nil _ = Nothing\nindex (a : _) 0 = Just a\nindex (_ : as) i = index as (i - 1)\n\n-- | An infix synonym for `index`.\ninfixl 8 index as !!\n\n-- | Find the index of the first element equal to the specified element.\nelemIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\nelemLastIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first index for which a predicate holds.\nfindIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindIndex fn = go 0\n  where\n  go :: Int -> List a -> Maybe Int\n  go n (x : xs) | fn x = Just n\n                | otherwise = go (n + 1) xs\n  go _ Nil = Nothing\n\n-- | Find the last index for which a predicate holds.\nfindLastIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindLastIndex fn xs = ((length xs - 1) - _) <$> findIndex fn (reverse xs)\n\n-- | Insert an element into a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ninsertAt :: forall a. Int -> a -> List a -> Maybe (List a)\ninsertAt 0 x xs = Just (x : xs)\ninsertAt n x (y : ys) = (y : _) <$> insertAt (n - 1) x ys\ninsertAt _ _ _  = Nothing\n\n-- | Delete an element from a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ndeleteAt :: forall a. Int -> List a -> Maybe (List a)\ndeleteAt 0 (_ : ys) = Just ys\ndeleteAt n (y : ys) = (y : _) <$> deleteAt (n - 1) ys\ndeleteAt _ _  = Nothing\n\n-- | Update the element at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nupdateAt :: forall a. Int -> a -> List a -> Maybe (List a)\nupdateAt 0 x ( _ : xs) = Just (x : xs)\nupdateAt n x (x1 : xs) = (x1 : _) <$> updateAt (n - 1) x xs\nupdateAt _ _ _ = Nothing\n\n-- | Update the element at the specified index by applying a function to\n-- | the current value, returning a new list or `Nothing` if the index is\n-- | out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nmodifyAt :: forall a. Int -> (a -> a) -> List a -> Maybe (List a)\nmodifyAt n f = alterAt n (Just <<< f)\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new list or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nalterAt :: forall a. Int -> (a -> Maybe a) -> List a -> Maybe (List a)\nalterAt 0 f (y : ys) = Just $\n  case f y of\n    Nothing -> ys\n    Just y' -> y' : ys\nalterAt n f (y : ys) = (y : _) <$> alterAt (n - 1) f ys\nalterAt _ _ _  = Nothing\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Reverse a list.\n-- |\n-- | Running time: `O(n)`\nreverse :: List ~> List\nreverse = go Nil\n  where\n  go acc Nil = acc\n  go acc (x : xs) = go (x : acc) xs\n\n-- | Flatten a list of lists.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcat :: forall a. List (List a) -> List a\nconcat = (_ >>= identity)\n\n-- | Apply a function to each element in a list, and flatten the results\n-- | into a single, new list.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcatMap :: forall a b. (a -> List b) -> List a -> List b\nconcatMap = flip bind\n\n-- | Filter a list, keeping the elements which satisfy a predicate function.\n-- |\n-- | Running time: `O(n)`\nfilter :: forall a. (a -> Boolean) -> List a -> List a\nfilter p = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs)\n    | p x = go (x : acc) xs\n    | otherwise = go acc xs\n\n-- | Filter where the predicate returns a monadic `Boolean`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. [a] -> [[a]]\n-- | powerSet = filterM (const [true, false])\n-- | ```\nfilterM :: forall a m. Monad m => (a -> m Boolean) -> List a -> m (List a)\nfilterM _ Nil = pure Nil\nfilterM p (x : xs) = do\n  b <- p x\n  xs' <- filterM p xs\n  pure if b then x : xs' else xs'\n\n-- | Apply a function to each element in a list, keeping only the results which\n-- | contain a value.\n-- |\n-- | Running time: `O(n)`\nmapMaybe :: forall a b. (a -> Maybe b) -> List a -> List b\nmapMaybe f = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs) =\n    case f x of\n      Nothing -> go acc xs\n      Just y -> go (y : acc) xs\n\n-- | Filter a list of optional values, keeping only the elements which contain\n-- | a value.\ncatMaybes :: forall a. List (Maybe a) -> List a\ncatMaybes = mapMaybe identity\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an list in increasing order.\nsort :: forall a. Ord a => List a -> List a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of a list in increasing order, where elements are\n-- | compared using the specified ordering.\nsortBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nsortBy cmp = mergeAll <<< sequences\n  -- implementation lifted from http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#sort\n  where\n  sequences :: List a -> List (List a)\n  sequences (a : b : xs)\n    | a `cmp` b == GT = descending b (singleton a) xs\n    | otherwise = ascending b (a : _) xs\n  sequences xs = singleton xs\n\n  descending :: a -> List a -> List a -> List (List a)\n  descending a as (b : bs)\n    | a `cmp` b == GT = descending b (a : as) bs\n  descending a as bs = (a : as) : sequences bs\n\n  ascending :: a -> (List a -> List a) -> List a -> List (List a)\n  ascending a as (b : bs)\n    | a `cmp` b /= GT = ascending b (\\ys -> as (a : ys)) bs\n  ascending a as bs = ((as $ singleton a) : sequences bs)\n\n  mergeAll :: List (List a) -> List a\n  mergeAll (x : Nil) = x\n  mergeAll xs = mergeAll (mergePairs xs)\n\n  mergePairs :: List (List a) -> List (List a)\n  mergePairs (a : b : xs) = merge a b : mergePairs xs\n  mergePairs xs = xs\n\n  merge :: List a -> List a -> List a\n  merge as@(a : as') bs@(b : bs')\n    | a `cmp` b == GT = b : merge as bs'\n    | otherwise       = a : merge as' bs\n  merge Nil bs = bs\n  merge as Nil = as\n\n--------------------------------------------------------------------------------\n-- Sublists --------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | A newtype used in cases where there is a list to be matched.\nnewtype Pattern a = Pattern (List a)\n\nderive instance eqPattern :: Eq a => Eq (Pattern a)\nderive instance ordPattern :: Ord a => Ord (Pattern a)\nderive instance newtypePattern :: Newtype (Pattern a) _\n\ninstance showPattern :: Show a => Show (Pattern a) where\n  show (Pattern s) = \"(Pattern \" <> show s <> \")\"\n\n\n-- | If the list starts with the given prefix, return the portion of the\n-- | list left after removing it, as a Just value. Otherwise, return Nothing.\n-- | * `stripPrefix (Pattern (1:Nil)) (1:2:Nil) == Just (2:Nil)`\n-- | * `stripPrefix (Pattern Nil) (1:Nil) == Just (1:Nil)`\n-- | * `stripPrefix (Pattern (2:Nil)) (1:Nil) == Nothing`\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to strip.\nstripPrefix :: forall a. Eq a => Pattern a -> List a -> Maybe (List a)\nstripPrefix (Pattern p') s = tailRecM2 go p' s\n  where\n  go prefix input = case prefix, input of\n    Cons p ps, Cons i is | p == i -> Just $ Loop { a: ps, b: is }\n    Nil, is -> Just $ Done is\n    _, _ -> Nothing\n\n-- | Extract a sublist by a start and end index.\nslice :: Int -> Int -> List ~> List\nslice start end xs = take (end - start) (drop start xs)\n\n-- | Take the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to take.\ntake :: forall a. Int -> List a -> List a\ntake = go Nil\n  where\n  go acc n _ | n < 1 = reverse acc\n  go acc _ Nil = reverse acc\n  go acc n (x : xs) = go (x : acc) (n - 1) xs\n\n-- | Take the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to take.\ntakeEnd :: forall a. Int -> List a -> List a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Take those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ntakeWhile :: forall a. (a -> Boolean) -> List a -> List a\ntakeWhile p = go Nil\n  where\n  go acc (x : xs) | p x = go (x : acc) xs\n  go acc _ = reverse acc\n\n-- | Drop the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to drop.\ndrop :: forall a. Int -> List a -> List a\ndrop n xs | n < 1 = xs\ndrop _ Nil = Nil\ndrop n (_ : xs) = drop (n - 1) xs\n\n-- | Drop the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to drop.\ndropEnd :: forall a. Int -> List a -> List a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Drop those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ndropWhile :: forall a. (a -> Boolean) -> List a -> List a\ndropWhile p = go\n  where\n  go (x : xs) | p x = go xs\n  go xs = xs\n\n-- | Split a list into two parts:\n-- |\n-- | 1. the longest initial segment for which all elements satisfy the specified predicate\n-- | 2. the remaining elements\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) (1 : 3 : 2 : 4 : 5 : Nil) == { init: (1 : 3 : Nil), rest: (2 : 4 : 5 : Nil) }\n-- | ```\n-- |\n-- | Running time: `O(n)`\nspan :: forall a. (a -> Boolean) -> List a -> { init :: List a, rest :: List a }\nspan p (x : xs') | p x = case span p xs' of\n  { init: ys, rest: zs } -> { init: x : ys, rest: zs }\nspan _ xs = { init: Nil, rest: xs }\n\n-- | Group equal, consecutive elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | group (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : (NonEmptyList (NonEmpty 1 Nil)) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroup :: forall a. Eq a => List a -> List (NEL.NonEmptyList a)\ngroup = groupBy (==)\n\n-- | Group equal elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupAll (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : 1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : Nil\n-- | ```\ngroupAll :: forall a. Ord a => List a -> List (NEL.NonEmptyList a)\ngroupAll = group <<< sort\n\n-- | Group equal, consecutive elements of a list into lists, using the specified\n-- | equivalence relation to determine equality.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) (1 : 3 : 2 : 4 : 3 : 3 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (3 : Nil))) : (NonEmptyList (NonEmpty 2 Nil)) : (NonEmptyList (NonEmpty 4 Nil)) : (NonEmptyList (NonEmpty 3 (3 : Nil))) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroupBy :: forall a. (a -> a -> Boolean) -> List a -> List (NEL.NonEmptyList a)\ngroupBy _ Nil = Nil\ngroupBy eq (x : xs) = case span (eq x) xs of\n  { init: ys, rest: zs } -> NEL.NonEmptyList (x :| ys) : groupBy eq zs\n\n-- | Sort, then group equal elements of a list into lists, using the provided comparison function.\n-- |\n-- | ```purescript\n-- | groupAllBy (compare `on` (_ `div` 10)) (32 : 31 : 21 : 22 : 11 : 33 : Nil) ==\n-- |   NonEmptyList (11 :| Nil) : NonEmptyList (21 :| 22 : Nil) : NonEmptyList (32 :| 31 : 33) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\ngroupAllBy :: forall a. (a -> a -> Ordering) -> List a -> List (NEL.NonEmptyList a)\ngroupAllBy p = groupBy (\\x y -> p x y == EQ) <<< sortBy p\n\n-- | Returns a lists of elements which do and do not satisfy a predicate.\n-- |\n-- | Running time: `O(n)`\npartition :: forall a. (a -> Boolean) -> List a -> { yes :: List a, no :: List a }\npartition p xs = foldr select { no: Nil, yes: Nil } xs\n  where\n    select x { no, yes } = if p x\n                           then { no, yes: x : yes }\n                           else { no: x : no, yes }\n\n-- | Returns all final segments of the argument, longest first. For example,\n-- |\n-- | ```purescript\n-- | tails (1 : 2 : 3 : Nil) == ((1 : 2 : 3 : Nil) : (2 : 3 : Nil) : (3 : Nil) : (Nil) : Nil)\n-- | ```\n-- | Running time: `O(n)`\ntails :: forall a. List a -> List (List a)\ntails Nil = singleton Nil\ntails list@(Cons _ tl)= list : tails tl\n\n--------------------------------------------------------------------------------\n-- Set-like operations ---------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nub 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnub :: forall a. Ord a => List a -> List a\nnub = nubBy compare\n\n-- | Remove duplicate elements from a list based on the provided comparison function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nubBy (compare `on` Array.length) ([1]:[2]:[3,4]:Nil) == [1]:[3,4]:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnubBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nnubBy p = reverse <<< go emptySet Nil\n  where\n    go _ acc Nil = acc\n    go s acc (a : as) =\n      let { found, result: s' } = insertAndLookupBy p a s\n      in if found\n        then go s' acc as\n        else go s' (a : acc) as\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubEq :: forall a. Eq a => List a -> List a\nnubEq = nubByEq eq\n\n-- | Remove duplicate elements from a list, using the provided equivalence function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | function, rather than an ordering function.\n-- |\n-- | ```purescript\n-- | mod3eq = eq `on` \\n -> mod n 3\n-- | nubByEq mod3eq 1:3:4:5:6:Nil == 1:3:5:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubByEq :: forall a. (a -> a -> Boolean) -> List a -> List a\nnubByEq _     Nil = Nil\nnubByEq eq' (x : xs) = x : nubByEq eq' (filter (\\y -> not (eq' x y)) xs)\n\n-- | Calculate the union of two lists.\n-- |\n-- | Running time: `O(n^2)`\nunion :: forall a. Eq a => List a -> List a -> List a\nunion = unionBy (==)\n\n-- | Calculate the union of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nunionBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first occurrence of an element from a list.\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> List a -> List a\ndelete = deleteBy (==)\n\n-- | Delete the first occurrence of an element from a list, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n)`\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> List a -> List a\ndeleteBy _ _ Nil = Nil\ndeleteBy eq' x (y : ys) | eq' x y = ys\ndeleteBy eq' x (y : ys) = y : deleteBy eq' x ys\n\ninfix 5 difference as \\\\\n\n-- | Delete the first occurrence of each element in the second list from the first list.\n-- |\n-- | Running time: `O(n^2)`\ndifference :: forall a. Eq a => List a -> List a -> List a\ndifference = foldl (flip delete)\n\n-- | Calculate the intersection of two lists.\n-- |\n-- | Running time: `O(n^2)`\nintersect :: forall a. Eq a => List a -> List a -> List a\nintersect = intersectBy (==)\n\n-- | Calculate the intersection of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nintersectBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nintersectBy _  Nil _   = Nil\nintersectBy _  _   Nil = Nil\nintersectBy eq xs  ys  = filter (\\x -> any (eq x) ys) xs\n\n--------------------------------------------------------------------------------\n-- Zipping ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Apply a function to pairs of elements at the same positions in two lists,\n-- | collecting the results in a new list.\n-- |\n-- | If one list is longer, elements will be discarded from the longer list.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) (1 : 2 : 3 : Nil) (4 : 5 : 6 : 7 Nil) == 4 : 10 : 18 : Nil\n-- | ```\n-- |\n-- | Running time: `O(min(m, n))`\nzipWith :: forall a b c. (a -> b -> c) -> List a -> List b -> List c\nzipWith f xs ys = reverse $ go xs ys Nil\n  where\n  go Nil _ acc = acc\n  go _ Nil acc = acc\n  go (a : as) (b : bs) acc = go as bs $ f a b : acc\n\n-- | A generalization of `zipWith` which accumulates results in some `Applicative`\n-- | functor.\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> List a -> List b -> m (List c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Collect pairs of elements at the same positions in two lists.\n-- |\n-- | Running time: `O(min(m, n))`\nzip :: forall a b. List a -> List b -> List (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms a list of pairs into a list of first components and a list of\n-- | second components.\nunzip :: forall a b. List (Tuple a b) -> Tuple (List a) (List b)\nunzip = foldr (\\(Tuple a b) (Tuple as bs) -> Tuple (a : as) (b : bs)) (Tuple Nil Nil)\n\n--------------------------------------------------------------------------------\n-- Transpose -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- |     transpose ((1:2:3:Nil) : (4:5:6:Nil) : Nil) ==\n-- |       ((1:4:Nil) : (2:5:Nil) : (3:6:Nil) : Nil)\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- |     transpose ((10:11:Nil) : (20:Nil) : Nil : (30:31:32:Nil) : Nil) ==\n-- |       ((10:20:30:Nil) : (11:31:Nil) : (32:Nil) : Nil)\ntranspose :: forall a. List (List a) -> List (List a)\ntranspose Nil = Nil\ntranspose (Nil : xss) = transpose xss\ntranspose ((x : xs) : xss) =\n  (x : mapMaybe head xss) : transpose (xs : mapMaybe tail xss)\n\n--------------------------------------------------------------------------------\n-- Folding ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Perform a fold using a monadic step function.\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> List a -> m b\nfoldM _ b Nil = pure b\nfoldM f b (a : as) = f b a >>= \\b' -> foldM f b' as\n","/* global Symbol */\n\nvar hasArrayFrom = typeof Array.from === \"function\";\nvar hasStringIterator =\n  typeof Symbol !== \"undefined\" &&\n  Symbol != null &&\n  typeof Symbol.iterator !== \"undefined\" &&\n  typeof String.prototype[Symbol.iterator] === \"function\";\nvar hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\nvar hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\nexport const _unsafeCodePointAt0 = function (fallback) {\n  return hasCodePointAt\n    ? function (str) { return str.codePointAt(0); }\n    : fallback;\n};\n\nexport const _codePointAt = function (fallback) {\n  return function (Just) {\n    return function (Nothing) {\n      return function (unsafeCodePointAt0) {\n        return function (index) {\n          return function (str) {\n            var length = str.length;\n            if (index < 0 || index >= length) return Nothing;\n            if (hasStringIterator) {\n              var iter = str[Symbol.iterator]();\n              for (var i = index;; --i) {\n                var o = iter.next();\n                if (o.done) return Nothing;\n                if (i === 0) return Just(unsafeCodePointAt0(o.value));\n              }\n            }\n            return fallback(index)(str);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const _countPrefix = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasStringIterator) {\n      return function (pred) {\n        return function (str) {\n          var iter = str[Symbol.iterator]();\n          for (var cpCount = 0; ; ++cpCount) {\n            var o = iter.next();\n            if (o.done) return cpCount;\n            var cp = unsafeCodePointAt0(o.value);\n            if (!pred(cp)) return cpCount;\n          }\n        };\n      };\n    }\n    return fallback;\n  };\n};\n\nexport const _fromCodePointArray = function (singleton) {\n  return hasFromCodePoint\n    ? function (cps) {\n      // Function.prototype.apply will fail for very large second parameters,\n      // so we don't use it for arrays with 10,000 or more entries.\n      if (cps.length < 10e3) {\n        return String.fromCodePoint.apply(String, cps);\n      }\n      return cps.map(singleton).join(\"\");\n    }\n    : function (cps) {\n      return cps.map(singleton).join(\"\");\n    };\n};\n\nexport const _singleton = function (fallback) {\n  return hasFromCodePoint ? String.fromCodePoint : fallback;\n};\n\nexport const _take = function (fallback) {\n  return function (n) {\n    if (hasStringIterator) {\n      return function (str) {\n        var accum = \"\";\n        var iter = str[Symbol.iterator]();\n        for (var i = 0; i < n; ++i) {\n          var o = iter.next();\n          if (o.done) return accum;\n          accum += o.value;\n        }\n        return accum;\n      };\n    }\n    return fallback(n);\n  };\n};\n\nexport const _toCodePointArray = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasArrayFrom) {\n      return function (str) {\n        return Array.from(str, unsafeCodePointAt0);\n      };\n    }\n    return fallback;\n  };\n};\n","module Data.Argonaut.Decode.Decoders where\n\nimport Prelude\n\nimport Data.Argonaut.Core (Json, caseJsonBoolean, caseJsonNull, caseJsonNumber, caseJsonString, isNull, toArray, toObject, toString, fromString)\nimport Data.Argonaut.Decode.Error (JsonDecodeError(..))\nimport Data.Array as Arr\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Array.NonEmpty as NEA\nimport Data.Bifunctor (lmap)\nimport Data.Either (Either(..), note)\nimport Data.Identity (Identity(..))\nimport Data.Int (fromNumber)\nimport Data.List (List, fromFoldable)\nimport Data.List as L\nimport Data.List.NonEmpty (NonEmptyList)\nimport Data.List.NonEmpty as NEL\nimport Data.String.NonEmpty (NonEmptyString)\nimport Data.String.NonEmpty as NonEmptyString\nimport Data.Map as M\nimport Data.Maybe (maybe, Maybe(..))\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.Set as S\nimport Data.String (CodePoint, codePointAt)\nimport Data.Traversable (traverse)\nimport Data.TraversableWithIndex (traverseWithIndex)\nimport Data.Tuple (Tuple(..))\nimport Foreign.Object as FO\n\ndecodeIdentity\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (Identity a)\ndecodeIdentity decoder json = Identity <$> decoder json\n\ndecodeMaybe\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (Maybe a)\ndecodeMaybe decoder json\n  | isNull json = pure Nothing\n  | otherwise = Just <$> decoder json\n\ndecodeTuple\n  :: forall a b\n   . (Json -> Either JsonDecodeError a)\n  -> (Json -> Either JsonDecodeError b)\n  -> Json\n  -> Either JsonDecodeError (Tuple a b)\ndecodeTuple decoderA decoderB json = decodeArray Right json >>= f\n  where\n  f :: Array Json -> Either JsonDecodeError (Tuple a b)\n  f = case _ of\n    [ a, b ] -> Tuple <$> decoderA a <*> decoderB b\n    _ -> Left $ TypeMismatch \"Tuple\"\n\ndecodeEither\n  :: forall a b\n   . (Json -> Either JsonDecodeError a)\n  -> (Json -> Either JsonDecodeError b)\n  -> Json\n  -> Either JsonDecodeError (Either a b)\ndecodeEither decoderA decoderB json =\n  lmap (Named \"Either\") $ decodeJObject json >>= \\obj -> do\n    tag <- note (AtKey \"tag\" MissingValue) $ FO.lookup \"tag\" obj\n    val <- note (AtKey \"value\" MissingValue) $ FO.lookup \"value\" obj\n    case toString tag of\n      Just \"Right\" -> Right <$> decoderB val\n      Just \"Left\" -> Left <$> decoderA val\n      _ -> Left $ AtKey \"tag\" (UnexpectedValue tag)\n\ndecodeNull :: Json -> Either JsonDecodeError Unit\ndecodeNull = caseJsonNull (Left $ TypeMismatch \"null\") (const $ Right unit)\n\ndecodeBoolean :: Json -> Either JsonDecodeError Boolean\ndecodeBoolean = caseJsonBoolean (Left $ TypeMismatch \"Boolean\") Right\n\ndecodeNumber :: Json -> Either JsonDecodeError Number\ndecodeNumber = caseJsonNumber (Left $ TypeMismatch \"Number\") Right\n\ndecodeInt :: Json -> Either JsonDecodeError Int\ndecodeInt = note (TypeMismatch \"Integer\") <<< fromNumber <=< decodeNumber\n\ndecodeString :: Json -> Either JsonDecodeError String\ndecodeString = caseJsonString (Left $ TypeMismatch \"String\") Right\n\ndecodeNonEmptyString :: Json -> Either JsonDecodeError NonEmptyString\ndecodeNonEmptyString json =\n  note (Named \"NonEmptyString\" $ UnexpectedValue json)\n    =<< map (NonEmptyString.fromString) (decodeString json)\n\ndecodeNonEmpty_Array\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (NonEmpty Array a)\ndecodeNonEmpty_Array decoder =\n  lmap (Named \"NonEmpty Array\")\n    <<< traverse decoder\n    <=< map (\\x -> x.head :| x.tail)\n      <<< note (TypeMismatch \"NonEmpty Array\")\n      <<< Arr.uncons\n    <=< decodeJArray\n\ndecodeNonEmptyArray\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (NonEmptyArray a)\ndecodeNonEmptyArray decoder =\n  lmap (Named \"NonEmptyArray\")\n    <<< traverse decoder\n    <=< map (\\x -> NEA.cons' x.head x.tail)\n      <<< note (TypeMismatch \"NonEmptyArray\")\n      <<< Arr.uncons\n    <=< decodeJArray\n\ndecodeNonEmpty_List\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (NonEmpty List a)\ndecodeNonEmpty_List decoder =\n  lmap (Named \"NonEmpty List\")\n    <<< traverse decoder\n    <=< map (\\x -> x.head :| x.tail)\n      <<< note (TypeMismatch \"NonEmpty List\")\n      <<< L.uncons\n    <=< map (map fromFoldable) decodeJArray\n\ndecodeNonEmptyList\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (NonEmptyList a)\ndecodeNonEmptyList decoder =\n  lmap (Named \"NonEmptyList\")\n    <<< traverse decoder\n    <=< map (\\x -> NEL.cons' x.head x.tail)\n      <<< note (TypeMismatch \"NonEmptyList\")\n      <<< L.uncons\n    <=< map (map fromFoldable) decodeJArray\n\ndecodeCodePoint :: Json -> Either JsonDecodeError CodePoint\ndecodeCodePoint json =\n  note (Named \"CodePoint\" $ UnexpectedValue json)\n    =<< map (codePointAt 0) (decodeString json)\n\ndecodeForeignObject\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (FO.Object a)\ndecodeForeignObject decoder =\n  lmap (Named \"ForeignObject\")\n    <<< traverse decoder\n    <=< decodeJObject\n\ndecodeArray\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (Array a)\ndecodeArray decoder =\n  lmap (Named \"Array\")\n    <<< traverseWithIndex (\\i -> lmap (AtIndex i) <<< decoder)\n    <=< decodeJArray\n\ndecodeList\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (List a)\ndecodeList decoder =\n  lmap (Named \"List\")\n    <<< traverse decoder\n    <=< map (map fromFoldable) decodeJArray\n\ndecodeSet\n  :: forall a\n   . Ord a\n  => (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (S.Set a)\ndecodeSet decoder =\n  map (S.fromFoldable :: List a -> S.Set a) <<< decodeList decoder\n\ndecodeMap\n  :: forall a b\n   . Ord a\n  => (Json -> Either JsonDecodeError a)\n  -> (Json -> Either JsonDecodeError b)\n  -> Json\n  -> Either JsonDecodeError (M.Map a b)\ndecodeMap decoderA decoderB =\n  map (M.fromFoldable :: List (Tuple a b) -> M.Map a b)\n    <<< decodeList (decodeTuple decoderA decoderB)\n\ndecodeVoid :: Json -> Either JsonDecodeError Void\ndecodeVoid _ = Left $ UnexpectedValue $ fromString \"Value cannot be Void\"\n\ndecodeJArray :: Json -> Either JsonDecodeError (Array Json)\ndecodeJArray = note (TypeMismatch \"Array\") <<< toArray\n\ndecodeJObject :: Json -> Either JsonDecodeError (FO.Object Json)\ndecodeJObject = note (TypeMismatch \"Object\") <<< toObject\n\ngetField\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> FO.Object Json\n  -> String\n  -> Either JsonDecodeError a\ngetField decoder obj str =\n  maybe\n    (Left $ AtKey str MissingValue)\n    (lmap (AtKey str) <<< decoder)\n    (FO.lookup str obj)\n\ngetFieldOptional\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> FO.Object Json\n  -> String\n  -> Either JsonDecodeError (Maybe a)\ngetFieldOptional decoder obj str =\n  maybe (pure Nothing) (map Just <<< decode) (FO.lookup str obj)\n  where\n  decode = lmap (AtKey str) <<< decoder\n\ngetFieldOptional'\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> FO.Object Json\n  -> String\n  -> Either JsonDecodeError (Maybe a)\ngetFieldOptional' decoder obj str =\n  maybe (pure Nothing) decode (FO.lookup str obj)\n  where\n  decode json =\n    if isNull json then\n      pure Nothing\n    else\n      Just <$> (lmap (AtKey str) <<< decoder) json\n","module Record\n  ( get\n  , set\n  , modify\n  , insert\n  , delete\n  , rename\n  , equal\n  , merge\n  , union\n  , disjointUnion\n  , nub\n  , class EqualFields\n  , equalFields\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried (runFn2)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Prim.Row (class Lacks, class Cons, class Nub, class Union)\nimport Prim.RowList (class RowToList, RowList, Cons, Nil)\nimport Record.Unsafe (unsafeGet, unsafeSet, unsafeDelete)\nimport Record.Unsafe.Union (unsafeUnionFn)\nimport Type.Proxy (Proxy(..))\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Get a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | get (Proxy :: Proxy \"x\") :: forall r a. { x :: a | r } -> a\n-- | ```\nget\n  :: forall r r' l a\n   . IsSymbol l\n  => Cons l a r' r\n  => Proxy l\n  -> Record r\n  -> a\nget l r = unsafeGet (reflectSymbol l) r\n\n-- | Set a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | set (Proxy :: Proxy \"x\")\n-- |   :: forall r a b. a -> { x :: b | r } -> { x :: a | r }\n-- | ```\nset\n  :: forall r1 r2 r l a b\n   . IsSymbol l\n  => Cons l a r r1\n  => Cons l b r r2\n  => Proxy l\n  -> b\n  -> Record r1\n  -> Record r2\nset l b r = unsafeSet (reflectSymbol l) b r\n\n-- | Modify a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | modify (Proxy :: Proxy \"x\")\n-- |   :: forall r a b. (a -> b) -> { x :: a | r } -> { x :: b | r }\n-- | ```\nmodify\n  :: forall r1 r2 r l a b\n   . IsSymbol l\n  => Cons l a r r1\n  => Cons l b r r2\n  => Proxy l\n  -> (a -> b)\n  -> Record r1\n  -> Record r2\nmodify l f r = set l (f (get l r)) r\n\n-- | Insert a new property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | insert (Proxy :: Proxy \"x\")\n-- |   :: forall r a. Lacks \"x\" r => a -> { | r } -> { x :: a | r }\n-- | ```\ninsert\n  :: forall r1 r2 l a\n   . IsSymbol l\n  => Lacks l r1\n  => Cons l a r1 r2\n  => Proxy l\n  -> a\n  -> Record r1\n  -> Record r2\ninsert l a r = unsafeSet (reflectSymbol l) a r\n\n-- | Delete a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | Note that the type of the resulting row must _lack_ the specified property.\n-- | Since duplicate labels are allowed, this is checked with a type class constraint.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | delete (Proxy :: Proxy \"x\")\n-- |   :: forall r a. Lacks \"x\" r => { x :: a | r } -> { | r }\n-- | ```\ndelete\n  :: forall r1 r2 l a\n   . IsSymbol l\n  => Lacks l r1\n  => Cons l a r1 r2\n  => Proxy l\n  -> Record r2\n  -> Record r1\ndelete l r = unsafeDelete (reflectSymbol l) r\n\n-- | Rename a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | Note that the type of the resulting row must _lack_ the specified property.\n-- | Since duplicate labels are allowed, this is checked with a type class constraint.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | rename (Proxy :: Proxy \"x\") (Proxy :: Proxy \"y\")\n-- |   :: forall a r. Lacks \"x\" r => Lacks \"y\" r => { x :: a | r} -> { y :: a | r}\n-- | ```\nrename :: forall prev next ty input inter output\n   . IsSymbol prev\n  => IsSymbol next\n  => Cons prev ty inter input\n  => Lacks prev inter\n  => Cons next ty inter output\n  => Lacks next inter\n  => Proxy prev\n  -> Proxy next\n  -> Record input\n  -> Record output\nrename prev next record =\n  insert next (get prev record) (delete prev record :: Record inter)\n\n-- | Merges two records with the first record's labels taking precedence in the\n-- | case of overlaps.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | merge { x: 1, y: \"y\" } { y: 2, z: true }\n-- |  :: { x :: Int, y :: String, z :: Boolean }\n-- | ```\nmerge\n  :: forall r1 r2 r3 r4\n   . Union r1 r2 r3\n  => Nub r3 r4\n  => Record r1\n  -> Record r2\n  -> Record r4\nmerge l r = runFn2 unsafeUnionFn l r\n\n-- | Merges two records with the first record's labels taking precedence in the\n-- | case of overlaps. Unlike `merge`, this does not remove duplicate labels\n-- | from the resulting record type. This can result in better inference for\n-- | some pipelines, deferring the need for a `Nub` constraint.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | union { x: 1, y: \"y\" } { y: 2, z: true }\n-- |  :: { x :: Int, y :: String, y :: Int, z :: Boolean }\n-- | ```\nunion\n  :: forall r1 r2 r3\n   . Union r1 r2 r3\n  => Record r1\n  -> Record r2\n  -> Record r3\nunion l r = runFn2 unsafeUnionFn l r\n\n-- | Merges two records where no labels overlap. This restriction exhibits\n-- | better inference than `merge` when the resulting record type is known,\n-- | but one argument is not.\n-- |\n-- | For example, hole `?help` is inferred to have type `{ b :: Int }` here:\n-- |\n-- | ```purescript\n-- | disjointUnion { a: 5 } ?help :: { a :: Int, b :: Int }\n-- | ```\ndisjointUnion\n  :: forall r1 r2 r3\n   . Union r1 r2 r3\n  => Nub r3 r3\n  => Record r1\n  -> Record r2\n  -> Record r3\ndisjointUnion l r = runFn2 unsafeUnionFn l r\n\n-- | A coercion which removes duplicate labels from a record's type.\nnub\n  :: forall r1 r2\n   . Nub r1 r2\n  => Record r1\n  -> Record r2\nnub = unsafeCoerce\n\n-- | Check two records of the same type for equality.\nequal\n  :: forall r rs\n   . RowToList r rs\n  => EqualFields rs r\n  => Record r\n  -> Record r\n  -> Boolean\nequal a b = equalFields (Proxy :: Proxy rs) a b\n\nclass EqualFields (rs :: RowList Type) (row :: Row Type) | rs -> row where\n  equalFields :: Proxy rs -> Record row -> Record row -> Boolean\n\ninstance equalFieldsCons\n  ::\n  ( IsSymbol name\n  , Eq ty\n  , Cons name ty tailRow row\n  , EqualFields tail row\n  ) => EqualFields (Cons name ty tail) row where\n  equalFields _ a b = get' a == get' b && equalRest a b\n    where\n      get' = get (Proxy :: Proxy name)\n      equalRest = equalFields (Proxy :: Proxy tail)\n\ninstance equalFieldsNil :: EqualFields Nil row where\n  equalFields _ _ _ = true\n","module Data.Argonaut.Decode.Class where\n\nimport Data.Argonaut.Decode.Decoders\n\nimport Data.Argonaut.Core (Json, toObject)\nimport Data.Argonaut.Decode.Error (JsonDecodeError(..))\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Bifunctor (lmap)\nimport Data.Either (Either(..))\nimport Data.Identity (Identity)\nimport Data.List (List)\nimport Data.List.NonEmpty (NonEmptyList)\nimport Data.String.NonEmpty (NonEmptyString)\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.NonEmpty (NonEmpty)\nimport Data.Set as S\nimport Data.String (CodePoint)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Tuple (Tuple)\nimport Foreign.Object as FO\nimport Prelude (class Ord, Unit, Void, bind, ($), (<$>))\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record as Record\nimport Type.Proxy (Proxy(..))\n\nclass DecodeJson a where\n  decodeJson :: Json -> Either JsonDecodeError a\n\ninstance decodeIdentity :: DecodeJson a => DecodeJson (Identity a) where\n  decodeJson = decodeIdentity decodeJson\n\ninstance decodeJsonMaybe :: DecodeJson a => DecodeJson (Maybe a) where\n  decodeJson = decodeMaybe decodeJson\n\ninstance decodeJsonTuple :: (DecodeJson a, DecodeJson b) => DecodeJson (Tuple a b) where\n  decodeJson = decodeTuple decodeJson decodeJson\n\ninstance decodeJsonEither :: (DecodeJson a, DecodeJson b) => DecodeJson (Either a b) where\n  decodeJson = decodeEither decodeJson decodeJson\n\ninstance decodeJsonNull :: DecodeJson Unit where\n  decodeJson = decodeNull\n\ninstance decodeJsonBoolean :: DecodeJson Boolean where\n  decodeJson = decodeBoolean\n\ninstance decodeJsonNumber :: DecodeJson Number where\n  decodeJson = decodeNumber\n\ninstance decodeJsonInt :: DecodeJson Int where\n  decodeJson = decodeInt\n\ninstance decodeJsonString :: DecodeJson String where\n  decodeJson = decodeString\n\ninstance decodeJsonNonEmptyString :: DecodeJson NonEmptyString where\n  decodeJson = decodeNonEmptyString\n\ninstance decodeJsonJson :: DecodeJson Json where\n  decodeJson = Right\n\ninstance decodeJsonNonEmpty_Array :: (DecodeJson a) => DecodeJson (NonEmpty Array a) where\n  decodeJson = decodeNonEmpty_Array decodeJson\n\ninstance decodeJsonNonEmptyArray :: (DecodeJson a) => DecodeJson (NonEmptyArray a) where\n  decodeJson = decodeNonEmptyArray decodeJson\n\ninstance decodeJsonNonEmpty_List :: (DecodeJson a) => DecodeJson (NonEmpty List a) where\n  decodeJson = decodeNonEmpty_List decodeJson\n\ninstance decodeJsonNonEmptyList :: (DecodeJson a) => DecodeJson (NonEmptyList a) where\n  decodeJson = decodeNonEmptyList decodeJson\n\ninstance decodeJsonCodePoint :: DecodeJson CodePoint where\n  decodeJson = decodeCodePoint\n\ninstance decodeForeignObject :: DecodeJson a => DecodeJson (FO.Object a) where\n  decodeJson = decodeForeignObject decodeJson\n\ninstance decodeArray :: DecodeJson a => DecodeJson (Array a) where\n  decodeJson = decodeArray decodeJson\n\ninstance decodeList :: DecodeJson a => DecodeJson (List a) where\n  decodeJson = decodeList decodeJson\n\ninstance decodeSet :: (Ord a, DecodeJson a) => DecodeJson (S.Set a) where\n  decodeJson = decodeSet decodeJson\n\ninstance decodeMap :: (Ord a, DecodeJson a, DecodeJson b) => DecodeJson (M.Map a b) where\n  decodeJson = decodeMap decodeJson decodeJson\n\ninstance decodeVoid :: DecodeJson Void where\n  decodeJson = decodeVoid\n\ninstance decodeRecord ::\n  ( GDecodeJson row list\n  , RL.RowToList row list\n  ) =>\n  DecodeJson (Record row) where\n  decodeJson json =\n    case toObject json of\n      Just object -> gDecodeJson object (Proxy :: Proxy list)\n      Nothing -> Left $ TypeMismatch \"Object\"\n\nclass GDecodeJson (row :: Row Type) (list :: RL.RowList Type) | list -> row where\n  gDecodeJson :: forall proxy. FO.Object Json -> proxy list -> Either JsonDecodeError (Record row)\n\ninstance gDecodeJsonNil :: GDecodeJson () RL.Nil where\n  gDecodeJson _ _ = Right {}\n\ninstance gDecodeJsonCons ::\n  ( DecodeJsonField value\n  , GDecodeJson rowTail tail\n  , IsSymbol field\n  , Row.Cons field value rowTail row\n  , Row.Lacks field rowTail\n  ) =>\n  GDecodeJson row (RL.Cons field value tail) where\n  gDecodeJson object _ = do\n    let\n      _field = Proxy :: Proxy field\n      fieldName = reflectSymbol _field\n      fieldValue = FO.lookup fieldName object\n\n    case decodeJsonField fieldValue of\n      Just fieldVal -> do\n        val <- lmap (AtKey fieldName) fieldVal\n        rest <- gDecodeJson object (Proxy :: Proxy tail)\n        Right $ Record.insert _field val rest\n\n      Nothing ->\n        Left $ AtKey fieldName MissingValue\n\nclass DecodeJsonField a where\n  decodeJsonField :: Maybe Json -> Maybe (Either JsonDecodeError a)\n\ninstance decodeFieldMaybe ::\n  DecodeJson a =>\n  DecodeJsonField (Maybe a) where\n  decodeJsonField Nothing = Just $ Right Nothing\n  decodeJsonField (Just j) = Just $ decodeJson j\n\nelse instance decodeFieldId ::\n  DecodeJson a =>\n  DecodeJsonField a where\n  decodeJsonField j = decodeJson <$> j\n","// module Data.BigInt\n\nimport bigInt from \"big-integer\";\n\nexport function fromTypeLevelInt(str) {\n  return bigInt(str, 10);\n}\n\nexport function fromBaseImpl(just) {\n  return function(nothing) {\n    return function(b) {\n      return function(s) {\n        try {\n          var x = bigInt(s, b);\n          return just(x);\n        } catch (err) {\n          return nothing;\n        }\n      };\n    };\n  };\n}\n\nfunction truncate(n) {\n  if (n > 0) return Math.floor(n);\n  return Math.ceil(n);\n}\n\nexport function fromNumberImpl(just) {\n  return function(nothing) {\n      return function(n) {\n        try {\n          var x = bigInt(truncate(n));\n          return just(x);\n        } catch (err) {\n          return nothing;\n        }\n      };\n  };\n}\n\nexport function fromInt(n) {\n  return bigInt(n);\n}\n\nexport function toBase(base) {\n  return function (x) {\n    return x.toString(base);\n  };\n}\n\nexport function toNumber(x) {\n  return x.toJSNumber();\n}\n\nexport function biAdd(x) {\n  return function(y) {\n    return x.add(y);\n  };\n}\n\nexport function biMul(x) {\n  return function(y) {\n    return x.multiply(y);\n  };\n}\n\nexport function biSub(x) {\n  return function(y) {\n    return x.minus(y);\n  };\n}\n\nexport function biMod(x) {\n  return function(y) {\n    return x.mod(y);\n  };\n}\n\nexport function biDiv(x) {\n  return function(y) {\n    return x.divide(y);\n  };\n}\n\nexport function biEquals(x) {\n  return function(y) {\n    return x.equals(y);\n  };\n}\n\nexport function biCompare(x) {\n  return function(y) {\n    return x.compare(y);\n  };\n}\n\nexport function abs(x) {\n  return x.abs();\n}\n\nexport function even(x) {\n  return x.isEven();\n}\n\nexport function odd(x) {\n  return x.isOdd();\n}\n\nexport function prime(x) {\n  return x.isPrime();\n}\n\nexport function pow(x) {\n  return function(y) {\n    return x.pow(y);\n  };\n}\n\nexport function not(x) {\n  return x.not();\n  }\n\nexport function or(x) {\n  return function(y) {\n    return x.or(y);\n  };\n}\n\nexport function xor(x) {\n  return function(y) {\n    return x.xor(y);\n  };\n}\n\nexport function and(x) {\n  return function(y) {\n    return x.and(y);\n  };\n}\n\nexport function shl(x) {\n  return function(n) {\n    return x.shiftLeft(n);\n  };\n}\n\nexport function shr(x) {\n  return function(n) {\n    return x.shiftRight(n);\n  };\n}\n\nexport function digitsInBase(radix) {\n  return function(x) {\n    return x.toArray(radix);\n  };\n}\n","-- | This module defines a `BigInt` data type for arbitrary length integers.\nmodule Data.BigInt\n  ( BigInt(..)\n  , BaseDigits\n  , fromString\n  , fromBase\n  , fromInt\n  , fromNumber\n  , fromTLInt\n  , toString\n  , toNonEmptyString\n  , toBase\n  , toBase'\n  , digitsInBase\n  , abs\n  , even\n  , odd\n  , prime\n  , pow\n  , not\n  , or\n  , xor\n  , and\n  , shl\n  , shr\n  , quot\n  , rem\n  , toInt\n  , toNumber\n  ) where\n\nimport Prelude\n\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Int (floor)\nimport Data.Int as Int\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.Reflectable (class Reflectable, reflectType)\nimport Data.String.NonEmpty (NonEmptyString)\nimport Data.String.NonEmpty as NES\nimport Partial.Unsafe (unsafePartial)\nimport Prim.Int (class ToString)\nimport Type.Proxy (Proxy(..))\n\n-- | An arbitrary length integer.\nforeign import data BigInt :: Type\n\ntype BaseDigits =\n  { value :: NonEmptyArray Int\n  , isNegative :: Boolean\n  }\n\n-- | FFI wrapper to parse a String in a given base representation into a BigInt.\nforeign import fromBaseImpl\n  :: forall a\n   . (a -> Maybe a)\n  -> Maybe a\n  -> Int\n  -> String\n  -> Maybe BigInt\n\n-- | Convert an integer to a BigInt.\nforeign import fromInt :: Int -> BigInt\n\ntoInt :: BigInt -> Maybe Int\ntoInt = toNumber >>> Int.fromNumber\n\n-- | FFI wrapper to parse a Number into a BigInt.\nforeign import fromNumberImpl\n  :: forall a\n   . (a -> Maybe a)\n  -> Maybe a\n  -> Number\n  -> Maybe BigInt\n\n-- | Convert a Number to a BigInt. The fractional part is truncated.\nfromNumber :: Number -> Maybe BigInt\nfromNumber = fromNumberImpl Just Nothing\n\n-- | Converts a BigInt to a Number. Loses precision for numbers which are too\n-- | large.\nforeign import toNumber :: BigInt -> Number\n\n-- | Exponentiation for `BigInt`. If the exponent is less than 0, `pow`\n-- | returns 0. Also, `pow zero zero == one`.\nforeign import pow :: BigInt -> BigInt -> BigInt\n\n-- | The absolute value.\nforeign import abs :: BigInt -> BigInt\n\n-- | Returns `true` if the number is even, `false` otherwise.\nforeign import even :: BigInt -> Boolean\n\n-- | Returns `true` if the number is odd, `false` otherwise.\nforeign import odd :: BigInt -> Boolean\n\n-- | Returns `true` if the number is prime, `false` otherwise.\nforeign import prime :: BigInt -> Boolean\n\n-- | Invert the bits.\nforeign import not :: BigInt -> BigInt\n\n-- | or the bits.\nforeign import or :: BigInt -> BigInt -> BigInt\n\n-- | Exlusive or the bits.\nforeign import xor :: BigInt -> BigInt -> BigInt\n\n-- | and the bits.\nforeign import and :: BigInt -> BigInt -> BigInt\n\n-- | shift the bits left and zero fill.\nforeign import shl :: BigInt -> Number -> BigInt\n\n-- | Shift the bits right and maintain pos/neg.\nforeign import shr :: BigInt -> Number -> BigInt\n\n-- Note: this function should not be exported!\n-- It's only safe if used with type-level integers.\nforeign import fromTypeLevelInt :: String -> BigInt\n\n-- | Converts a type-level integer into a `BigInt`:\n-- | ```\n-- | import Type.Proxy (Proxy(..))\n-- | foo = fromTLInt (Proxy :: Proxy 857981209301293808359384092830482)\n-- | ```\nfromTLInt :: forall i sym. ToString i sym => Reflectable sym String => Proxy i -> BigInt\nfromTLInt _ = fromTypeLevelInt (reflectType (Proxy :: Proxy sym))\n\n-- | Parse a string into a `BigInt`, assuming a decimal representation. Returns\n-- | `Nothing` if the parse fails.\n-- |\n-- | Examples:\n-- | ```purescript\n-- | fromString \"42\"\n-- | fromString \"857981209301293808359384092830482\"\n-- | fromString \"1e100\"\n-- | ```\nfromString :: String -> Maybe BigInt\nfromString = fromBase 10\n\n-- | Parse a string into a `BigInt`, assuming a representation in the given base.\n-- | The letters \"a-z\" and \"A-Z\" will be interpreted as the digits `10` to\n-- | `36`. Returns `Nothing` if the parse fails.\n-- |\n-- | ```purescript\n-- | fromBase 2 \"100\" == fromString \"4\"\n-- | fromBase 16 \"ff\" == fromString \"255\"\n-- | ```\nfromBase :: Int -> String -> Maybe BigInt\nfromBase = fromBaseImpl Just Nothing\n\nforeign import biEquals :: BigInt -> BigInt -> Boolean\n\ninstance eqBigInt :: Eq BigInt where\n  eq = biEquals\n\nforeign import biCompare :: BigInt -> BigInt -> Int\n\ninstance ordBigInt :: Ord BigInt where\n  compare x y = case biCompare x y of\n                  1 -> GT\n                  0 -> EQ\n                  _ -> LT\n\n-- | A decimal representation of the `BigInt` as a `String`.\ntoString :: BigInt -> String\ntoString = toBase 10\n\n-- | A decimal representation of the `BigInt` as a `NonEmptyString`.\ntoNonEmptyString :: BigInt -> NonEmptyString\ntoNonEmptyString = toBase' 10\n\n-- | A base N representation of the `BigInt` as an array of digits.\nforeign import digitsInBase :: Int -> BigInt -> BaseDigits\n\n-- | A base N representation of the `BigInt` as a `String`.\nforeign import toBase :: Int -> BigInt -> String\n\n-- | A base N representation of the `BigInt` as a `NonEmptyString`.\ntoBase' :: Int -> BigInt -> NonEmptyString\ntoBase' i bi = unsafePartial fromJust $ NES.fromString $ toBase i bi\n\ninstance showBigInt :: Show BigInt where\n  show x = \"(fromString \\\"\" <> toString x <> \"\\\")\"\n\nforeign import biAdd :: BigInt -> BigInt -> BigInt\nforeign import biMul :: BigInt -> BigInt -> BigInt\n\ninstance semiringBigInt :: Semiring BigInt where\n  add  = biAdd\n  zero = fromInt 0\n  mul  = biMul\n  one  = fromInt 1\n\nforeign import biSub :: BigInt -> BigInt -> BigInt\n\ninstance ringBigInt :: Ring BigInt where\n  sub = biSub\n\nforeign import biDiv :: BigInt -> BigInt -> BigInt\nforeign import biMod :: BigInt -> BigInt -> BigInt\n\ninstance commutativeRingBigInt :: CommutativeRing BigInt\n\ninstance euclideanRingBigInt :: EuclideanRing BigInt where\n  div x y = (x - x `mod` y) `biDiv` y\n\n  mod x y = ((x `biMod` yy) + yy) `biMod` yy\n    where yy = abs y\n\n  degree = floor <<< toNumber <<< abs\n\n-- | Truncating integer division\nquot :: BigInt -> BigInt -> BigInt\nquot = biDiv\n\n-- | The remainder after truncating integer division\nrem :: BigInt -> BigInt -> BigInt\nrem = biMod\n","module Effect.Class where\n\nimport Control.Category (identity)\nimport Control.Monad (class Monad)\nimport Effect (Effect)\n\n-- | The `MonadEffect` class captures those monads which support native effects.\n-- |\n-- | Instances are provided for `Effect` itself, and the standard monad\n-- | transformers.\n-- |\n-- | `liftEffect` can be used in any appropriate monad transformer stack to lift an\n-- | action of type `Effect a` into the monad.\n-- |\nclass Monad m <= MonadEffect m where\n  liftEffect :: forall a. Effect a -> m a\n\ninstance monadEffectEffect :: MonadEffect Effect where\n  liftEffect = identity\n","export const log = function (s) {\n  return function () {\n    console.log(s);\n  };\n};\n\nexport const warn = function (s) {\n  return function () {\n    console.warn(s);\n  };\n};\n\nexport const error = function (s) {\n  return function () {\n    console.error(s);\n  };\n};\n\nexport const info = function (s) {\n  return function () {\n    console.info(s);\n  };\n};\n\nexport const debug = function (s) {\n  return function () {\n    console.debug(s);\n  };\n};\n\nexport const time = function (s) {\n  return function () {\n    console.time(s);\n  };\n};\n\nexport const timeLog = function (s) {\n  return function () {\n    console.timeLog(s);\n  };\n};\n\nexport const timeEnd = function (s) {\n  return function () {\n    console.timeEnd(s);\n  };\n};\n\nexport const clear = function () {\n  console.clear();\n};\n\nexport const group = function (s) {\n  return function () {\n    console.group(s);\n  };\n};\n\nexport const groupCollapsed = function (s) {\n  return function () {\n    console.groupCollapsed(s);\n  };\n};\n\nexport const groupEnd = function () {\n  console.groupEnd();\n};\n","module Effect.Class.Console where\n\nimport Control.Bind (discard, bind, pure)\nimport Data.Function ((<<<))\nimport Data.Show (class Show)\nimport Data.Unit (Unit)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Console as EffConsole\n\nlog :: forall m. MonadEffect m => String -> m Unit\nlog = liftEffect <<< EffConsole.log\n\nlogShow :: forall m a. MonadEffect m => Show a => a -> m Unit\nlogShow = liftEffect <<< EffConsole.logShow\n\nwarn :: forall m. MonadEffect m => String -> m Unit\nwarn = liftEffect <<< EffConsole.warn\n\nwarnShow :: forall m a. MonadEffect m => Show a => a -> m Unit\nwarnShow = liftEffect <<< EffConsole.warnShow\n\nerror :: forall m. MonadEffect m => String -> m Unit\nerror = liftEffect <<< EffConsole.error\n\nerrorShow :: forall m a. MonadEffect m => Show a => a -> m Unit\nerrorShow = liftEffect <<< EffConsole.errorShow\n\ninfo :: forall m. MonadEffect m => String -> m Unit\ninfo = liftEffect <<< EffConsole.info\n\ninfoShow :: forall m a. MonadEffect m => Show a => a -> m Unit\ninfoShow = liftEffect <<< EffConsole.infoShow\n\ndebug :: forall m. MonadEffect m => String -> m Unit\ndebug = liftEffect <<< EffConsole.debug\n\ndebugShow :: forall m a. MonadEffect m => Show a => a -> m Unit\ndebugShow = liftEffect <<< EffConsole.debugShow\n\ntime :: forall m. MonadEffect m => String -> m Unit\ntime = liftEffect <<< EffConsole.time\n\ntimeLog :: forall m. MonadEffect m => String -> m Unit\ntimeLog = liftEffect <<< EffConsole.timeLog\n\ntimeEnd :: forall m. MonadEffect m => String -> m Unit\ntimeEnd = liftEffect <<< EffConsole.timeEnd\n\nclear :: forall m. MonadEffect m => m Unit\nclear = liftEffect EffConsole.clear\n\ngroup :: forall m. MonadEffect m => String -> m Unit\ngroup = liftEffect <<< EffConsole.group\n\ngroupCollapsed :: forall m. MonadEffect m => String -> m Unit\ngroupCollapsed = liftEffect <<< EffConsole.groupCollapsed\n\ngroupEnd :: forall m. MonadEffect m => m Unit\ngroupEnd = liftEffect EffConsole.groupEnd\n\ngrouped :: forall m a. MonadEffect m => String -> m a -> m a\ngrouped name inner = do\n  group name\n  result <- inner\n  groupEnd\n  pure result\n","export function typeOf(value) {\n  return typeof value;\n}\n\nexport function tagOf(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isUndefined(value) {\n  return value === undefined;\n}\n\nexport const isArray = Array.isArray || function (value) {\n  return Object.prototype.toString.call(value) === \"[object Array]\";\n};\n","-- | This module defines types and functions for working with _foreign_\n-- | data.\n-- |\n-- | `ExceptT (NonEmptyList ForeignError) m` is used in this library\n-- | to encode possible failures when dealing with foreign data.\n-- |\n-- | The `Alt` instance for `ExceptT` allows us to accumulate errors,\n-- | unlike `Either`, which preserves only the last error.\nmodule Foreign\n  ( Foreign\n  , ForeignError(..)\n  , MultipleErrors(..)\n  , F\n  , FT\n  , renderForeignError\n  , unsafeToForeign\n  , unsafeFromForeign\n  , unsafeReadTagged\n  , typeOf\n  , tagOf\n  , isNull\n  , isUndefined\n  , isArray\n  , readString\n  , readChar\n  , readBoolean\n  , readNumber\n  , readInt\n  , readArray\n  , readNull\n  , readUndefined\n  , readNullOrUndefined\n  , fail\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Except (Except, ExceptT, mapExceptT, throwError)\nimport Data.Either (Either(..), either)\nimport Data.Int as Int\nimport Data.List.NonEmpty (NonEmptyList)\nimport Data.List.NonEmpty as NEL\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.String.CodeUnits (toChar)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | A type for _foreign data_.\n-- |\n-- | Foreign data is data from any external _unknown_ or _unreliable_\n-- | source, for which it cannot be guaranteed that the runtime representation\n-- | conforms to that of any particular type.\n-- |\n-- | Suitable applications of `Foreign` are\n-- |\n-- | - To represent responses from web services\n-- | - To integrate with external JavaScript libraries.\nforeign import data Foreign :: Type\n\n-- | A type for foreign type errors\ndata ForeignError\n  = ForeignError String\n  | TypeMismatch String String\n  | ErrorAtIndex Int ForeignError\n  | ErrorAtProperty String ForeignError\n\nderive instance eqForeignError :: Eq ForeignError\nderive instance ordForeignError :: Ord ForeignError\n\ninstance showForeignError :: Show ForeignError where\n  show (ForeignError msg) = \"(ForeignError \" <> show msg <> \")\"\n  show (ErrorAtIndex i e) = \"(ErrorAtIndex \" <> show i <> \" \" <> show e <> \")\"\n  show (ErrorAtProperty prop e) = \"(ErrorAtProperty \" <> show prop <> \" \" <> show e <> \")\"\n  show (TypeMismatch exps act) = \"(TypeMismatch \" <> show exps <> \" \" <> show act <> \")\"\n\n-- | A type for accumulating multiple `ForeignError`s.\ntype MultipleErrors = NonEmptyList ForeignError\n\nrenderForeignError :: ForeignError -> String\nrenderForeignError (ForeignError msg) = msg\nrenderForeignError (ErrorAtIndex i e) = \"Error at array index \" <> show i <> \": \" <> renderForeignError e\nrenderForeignError (ErrorAtProperty prop e) = \"Error at property \" <> show prop <> \": \" <> renderForeignError e\nrenderForeignError (TypeMismatch exp act) = \"Type mismatch: expected \" <> exp <> \", found \" <> act\n\n-- | While this alias is not deprecated, it is recommended\n-- | that one use `Except (NonEmptyList ForeignError)` directly\n-- | for all future usages rather than this type alias.\n-- |\n-- | An error monad, used in this library to encode possible failures when\n-- | dealing with foreign data.\n-- |\n-- | The `Alt` instance for `Except` allows us to accumulate errors,\n-- | unlike `Either`, which preserves only the last error.\ntype F = Except MultipleErrors\n\n-- | While this alias is not deprecated, it is recommended\n-- | that one use `ExceptT (NonEmptyList ForeignError)` directly\n-- | for all future usages rather than this type alias.\ntype FT = ExceptT MultipleErrors\n\n-- | Coerce any value to the a `Foreign` value.\n-- |\n-- | This is considered unsafe as it's only intended to be used on primitive\n-- | JavaScript types, rather than PureScript types. Exporting PureScript values\n-- | via the FFI can be dangerous as they can be mutated by code outside the\n-- | PureScript program, resulting in difficult to diagnose problems elsewhere.\nunsafeToForeign :: forall a. a -> Foreign\nunsafeToForeign = unsafeCoerce\n\n-- | Unsafely coerce a `Foreign` value.\nunsafeFromForeign :: forall a. Foreign -> a\nunsafeFromForeign = unsafeCoerce\n\n-- | Read the Javascript _type_ of a value\nforeign import typeOf :: Foreign -> String\n\n-- | Read the Javascript _tag_ of a value.\n-- |\n-- | This function wraps the `Object.toString` method.\nforeign import tagOf :: Foreign -> String\n\n-- | Unsafely coerce a `Foreign` value when the value has a particular `tagOf`\n-- | value.\nunsafeReadTagged :: forall m a. Monad m => String -> Foreign -> ExceptT (NonEmptyList ForeignError) m a\nunsafeReadTagged tag value\n  | tagOf value == tag = pure (unsafeFromForeign value)\n  | otherwise = fail $ TypeMismatch tag (tagOf value)\n\n-- | Test whether a foreign value is null\nforeign import isNull :: Foreign -> Boolean\n\n-- | Test whether a foreign value is undefined\nforeign import isUndefined :: Foreign -> Boolean\n\n-- | Test whether a foreign value is an array\nforeign import isArray :: Foreign -> Boolean\n\n-- | Attempt to coerce a foreign value to a `String`.\nreadString :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m String\nreadString = unsafeReadTagged \"String\"\n\n-- | Attempt to coerce a foreign value to a `Char`.\nreadChar :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Char\nreadChar value = mapExceptT (map $ either (const error) fromString) (readString value)\n  where\n  fromString = maybe error pure <<< toChar\n  error = Left $ NEL.singleton $ TypeMismatch \"Char\" (tagOf value)\n\n-- | Attempt to coerce a foreign value to a `Boolean`.\nreadBoolean :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Boolean\nreadBoolean = unsafeReadTagged \"Boolean\"\n\n-- | Attempt to coerce a foreign value to a `Number`.\nreadNumber :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Number\nreadNumber = unsafeReadTagged \"Number\"\n\n-- | Attempt to coerce a foreign value to an `Int`.\nreadInt :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Int\nreadInt value = mapExceptT (map $ either (const error) fromNumber) (readNumber value)\n  where\n  fromNumber = maybe error pure <<< Int.fromNumber\n  error = Left $ NEL.singleton $ TypeMismatch \"Int\" (tagOf value)\n\n-- | Attempt to coerce a foreign value to an array.\nreadArray :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Array Foreign)\nreadArray value\n  | isArray value = pure $ unsafeFromForeign value\n  | otherwise = fail $ TypeMismatch \"array\" (tagOf value)\n\nreadNull :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadNull value\n  | isNull value = pure Nothing\n  | otherwise = pure (Just value)\n\nreadUndefined :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadUndefined value\n  | isUndefined value = pure Nothing\n  | otherwise = pure (Just value)\n\nreadNullOrUndefined :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadNullOrUndefined value\n  | isNull value || isUndefined value = pure Nothing\n  | otherwise = pure (Just value)\n\n-- | Throws a failure error in `ExceptT (NonEmptyList ForeignError) m`.\nfail :: forall m a. Monad m => ForeignError -> ExceptT (NonEmptyList ForeignError) m a\nfail = throwError <<< NEL.singleton\n","module TcgCalculator.Math\n  ( Combination\n  , PartitionNumber\n  , PascalTriangle\n  , Permutation\n  , combinationNumber\n  , combinations\n  , createPascalTriangle\n  , partitionNumber\n  , partitionNumbers\n  , pascalTriangle\n  , permutations\n  ) where\n\nimport Prelude\n\nimport Data.Array (filter, fromFoldable, head, insertAt, length, singleton, uncons, zipWith, (!!), (..), (:))\nimport Data.BigInt (BigInt)\nimport Data.BigInt as BigInt\nimport Data.Foldable (fold, product)\nimport Data.List as L\nimport Data.Maybe (Maybe(..), fromMaybe)\n\n----------------------------------------------------------------\n\ntype PascalTriangle = Array (Array BigInt)\n\ncreatePascalTriangle :: Int -> PascalTriangle\ncreatePascalTriangle size = f [one] size\n  where\n  f _ n | n <= 0 = []\n  f r n = r : f (zipWith (+) ([zero] <> r) (r <> [zero])) (n - 1)\n\nptCacheSize :: Int\nptCacheSize = 256\n\npascalTriangle :: PascalTriangle\npascalTriangle = createPascalTriangle ptCacheSize\n\ncombinationNumber :: Int -> Int -> BigInt\ncombinationNumber n r\n  | n < r            = zero\n  | r == 0 || n == r = one\n  | r == 1           = BigInt.fromInt n\n  | n < ptCacheSize  = fromMaybe zero $ pascalTriangle !! n >>= (_ !! r) -- fast path using cached pascal triangle\n  | otherwise        = do\n      let k = min r (n - r)\n      product' ((n - k + 1) .. n) / product' (1 .. k)\n  where\n  product' = product <<< map BigInt.fromInt\n\n----------------------------------------------------------------\n\ntype PartitionNumber = Array (Array Int)\n\n-- partitionNumber 4 -> [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]\npartitionNumber :: Int -> PartitionNumber\npartitionNumber n | n < 0 = []\npartitionNumber 0 = [[]]\npartitionNumber n = fold <<< L.head $ buildPartitionNumbers n\n\n-- partitionNumbers 3 -> [partitionNumber 3, partitionNumber 2, paritionNumber 1, partitionNumber 0]\npartitionNumbers :: Int -> Array PartitionNumber\npartitionNumbers n | n < 0 = []\npartitionNumbers 0 = [[[]]]\npartitionNumbers n = fromFoldable $ buildPartitionNumbers n\n\nbuildPartitionNumbers :: Int -> L.List PartitionNumber\nbuildPartitionNumbers 0 = L.singleton [[]]\nbuildPartitionNumbers k = do\n  let prev = buildPartitionNumbers (k - 1)\n  new prev 1 L.: prev\n  where\n  new :: L.List PartitionNumber -> Int -> PartitionNumber\n  new (h L.: t) i = new t (i + 1) <> ((i : _) <$> filter ((_ <= i) <<< fromMaybe 0 <<< head) h)\n  new _         _ = []\n\n----------------------------------------------------------------\n\ntype Permutation a = Array (Array a)\n\n-- permutations [1, 2, 3] -> [[1, 2, 3], [2, 1, 3], [2, 3, 1], [1, 3, 2], [3, 1, 2], [3, 2, 1]]\npermutations :: Array ~> Permutation\npermutations [] = [[]]\npermutations [a] = [[a]]\npermutations a = case uncons a of\n  Just { head, tail } -> do\n    let r = 0 .. length tail\n    p <- permutations tail\n    r <#> \\i -> fold $ insertAt i head p\n  _ -> []\n\n----------------------------------------------------------------\n\ntype Combination a = Array (Array a)\n\n-- combination 2 [1, 2, 3, 4] -> [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\ncombinations :: forall a. Int -> Array a -> Combination a\ncombinations n a\n  | n == 0        = [[]]\n  | n == 1        = singleton <$> a\n  | length a == n = [a]\n  | length a < n  = []\n  | otherwise     = case uncons a of\n      Just { head, tail } -> ((head : _) <$> combinations (n - 1) tail) <> combinations n tail\n      _ -> []\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return unsafeStringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","// module Data.UUID\nimport { v3, v4, v5, validate } from \"uuid\";\n\nexport const getUUID3Impl = function (str) {\n  return function (namespace) {\n    return v3(str, namespace);\n  };\n};\n\nexport const getUUIDImpl = v4;\n\nexport const getUUID5Impl = function (str) {\n  return function (namespace) {\n    return v5(str, namespace);\n  };\n};\n\nexport const validateV4UUID = validate;\n","module Data.UUID\n  ( UUID\n  , emptyUUID\n  , genUUID\n  , parseUUID\n  , genv3UUID\n  , genv5UUID\n  , toString\n  ) where\n\nimport Prelude\nimport Data.Maybe (Maybe(Nothing, Just))\nimport Effect (Effect)\n\nnewtype UUID\n  = UUID String\n\nemptyUUID :: UUID\nemptyUUID = UUID \"00000000-0000-0000-0000-000000000000\"\n\nforeign import getUUIDImpl :: Effect String\n\n-- | Generates a v4 UUID\ngenUUID :: Effect UUID\ngenUUID = getUUIDImpl >>= pure <<< UUID\n\nforeign import validateV4UUID :: String -> Boolean\n\n-- | Validates a String as a v4 UUID\nparseUUID :: String -> Maybe UUID\nparseUUID str = case validateV4UUID str of\n  true -> Just $ UUID str\n  _ -> Nothing\n\nforeign import getUUID3Impl :: String -> String -> String\n\ngenv3UUID :: String -> UUID -> UUID\ngenv3UUID s (UUID n) = UUID $ getUUID3Impl s n\n\nforeign import getUUID5Impl :: String -> String -> String\n\ngenv5UUID :: String -> UUID -> UUID\ngenv5UUID s (UUID n) = UUID (getUUID5Impl s n)\n\ninstance showUUID :: Show UUID where\n  show (UUID uuid) = \"(UUID \" <> uuid <> \")\"\n\nderive instance eqUUID :: Eq UUID\n\nderive instance ordUUID :: Ord UUID\n\ntoString :: UUID -> String\ntoString (UUID uuid) = uuid\n","module TcgCalculator.Types where\n\nimport Prelude\n\nimport Data.Argonaut.Decode (class DecodeJson, JsonDecodeError(..), decodeJson)\nimport Data.Argonaut.Encode (class EncodeJson, encodeJson)\nimport Data.Either (note)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..), maybe')\nimport Data.Newtype (class Newtype)\nimport Data.Show.Generic (genericShow)\nimport Data.UUID (UUID)\nimport Data.UUID as UUID\nimport Effect.Class (class MonadEffect, liftEffect)\n\n----------------------------------------------------------------\n\nnewtype Id = Id UUID\n\nderive instance Eq Id\nderive instance Ord Id\n\nderive instance Newtype Id _\n\ninstance Show Id where\n  show (Id uuid) = UUID.toString uuid\n\ninstance EncodeJson Id where\n  encodeJson = encodeJson <<< show\n\ninstance DecodeJson Id where\n  decodeJson json = decodeJson json <#> \\id -> maybe' (\\_ -> mkId id) Id (UUID.parseUUID id)\n\nnamespaceTcgCalculator :: UUID\nnamespaceTcgCalculator = UUID.genv5UUID \"tcg-calculator\" UUID.emptyUUID\n\nmkId :: String -> Id\nmkId s = Id $ UUID.genv5UUID s namespaceTcgCalculator\n\ngenerateId :: forall m. MonadEffect m => m Id\ngenerateId = liftEffect $ Id <$> UUID.genUUID\n\n----------------------------------------------------------------\n\ntype Card = { id :: Id, name :: String, count :: Int }\n\ntype Cards = Array Card\n\ntype Deck = { cards :: Array Card, others :: Int, hand :: Int }\n\n----------------------------------------------------------------\n\ndata ConditionMode\n  = AtLeast\n  | JustDraw\n  | Remains\n  | JustRemains\n  | Choice\n  | LeftOne\n  | LeftAll\n\nderive instance Eq ConditionMode\nderive instance Ord ConditionMode\nderive instance Generic ConditionMode _\n\ninstance Show ConditionMode where\n  show = genericShow\n\ninstance EncodeJson ConditionMode where\n  encodeJson = encodeJson <<< show\n\ninstance DecodeJson ConditionMode where\n  decodeJson json = note (UnexpectedValue json) <<< readConditionMode =<< decodeJson json\n\nreadConditionMode :: String -> Maybe ConditionMode\nreadConditionMode = case _ of\n  \"AtLeast\" -> Just AtLeast\n  \"JustDraw\" -> Just JustDraw\n  \"Remains\" -> Just Remains\n  \"JustRemains\" -> Just JustRemains\n  \"Choice\" -> Just Choice\n  \"LeftOne\" -> Just LeftOne\n  \"LeftAll\" -> Just LeftAll\n  _ -> Nothing\n\n----------------------------------------------------------------\n\ntype Condition' = { mode :: ConditionMode, count :: Int, cards :: Cards }\n\nnewtype Condition = Condition Condition'\n\nderive instance Eq Condition\nderive instance Ord Condition\n\nderive instance Newtype Condition _\n\nderive newtype instance Show Condition\n\nderive newtype instance EncodeJson Condition\nderive newtype instance DecodeJson Condition\n","module TcgCalculator where\n\nimport Prelude\n\nimport Control.Alternative (empty)\nimport Data.Array (all, any, concat, concatMap, deleteBy, filter, find, foldMap, foldr, group, groupAllBy, length, nubByEq, nubEq, replicate, sortBy, take, unionBy, zipWith, (!!), (..))\nimport Data.Array.NonEmpty (NonEmptyArray, foldl1, toArray)\nimport Data.BigInt (BigInt)\nimport Data.Foldable (and, fold, maximum, product, sum)\nimport Data.Function (on)\nimport Data.Maybe (fromMaybe)\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Newtype (alaF, unwrap)\nimport TcgCalculator.Math (Combination, combinationNumber, combinations, partitionNumber, partitionNumbers, permutations)\nimport TcgCalculator.Types (Card, Cards, Condition(..), ConditionMode(..), Deck)\n\n----------------------------------------------------------------\n\ncalculate :: Deck -> Array (NonEmptyArray Condition) -> BigInt\ncalculate deck conditions = do\n  let drawPattern = generateDrawPatterns deck\n  let conditionPattern = nubEq $ buildConditionPattern =<< conditions\n  let pattern = filter (\\dp -> any (satisfyCondition dp) conditionPattern) drawPattern\n  sum $ calculatePatternCount deck <$> pattern\n\nnormalizeDeck :: Deck -> Array (NonEmptyArray Condition) -> Deck\nnormalizeDeck deck conditions = do\n  let used = usedCards conditions\n  let unused = diffCards deck.cards used\n  deck { cards = used, others = deck.others + sumBy _.count unused }\n  where\n  usedCards = nubByEq ((==) `on` _.id) <<< concatMap (_.cards <<< unwrap) <<< concatMap toArray\n  diffCards = foldr $ deleteBy ((==) `on` _.id)\n\ncalculateTotal :: Deck -> BigInt\ncalculateTotal { cards, others, hand } = combinationNumber (sumBy _.count cards + others) hand\n\n----------------------------------------------------------------\n\n-- 各カードをそれぞれ何枚引いているかの状態を表す\ntype DrawPattern = Array { card :: Card, draw :: Int }\n\ngenerateDrawPatterns :: Deck -> Array DrawPattern\ngenerateDrawPatterns { cards, others, hand } = do\n  let zeroDrawPattern = { card: _, draw: 0 } <$> cards\n  let maxDrawCount = min hand (sumBy _.count cards)\n  let maxPatternLength = others - (hand - maxDrawCount) + 1\n  ado\n    drawPattern <- mkDrawPattern' cards <<< concat <<< take maxPatternLength $ partitionNumbers maxDrawCount\n    in unionBy ((==) `on` _.card.id) drawPattern zeroDrawPattern\n\ncalculatePatternCount :: Deck -> DrawPattern -> BigInt\ncalculatePatternCount { others, hand } pattern = do\n  let patternCount = product $ pattern <#> \\{ card: { count }, draw } -> combinationNumber count draw -- 条件のカードを引くときの組み合わせの数\n  let drawCount = sumBy _.draw pattern\n  patternCount * combinationNumber others (hand - drawCount) -- 残りの手札に条件外のカードを引く組み合わせの数\n\n----------------------------------------------------------------\n\n-- 各カードを何枚まで引いて良いかの条件の組み合わせを表す\ntype ConditionPattern = Array { card :: Card, min :: Int, max :: Int }\n\nsatisfyCondition :: DrawPattern -> ConditionPattern -> Boolean\nsatisfyCondition dp = all \\{ card: { id }, min, max } -> fromMaybe false ado\n  { draw } <- find (_.card.id >>> (_ == id)) dp\n  in min <= draw && draw <= max\n\n-- 一列の条件を満たすパターンのリストを生成\nbuildConditionPattern :: NonEmptyArray Condition -> Array ConditionPattern\nbuildConditionPattern conditions = do\n  let patterns = mkConditionPattern <$> conditions\n  foldl1 <@> patterns $ \\left right -> do\n    l <- left\n    r <- right\n    let merged = mergeConditionPattern l r\n    if isValidConditionPattern merged then pure merged else empty\n\nmergeConditionPattern :: ConditionPattern -> ConditionPattern -> ConditionPattern\nmergeConditionPattern left right = foldl1 merge <$> groupAllBy (comparing _.card.id) (left <> right)\n  where\n  merge { card, min: min1, max: max1 } { min: min2, max: max2 } = { card, min: min1 + min2, max: min max1 max2 }\n\nisValidConditionPattern :: ConditionPattern -> Boolean\nisValidConditionPattern = all \\{ card: { count }, min, max } -> min <= max && min <= count\n\n-- Condition に対応する全パターンのリストを出力する\nmkConditionPattern :: Condition -> Array ConditionPattern\nmkConditionPattern (Condition { mode, count, cards }) = case mode of\n  -- cards の中から count 枚以上を引くパターン\n  AtLeast -> ado\n    pattern <- mkDrawPattern cards count\n    in pattern <#> \\p -> { card: p.card, min: p.draw, max: p.card.count }\n  -- cards の中からちょうど count 枚を引くパターン\n  JustDraw -> ado\n    pattern <- mkDrawPattern cards count\n    let cond = pattern <#> \\p -> { card: p.card, min: p.draw, max: p.draw }\n    in unionBy ((==) `on` _.card.id) cond $ { card: _, min: 0, max: 0 } <$> cards -- fill others with zero\n  -- count 枚以上デッキに残すパターン\n  Remains -> ado\n    pattern <- mkDrawPattern cards (sumBy _.count cards - count)\n    let cond = pattern <#> \\p -> { card: p.card, min: 0, max: p.draw }\n    in unionBy ((==) `on` _.card.id) cond $ { card: _, min: 0, max: 0 } <$> cards\n  -- ちょうど count 枚デッキに残すパターン\n  JustRemains ->\n    mkConditionPattern (Condition { mode: JustDraw, count: (sumBy _.count cards - count), cards })\n  -- cards の中から count 種類以上を1枚以上引くパターン\n  Choice -> ado\n    pattern <- mkDrawPattern' cards [replicate count 1]\n    in pattern <#> \\p -> { card: p.card, min: 1, max: p.card.count }\n  -- cards の中から count 種類以上を1枚以上残すパターン\n  LeftOne -> ado\n    pattern <- mkDrawPattern' cards [replicate count 1]\n    in pattern <#> \\p -> { card: p.card, min: 0, max: p.card.count - 1 }\n  -- cards の中から count 種類以上を1枚も引かないパターン\n  LeftAll -> ado\n    pattern <- mkDrawPattern' cards [replicate count 0]\n    in pattern <#> \\p -> { card: p.card, min: 0, max: 0 }\n\n-- カードを指定枚数引く全ての組み合わせを列挙する\nmkDrawPattern :: Cards -> Int -> Array DrawPattern\nmkDrawPattern cards count = mkDrawPattern' cards $ partitionNumber count\n\n-- 指定の枚数パターンに合致するカードの組み合わせを全て列挙する\nmkDrawPattern' :: Cards -> Combination Int -> Array DrawPattern\nmkDrawPattern' _ [] = []\nmkDrawPattern' _ [[]] = [[]]\nmkDrawPattern' cards pattern = do\n  let cardsLength = length cards\n  let cardCounts = sortBy (flip compare) $ _.count <$> cards\n  let pattern' = filter (and <<< zipWith (>=) cardCounts) $ sortBy (flip compare) <$> filter (length >>> (_ <= cardsLength)) pattern\n  let maxPatternLength = fromMaybe 0 <<< maximum $ length <$> pattern'\n  let cardCombinations = combinations <@> cards <$> 0 .. maxPatternLength\n  p <- pattern'\n  let len = length p\n  let con = fold $ cardCombinations !! len\n  p' <- p # case length (group p) of\n    1            -> pure\n    n | n == len -> permutations\n    _            -> nubEq <<< permutations\n  filter (all \\d -> d.draw <= d.card.count) $ zipWith { draw: _, card: _ } p' <$> con\n\n----------------------------------------------------------------\n\nsumBy :: forall a. (a -> Int) -> Array a -> Int\nsumBy = alaF Additive foldMap\n","/* @globals self */\n\nexport function location() {\n  return self.location;\n}\n\nexport function navigator() {\n  return self.navigator;\n}\n\nexport function postMessageImpl(data) {\n  return function(tr) {\n    return function () {\n      self.postMessage(data, tr.length > 0 ? tr : undefined);\n    };\n  };\n}\n\nexport function close() {\n  self.close();\n}\n\nexport function onMessage(f) {\n  return function () {\n    self.onmessage = function (ev) {\n      f(ev)();\n    };\n  };\n}\n\nexport function onMessageError(f) {\n  return function () {\n    self.onmessageerror = function (ev) {\n      f(ev)();\n    };\n  };\n}\n\nexport function onError(f) {\n  return function () {\n    self.onerror = function (ev) {\n      f(ev)();\n    };\n  };\n}","module Web.Worker.GlobalScope\n  ( close\n  , location\n  , navigator\n  , onError\n  , onMessage\n  , onMessageError\n  , postMessage\n  , postMessage'\n  ) where\n\nimport Prelude\nimport Effect (Effect)\nimport Web.Worker.Navigator (Navigator)\nimport Web.Worker.Location (Location)\nimport Web.Event.Event (Event)\nimport Web.Worker.MessageEvent (MessageEvent)\nimport Web.Worker.Types (Transferable)\n\nforeign import location :: Effect Location\n\nforeign import navigator :: Effect Navigator\n\nforeign import postMessageImpl :: forall msg. msg -> Array Transferable -> Effect Unit\n\npostMessage :: forall msg. msg -> Effect Unit\npostMessage msg = postMessageImpl msg []\n\npostMessage' :: forall msg. msg -> Array Transferable -> Effect Unit\npostMessage' = postMessageImpl\n\n\nforeign import close :: Effect Unit\n\nforeign import onMessage :: (MessageEvent -> Effect Unit) -> Effect Unit\n\nforeign import onMessageError :: (MessageEvent -> Effect Unit) -> Effect Unit\n\nforeign import onError :: (Event -> Effect Unit) -> Effect Unit\n","export function data_(ev) {\n  return ev.data; \n}\n\nexport function origin(ev) {\n  return ev.origin; \n}\n\nexport function lastEventId(ev) {\n  return ev.lastEventId;\n}\n\nexport function ports(ev) {\n  return ev.ports;\n}","module Worker.Main where\n\nimport Prelude\n\nimport Data.Argonaut.Decode (decodeJson, printJsonDecodeError)\nimport Data.BigInt as BigInt\nimport Data.Either (Either(..))\nimport Effect (Effect)\nimport Effect.Class.Console as Console\nimport Foreign (unsafeFromForeign)\nimport SharedTypes (TcgCalculatorWorkerParam)\nimport TcgCalculator as TC\nimport Web.Worker.GlobalScope as Worker\nimport Web.Worker.MessageEvent as MessageEvent\n\n----------------------------------------------------------------\n\nmain :: Effect Unit\nmain = do\n  Worker.onMessage \\event -> do\n    case decodeJson @TcgCalculatorWorkerParam <<< unsafeFromForeign $ MessageEvent.data_ event of\n      Left error -> Console.error $ printJsonDecodeError error\n      Right { deck, conditions } -> do\n        let result = TC.calculate deck conditions\n        Worker.postMessage $ BigInt.toString result\n","import { main } from './output/Worker.Main/index.js'; main();"],"names":["foldMap22","add4","decoder","$60","$61","$63","$64","$79","cb","mod2","v","moduleName","val","state2","pure1","fn","def","just","bindFlipped1","d","$52","$84","f2","compare32","compare5","map12","eq22","foldl22","dictSemiring","semigroupAdditive1","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","require_BigInteger","exports","module","bigInt2","undefined2","MAX_INT_ARR","smallToArray","DEFAULT_ALPHABET","supportsNativeBigInt","BigInt","Integer","radix","alphabet","caseSensitive","parseBase","parseValue","BigInteger","value","sign2","sign","isSmall","SmallInteger","NativeBigInt","isPrecise","n","Math","floor","arrayToSmall","arr","trim2","length4","length","compareAbs","i2","createArray","x","Array","truncate","ceil","a","b","sum3","l_a","l_b","r","carry","push","addAny","addSmall","l","subtract","difference3","a_l","b_l","borrow","subtractSmall","multiplyLong","product5","a_i","j","multiplySmall","shiftLeft","concat","multiplySmallAndArray","square","divModSmall","lambda","q","remainder2","divisor","quotient","divModAny","self2","Error","negate","abs4","abs","comparison","divMod1","quotientDigit","shift","result","divisorMostSignificantDigit","base","divMod2","guess","xlen","highx","highy","check","part","unshift","reverse","qSign","mSign","isBasicPrime","isUnit","equals","isEven","isDivisibleBy","lesser","millerRabinTest","nPrev","prev","divide","next","modPow","mod","add","plus","minus","small","multiply","l1","l2","multiplyKaratsuba","y","max","slice","c","ac","bd","abcd","times","_multiplyBySmall","divmod","remainder","over","pow","toString","_0","_1","_2","isNegative","exp2","isZero","modInv","isPositive","isOdd","compare","Infinity","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","geq","lesserOrEquals","leq","isPrime","strict","bits","bitLength","logN","log","toJSNumber","t","isProbablePrime","iterations","rng","randBetween","lastT","lastR","zero","newT","one","newR","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","xSign","ySign","xRem","not","yRem","xDigit","yDigit","xDivMod","yDivMod","roughLOB","max3","min5","gcd","String","shiftRight","remQuo","and","or","xor","integerLogarithm","tmp","p","e","text","toLowerCase","absBase","alphabetValues","digits","start","parseBaseFromArray","pow4","toBase2","apply","map","valueOf","neg","Number","out","left","digit","toBaseString","join","parseStringValue","split2","split","decimalPlace","indexOf","test","max4","min6","parseNumberValue","toArray","str","zeros","toJSON","parseInt","i","minusOne","min","lcm","isInstance","usedRNG","random","low","range3","high","restricted","top3","fromArray","define","amd","semigroupoidFn","compose","g","identity","dict","categoryFn","Semigroupoid0","on","flip","$$const","unit","$$Proxy","$$Proxy2","mapFlipped","dictFunctor","fa","$$void","functorFn","functorArray","applyArray","fs","xs","k","Functor0","pure","liftA1","dictApplicative","apply2","Apply0","bindArray","bind","bindFlipped","dictBind","_caseJson","isNull3","isBool","isNum","isStr","isArr","isObj","call","refEq","r1","r2","reflectSymbol","eqString","eqRecord","eqInt","eqArray","dictEq","ys","eqRowCons","dictEqRecord","eqRecord1","dictIsSymbol","reflectSymbol2","eq32","ra","rb","label","tail2","get2","rec","semigroupArray","append","fromCharCode","unsafeCompareImpl","eq4","LT","LT2","GT","GT2","EQ","EQ2","eqOrdering","v1","mul","ordString","ordStringImpl","Eq0","ordInt","ordIntImpl","dictOrd","constructor","name","boundedInt","top","bottom","identity2","Nothing","Nothing2","Just","Just2","value0","maybe","v2","functorMaybe","map2","fromMaybe","applyMaybe","newSTRef","read","ref","write","ap","dictMonad","bind5","Bind1","pure3","Applicative0","f$prime","a$prime","Left","Left2","Right","Right2","note","functorEither","m","map3","applyEither","bindEither","either","applicativeEither","monoidArray","mempty","Semigroup0","$runtime_lazy","name2","init3","lineNumber","ReferenceError","monadEffect","applicativeEffect","bindEffect","$lazy_applyEffect","$lazy_functorEffect","modify","s","s$prime","state","functorST","monadST","applicativeST","bindST","$lazy_applyST","replicateImpl","fill","count","fromFoldableImpl","Cons2","head3","head","tail","emptyList","curryCons","foldr3","listToArray","list","xss","sortByImpl","fromOrdering","mergeFromTo","xs1","xs2","from2","to","mid","unsafeFreeze","heytingAlgebraBoolean","ff","tt","implies","disj","conj","b1","b2","map4","not2","$$void2","Iterator","Iterator2","value1","peek","Tuple","Tuple2","identity3","lmap","dictBifunctor","bimap1","bimap","bifunctorEither","Conj","semigroupConj","dictHeytingAlgebra","conj2","monoidConj","semigroupConj1","unsafeCoerce2","alaF","identity4","eq12","alaF2","foldr","foldl","maximumBy","dictFoldable","cmp","product","foldableMaybe","foldMap","dictMonoid","mempty2","foldMapDefaultR","foldr22","append5","acc","foldableArray","len","fold","runFn2","runFn3","runFn4","mapWithIndex","functorWithIndexArray","traverseArrayImpl","array1","array2","array3","concat2","map10","array","go","bot","pivot","identity5","traverse","sequenceDefault","dictTraversable","traverse2","traversableArray","sequence","Foldable1","foldl1","foldMap1DefaultL","dictFoldable1","foldl11","dictSemigroup","$162","$163","$164","$$void3","map5","map22","fromJust2","when2","eq13","foldMap1","append2","zipWith","unsafeIndex1","uncons","empty5","next2","sortBy","comp","singleton2","replicate","range2","end","step","insertAt","runFn5","nothing","splice","index","groupBy","op","iter","iterate","iterator","$$break","mx","sub1","pushWhile","groupAllBy","$186","$187","$188","foldl2","findIndex","filter","deleteAt","cons","any2","nubByEq","foreach","$194","$195","as","nubEq","unionBy","all2","foldr8","mapWithIndex2","foldl8","foldMapWithIndexDefaultR","dictFoldableWithIndex","foldrWithIndex1","foldrWithIndex","foldableWithIndexArray","z","$291","$292","$293","foldlWithIndex","$294","$295","$296","foldMapWithIndex","Foldable0","traverseWithIndexDefault","dictTraversableWithIndex","sequence2","Traversable2","mapWithIndex4","FunctorWithIndex0","sequence12","$174","$175","traversableWithIndexArray","traverseWithIndex","FoldableWithIndex1","lookup","no","yes","toJsonType","verbJsonType","toObject","TypeMismatch","TypeMismatch2","UnexpectedValue","UnexpectedValue2","AtIndex","AtIndex2","AtKey","AtKey2","Named","Named2","MissingValue","MissingValue2","printJsonDecodeError","err","JSON","stringify","foldable1NonEmptyArray","foldr1","foldl12","toNumber","isFiniteImpl","isFinite","top2","bottom2","fromNumber","fromNumberImpl","Nil","Nil2","Cons","foldableList","$copy_v","rev","$copy_v1","$tco_result","$tco_var_v","$tco_done","$tco_loop","$284","$285","$copy_b","$tco_var_b","$tco_done1","append22","$286","$287","head2","Symbol","fromCodePoint","codePointAt","map6","lmap2","composeKleisliFlipped2","traverse12","traverseWithIndex2","decodeString","caseJsonString","decodeNumber","caseJsonNumber","decodeJArray","$53","decodeInt","$85","decodeArray","$89","$90","$92","$93","$91","insert3","unsafeSet","copy","key","bind2","lmap3","map7","gDecodeJsonNil","gDecodeJson","decodeRecord","dictGDecodeJson","gDecodeJson1","decodeJson","json","decodeJsonString","decodeJsonInt","gDecodeJsonCons","dictDecodeJsonField","decodeJsonField1","decodeJsonField","insert5","object","fieldName","rest","decodeFieldId","dictDecodeJson","decodeJson1","decodeArray2","import_big_integer","__copyProps","except","desc","get","enumerable","fromInt","default","biMod","semiringBigInt","add2","ringBigInt","sub","Semiring0","sub2","commutativeRingBigInt","Ring0","euclideanRingBigInt","div","biDiv","yy","degree","$13","CommutativeRing0","monadEffectEffect","liftEffect","Monad0","bind3","mapFlipped2","fold2","add3","append3","zero2","one2","map8","bind1","product3","min3","div2","fromFoldable5","permutations","pascalTriangle","combinations","combinationNumber","$59","product$prime","buildPartitionNumbers","$$new2","v3","$62","regex_default","validate_default","uuid","byteToHex","parse_default","TypeError","Uint8Array","ROTL","v5","v35","version","hashfunc","generateUUID","namespace","buf","offset","_namespace","stringToBytes","unescape","encodeURIComponent","bytes","charCodeAt","set","unsafeStringify","DNS","URL","K","H","msg","isArray","N","M","Uint32Array","W","T","f","compare2","genv5UUID","v5_default","eqUUID","countIsSymbol","eq2","compare3","bindFlipped2","decodeJson2","mapFlipped3","gDecodeJsonCons2","Id","AtLeast","AtLeast2","JustDraw","JustDraw2","Remains","Remains2","JustRemains","JustRemains2","Choice","Choice2","LeftOne","LeftOne2","LeftAll","LeftAll2","eqId","namespaceTcgCalculator","decodeJsonId","id2","maybe$prime","validateV4UUID","decodeJsonCondition","$263","$264","map9","eq3","compare4","map1","and3","all1","greaterThanOrEq2","a1","a2","maximum2","maximum","flap2","ff2","bind4","fold3","group4","pure2","nubEq3","mapFlipped4","min4","comparing2","append4","product4","mul2","map23","empty4","eqRec2","eqRowCons2","nubEq1","bindFlipped3","sum2","sum","sumBy","mkDrawPattern$prime","$177","cardsLength","cardCounts","pattern$prime","$178","$179","maxPatternLength","cardCombinations","con","$180","p$prime","draw","card","mkDrawPattern","cards","mkConditionPattern","mode","cond","id","isValidConditionPattern","generateDrawPatterns","zeroDrawPattern","maxDrawCount","hand","others","buildConditionPattern","conditions","patterns","right","merged","postMessage","tr","self","gDecodeJsonCons3","decodeJson3","cons$prime","$65","error4","$80","console","error","main","event","deck","unsafeFromForeign","ev","data","calculate","drawPattern","conditionPattern","pattern","dp","find2","$171","patternCount","drawCount","onmessage","bigInt","undefined","trim","difference","exp","range","toBase","isNull","empty","from","runSTFn1","runSTFn2","__do","init","unsafeCoerce","singleton","find","any","all","traverse1","composeKleisliFlipped","insert","size","$$new","fromFoldable","greaterThanOrEq","flap","group","comparing"],"version":3,"file":"worker.js.map"}