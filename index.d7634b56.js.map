{"mappings":"A,C,S,E,E,E,I+BwI0B,EAMG,EAMC,EkI4I9B,ExGlOA,E,E,E,E,EoB7DmBigB,E,E,E,E,E,E,E/B4DnB,EAKuB,E,E,E,E,E,E,EgCmGb,EoG9FoB,EnGuDb,E,EHgFP,EyDzFV,E,E/DqRwB,E,E,E,ER5TkB,ES2BV,E,E,E,EgBonB9B4mE,EAhBA,EAQA,E,E,E,EyBxsBwC,EAbF,EG+WtC,E,E,E,GvGvRoB,G,G,G,G,GqHjBtB,GlH0D2B,GkJsCjB,GA6CA,GAkBI,GAMD,GAGC,GAGL,GClFC,GAAA,GAAA,GAHD,GS3CT,GAbA,GALA,GK4Ge,GAzHH,GLQZ,GsBnEU,GCmBG,GCQE,GAAA,G,G9BoCb,GAtCe,GgCsBf,GAsEA,GA0BAjC,GA9BE,GAJA,GC7HyB,GS0CrB,GzI4UE,G,G0EhSE,GAwBG,GmEpDbA,GrCoHa,G9FmPa,G,G,GyE1X5B,G,G,G2D8DE,GAsCc,GAAA,GADd,GAKA,GAKAA,GA1CAoD,G9I+GK,G0J7DL,GALA,GAhBA,GAyFA,GAGA,GAlEAA,GG5JU,GpNwGD,GJ3CG,G8N9C2C,GAAA,GAA/C,G,GJNF,GKiFN,GALA,GA4BA,GAIAA,G,G,G,GrGuBF,G,G,G,G,G,G,G,G4GvEa,GAqCC,G3DpHV,G,G,O,M,C,G,O,c,C,G,O,wB,C,G,O,mB,C,G,O,c,C,G,O,S,C,c,CpLHJ,I,EAAA,CAAA,yCAAA,CAAA,CAAA,CAAA,EAAA,IAAIlD,EAAU,SAAUC,CAAAA,EAGpB,IAGI,EAAc,EADJ,kBAEV,EAAmB,uCAEnB,EAAuB,AAAkB,YAAlB,OAAO,OAElC,SAAS,EAAQ,CAAA,CAAG,CAAA,CAAO,CAAA,CAAU,CAAA,SACjC,AAAI,AAAa,KAAA,IAAN,EAA0B,CAAA,CAAQ,EAAf,CACT,KAAA,IAAV,GAA8B,CAAA,AAAW,IAAX,CAAC,GAAiB,CAAA,EAA2B,EAAU,EAAG,EAAO,EAAU,GAA9C,EAAW,EAErF,CAEA,SAAS,EAAWr8E,CAAAA,CAAOC,CAAAA,EACvB,IAAA,CAAK,KAAA,CAAQD,EACb,IAAA,CAAK,IAAA,CAAOC,EACZ,IAAA,CAAK,OAAA,CAAU,CAAA,CACnB,CA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zB,EAAA,EAAA,MAAA,EAAApoC,EAAAooC,GAAAuzB,GAAA,EAAA,MAAA,E,C,C,C,EAmBF,CAAA,SAAA,SAAA,CAAA,E,I,E,G,GAAA,OAAA,SAAAvzB,CAAAA,EAAA,OAAA,SAAA,CAAA,EACW,OAAA5nC,EAAqB,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAS,OAAA,EAAA,GAAvC4nC,EAA8C,G,CAA9CA,GAAAA,EAAA,EAAA,MAAA,GAAA,EAAA,MAAA,C,C,C,EADF,OAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EAES,OAAA,GAAP,EAAA,MAAA,EAAAA,EAAA,EAAA,MAAA,GAAApoC,EAA4C,SAAA,CAAA,EAAO,IAAA,EAAA,GAAe,GAAlEooC,EAAwE,IAArB,OAAA,SAAA,CAAA,EAAS,OAAA,GAAA,MAAA,CAAA,EAAT,G,CAAnD,GAAA,GAAA,KAAA,EAAA,EAAA,MAAA,E,C,EAFF,OAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EAGS,OAAA5nC,EAAP4nC,GAAA,EAAA,MAAA,EAAA,EAAA,MAAA,C,C,EAHF,UAAA,W,O,C,C,GCUA,GAAA,C,I,GAAA,SAAA,W,O,E,C,EAGA,GAAA,C,M,G,K,CAAA,KAAA,W,O,E,C,E,G,S,C,C,C,C,C,E,I,E,E,E,O,S,C,E,G,A,I,E,O,E,G,A,I,E,M,A,e,E,uD,E,U,E,I,E,G,O,E,E,E,I,E,E,C,C,E,G,G,I,G,G,ICzFA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,E,C,C,C,C,C,C,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,E,E,E,C,C,C,C,C,E,C,IAoqBA,GAAA,W,S,E,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,C,C,E,C,IAZA,GAAA,W,S,E,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,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,G,G,I,G,M,E,G,K,EA3UA59D,G,G,K,CApGA,GAAA,SAAA,CAAA,E,I,EAHA,CACQ,IA4bA,G,GAAA,IA7bR,SAAA,W,O,E,C,EAGA,MAAA,CACUA,MAAAA,GADV,KAAA,W,O,C,C,C,ECnFA,GAAA,SAAA,CAAA,E,I,EnEnBE,A,EAAA,GAAA,CmEmBF,MAAA,CAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EACU,OAAAkL,EAAR,GAAA,E,C,C,C,EAEF,GAAA,SAAA,CAAA,E,I,E,G,E,I,IAAA,MAAA,C,O,G,GAAA,WAAA,W,O,C,C,C,EChDA,GAAA,W,S,E,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,C,C,E,C,IAQA,GAAA,SAAA,CAAA,E,O,G,M,C,G,E,G,K,G,G,EANA,GAAA,CAAA,GAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EACM,OAAJ,EAAA,MAAA,CAAA,EAAA,MAAA,EAAA,EAAA,MAAA,C,C,C,E,G,C,E,G,I,E,G,A,G,G,I,EpCWF,SAAA,CAAA,E,I,E,G,GAAA,MAAA,C,G,S,C,E,O,S,C,E,O,E,E,M,E,E,M,G,E,E,M,E,E,M,C,C,C,C,EAQA,SAAA,CAAA,E,I,E,G,G,E,E,E,G,IAAA,MAAA,C,Q,S,C,E,O,S,C,EAAA,IAAA,EAAAxjB,EAAA,EAAA,MAAA,EAAA,EAAA,MAAA,SAAA,AAAA,aAAA,G,G,K,CAAA,aAAA,G,G,K,C,E,E,M,E,E,M,C,C,E,I,W,O,C,C,C,GoCjBA,CAAA,QAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EACW,OAAT,EAAA,MAAA,CAAA,EAAA,MAAA,EAAA,EAAA,MAAA,C,C,EADF,IAAA,W,O,E,C,G,I1DyH0B,EAAA,G,IAMG,EAAA,G,IAMC,EAAA,G,I,EAD9B,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,SAAA,CAAA,AAAAmiD,EAC0B,GAAa,cADvC,EAAA,C,C,EwDwOA,SAAA,CAAA,MAGA,E,M,CAAA,E,G,E,U,IAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAAb,CAAAA,EAGI,IAAA,EAAA,WAEI,GADG,aAAA,GACE,OACH,SAAA,CAAA,MxD7PV,EwD6PgB,MAAA,CxD7PhB,EwD6PgB,ExD7PhB,SAAA,CAAA,SAAA,AAAAa,EACsB,GAAa,cADnC,E,GwD2PW,EAAA,MAAA,C,EAGH,GAHG,aAAA,GAIK,OAAA,GAAA,CAAA,EAJL,OAAA,AAAA,MAAA,yFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,IAMP,EAAA,WAEI,GADG,aAAA,GACE,OACH,SAAA,CAAA,MxD9PV,EwD8PgB,MAAA,CxD9PhB,EwD8PgB,ExD9PhB,SAAA,CAAA,SAAA,AAAAA,EACyB,GAAa,cADtC,E,GwD4PW,EAAA,MAAA,C,EAGH,GAHG,aAAA,GAIK,OAAA,GAAA,CAAA,EAJL,OAAA,AAAA,MAAA,yFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,IAMP,EAAA,WAEI,GADG,aAAA,IAAM,aAAA,GACQ,OACf,SAAA,CAAA,EAFC,OAAA,EAAA,EAAA,MAAA,EAEc,IAAA,EAAK,GAFb,EAAA,MAAA,C,EAGT,GAHG,aAAA,IAAM,aAAA,GAIP,OAAA,SAAA,CAAA,EAJC,OAAA,EAAA,EAAA,MAAA,EAIc,E,EACjB,GALG,aAAA,IAAM,aAAA,GAKK,OACZ,SAAA,CAAA,EAAM,OAAA,EAAA,GANC,EAAA,MAAA,C,EAOT,GAPG,aAAA,IAAM,aAAA,GAQD,OAAA,GAAA,CAAA,EARL,OAAA,AAAA,MAAA,yFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAM,EAAA,WAAA,CAAA,IAAA,CAAA,C,IAUb+zB,EAAK,SAAA,CAAA,EACH,GAAA,aAAA,GACE,OAAA,EACF,GAAA,aAAA,GAAK,OAGF,EADA,EADY,AAAG,EAAA,EAAA,MAAA,EAAgB,EAAiBA,EAAA,EAAA,MAAA,GACrC,AAAG,EAAA,EAAA,MAAA,EAAgB50B,EAAA,EAAA,MAAA,EAAA,EAAA,MAAA,EAAW,IAC9B,AAAG,EAAA,EAAA,MAAA,EAAgB,EAAiB40B,EAAA,EAAA,MAAA,E,O,A,M,0F,C,E,W,C,I,C,C,EAEpDA,OAAAA,C,C,C,C,G,G,G,G,I,E,G,IAoFJ,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAA,IAAA,EAE6B,GAAAl2E,EAAoB,EAAE,GAA5C,OAAAsE,GACA,SAAAmsC,CAAAA,EAAYA,OAAAA,IAAAA,GAAAA,EAAU,GAH7B,EAAA,MAAA,CAAA,EAAA,MAAA,EAAA,GAAA,EAAA,MAAA,C,C,G,G,G,I,G,G,IGjcAlqB,GAAA,WAAA,OAAA,SAAA,CAAA,E,I,E,G,GAAA,OAAA,SAAA,CAAA,E,I,E,G,GAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EASO,OAAA,GAAA,IAAA,GAAA/b,EAAP,GAAAod,EAAA,KAAA,E,C,C,C,C,C,ECfa,GAAW,SAAU,CAAA,EAChC,OAAO,SAAU,CAAA,EACf,OAAO,EAAG,IAAA,CAAK,EACjB,CACF,EC7BAnK,GAAA,SAAA,CAAA,EACS,MAAA,AAAK,KAAL,C,ECnBT,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IA2BA,GACkB,SAAA,CAAA,EAChB,GAAA,aAAA,GAAe,MAAA,SACf,GAAA,aAAA,GAAiB,MAAA,WACjB,GAAA,aAAA,GAAc,MAAA,QACd,GAAA,aAAA,GAAa,MAAA,OACb,GAAA,aAAA,GAAsB,MAAA,iBACtB,GAAA,aAAA,GAAc,MAAA,QACd,GAAA,aAAA,GAAa,MAAA,OACb,GAAA,aAAA,GAAe,MAAA,SACf,GAAA,aAAA,GAAc,MAAA,QACd,GAAA,aAAA,GAAc,MAAA,QACd,GAAA,aAAA,GAAe,MAAA,SACf,GAAA,aAAA,GAAiB,MAAA,WACjB,GAAA,aAAA,GAAc,MAAA,QACd,GAAA,aAAA,GAAc,MAAA,QACd,GAAA,aAAA,GAAc,MAAA,QACd,GAAA,aAAA,GAAe,MAAA,SACf,GAAA,aAAA,GAAe,MAAA,SACf,GAAA,aAAA,GAAY,MAAA,MACZ,GAAA,aAAA,GAAa,MAAA,OACb,GAAA,aAAA,GAAa,MAAA,OACb,GAAA,aAAA,GAAY,MAAA,MACZ,GAAA,aAAA,GAAa,MAAA,M,O,A,M,iG,C,E,W,C,I,C,C,E,G,G3DnBf,C,KD/B8B,SAAU,CAAA,EACtC,IAAI,EAAM,EAAE,QAAA,GACZ,OAAO,MAAM,EAAM,MAAQ,EAAM,EAAM,IACzC,C,G6DHA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAOA,GACkB,SAAA,CAAA,EAChB,GAAA,aAAA,GAAO,MAAA,MACP,GAAA,aAAA,GAAK,OAAA/O,GAAA,EAAA,MAAA,C,O,A,M,iG,C,E,W,C,I,C,C,ECAP,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IE0CA,GAAA,GDtDiB,MAOV,SAAiB,CAAA,EACtB,OAAO,CACT,GCmDA,GAAA,SAAA,CAAA,MDzD4B,EAAG4yC,EC0DH,OD1DA,EC0DA,GAAA,KAAA,CD1DGA,EC0DH,GAAA,MAAA,CDzDnB7Q,AAAK,MCyDc,EDzDP,EAAI6Q,ECyDG,E,EC7C5B50B,GAAA,W,S,E,C,C,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,E,C,C,C,E,C,IAeA,GACgB,SAAA,CAAA,CAAA+jB,CAAAA,EAAiDA,OAAAA,EAAAA,MAAAA,CAAAA,EAAAA,MAAAA,CAAAA,E,EAMjE,GACgB,SAAA,CAAA,E,O,E,M,C,E,M,C,EAZhBimC,GACU,AALVT,GAKiB,SAAA,CAAA,EAAE,OAAA,EAAA,MAAA,A,G,G,G,I,G,G7CoDnB,C,I,S,C,E,O,S,C,E,O,I,G,E,M,C,E,E,M,E,C,C,G8CzDA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,E,C,C,C,E,C,IAAA,GAAA,W,S,E,C,C,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,E,C,C,C,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAqCA,GAAA,W,S,E,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,C,C,E,C,IASA,GAAA,SAAA30B,CAAAA,EAKY,OAAA,SAAA,CAAA,EAAAA,OAAAA,EAAA,E,C,E,G,GAjBZ,CAAA,MAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EACc,OAAA,GAAQ,SAAA,CAAA,EAAE,OAAiB,AAKzC20B,GALyC,IAAA,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,CAAA,EAC/B,OAAO,SAAU,CAAA,EACf,OAAO,SAAU,CAAA,EACf,OAAO,SAAU+X,CAAAA,EACf,OAAO,WACL,OAAOA,EAAO,gBAAA,CAAiB,EAAM,EAAU,EACjD,CACF,CACF,CACF,CACF,CAEO,SAAS7X,GAAoB,CAAA,EAClC,OAAO,SAAU,CAAA,EACf,OAAO,SAAU,CAAA,EACf,OAAO,SAAU6X,CAAAA,EACf,OAAO,WACL,OAAOA,EAAO,mBAAA,CAAoB,EAAM,EAAU,EACpD,CACF,CACF,CACF,CACF,C,I,G,S,C,C,C,C,C,E,I,E,E,E,O,S,C,E,G,A,I,E,O,E,G,A,I,E,M,A,e,E,uD,E,U,E,I,E,G,O,E,E,E,I,E,E,C,C,ECEA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAXA,GAAA,W,S,E,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,C,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAmJA,GACe,SAAA,CAAA,EACb,GAAA,aAAA,IAAA,EAAA,MAAA,YAAA,GAAiB,MAAwB,QAAA,EAAA,MAAA,CAAA,MAAA,CAAiB,IAAA,EAAA,MAAzC,CACjB,GAAA,aAAA,GAAU,MAAW,SAAA,EAAA,MAAX,CACV,GAAA,aAAA,GAAS,MAAS,QAAA,EAAA,MAAT,CACT,GAAA,aAAA,GAAS,MAAsB,WAAA,EAAA,MAAtB,CACT,GAAA,aAAA,GAAI,MAAI,K,O,A,M,8F,C,E,W,C,I,C,C,ECjKV,GAAA,SAAA,CAAA,EAAA,OAAA,C,ECwBA,GAAA,SAAA,CAAA,EAAA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A,C,O,A,M,mF,C,E,W,C,I,C,C,EATD,SAYK,SAAA,CAAA,EACf,GAAA,aAAA,GAAK,OAAA,EAAA,MAAA,CACL,GAAA,aAAA,GAAM,OAAA,GAAqB,wB,O,A,M,mF,C,E,W,C,I,C,C,EAbhB,UAgBK,SAAA,CAAA,EAChB,GAAA,aAAA,GAAM,OAAA,EAAA,MAAA,CACN,GAAA,aAAA,GAAK,OAAA,GAAqB,wB,O,A,M,mF,C,E,W,C,I,C,C,E,K,G,M,C,M,G,M,A,EAjC9B,GAAA,SAAA,CAAA,EACqC,OJktB5B,WACL,OAAO,GAAI,KAAA,CIntBsB,GJmtBV,KIntBkB,EJotB3C,C,EI78BF,GAAA,C,MJo7BO,SAAsB,CAAA,EAC3B,OAAO,SAAU,CAAA,EACf,OAAO,GAAI,QAAA,CAAS,EAAM,EAC5B,CACF,EIx7BA,SAAA,W,O,E,C,EAnDA,GAAA,CAAA,aAAA,W,O,E,EAAA,MAAA,W,O,E,C,EAHA,GAAA,C,KJs9BO,SAAe,CAAA,EACpB,OAAO,SAAU,CAAA,EACf,OAAO,GAAI,IAAA,CAAK,EAAK,EACvB,CACF,EI19BA,OAAA,W,O,G,E,C,EAHA,GAAA,C,K,GAAA,OAAA,W,O,G,E,C,E,I,G,a,G,E,S,C,E,G,A,I,G,O,G,G,A,I,G,M,A,e,+D,G,U,E,I,G,G,O,G,E,GAHA,C,M,G,IAAA,SAAA,W,O,E,C,E,G,E,E,GAAA,GAAA,GAAA,I,G,G,I,G,G,I,G,G,IAmFA,GAAA,C,S,G,W,GAAA,OAAA,W,O,E,EAAA,OAAA,W,O,E,C,E,G,G,IApBA,GAAA,CACS,KAAA,SAAA,CAAA,EAAA,OAAA,GAAA,GAAA,G,EADT,OAAA,W,O,E,C,EAtBA,GAAA,C,W,GAAA,OAAA,W,O,E,C,E,G,G,IAyGA,GACiB,SAAA,CAAA,EAAA,OAAA,GAAA8c,GAAA,G,EAxBjB,GAAA,SAAA,CAAA,EACW,OAAA,GAAmB,SAAA,CAAA,EAAM,OAAA,GAAA,IAApC,EAAA,IAAA,CAA8D,G,E,EAtB9D,GAAA,CAAA,IAAA,SAAAksC,CAAAA,EAAA,OAAA,SAAA,CAAA,EACiC,OD9KxBA,AC8KwB,GAAA7zB,GAAW6zB,G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M,0F,C,E,W,C,I,C,C,EALFA,OAAAA,C,C,EAbvB,UAAA,W,O,E,C,G,G,G,I,GG3EA,SAAA,CAAA,E,I,E,G,GAAA,OAAA,SAAA,CAAA,E,I,E,G,G,G,KAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAUE,IAAA,EAAA1rE,EAFF,GAA0E0rE,OAAAA,A,GAAAA,EAAAA,GAAAA,KAAAA,EAAAA,GAAAA,KAAAA,EAIxE,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,SAAI,AACA,IADJ,EAAA,MAAA,CAAA,GDlGF,ACkGE,EAAA,MAAA,CDlGF,MAAU,ECkGR,G,E,C,GAJF,G,C,C,C,E,G,KsD+CA,GAAA,SAAA,CAAA,EAAA,OAAA,C,EAgCA,GAAA,SAAA,CAAA,EAAA,OAAA,C,EAzJA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAAj7C,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA+O,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAsCA,GAAA,SAAA,CAAA,EAAA,OAAA,C,EAiDA,GAAA,SAAA,CAAA,EACmC,OAAA,GAAA,IAAA,GAAA,EAAA,I,EAtBnC,GAAA,CACU,MAAA,SAAA,CAAA,EAAA,OAAA,GAAA,GAAA,GAAA,MAAA,CAAA,I,EADV,OAAA,W,OAtBA,E,C,EAIA,GAAA,SAAA,CAAA,EACe,IAAA,EADf,MAAA,CACe,UAAA,EAAA,EAAA,GAAA,GAAA,SAAA,CAAA,EAAA,OAAA,GAAA,GAAA/O,GAAA,MAAA,CAAgC,EAAhC,K,GADf,OAAA,W,OAJA,E,C,C,EA8IA,GAAA,SAAA,CAAA,EACmC,OAAA,GAAA,IAAA,GAAA,EAAA,I,EAbnC,GAAA,SAAA,CAAA,EACmC,OAAA,GAAA,IAAA,GAAA,EAAAj0B,I,EClNnC,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA+lB,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,I,G,S,C,C,C,C,C,E,I,E,E,E,O,S,C,E,G,A,I,E,O,E,G,A,I,E,M,A,e,E,uD,E,U,E,I,E,G,O,E,E,E,I,E,E,C,C,ECyEA,GAAA,SAAA,CAAA,EACU,OAAV,EAAA,MAAA,CAAA,EAAA,MAAA,C,EAcA,GAAA,SAAA,CAAA,EAqBE,IAAA,EACY,SAAApa,CAAAA,EACcA,OAAAA,GAAAA,EAAA,IAAA,C,E,E,G,a,qB,WAVb,OAAA,SAAAA,CAAAA,CAAA,CAAA,EAEX,GA1BY,EAyBoBA,EAAA,KAAA,CAzBpB,EA0BkB,EA1BYtH,AA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p9E,EACPq9E,CACT,CACF,GgJ8EyCllC,GAAE,E,C,C,C,C,C,EAnE7Cx7B,GAAA,SAAA,CAAA,E,I,E,G,GAAA,OAAA,WAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAOmC,OAAA,GAAA,EAAA,IAAG,E,C,C,C,E,G,G,ICzBtC,GAAA,SAAA,CAAA,EACa,OAAA,GAAA,CAAA,GAA2B,YAAe,GAAA,EAAK,EAAA,C,EAP5DqD,GAAA,GAAA,G1H8CA,CACW,OAAA,GADX,WAAA,W,O,E,C,I0HtBAk4B,GAAA,SAAAknC,CAAAA,EAAA,OAAA,SAAAC,CAAAA,EAAA,OAAA,SAAA,CAAA,EAGI,OAAA,GAAA,CAAA,GACI,CAAE,gEACAA,EAAA,EAAA,GAAA,GAEe,IAAA,EAErB,CAAED,EAAA,C,C,C,EAZN,GACalnC,GAAQ,GAAI,kBAAmB,mCAb5C,GACaA,GAAQ,GAAI,YAAa,uDAEtC,GACeA,GAAQ,GAAI,aAAc,mCAEzC,GACeA,GAAQ,GAAI,qBAAsB,mCAEjD,GACWA,GAAQ,GAAI,gBAAiB,mC,G,G,G,K,G,G,I,G,G,I,GpBwDxC,K,G,G,G,K,G,G,GAAA,K,G,G,IqBrC0D,GAAA,GAAA,C,c,W,M,U,C,O,G,G,I,G,GrBoC1D,I,G,G,I,G,GACA,I,G,G,I,G,G,IqBvDA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IANA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAAnD,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,I,GlBmMA,SAAA,CAAA,E,I,E,G,G,E,G,G,E,G,GAAA,OAAA,SAAA,CAAA,E,I,E,E,G,E,E,G,E,E,GAAA,OAAA,SAAAqoC,CAAAA,EAAA,OAAA,SAAAhyE,CAAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAAssC,CAAAA,EAAA,OAAA,SAAA+G,CAAAA,EAYE,OAAA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OAAO,EAAwB,EAAO,GACtC,AAAa,UAAb,OAAO,EAAuB,EAAM,GACpC,AAAa,UAAb,OAAO,EAAuB,EAAM,GACpC,AAAsC,mBAAtC,OAAO,SAAA,CAAU,QAAA,CAAS,IAAA,CAAK,GAC/B,EAAM,GACH,EAAM,EACpB,CCkHA,IAAA,GAKa,CAvCb,GAuCa,GAAA,KAAA,CAvCb,SAAAx2B,CAAAA,EAAA,OAAA,SAAA,CAAA,EACuB,OAAA,EAAE,IAAIA,E,C,GAsChB,GAAA,MAAA,EAwBb,GACW,GAnEX,SAAA,CAAA,EAAA,OAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EAC+C,OAAA,GAAA,GAAA,GAAA,GAAU,GAAA,GAAU,GAAA,GAAU,GAAA,GAAU,GAAGA,EAAE,E,C,C,GA6D5F,GACU,GApEV,SAAA,CAAA,EAAA,OAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EAC8C,OAAA,GAAA,GAAA,GAAA,GAAU,GAAA,GAAU,GAAA,GAAU,GAAGA,EAAA,GAAS,GAAG,E,C,C,G,G,G,ICjG3FlqB,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAsBA,GAAA,SAAA,CAAA,EAIE,IAAA8+C,EAAK,SAAA,CAAA,EACH,GAAA,aAAA9+C,GAAa,MAAM,6BAAA,EAAA,MAAA,CAAsC,KACzD,GAAA,aAAA,GAAgB,MAAO,sBAAA,GAAA,EAAA,MAAA,EAA0C,IACjE,GAAA,aAAA,GAAQ,MAAY,oBAAAH,GAAA,EAAA,MAAA,EAAkC,MAASi/C,EAAA,EAAA,MAAA,EAC/D,GAAA,aAAA,GAAM,MAAa,oBAAA,EAAA,MAAA,CAA+B,OAAWA,EAAA,EAAA,MAAA,EAC7D,GAAA,aAAA,GAAM,MAAc,YAAA,EAAA,MAAA,CAAuB,OAAUA,EAAA,EAAA,MAAA,EACrD,GAAA,aAAA,GAAgB,MAAA,uB,O,A,M,gG,C,E,W,C,I,C,C,EARlB,MAAA,mDAAsDA,EAAG,E,EE6I3D1wE,GAAA,SAAA,CAAA,EACS,OAAT,C,CC5KE,AAAkB,CAAA,aAAlB,OAAO,QACP,AAAU,MAAV,QACA,AAA2B,KAAA,IAApB,OAAO,QAAA,EACP,OAAO,SAAA,CAAU,OAAO,QAAQ,CAAA,CACX,OAAO,SAAA,CAAU,aAAA,CACnB,OAAO,SAAA,CAAU,WAAA,C,I,G,G,I,G,G,I,G,A3F8C3C,A,GAAA,iBAAA,C,I4F8BF,GACmD,CLenD,GKfmD,IAAA,GAAA,IAAA,GAAA,WLenD,SAAA87C,CAAAA,EAAA,OAAA,SAAA,CAAA,EAC+C,OAAA,GAAA,GAAA,IAAA,GAAU,IAAA,GAAU,IAAGA,EAAA,GAAS,IAAA,GAAU,IAAG,E,C,GKhBzC,GAAA,MAAA,EAPnD,GACmD,CLgBnD,GKhBmD,IAAA,GAAA,IAAA,GAAA,WLgBnD,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EAC+C,OAAA,GAAA,GAAA,IAAA,GAAU,IAAGA,EAAA,GAAS,IAAA,GAAU,IAAA,GAAU,IAAG,E,C,GKjBzC,GAAA,MAAA,EA2HnD,IACe,GAAA,GAAA,IAAAlqB,GAAmB,UAAnB,SAAA,CAAA,EAAA,OAAA,GAAA,GAAA,G,GA1Hf,GAAAvtB,IACY,GAAA,GAAA,IAAAutB,GAAmB,YAAnB,SAAA,CAAA,EAAA,OAAA,GAAA,GAAA,G,IAAiD,IAP7D,GACqD,CLcrD,GKdqD,IAAA,GAAA,IAAA,GAAA,YLcrD,SAAAkqB,CAAAA,EAAA,OAAA,SAAA,CAAA,EACgD,OAAA,GAAA,GAAA,IAAGA,EAAA,GAAS,IAAA,GAAU,IAAA,GAAU,IAAA,GAAU,IAAG,E,C,GKfxC,GAAA,MAAA,EAmFrD,GAAA,SAAA,CAAA,MAME,EAAA,EAAA,OAAA,IAAA,EAAA7oC,GAAA,GAAA,MAAA,CAAY,UAAZ,EAAAsI,GACyB,SAAAgvB,CAAAA,EAAM,IAAA,EAAAt3B,GAAA,GAAA,MAAA,CAAcs3B,IAAd,OAAA,SAAA,CAAA,EAAA,OAAA,EAAqB,EAArB,G,C,GAD/B,SAAA,CAAA,EAAA,OAAA,EACM,EADN,G,IAEM,G,E,G,G,I,G,G,I,G,G,IC3DR,GAAA,CAAA,YAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAC0B,OAAA,IAAA,GAAA,CAAA,E,C,C,EAHxB,GAAA,SAAA,CAAA,EAAA,OAAA,EAAA,WAAA,A,EAXF,GAAA,SAAA,CAAA,EAOqB,IAAA,EAAA,GAAA,GAPrB,OAAA,WAAA,MAAA,CAAA,WAAA,SAAA,CAAA,EAAA,IAAA,EAAA,GAMkB,GACZ,GAPN,aAAA,GAOW,OAAA,EAPX,EAAA,MAAA,EAAA,GAAA,KAAA,EAQM,GARN,aAAA,GAQqC,OAAA,IAAA,GAAA,IAAA,GAAA,UARrC,OAAA,AAAA,MAAA,kGAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,C,C,EA1CA,GAAA,C,W,E,EA0DA,GAAA,SAAA,CAAA,EAcS,IAAA,EAUP,AAVO,EAUP,eAAA,CAxBF,OAAA,SAAA,CAAA,EAiBgB,IAAA,EAAA,GAAA,GAjBhB,OAAA,SAAA,CAAA,E,I,E,G,G,E,G,OAAA,OAAA,WAAA,OAAA,WAAA,MAAA,CAAA,YAAA,SAAAgoC,CAAAA,EAAA,OAAA,SAAA,CAAA,EAWM,IAAA,EAAAvtE,EAAA,GAAA,KAAA,EAXN,EAAA,EAYM+b,GAAuB,GAAUwxD,IAGjC,GAfN,aAAA,GAeW,OAAAtuE,GAAAgP,GAAA,GAAA,MAAA,CACgB,IAhB3B,EAAA,MAAA,GAgBQ,SAAA,CAAA,EACoBs/D,OAAAA,GAAAA,EAAAA,GAAA,GAAA,KAAA,GAApB,SAAA,CAAA,EAC6B,OAAA,IAAA,GAAA,EAAA,GAAA,KAAA,EAAA,GAAI,G,E,GAEnC,GApBN,aAAA,GAqBqB,OAAA,IAAA,GAAA,IAAA,GAAA,EAAA,GAAA,KAAA,EArBrB,OAAA,AAAA,MAAA,kGAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,C,C,C,C,C,C,EApFE,GAAA,SAAA,CAAA,EAAA,OAAA,EAAA,UAAA,A,EAoHG,GAAA,SAAA,CAAA,EAGiB,IAAA,EAAA,GAAA,GAHjB,MAAA,CAAA,gBAAA,SAAA,CAAA,EAGgC,OAAA,GAAA,GAAA,E,C,C,EAlErCp8B,GAAA,SAAA,CAAA,EAAA,MAAA,CAC2B,WAAA,GAAA,GAAA,G,C,E,G,G,ICA3B,GAAA,SAAA,CAAA,EACsB,IAAA,EAAAr3C,GAAkB,GAAlB,OAAA,SAAA,CAAA,EAAc,OAAA,EAAd,E,C,ECwBtB,GAAA,CAAA,YAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,E,O,E,C,C,EAFE,GAAA,SAAA,CAAA,EAAA,OAAA,EAAA,WAAA,A,EARF,GAAA,SAAA,CAAA,EAKgC,IAAA,EAAA,GAAA,GALhC,OAAA,WAAA,MAAA,CAAA,WAAA,SAAA,CAAA,EAK4C,OAAA,EAAA,GAAA,GAAA,KAAA,C,C,C,C,EAlD5C,GAAA,C,WDMAkhD,E,ECTA,GAAA,C,WDOY,SAAA,CAAA,EAAA,OAAA,GAAA,E,C,EC9BV,GAAA,SAAA,CAAA,EAAA,OAAA,EAAA,UAAA,A,EAqDF,GAAA,SAAA,CAAA,EAAA,MAAA,CAC2B,WAAA,GAAA,GAAA,G,C,EA8B3B,GAAA,SAAA,CAAA,EAWO,IAAA,EAAA,GAAA,GAXP,OAAA,SAAA,CAAA,EAYO,IAAA,EAAA,GAAA,GAZP,OAAA,SAAA,CAAA,E,I,E,G,G,E,G,KAAA,OAAA,WAAA,MAAA,CAAA,YAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,MtDqFA,EsD1EsC,MAAA,CtD0EtC,EsD1EsC,EAAA,GAAA,KAAA,EtD0EtC,SAAA,CAAA,EACa,OA9Gb,SAAA,CAAA,EAEE,ODzEOlE,ACyEP,WAAK,IAAA,EAAA,ADvFE,WACL,IAAI,EAAI,CAAC,EACT,IAAA,IAAS,KCqFC,EDpFJ,eAAe,IAAA,CCoFX,EDpFmB,IACzB,CAAA,CAAA,CAAE,EAAC,CAAI,ACmFD,CDnFC,CAAE,EAAT,AAAS,EAGb,OAAO,CACT,ICiFK,OxBrEC,AwBoEC,CxBpED,CwB+KsB,ExB/KnB,CwB+KqB,EA1GzB,C,G,C,GsD+B+B,EAAA,EAAA,GAAA,KAAA,EAAA,KAAA,EACnB,GAAA,GAAA,KAAA,E,C,C,C,C,C,C,E,G,G,IE5GjB,GAAA,SAAA,CAAA,EAAA,OAAA,CAAA,CAAA,eAAA,A,EAWF,GAAA,SAAA,CAAA,EACyB,IAAA,EAAA,GAAA,GADzB,OAAA,SAAA,CAAA,EAEyB,IAAA,EAAA,GAAA,GAFzB,MAAA,CAAA,eAAA,SAAA,CAAA,EACgB,GAAd,aAAA,GAAkB,OAAA,EAAlB,EAAA,MAAA,EACc,GADd,aAAA,GACkB,OAAA,EADlB,EAAA,MAAA,CAAA,OAAA,AAAA,MAAA,uFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,C,C,ECtBI,GAAQ,IAAI,WAAW,ICJtB,GAAQ,sHCMR,GAJP,SAAkB,CAAA,EAChB,MAAO,AAAgB,UAAhB,OAAO,GAAqB,GAAM,IAAA,CAAK,EAChD,ECEM,GAAY,EAAlB,CAEA,IAAA,IAASvR,EAAI,EAAGA,EAAI,IAAK,EAAEA,EACzB,GAAU,IAAA,CAAA,AAAMA,CAAAA,EAAI,GAAA,EAAO,QAAA,CAAS,IAAI,KAAA,CAAM,IAGzC,SAAS,GAAgB,CAAA,CAAK,EAAS,CAAA,EAG5C,OAAO,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,IAAM,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,IAAM,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,IAAM,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,EAAE,CAAA,CAAI,IAAM,EAAA,CAAU,CAAA,CAAI,EAAS,GAAG,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,GAAG,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,GAAG,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,GAAG,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,GAAG,CAAA,CAAI,EAAA,CAAU,CAAA,CAAI,EAAS,GAAG,CAAjf,AACF,CCkBA,IAAO,GAhCP,SAAe,CAAA,MAKT,EAJJ,GAAI,CAAC,GAAS,GACZ,MAAM,UAAU,gBAIlB,IAAM,EAAM,IAAI,WAAW,IAuB3B,OArBA,CAAA,CAAI,EAAC,CAAA,AAAK,CAAA,EAAI,SAAS,EAAK,KAAA,CAAM,EAAG,GAAI,GAAA,IAAS,GAClD,CAAA,CAAI,EAAC,CAAI,IAAM,GAAK,IACpB,CAAA,CAAI,EAAC,CAAI,IAAM,EAAI,IACnB,CAAA,CAAI,EAAC,CAAI,AAAI,IAAJ,EAET,CAAA,CAAI,EAAC,CAAA,AAAK,CAAA,EAAI,SAAS,EAAK,KAAA,CAAM,EAAG,IAAK,GAAA,IAAS,EACnD,CAAA,CAAI,EAAC,CAAI,AAAI,IAAJ,EAET,CAAA,CAAI,EAAC,CAAA,AAAK,CAAA,EAAI,SAAS,EAAK,KAAA,CAAM,GAAI,IAAK,GAAA,IAAS,EACpD,CAAA,CAAI,EAAC,CAAI,AAAI,IAAJ,EAET,CAAA,CAAI,EAAC,CAAA,AAAK,CAAA,EAAI,SAAS,EAAK,KAAA,CAAM,GAAI,IAAK,GAAA,IAAS,EACpD,CAAA,CAAI,EAAC,CAAI,AAAI,IAAJ,EAGT,CAAA,CAAI,GAAE,CAAA,AAAK,CAAA,EAAI,SAAS,EAAK,KAAA,CAAM,GAAI,IAAK,GAAA,EAAO,cAAgB,IACnE,CAAA,CAAI,GAAE,CAAI,EAAI,WAAc,IAC5B,CAAA,CAAI,GAAE,CAAI,IAAM,GAAK,IACrB,CAAA,CAAI,GAAE,CAAI,IAAM,GAAK,IACrB,CAAA,CAAI,GAAE,CAAI,IAAM,EAAI,IACpB,CAAA,CAAI,GAAE,CAAI,AAAI,IAAJ,EACH,CACT,EE/BO,GAAQ,CACb,WAFiB,AAAkB,aAAlB,OAAO,QAA0B,OAAO,UAAA,EAAc,OAAO,UAAA,CAAW,IAAA,CAAK,OAGhG,EEeA,SAAS,GAAK,CAAA,CAAG,CAAA,EACf,OAAO,GAAK,EAAI,IAAM,GAAK,CAC7B,CClBA,IAAM,GAAK,AJeI,SAAa9mC,CAAAA,CAAM,CAAA,CAAS,CAAA,EACzC,SAAS,EAAa3Q,CAAAA,CAAO,CAAA,CAAW,CAAA,CAAK,CAAA,EAC3C,IAAI,EAUJ,GARqB,UAAjB,OAAOA,GACTA,CAAAA,EAAQ,AAnBd,SAAuB,CAAA,EACrB,EAAM,SAAS,mBAAmB,IAElC,IAAM,EAAQ,EAAd,CAEA,IAAA,IAASy3C,EAAI,EAAGA,EAAI,EAAI,MAAA,CAAQ,EAAEA,EAChC,EAAM,IAAA,CAAK,EAAI,UAAA,CAAWA,IAG5B,OAAO,CACT,EAS4Bz3C,EADxB,EAIyB,UAArB,OAAO,GACT,CAAA,EAAY,GAAM,EADpB,EAIA,AAAM,CAAA,AAA4B,OAA5B,CAAA,EAAa,CAAA,GAAuB,AAAe,KAAA,IAAf,EAAwB,KAAA,EAAS,EAAW,MAAA,AAAA,IAAY,GAChG,MAAM,UAAU,oEAMlB,IAAI,EAAQ,IAAI,WAAW,GAAKA,EAAM,MAAM,EAO5C,GANA,EAAM,GAAA,CAAI,GACV,EAAM,GAAA,CAAIA,EAAO,EAAU,MAAM,EAEjC,AADA,CAAA,EAAQ,EAAS,EAAjB,CACA,CAAM,EAAC,CAAI,AAAW,GAAX,CAAA,CAAM,EAAC,CItCD,GJuCjB,CAAA,CAAM,EAAC,CAAI,AAAW,GAAX,CAAA,CAAM,EAAC,CAAW,IAEzB,EAAK,CACP,EAAS,GAAU,EAEnB,IAAA,IAASy3C,EAAI,EAAGA,EAAI,GAAI,EAAEA,EACxB,CAAA,CAAI,EAASA,EAAC,CAAI,CAAA,CAAMA,EAAxB,CAGF,OAAO,CACT,CAEA,OAAO,GAAgB,EACzB,CAGA,GAAI,CACF,EAAa,IAAA,CIxDF,IJyDb,CAAA,MAAS,EAAK,CAAC,CAKf,OAFA,EAAa,GAAA,CA/CI,uCAgDjB,EAAa,GAAA,CA/CI,uCAgDV,CACT,EI/De,EAAM,EDoBrB,SAAc,CAAA,EACZ,IAAM,EAAI,CAAC,WAAY,WAAY,WAAY,WAA/C,CACM,EAAI,CAAC,WAAY,WAAY,WAAY,UAAY,WAA3D,CAEA,GAAI,AAAiB,UAAjB,OAAO,EAAoB,CAC7B,IAAM,EAAM,SAAS,mBAAmB,IAExC,EAAQ,EAAR,CAEA,IAAA,IAASA,EAAI,EAAGA,EAAI,EAAI,MAAA,CAAQ,EAAEA,EAChC,EAAM,IAAA,CAAK,EAAI,UAAA,CAAWA,GAE9B,MAAY,MAAM,OAAA,CAAQ,IAExB,CAAA,EAAQ,MAAM,SAAA,CAAU,KAAA,CAAM,IAAA,CAAK,EAFrC,EAKA,EAAM,IAAA,CAAK,KAEX,IAAM,EAAI,KAAK,IAAA,CAAK,AADV,CAAA,EAAM,MAAA,CAAS,EAAI,CAAA,EACL,IAClB,EAAI,AAAI,MAAM,GAEpB,IAAA,IAASA,EAAI,EAAGA,EAAI,EAAG,EAAEA,EAAG,CAC1B,IAAM,EAAM,IAAI,YAAY,IAE5B,IAAA,IAAS,EAAI,EAAG,EAAI,GAAI,EAAE,EACxB,CAAA,CAAI,EAAC,CAAI,CAAA,CAAMA,AAAI,GAAJA,EAAS,AAAI,EAAJ,EAAK,EAAK,GAAK,CAAA,CAAMA,AAAI,GAAJA,EAAS,AAAI,EAAJ,EAAQ,EAAC,EAAK,GAAK,CAAA,CAAMA,AAAI,GAAJA,EAAS,AAAI,EAAJ,EAAQ,EAAC,EAAK,EAAI,CAAA,CAAMA,AAAI,GAAJA,EAAS,AAAI,EAAJ,EAAQ,EAAjI,AAGF,CAAA,CAAA,CAAEA,EAAC,CAAI,CACT,CAEA,CAAA,CAAE,EAAI,EAAC,CAAE,GAAE,CAAK,AAAA,CAAA,EAAM,MAAA,CAAS,CAAA,EAAK,EAAI,WACxC,CAAA,CAAE,EAAI,EAAC,CAAE,GAAE,CAAI,KAAK,KAAA,CAAM,CAAA,CAAE,EAAI,EAAC,CAAE,GAAG,EACtC,CAAA,CAAE,EAAI,EAAC,CAAE,GAAE,CAAK,AAAA,CAAA,EAAM,MAAA,CAAS,CAAA,EAAK,EAAI,WAExC,IAAA,IAASA,EAAI,EAAGA,EAAI,EAAG,EAAEA,EAAG,CAC1B,IAAM,EAAI,IAAI,YAAY,IAE1B,IAAA,IAAS,EAAI,EAAG,EAAI,GAAI,EAAE,EACxB,CAAA,CAAE,EAAC,CAAI,CAAA,CAAEA,EAAC,CAAE,EAAZ,CAGF,IAAA,IAAS,EAAI,GAAI,EAAI,GAAI,EAAE,EACzB,CAAA,CAAE,EAAC,CAAI,GAAK,CAAA,CAAE,EAAI,EAAC,CAAI,CAAA,CAAE,EAAI,EAAC,CAAI,CAAA,CAAE,EAAI,GAAE,CAAI,CAAA,CAAE,EAAI,GAAE,CAAG,GAG3D,IAAIU,EAAI,CAAA,CAAE,EAAV,CACIokC,EAAI,CAAA,CAAE,EAAV,CACI,EAAI,CAAA,CAAE,EAAV,CACI,EAAI,CAAA,CAAE,EAAV,CACI,EAAI,CAAA,CAAE,EAAV,CAEA,IAAA,IAAS,EAAI,EAAG,EAAI,GAAI,EAAE,EAAG,CAC3B,IAAM,EAAI,KAAK,KAAA,CAAM,EAAI,IACnB,EAAI,GAAKpkC,EAAG,GAAK,AA3E7B,SAAW,CAAA,CAAG,CAAA,CAAG,CAAA,CAAG,CAAA,EAClB,OAAQ,GACN,KAAK,EACH,OAAO,EAAI,EAAI,CAAC,EAAI,CAEtB,MAAK,EAML,KAAK,EALH,OAAO,EAAI,EAAI,CAEjB,MAAK,EACH,OAAO,EAAI,EAAI,EAAI,EAAI,EAAI,CAI/B,CACF,EA6D+B,EAAGokC,EAAG,EAAG,GAAK,EAAI,CAAA,CAAE,EAAC,CAAI,CAAA,CAAE,EAAC,GAAM,EAC3D,EAAI,EACJ,EAAI,EACJ,EAAI,GAAKA,EAAG,MAAQ,EACpBA,EAAIpkC,EACJA,EAAI,CACN,CAEA,CAAA,CAAE,EAAC,CAAI,CAAA,CAAE,EAAC,CAAIA,IAAM,EACpB,CAAA,CAAE,EAAC,CAAI,CAAA,CAAE,EAAC,CAAIokC,IAAM,EACpB,CAAA,CAAE,EAAC,CAAI,CAAA,CAAE,EAAC,CAAI,IAAM,EACpB,CAAA,CAAE,EAAC,CAAI,CAAA,CAAE,EAAC,CAAI,IAAM,EACpB,CAAA,CAAE,EAAC,CAAI,CAAA,CAAE,EAAC,CAAI,IAAM,CACtB,CAEA,MAAO,CAAC,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,EAAI,IAAM,AAAO,IAAP,CAAA,CAAE,EAAC,CAAU,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,EAAI,IAAM,AAAO,IAAP,CAAA,CAAE,EAAC,CAAU,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,EAAI,IAAM,AAAO,IAAP,CAAA,CAAE,EAAC,CAAU,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,EAAI,IAAM,AAAO,IAAP,CAAA,CAAE,EAAC,CAAU,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,GAAK,IAAM,CAAA,CAAE,EAAC,EAAK,EAAI,IAAM,AAAO,IAAP,CAAA,CAAE,EAAC,CAAvV,AACF,G,G,G,IG1CAv1E,GAAA,SAAA,CAAA,EACU,OAAV,C,EAvBA,GAAA,SAAA,CAAA,SAEE,AAFF,ADZ8B,GCaM,GACnB,IAAA,GAAA,GACf,GAAA,KAAA,A,EASF,GAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EACU,OD7BC,ADVI,GEuCf,EAAA,E,C,EAnBA,GAAA,GAAA,IJnBA,SAAY43E,CAAAA,CAAS,CAAA,CAAK,CAAA,EACxB,GAAI,GAAO,UAAA,EAAc,CAAC,GAAO,CAACA,EAChC,OAAO,GAAO,UAAA,GAIhB,IAAM,EAAOA,AADbA,CAAAA,EAAUA,GAAW,CAAC,CAAA,EACD,MAAA,EAAWA,AAAAA,CAAAA,EAAQ,GAAA,EPL3B,WAEb,GAAI,CAAC,IAIC,CAFJ,CAAA,GAAkB,AAAkB,aAAlB,OAAO,QAA0B,OAAO,eAAA,EAAmB,OAAO,eAAA,CAAgB,IAAA,CAAK,OAAzG,EAGE,MAAM,AAAI,MAAM,4GAIpB,OAAO,GAAgB,GACzB,COPiD,IAK/C,GAHA,CAAA,CAAK,EAAC,CAAI,AAAU,GAAV,CAAA,CAAK,EAAC,CAAW,GAC3B,CAAA,CAAK,EAAC,CAAI,AAAU,GAAV,CAAA,CAAK,EAAC,CAAW,IAEvB,EAAK,CACP,EAAS,GAAU,EAEnB,IAAA,IAASnnC,EAAI,EAAGA,EAAI,GAAI,EAAEA,EACxB,CAAA,CAAI,EAASA,EAAC,CAAI,CAAA,CAAKA,EAAvB,CAGF,OAAO,CACT,CAEA,OAAO,GAAgB,EACzB,IIFU,GAAA,GAAA,IAAA,SAAA,CAAA,EAAgB,OAAA,GAAhB,E,IAuBV,GAAA,C,G,S,C,E,O,S,C,E,O,I,C,C,C,E,G,G,I,G,GAEA,C,Q,S,C,E,O,S,C,E,O,G,G,E,C,E,I,W,O,E,C,G,G,G,I,G,G,I,G,G,I,G,G,ICnCA,GAAA,SAAA,CAAA,EAAA,OAAA,C,EAEA,GAAA,C,G,S,C,E,O,S,C,E,O,G,G,E,C,C,EACA,GAAA,C,Q,S,C,E,O,S,C,E,O,G,G,E,C,E,I,W,O,E,C,EAOA,GAAA,CAAA,WAAA,SAAA,CAAA,EACc,OAAAkO,GAAA3+C,GAAZ,G,C,EAcFA,GAAA,SAAA,CAAA,EACU,OAAAA,GAAV,E,EAVA,GAAA,GACwC,kBDb5B,wCCSZ,GAAA,CAAA,WAAA,SAAA,CAAA,EAC+B,OAAA,GAAA,GAAA,IAAS,SAAAkmD,CAAAA,M9J6NxC,E8J7NuD,MAAA,C9J6NvD,E8J7NuD,SAAA,CAAA,EAAM,OAMhC,GANqCA,GAMnC,GANuC,E9J6NtE,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EACO,GAAP,aAAA,GAAA,OAAA,EAAA,IACO,GADP,aAAA,GACiB,OADjB,EAAA,EAAA,MAAA,CAAA,OAAA,AAAA,MAAA,kFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,G8J9NsE,IAAA,GAAmBA,G,E,C,EAQzF,GAAA,SAAA,CAAA,EAC0B,OAAA,GAAA,GAAA,GAAA,IAAA,I,EAK1BxvB,IACa,GAAA,GAAA,IAAI,IAAJ,SAAA,CAAA,EAAA,OAAA,GAAA,GAAA,G,G,GbPb,SAAA,CAAA,E,I,E,G,GAAA,MAAA,CAAA,eAAA,SAAA,CAAA,EAUI,IAxBJ,EAwBI,EAAAxrB,EAAA,GAAA,KAAA,EAVJ,GAdA,EAmBE,EAlBoB,EAAA,SAoBhB,AAPN,AAAA,IAAA,EAAA,MAAA,CAOY,EACE,ID1CH,AC0CsBK,GAAK,CAAE,EAAA,EARxC,GDlCc,IAAA,CC0CmB,KAA0B,G,C,C,EckC3D,GAAA,C,c,W,M,O,C,E,G,G,I,G,G,I,G,G,IA5CA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAaA,GAAA,CACS,KAAA,C,EAHT,SAAA,CAAA,EAAA,GAAA,aAAA,G,O,I,G,G,K,EAAA,GAAA,aAAA,G,O,I,G,I,G,G,K,GAAA,GAAA,aAAA,G,O,I,G,I,G,I,G,G,K,IAAA,GAAA,aAAA,G,O,I,G,I,G,I,G,I,G,G,K,KAAA,GAAA,aAAA,G,O,I,G,I,G,I,G,I,G,I,G,G,K,MAAA,GAAA,aAAA,G,O,I,G,I,G,I,G,I,G,I,G,I,G,G,K,OAAA,GAAA,aAAA,G,O,I,G,I,G,I,G,I,G,I,G,I,G,G,K,M,O,A,M,yF,C,E,W,C,I,C,C,EdQA,SAAA,CAAA,EACgB,IAAA,EAAA,GAAA,GADhB,OAAA,SAAA,CAAA,EACmC,OAAA,EAAA,EAAA,G,C,GcN1B,GAAA,GAAA,C,c,W,M,S,CAAA,IAAA,GAAA,GAAA,C,c,W,M,U,CAAA,IAAA,GAAA,GAAA,C,c,W,M,S,CAAA,IAAA,GAAA,GAAA,C,c,W,M,a,CAAA,IAAA,GAAA,GAAA,C,c,W,M,Q,CAAA,IAAA,GAAA,GAAA,C,c,W,M,S,CAAA,IAAA,GAAA,C,c,W,M,S,C,S,EAET,GAAA,CACe,UAAA,EAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,SAAA,CAAA,EAAA,OAAA,GAAe,GAAf,G,E,EA6Bf,GAAA,GAAA,GAAA,GAAA,GAAAyzC,GAAA,GAAA,IAAA,GAAA,IAAA,IAFA,C,c,W,M,M,C,MAAA,C,c,W,M,I,C,MAEA,WAAAA,GAAA,GAAA,IAAA,IAFA,C,c,W,M,M,C,MAEA,OAFA,C,c,W,M,O,C,QAtBA,GACoB,SAAA,CAAA,QAClB,AAAA,AAAA,YAAA,E,I,G,G,K,EACA,AAAA,aAAA,E,I,G,G,K,EACA,AAAA,YAAA,E,I,G,G,K,EACA,AAAA,gBAAA,E,I,G,G,K,EACA,AAAA,WAAA,E,I,G,G,K,EACA,AAAA,YAAA,E,I,G,G,K,EACA,AAAA,YAAA,E,I,G,G,K,EACA,GAAA,KAAA,A,E,G,G,I,G,G,I,G,G,IEQE,GAAA,C,c,W,M,U,C,E,G,K,I,I,I,G,G,IhCcF,GAAA,GAEI,CAAA,GAAA,GAAA,KAAA,EAAA,EAnDJ,AlB+CF23B,GkB/CE,C,Y,EAWe,GAAA3xE,GAAAkiB,GAAA,GAAA,KAAA,EAA2E,CAAA,IAA3E,SAAA,CAAA,EAAA,MAAA,C,MAAoC,GAApC,GAAwB,WAAA,CAAA,C,C,G,OAEvC,SAAA,CAAA,MAqBA,EArBO,OAAA1V,GAEH,CAAA,GAAc,aAAA,EACd,CAAE,AAAkB,GAAA,GAAA,SAAA,CAAA,E,O,E,Q,AAHxB,IAAA,EAAA,KAAA,GAAA,EAAA,UAAA,CAG6D,GAAvDwH,GAaF,GAAA,CAAA,GAAY,AAhBhB,EAAA,UAAA,CAgBmC,oCAAqD,UAGpF,GAAA,GAAA,GAAA,KAAA,GAAA,EAAA,EAAA,EAnBJ,GAMQ,CAAA,GAAY,AANpB,EAAA,UAAA,CAOiB,gFACA,8CARjB,GAAA,GAAA,GAAA,KAAA,GAAA,EAAA,GAAA,EAAA,KAAA,GAqBA,EArBA,EAAA,UAAA,CAqBA,SAAA,CAAA,EAEI,OAAA,GAAA,CAAA,GAAY,AAAG,EAAA,QAAA,EAAiB,EAAgB,UAA2B,UAC3E,EAAA,CAAA,GACI,CAAA,GACI,CAAE,uEACA,AAAG,EAAA,QAAA,CACI,wDACA,2DAEgB,EAAA,GAAA,GAAA,IAAA,GAAA,EAAA,EAAA,IAAA,EAE7B,CAAA,GAAU,EAAA,KAAA,EAAA,EAAA,C,KAjClB,C,EAXmB,KAAA,GAAA,C,W,G,U,C,S,G,Q,CACEs/D,aAkDZ,SAAA,CAAA,EACP,GAAA,aAAA,GACY,OAAA,GAAA,SAAA,CAAA,E,I,E,C,E,I,I,K,E,A,C,C,C,E,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,E,OAAiB,EAAA,UAAA,CAAA,CAAA,E,C,GAC7B,GAAA,aAAA,GACwB,OAAA,GAAA,GAAA,SAAA,CAAA,E,I,E,C,E,I,I,K,E,A,C,C,C,E,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,E,OAAiB,EAAA,UAAA,CAAA,CAAA,E,CAAvC,IAAA,SAAA,CAAA,EAAA,OAAA,GAAAlwE,GAAA,GAC+B,SAAA,CAAA,E,O,E,Q,AAD/B,GAAA,EAAA,KAAA,GAC8C,SAAA,CAAA,E,O,E,E,A,G,GAChD,GAAA,aAAA,GAAO,OAAAsC,GAAAgL,GACS,SAAA,CAAA,E,O,E,U,AAED,IAAA,GAAA,GAAA,SAAA,CAAA,E,O,E,K,AAAT,GAAA,SAAAowC,CAAAA,EACI,IAAA,EAAA19C,GAAS09C,GAAU,SAAA,CAAA,EAAS,GAAG,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,EAAH,C,I,E,C,EAAsB,IAAA,IAAA,KAAA,EAAA,AAAA,CAAA,CAAA,CAAA,EAAA,cAAA,CAAA,IAAA,CAAA,EAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,AAAA,E,OAAsB,EAAA,QAAA,CAAA,CAAA,EAAA,QAAA,C,C,CAA5C,OAAiE,C,GACjG,OAAA,SAAA,CAAA,E,I,E,C,E,I,I,K,E,A,C,C,C,E,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,E,OAAY,EAAA,KAAA,CAAA,E,C,C,KAClB,GAAA,aAAA/X,GAAQ,OAAAz6B,GAAA81B,GAEK,SAAA,CAAA,E,O,E,K,AAAT,GAAA,SAAA0c,CAAAA,EACI,IAAA,EAAA19C,GAAA,EAAA,MAAA,EAAmB,SAAA,CAAA,EAAC,MAAiB,C,G,E,E,C,M,E,K,CAA6B,SAAA,GAAA,CAAA,GAAM,SAAA,CAAA,E,O,E,Q,AAAwB,GAAA,GAAA,SAAA,CAAA,EAAS,O,G,AAAT,E,E,E,E,E,CAAoB09C,GAAAA,G,C,GACxH,OAAA,SAAA,CAAA,E,I,E,C,E,I,I,K,E,A,C,C,C,E,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,E,OAAY,EAAA,KAAA,CAAA,E,C,C,G,O,A,M,oF,C,E,W,C,I,C,C,EAjEE,YAAA,SAAA,CAAA,EAAcovB,OAAAA,GAqEhCjrE,GAAAoL,GACQ,C,M,AAtEU,E,M,CAsEW,WAAA,CAAA,CAA3B,IAAA,W,O,G,AAtEgB,E,M,C,G,EACJ,QAAA,SAAA,CAAA,EAAA,OAAA,GAAA,MAAA,CAAA,GAAA,MAAA,CAAA,G,C,E,I,G,G,I,G,G,I,G,W,G,G,G,K,G,G,I,G,G,GrBuClB,K,G,G,G,K,G,G,IAIA,I,G,G,IADA,I,G,G,IqDyFgF,GAAA,GAAA,KAAA,GAAA,GAAA,GAAA,MAAA,C,c,W,M,M,CAAA,GAAA,OAAA,C,c,W,M,I,CAAA,GAAA,OAAA,C,c,W,M,O,C,G,M,G,K,I,I,G,GrD1FhF,I,G,G,I,G,GACA,I,G,G,I,G,G,I,G,GADA,I,I,G,G,I,G,G,I,G,G,G,K,G,G,I,IqDjDA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,C,C,E,C,IAVA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAEAs4B,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAAI,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAcAyJ,IA8BE,GAAA,SAAA,CAAA,EACM,IAAA,EAAApvC,GAAS,GAAU,SAAA,CAAA,EAAS,MAAA,CAAM,GAAA,EAAA,EAAA,CAAgB,MAAA,EAAA,IAAA,A,C,GACF,OAAA,GAAA,GAAA,KAAA,EAAA,IAAA,IAAA,GAAA,GAAA,MAAA,C,EAoEtD,GAAA,SAAA,CAAA,EAwBE,IAAA,EAAAsR,GAAA,IAAAY,IAAyC,SAAA,CAAA,E,O,E,K,A,GAvBzB,OAAA,SAAA,CAAA,EAChB,GAA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5DmB,EC6De,OD7Df,EC6DmB,EAAA,CD5D3B,SAAU,CAAA,EACf,OAAO,WACL,EAAO,WAAA,CC0DmB,ED1DD,EAAS,MAAA,CAAS,EAAI,EAAW,KAAA,EAC5D,CACF,C,ECoCJ,GAEE,CAAQ,KAAA,G,Y,G,K,C,K,G,K,A,E,G,G,I,G,G,I,G,C9HiHA,EAlHR,A,GAAA,QAAA,CA4GF,SAAA,CAAA,E,I,E,E,G,IAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAAhK,CAAAA,EAAA,OAAA,SAAA,CAAA,EAME,OAAA,AAAAzkC,EAAkB,SAAA,CAAA,EAAA,OAAA,GAAuBykC,EAAvB,GAA0B,GAAA,GAAU,E,C,C,C,G,I,G,G,I,G,G,I+HtIlC,GAAA,GAAA,GAAA,GAAA,G1BoCtB,CACmC,UAAA,EDGL,EAAA,GCHK,G0BrCb,K3BwCQ,SAAA,CAAA,EAAA,OAAA,EAAA97C,GAAA,G,E,I2BxCR,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,GAAA,IAAA,IAAA,C,c,W,M,M,CAAA,MAAA,C,c,W,M,I,CAAA,MAAA,C,c,W,M,O,CAAA,UAAA,GAAA,GAAA,IAAA,C,c,W,M,Q,CAAA,MAAA,C,c,W,M,M,CAAA,MAAA,C,c,W,M,O,CAAA,SAAA,IAAA,C,c,W,M,M,CAAA,MAAA,C,c,W,M,Y,C,SC/BtB,SAAS4yE,GAAKC,CAAAA,EACZ,OAAO,SAAS,CAAA,EACd,OAAO,SAAS,CAAA,EACd,OAAOA,EAAO,KAAA,CAAM,EAAK,CAAC,EAAE,CAC9B,CACF,CACF,CAEO,IAAM,GAAoBD,GAAK,OAAO,SAAA,CAAU,WAAW,EACrD,GAAgBA,GAAK,OAAO,SAAA,CAAU,OAAO,EAC7C,GAAsBA,GAAK,OAAO,SAAA,CAAU,aAAa,E,G,G,IC2BtE,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAqBA,GAAA,SAAA,CAAA,EACc,GAAd,aAAA,GAAwB,OAAA,GAAxB,EAAA,MAAA,EACc,GADd,aAAA,GACoB,OAAA,GADpB,EAAA,MAAA,EAEc,GAFd,aAAA,GAE0B,OAAA,GAF1B,EAAA,MAAA,CAAA,OAAA,AAAA,MAAA,wFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,EAVA,IACQ,GAAAlqE,GAAgB,GAAE,IAAlB,SAAA,CAAA,EAAU,OAAA,GAAA,MAAA,CAAA,GAAV,G,G,G,G,I,G,G,I,IhI4ES,EAvFf,A,GAAA,QAAA,CAsFF,SAAA,CAAA,EAAA,OAAA,SAAAozC,CAAAA,EAAA,OAAA,SAAA,CAAA,EAC0B40B,OAAAA,EAExB,SAAA,CAAA,EAAI,OAAA,IAAA,GAAJ,EAAA,MAAA,CACE,AADF,EAAA,MAAA,CACU,EAAqB50B,IAAAA,GAAAA,IAAAA,GAAAA,EAD/B,EAAA,MAAA,EAAA,EAAA,MAAA,CAC2C,EAA1B,IAAf,GAAA,KAAA,C,GAHsB,IAAA,GAAW,EAAG,EAAI,EAAJ,G,C,C,G,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,K,G,CTgQ9B,GAAA,G,IADV,SAAA,CAAA,E,O,GzC/UE,A,EAAA,GAAA,E,G,G,G,I,G,G,IoLLF,GALqBg3B,GAGP,IAHoC,SAAA,CAAA,EAAmB,OAAA,GAAA,IAAA,GAAA,CAAA32E,GAAA,EAAU,IAAAkJ,GAAI,GAAK,CAAAlJ,GAAA,EAA5D,GAAA,CAAAE,GAAA,E,G,W,G,G,I,G,KCLkB,G,G,I,G,GAAA,MAM9C,GAAA,SAAA,CAAA,MDOA,ECNe,MAAA,CDMf,ECNe,GAAmD,SAAA,CAAA,E,O,E,K,AAAlE,GAAA,EAAA,KAAA,EAAA,EAAA,MAAA,CAA4D,EDM5D,SAAA,CAAA,E,I,I,E,E,E,E,C,E,C,G,E,A,S,C,C,C,EACkB,GAAlB,EACQ,GADR,EACiB,E,O,E,C,E,GADC,GAAlB,AAES,IAFT,E,O,E,C,E,GAAkB,GAAlB,AAGS,IAHT,EAAA,O,E,C,EAAA,GAAA,GAAkB,GAAlB,AAAA,CAAA,EAAA,EAII,CAAA,EAJJ,EAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAI2C,E,M,CAJzB,GAAlB,EANc,GAWwB,O,E,C,EAAA,GAAA,GAAA,IALtC,IAAA,GAQE,IAAW,EAAX,GAAW,EAAAyC,GAAA,IAAA,SAAA,CAAA,EAAY,OAAA,GAAA,EAAZ,G,GAFS,O,E,C,EAAA,GAAA,EAAAgxE,GAAAA,AANtB,CAAA,EAAA,EAMiC,CAAA,EAAQ,EAAR,GANjC,KAMoD,EAAAA,GAAU,GAN9D,I,E,E,G,O,C,GCPA,EAAA,IAAA,C,E,G,GXoHA,C,GDrEO,SAAkB,CAAA,EACvB,OAAO,SAAS,CAAA,EACd,OAAO,EAAE,MAAA,CAAO,EAClB,CACF,C,G,G,G,I,G,G7JXA,CAAA,OAAA,SAAA,CAAA,EACa,OAAA,C,E,IF1DS,SAAU,CAAA,EAC9B,OAAO,SAAU,CAAA,EACf,OAAO,EAAK,CACd,CACF,EEqDA,IAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAGY,OAAA,C,C,EAHZ,iBAAA,W,O,E,C,G,G,G,IuGQA,I,G,GADA,I,G,I,G,G,A,G,Y,IAQA,CACY,OAAA,EAAA,GAAA,G,IAAA,SAAA,CAAA,EAAA,OAAA,GAAA,GAAAr6C,GAAA,MAAA,CAAgC,GAAhC,K,GADZ,aAAA,W,O,E,C,I,G,G,IARA,I,G,G,I,G,GAgCA,CACe,UAAA,EAAA,GAAA,G,IAAA,SAAA,CAAA,EAAA,OAAA,GAAA,GAAAA,GAAA,MAAA,CAAgC,GAAhC,K,GADf,OAAA,W,OA/BA,E,C,G,G,G,I,G,G,I,G,GAFA,I,I,G,GAAA,ImE3DA,GAAA,W,S,E,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,C,C,E,C,IAKA6b,IAoCE09B,GACQ,SAAA,CAAA,MDxCV,EC2CY,ENjDZ2D,EM+CI,OAAAjjE,GAAAzL,GAAA,GAGiD,GAAA,GAAA,AzE4MrD0tE,ImE9PAgB,EMkDqD,CAAQ,IAAA,CADjD,EAAA,CD3CZ,EC2CY,EAAA,MAAA,CD3CZ,SAAA,CAAA,EAME,IlIklCFnsE,EkIllCc,EAAA,EAAA,EAAZ,GlIklCFA,EkIllCc,GAAA7L,IAAmB,SAAA,CAAA,E,O,E,E,A,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AIhH,GAAA,CAAA,GAAc,kEAAA,EACd,CAAA7kB,GAAS,CAAA,GAAc,QAAA,EAAqB,CAAA,GAAAxR,GApBpD,EAAA,WAAA,GAAA,EAAAwR,GAqBiB,CAAA,GAAc,QAAA,EAAqB,CAAA,GAAAxR,GArBpD,EAAA,KAAA,GAAA,EAAA,EAAA,C,EAPiB,KAAA,GAAA,C,a,G,Y,C,Q,G,O,C,W,G,U,C,S,G,Q,CAA8B,YAAA,SAAA,CAAA,EAAck1E,OAAAA,GAAAA,GAAd,G,C,E,ICwErC,GAAA,C,c,W,M,M,C,E,G,K,I,IAjBA,GAAA,C,c,W,M,Q,C,E,G,K,I,I,G,G,I,G,GpENZ,I,G,GADA,I,I8BoGe,GAAA,G,IAAA,SAAA,CAAA,MAtBf,EAsBe,OArBL,AAAA,GADV,EAsB6B,GAAd,IApBG,EAAU,IAAA,GAD5B,G,G,K,A,G,GvFydA,SAAAlzB,CAAAA,EAGE,IAAA40B,EAAK,SAAA,CAAA,EACH,GAAA,aAAA,G,O,G,K,CACA,GAAA,aAAA,UAAK,AACD50B,EAAA,EAAA,MAAA,EACS,GAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAAwB40B,EAAA,EAAA,MAAA,EAAOA,EAAA,EAAA,MAAA,GAE/B,GAAiBA,EAAA,EAAA,MAAA,EAAOA,EAAA,EAAA,MAAA,E,O,A,M,yF,C,E,W,C,I,C,C,EAR1BA,OAAAA,C,E,G,G,I,IPlNa,GAAA,G,IAD5B,SAAAzlC,CAAAA,EAAA,OAAA,SAAA,CAAA,EACsCA,OAAAA,GAAAA,GAAAA,GAAE,G,C,G,G,G,I,G,K,I,I,G,GgEpVxC,I,G,G,I,G,K,G,G,I,I,G,G,GACA,K,G,G,GAJA,K,G,GAIA,I,G,G,I,I,G,G,C,G,GAAA,I,E,G,E,CvFxBA,EuFwBA,I,K,I,E,G,E,Y,I,E,G,E,M,G,Q,I,EvFxBA,CAAA,IAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EACO,OAAAhnC,EAAL,GACE,SAAA,CAAA,SAEE,AADG,aAAA,GAFP,EAIIb,EAFG,E,E,C,EAHT,SAAA,W,O,C,C,E,GAOA,C,M,G,AuFiBA,G,Y,I,G,K,EvFjBA,KAAA,W,O,C,C,EgGtBA,GhGyBA,CAAA,aAAA,W,O,E,EAAA,MAAA,W,O,E,C,G,Y,I,G,G,G,K,IgGzBA,SAAA,CAAA,EACM,GAAN,E,O,G,IACM,GAAA,CADN,E,O,EAAA,OAAA,AAAA,MAAA,yFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,G,G,G,I,G,G,I,G,G,I,I7E8JU,EAAA,G,I,IAPV,SAAA,CAAA,EAAA,OAAA,SAAA04C,CAAAA,EAOmBA,OAAAA,EAAAA,GAAE,E,C,G,G,G,I,G,G,I,G,G,I,G,G,I,G,G,IoExHrB,I,G,G,IAFA,I,G,GAFA,IoEwFsC,GAAA,C,c,W,M,I,C,E,G,G,Q,G,G,G,K,G,G,I,G,GpErFtC,I,G,G,I,G,GADA,I,I,G,G,I,G,G,I,I,G,GAAA,I,G,G,I,G,G,I,G,G,I,G,G,GAEA,K,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,GAFA,I,G,K,G,G,MoEuDY,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,C,c,W,M,Q,CAAA,GAAA,OAAA,C,c,W,M,M,CAAA,GAAA,OAAA,C,c,W,M,O,CAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,C,c,W,M,M,CAAA,GAAA,OAAA,IAAA,OAAA,C,c,W,M,O,C,G,SA5GZqG,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAYA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAAF,GAAA,W,S,E,C,C,C,C,C,E,I,C,M,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,S,C,E,O,I,E,E,E,E,C,C,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IARAxa,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,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AAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,I,G,G,ICwFA,GAAA,SAAA,CAAA,EACkB,IAAA,EAAA,OAAA,IAAA,EAAA,GAAA,GAAA,KAAA,EAAA,SAAA,CAAA,EAAA,OAAA,EDnEhB,AAAA,AAAA,YCmEgB,E,I,G,G,K,EDlEhB,AAAA,gBCkEgB,E,I,G,G,K,EDjEhB,AAAA,aCiEgB,E,I,G,G,K,EDhEhB,GAAA,KAAA,C,I,WCgEiG,OFlF1F,AEkF0F,EFlFtF,UAAX,A,E,EIbK,SAAS,GAAStjD,CAAAA,EACvB,OAAO,WACL,OAAOA,EAAO,QAAd,AACF,CACF,CAQO,SAAS,GAASA,CAAAA,EACvB,OAAO,WACL,OAAOA,EAAO,QAAd,AACF,CACF,CIhBO,SAAS,GAAa,CAAA,EAC3B,OAAO,EAAE,YAAT,AACF,C,I,GzJySA,SAAA,CAAA,E,O,E,E,G,G,I,G,G,I,G,G,I,G,G,I,G,G,G,K,G,G,I,G,G,G2ErNA,K,G,G,G,K,G,G,GAAA,K,G,GADA,I,G,G,I,G,G,I,G,G,I,G,G,I,G,GAHA,I,G,GAIA,I,G,GAFA,I,G,G,I,G,G,I,G,G,I,G,G,I,G,GACA,I,G,G,I,I1E4IO,GAAA,G,IADP,SAAA,CAAA,E,O,G,G,G,G,G,I,E+D9GA,C,O,G,G,CAGA,E3FrEA,C,O,GAAA,WAAA,W,O,E,C,G,U,I,E2FqEA,C,O,G,G,IAAA,WAAA,W,O,C,C,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,I,G,GWhCA,I,G,GADA,I,G,G,G,K,G,GAAA,I,G,GtGxBA,CACW,OAAA,EAAA,CADX,WAAA,W,O,E,C,GsLTA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAZA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAAm3B,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAiBAvR,IA4GE,GAAA2hC,GAAA,IAAA,GAAsD,MACpD,CAAE,yEACA,gGAAA,EAPJ,GAAAA,GAAA,IAAA,GAAuD,MACrD,CAAE,kBACA,GAAA,EAlBJ,GAAA,SAAAv+C,CAAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAAx7B,CAAAA,EAAA,OAAA,SAAA,CAAA,EAYU,IAAA,EAVN,OAAA,GAAA,CAAA,GAAc,2EAAA,EACd,CAAAoS,GAAS,CAAA,GAAc,OAAA,EAAoB,CAAA,GAAUopB,GAAA,EAAA,GAEjD,CAAA,GAAY,IAAAu9C,GAAA,GAAA,KAAA,EAAAn/E,GAAAoW,GAEM,IAAA0e,GAAA,IAAA,GACE,IAAArnB,GAAA,GACI,IAAArH,GAAA,GACAA,IAAA,GAAA2pD,GAAA,MAAA,EAAA,IAEtB,EAAA,GAAmC,GAAnC,SAAA,CAAA,EAAmB,OAAA,EAAM,EAAA,GAAzB,I,I,E,C,C,C,C,C,EA6EV,GAAA,SAAA,CAAA,EACuC,IAAA,EAA7B,OAAA,GAAA,CAAA,OAAA,EAAA,MAAA,CAAA,KAAA,EAAA,IAAA,CAA6B,MAAA,IAAA,EAAA9lD,GAAAkb,IAAA,SAAA,CAAA,EAAW,OAAA,E,AAAX,E,I,C,IAA4B,EAAA,KAAA,C,E,EAEnE,GAAA,WAAA,IAAA7D,GAAA,GAAA,MAAy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CAAa,EAAb,EAAsB,KAAA,EAAA,IAAA,A,C,C,GARX,C,K,G,K,CAAsB,IAAA,C,GAA1C,OAAA,SAAA,CAAA,EAAA,O,AAAW,EAAX,G,I,A,C,EmKhUb,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAQE,IAzCFulC,EAyCEE,EAAA,SAAAzlC,CAAAA,EACE,IAAA,EAAA,GAAA7nC,GAAY6nC,IAAI,SAAAokC,CAAAA,EAAWA,OAAAA,GAAAA,IAAAA,GAAAA,IAAK,EAAGpkC,GAAEokC,G,GAArC,EAAAgE,GACa,GADb,OAAA,SAAA,CAAA,EAAA,OAAA,EACM,EACA,EAFN,I,C,EAHoB,OAvCxB7C,EAuCuCE,EAAA,GAAA,KAAA,EAjCrC,WAAmBF,IAAAA,EAAAA,GAAAA,IAAAA,GAAAA,GAAS,O,E,GdS9BC,I,McP4B,EAAA,GAAA,SAAA,CAAA,EAAqBL,OAAAA,GAAAA,GAAAA,IAAAA,IAAA9wE,GAAAT,GAAAC,GA+Bd4xE,GA/B4B,GAAgBN,KAAQ,K,KAE5C,OADV,GAAA,IAAA,GAAS,CAAA,GAAM,KACL,GAAA,IAAA,GAAS,CAAA,GAAM,E,C,C,G,G,G,I,G,GzFiC1D,I,G,G,I,G,G,IACA,I,G,G,I,G,K,G,G,I,I,G,G,I,G,K,G,G,M0F+DY,GAAA,C,c,W,M,Q,C,EAAA,GAAA,C,c,W,M,M,C,EAAA,GAAA,C,c,W,M,O,C,EAAA,GAAA,C,c,W,M,M,C,EAAA,GAAA,C,c,W,M,I,C,EAAA,GAAA,C,c,W,M,O,C,E,G,G,G,G,G,G,I,O,I,O,I,G,G,G,G,G,I,O,I,O,I,S,G,G,I,G,G,I,G,G,I,I,G,K,I,I,G,G,I,G,G,I,I,G,G,I,G,G,GzDjGZ,C,W,E,I,G,G,GANA,C,W,E,IyDsI8B,GAAA,C,c,W,M,M,C,EAAA,GAAA,C,c,W,M,U,C,EAAA,GAAA,C,c,W,M,Y,C,E,G,G,G,G,G,G,G,G,G,G,G,G,G,G,M,G,G,G,GvC9H9B,CAAA,WAAA,SAAA,CAAA,EACoB,IAAA,EAAA,OAAA,IAAA,EAAA,GAAA,IAAA,GAAsB,IAAtB,SAAA,CAAA,EAAA,OAAA,EAAgC,GAAhC,G,IAAiE,GAAA,G,C,I,I,S,S,S,c,G,I,S,c,G,G,G,G,G,G,G,G,G,G,K,G,G,K,I,S,S,c,G,G,I,S,S,a,I,S,Y,IkChC7E,GAAA,G,IAAA,SAAA,CAAA,EAAA,OAAA,GDTC,WACL,QAAQ,KAAA,CCQJ,EDPN,E,G,G,G,IpFqEF,I,G,GAFA,I,G,GAAA,I,G,G,I,G,G,I,G,GAEA,I,I,G,G,I,G,G,I,G,G,I,G,GmCzCA,C,WDMApwB,E,G,G,G,G,G,G,G,G,G,G,G,G,K,G,G,G,I,I,O,O,O,W,G,I,O,W,G,G,G,G,G,G,G,I,G,I,I,O,O,W,G,G,I,O,O,U,I,O,UwDZAvY,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAAkwB,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA5F,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAAE,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAAL,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAA,GAAA,W,S,E,C,C,C,E,I,C,M,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,S,C,E,O,I,E,E,E,C,E,C,IAAApG,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAAAvJ,GAAA,W,S,E,C,E,I,C,M,C,C,C,O,E,M,C,S,C,E,O,I,E,E,E,C,IAAA,GAAA,W,S,I,C,O,E,K,C,I,E,C,IAeA3Q,IAmDE,GAAAhmC,GAEI,CAAA,GAAc,uEAAA,EACd,CAAAA,GACI,CAAA,GAAc,iCAAA,EACd,CAAA,GAAU,CAAA0/B,GAAA,GAAqB,SAAS,4CAAA,GAAA,KAAA,EAAA,EAAA,KAAA2iB,IAAA,IAAA,GAAA,KAAA,EAAA,IAAArc,IAAA,IAAA,EAAA,EAVhD,GAAAhmC,GAEI,CAAA,GAAc,QAAA,EACd,CAAAsmC,GAAA,IAAA,IAAA,GAAA,KAAA,EAAA,IAAAN,IAAA,IAAA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AA,EAAA,EAAA,C,EAtCL,KAAA,GAAA,C,Y,G,W,C,Q,G,O,C,S,G,Q,CAA+B+mC,aAAAA,G,W,I,G,G,K,C,E,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,ICPlD,GAAA,SAAApD,CAAAA,EAGK,IAAA,EAAA,OAAA,GAAA,GAAA,GAAA,IAAA,EAAA,GAAcA,GAAd,SAAA,CAAA,EAAA,OAAA,EAAA,AnBgBLyB,GmBhBK,G,IADH,KAAA,MAAA,SAAA,CAAA,EAEmC,OAAA,GAAA,GAAA,IAAA,G,E,EAIrC,GAAA,GAAA,GAAA,IAAA,GAAAhgB,GAAA,OA7BA,GAAA,GACoB,SAAA,CAAA,EAClB,OAAA,WAEE,GADG,A,G,I,G,I,kBAAA,GAAA,C,I,E,GhByBPggB,I,MgBtBiC,EAAA,GAAA,SAAA,CAAA,EAAM,OAAA,EAAA,IAAA,GAAA,I,KAE8B,OAD1B,GAAA,IAAA,GAAS,CAAA,GAAM,KACW,GAAA,GAAA,IAAA,GAAS,CAAA,GAAM,G,C,OAE9E,EAAA,IAAA,GAAA,O,E,C,GAIN,GAAA1sE,GAAA,IAEE,IAAA,WACQ,OAAA,GAAA,GAAe,SAAvB,SAAAuvE,CAAAA,EACyB,OAAA,GAAA,GAAA,GAAA,yBAAAlwE,IAA6BkwE,E,E,GCfxD,GAAA,C,Q,G,K,G,K,GAAA,OAAA,W,O,E,EAAA,SAAA,W,O,E,C,EAHE/rC,GAAA,SAAA,CAAA,EAAA,OAAA,EAAA,IAAA,A,ECgCF,GAAA,SAAAuU,CAAAA,EAAA,OAAA,SAAA,CAAA,EAKe,OAAfA,EAAA,E,C,E,G,G,I,I,G,G,I,G,G7FqGA,I,G,G,I,G,G,I,G,A,G,I,I,G,G,I,G,G,I,G,G,I,G,G,I,I,I,G,G,I,G,G9DvGA,CAAA,IAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA,CAAA,EACM,OAAA,ADTN20B,GCSkC,SAAA,CAAA,EAAE,OAAmB,GAAU,SAAA,CAAA,EAA/D30B,OAAAA,EAAA,EAAA,MAAA,CAA+D,G,G,E,M,CAA/D,GAAA,E,C,C,G,G,G,I,G,G,I,G,G,I,G,G,I,G,G8DsGF,I,GdtDgB,G,IAAAt6C,I,I,G,GcsFhB,IzDmSA,SAAA,CAAA,EAGE,IAAAkvE,EAAK,SAAA,CAAA,EACH,GAAA,aAAA,G,O,G,K,CACA,GAAA,aAAA,GAAA,CALJ,IAAA,EAAAl2E,GAMmB,GAAA,EAAA,MAAA,EACX,GAPR,aAAA,GAOqB,OAAA,GAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAA0Bk2E,EAAA,EAAA,MAAA,EAAA,EAAA,MAAA,EACvC,GARR,aAAA,GAQqB,OAAA,GAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAA6BA,EAAA,EAAA,MAAA,GAC1C,GATR,aAAA,GASqB,OAAA,GAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CATrB,OAAA,AAAA,MAAA,yFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,M,A,M,yF,C,E,W,C,I,C,C,EACWA,OAAAA,C,G,I,G,G,A,G,K,I,G,G,A,G,Y,IvE3aX,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAEO,OAAA,GAAA,GAAL,SAAArB,CAAAA,EACOA,OAAAA,GAAAA,GAAE,E,E,C,G,G,GgIoIX,I,G,G,I,G,GAAA,I,G,G,I,I,G,G,C,G,CX7CA,GKvDA,CAAA,SAAA,SAAA,CAAA,EAGI,IAAAqB,EAAA,SAAAzlC,CAAAA,EACS,OAAA,GAAA,EAAEA,IAAT,SAAA,CAAA,EAEE,GADG,aAAA,GACE,OAAAvR,GADF,EAAA,MAAA,EAEH,GAFG,aAAA,GAEE,OAAKg3C,EAFP,EAAA,MAAA,CAAA,OAAA,AAAA,MAAA,kFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,E,EAJIA,OAAAA,C,EADf,OAAA,W,O,E,C,G,M,I,K,G,M,G,Q,I,G,G,G,Y,I,G,G,ILuDA,SAAA,CAAA,EACsBA,OAAAA,GAEpB,SAAA50B,CAAAA,EAHF,IAAA,EAIc,GAAOA,GACjB,GALJ,aAAA,GAKW,OAAA7zB,GAAA,GAAA,MAAA,EAAAwoC,GALX,EAAA,MAAA,GAMI,GANJ,aAAA,GAMS,OAAAxoC,GAAQ,SAAA,CAAA,EANjB,OAAA,GAAA,MAAA,CAAA,EAAA,MAAA,CAMiB,GAAgB,GAAA,EANjC,EAAA,MAAA,EAAA,OAAA,AAAA,MAAA,2FAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,E,G,I,G,G,I9CmWA,SAAA6zB,CAAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAA,IAAA,EAE2B,GAAAthD,GAAoB,EAAE,GAFjD,EAGOshD,EAHP,EAAA,MAAA,EAII,GAJJ,aAAA,GAKa,OAAA,GALb,EAAA,MAAA,CAAA,EAAA,MAAA,EAMI,GANJ,aAAA,GAMS,OACI,GAAmB,EAPhC,EAAA,MAAA,CAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAAA,OAAA,AAAA,MAAA,yFAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,C,GuJtUA,GAAA,SAAAs0B,CAAAA,EAAA,OAAA,SAAA,CAAA,EAKuBA,OAAAA,GAAAA,GAAAA,GAAAA,KAAS,SAAA,CAAA,EAC5B,GAAA,aAAA,GAAW,OAAA,EACX,GAAA,aAAA,GAAK,OAAAxgE,GAAA,GAAA,IAAA,GAAA,IAAA,GAAmC,EAAA,EAAA,MAAA,IAASwgE,G,O,A,M,gG,C,E,W,C,I,C,C,E,C,EAzBrD,GAAA,SAAA,CAAA,EAAA,OAAA,SAAAt0B,CAAAA,EAEyB,OAAA,GAAA,GAAA,GAAA,C,a,G,K,C,W,G,K,AAA2C,GAAA,KAAlE,WACqBA,OAAAA,GAAAA,GAAAA,IAArB,SAAA,CAAA,EACsD,OAAA,GAAA,GAAA,GAAA,KAAtD,SAAA,CAAA,EAAA,OAAAkU,GAAAjrB,GAAAwC,IAAA,EAAA,UAAA,GACA,WADA,OAAA,GAAA,GAAA,EAAA,YAAA,GAEA,WACK,OAAA,GAAA,E,E,E,E,E,E,C,EAsBP,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,IAAA,OApBA,GAAA,SAAAuU,CAAAA,EAAA,OAAA,SAAAs0B,CAAAA,EAMyCA,OAAAA,GAAAA,GAAAA,GAAAA,KAAvC,SAAA,CAAA,EAAA,OAAAxgE,GAAA,GAC0B,SAAA26B,CAAAA,EAAM,MAAA,CAASA,MAAAA,EAAI,EAAJ,EAAcuR,MAAAA,EAAEvR,E,CADzD,GAAA,EAAA,KAAA,E,E,C,EAxHF,GAAA,SAAA,CAAA,EAAA,OAAA,SAAA6lC,CAAAA,EAAA,OAAA,SAAAV,CAAAA,EAOyCU,OAAAA,GAAAA,GAAAA,GAAAA,KAAvC,SAAA,CAAA,EAAA,OACA,GAAM,GAAOA,GADb,EAAA,SAAA,CAAA,IAAA,CAAA,IAAA,GAAAtxE,GAAA,GAAA,MAAA,EAAA,GACqE4wE,IAAA,GAAA,GAAA,KAAA,I,E,C,C,EAEvE,GAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAM+CgB,OAAAA,GAOpC,SAAA,CAAA,MAwEX,EA1CgD,EA4B9C,EAzDE,GAAA,aAAA,GAAM,OAAAxtC,GAAAtzB,GAAA,GARV,KASM,SAAA,CAAA,EAzBN,IAAA,EAAA,EAAA,MAAA,CAyBM,EAAA,KAAA,SAEE,AAAA,GAFF,EAAA,KAAA,EAzBN,EAAA,MAAA,EAAA,GAAA,EAAA,MAAA,EA8BmD,GAAA,GAAA,GAAA,CAL7C,UAAA,EAAA,SAAA,CAAA,KAAA,EAAA,IAAA,CAAA,SAAA,EAAA,QAAA,CAAA,WAAA,EAAA,UAAA,CAAA,YAAA,EAAA,WAAA,CAAA,QAAA,EAAA,OAAA,CAAA,WAAA,EAAA,UAAA,CAAA,eAAA,EAAA,cAAA,CAAA,YAAA,EAAA,WAAA,CAAA,gBAAA,EAAA,eAAA,CAAA,UAAA,EAAA,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,cAAA,EAAA,aAAA,CAAA,MAAA,EAAA,KAAA,CAAA,kBAAA,EAAA,iBAAA,CAzBN,MAAA,EAAA,MAAA,AA8B2EwgE,GAd3E,KAcc,WACA,OAAA,GAAA,GANR,EAAA,iBAAA,EATN,EASM,EAAA,iBAAA,EATN,KAec,WA/Bd,OAAA,GAAA,EAAA,MAAA,C,E,E,GAiCI,GAAA,aAAA,GAAU,OAAAltC,GACD,GAAA,IAlBb,IAkBM,SAAA,CAAA,M/FqEN,E+FpEiD,OAAA,GAAA,GAAA,C/FoEjD,E+FpEiD,EAAA,MAAA,CAAA,G/FoEjD,SAAA,CAAA,EAKW,OAAX,EAA6B,SAAA,CAAA,EAA7B,OAAA,GAAA,EAA6B,G,E,G+FzEyB,SAAA,CAAA,EAC9C,OAAA,GAAY,GApBpB,GAAA,GAoBiC,IAAA,GAAkB,IAD7C,KAAA,SAAA,CAAA,EAEwDktC,OAAAA,GAAAA,GAAAA,GArB9D,KAqBM,SAAA,CAAA,EAAA,OAAApgB,GAAApgD,GAAA,GAAAzF,GAAA6W,GACwC,GAAI,KAD5C,EAAA,aAAA,IACA,WACQ,OAAA,GAAA,EAAA,MAAA,CAAA,G,E,E,E,GACV,GAAA,aAAA,GAAY,OAAAgvC,GAAApgD,GACGo1B,CAsDnB,EAtDmB,EAAA,MAAA,CAsDnB,SAAAorC,CAAAA,EAME,OAAA,WAA4CA,IAAAA,EAAAA,GAAAA,KAA5C,EAAA,GAAA,EAAA,aAAA,IAEmC,OAAA,GAAA,IAAA,GAAA,GAAA,IAAQ,K,C,GAvF7C,KAyBM,W,O,G,E,M,C,GAEF,GAAA,aAAA36C,GAAK,OAAA,EAAA,MAAA,CAEL,GAAA,aAAA+O,GAAW,OAoCb,EAnCmB,EAAA,MAAA,CAyCsB4rC,GAAAA,GAAAA,GAvE3C,KAuEI,SAAA,CAAA,EAAA,OAAA,AlGvHJK,GkGwH6B,SAAA,CAAA,EAKM,OAAA,GAAA,EAAA,MAAA,EAAA,GAAA,EAAA,MAAA,CAAA,IAH3B,SAAA,CAAA,EAAW,OAAApvC,GAAA6B,GAAAtzB,GAAA,GAAX,KACE,SAAA,CAAA,EACgB,OAAA,ADrE1B6gE,GCqE0B,SAAA,CAAA,EAAO,OAAA,GA5EjC,GA4E8C,EAAA,OAAA,EAAA,EAAA,MAAA,CAAkB,GAAA,E,G,GAL5D,EAAA,QAAA,GACA,GAAA,E,GAzCA,GAAA,aAAA,GAAM,OAAAvtC,GAAAtzB,GAAA,GA/BV,KAgCM,SAAA,CAAA,EAAA,OAAAszB,GAAAtzB,GAAA,GAAA,EAAA,UAAA,IACA,SAAAylB,CAAAA,EACA,OAAA,GAAA,GAFA,EAAA,WAAA,EAEwBA,EAAA,EAAA,MAAA,IAAxB,W,O,G,E,M,C,E,E,GAEF,GAAA,aAAA,GAAK,OAAA+L,GAAAmyC,GAAA,CACuC,EAAa,GArC7D,GAAA,G5G0C4B,GAAA,SAAA,CAAA,EAAM,OAAA,G4GL2B,GAAA,E5GKjC,I,I,E,M,I4GJxB,GAAA,aAAA,GAAK,OAAArwC,GACI,GAAA,IAvCb,IAuCM,SAAA,CAAA,EACgDktC,OAAAA,GAAAA,GAAAA,GAxCtD,KAwCM,SAAA,CAAA,EAAA,OAAAltC,GAAAtzB,GAAA,GAC+B,CAAA,KAA/B,SAAA,CAAA,MpGwKN,EoGrKY,OAAA,GAAA,GAAA,CpGqKZ,EoGrKY,GAAA,WACU,OADY,GAAA,GAAA,IAJ5B,EAAA,KAAA,IAKgB,GAAA,CAAA,GAAK,IAElB,GpGkKT,SAAAq7B,CAAAA,MAuBA,EAtBgB,MAAA,CAsBhB,EAtBgBvR,GAAA,IAsBhB,SAAA,CAAA,MJoxBmBg4C,EIlxBF,OJkxBEA,EIjxBf,CAAgB,OAAA,GAAA,GACA,OAAA,GAAA,GACG,UAAA,GAAA,E,EJgxBZ,SAAU,CAAA,EACf,OAAO,GAAI,OAAA,CIpxBA,EJoxBiBA,EAAS,EACvC,C,GI7yBY,GAA2B,IAAA,GAAYzmC,G,GoGnK9C,GA/CT,GAAA,GA+CsB,EAAA,MAAA,KALhB,SAAA,CAAA,EAM+B,OAAA,GAAA,GAAA,GAAA,GAAA,IAAA,GAAAvnB,GACP,GAAI,IAT5B,EAAA,KAAA,KAQA,WAEQ,OAAA,GAAA,EAAA,MAAA,CAAA,G,E,E,E,E,GACV,GAAA,aAAA,GAAK,OAAAwf,GAAAtzB,GAAA,GAnDT,KAoDM,SAAA,CAAA,EAAA,OAAAszB,GAAAtzB,GAAA,GAAA,EAAA,KAAA,IACA,SAAA,CAAA,EACkC,OAAA,GAAA,GAAA,IAAA,GAAA,EAAA,MAAA,EAAA,KAAlC,W,O,G,E,M,C,E,E,GAEF,GAAA,aAAA,GAAK,OAAAszB,GAAAtzB,GAAA,GAxDT,KAyDM,SAAA,CAAA,EAAA,OAAAszB,GAAAtzB,GAAA,GAAA,EAAA,KAAA,IACA,SAAA,CAAA,EAC4B,OAAA,GAAA,GAAA,GAAA,GAAA,eAAA6T,GAAA,EAAA,MAAA,EAA4B,KAAxD,W,O,G,E,M,C,E,E,GAEF,GAAA,aAAA,GAAQ,OAAAyf,GAAAtzB,GAAA,GA7DZ,KA8DM,SAAA,CAAA,EAAA,OAAAxM,GAAA,EAAA,MAAA,CAAAugB,GAAA,EAAA,MAAA,EAAA,EAAA,IAAA,G,E,O,A,M,+F,C,E,W,C,I,C,C,GA9DN,E,C,C,EA9BA,GAAA,SAAA,CAAA,EAAA,OAAA,SAAAysD,CAAAA,EAMmB,OAAA,SAAA,CAAA,EACjB,GAAA,aAAA,GAAiB,OAAAxgE,GAAA,GAAA,IACewgE,GAAA,GAAqB,SAAA,CAAA,EACjD,MAAA,CAAA,UAAA,EAAA,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,SAAA,EAAA,QAAA,CAAA,WAAA,EAAA,UAAA,CAAA,YAAA,EAAA,WAAA,CAAA,QAAA,EAAA,OAAA,CAAA,WAAA,EAAA,UAAA,CAAA,eAAA,EAAA,cAAA,CAAA,YAAA,EAAA,WAAA,CAAA,gBAAA,EAAA,eAAA,CAAA,UAAA,EAAA,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,cAAA,EAAA,aAAA,CAAA,MAAA,EAAA,KAAA,CAAA,kBAAA,EAAA,iBAAA,CAAiC,KAAA,GAAA,GAAA,EAAA,MAAA,GAAA,EAAA,MAAA,EAAA,EAAA,IAAA,C,C,KACrC,GAAA,aAAA,GAAa,OAAAltC,GAAAtzB,GAAA,GAC4BwgE,KAAvC,SAAA,CAAA,EAAA,OACA,GAAM,GAAOA,GADb,EAAA,SAAA,CAAA,IAAA,CAAA,IAAA7oD,GAAA,EAAA,MAAA,CAAA,K,E,O,A,M,8F,C,E,W,C,I,C,C,C,C,E,G,G,I,G,G,I,G,G,I,I,G,G,I,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,I,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,G,G,I,I,G,G,I,IpJ0EJ,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAMa,OAAA5T,GAA8B,SAAA,CAAA,EAA3C,OAAA,EAA2C,EAA3C,GAAA,E,C,G,I,G,G,I,ImJrBA,SAAAmoC,CAAAA,EAMkB,OAAA,AAvClB20B,GAuCiC,SAAA,CAAA,EAAiB30B,OAAAA,GAAAA,GAAE,EAAA,SAAA,C,E,G,G,G3LEpD,CAAA,SAAA,SAAAA,CAAAA,EAAA,OAAA,SAAA7Q,CAAAA,EAYI,IAAA,EACyB,SAAA,CAAA,EAAE,GAAA,aAAA,GAAK,OAAA,EAAA,MAAA,A,O,A,M,gG,C,E,W,C,I,C,C,EAXhC,OAAA,WAAiB6Q,IAAAA,EAAAA,GAAAA,IAAAA,EAAE7Q,MAQnB,O,A,WANiB,KAAA,CAAA,WAAN,IAAA,EAAA,GAAA,KACP,GAAA,aAAA,GAGO,OADU,GADV6Q,EAAA,EAAA,MAAA,KACY,KACZ,CAAA,EACP,GAAA,aAAA,GAAK,MAAU,CAAA,C,O,A,M,gG,C,E,W,C,I,C,C,M,IACnB,GAAA,GAAA,GAAsB,K,C,C,EAV1B,OAAA,W,O,E,C,G,G,G,I,G,G,I,G,G,I6LkKA,GAC+B,GAAA,C,a,G,K,C,W,G,K,A,GAE/B,GAAA,SAAAs0B,CAAAA,EAEE,OAAA,WAAkBA,IAEN,EAFMA,EAAAA,GAAAA,KAEb,OADaA,GAAAA,GAAAA,KAAAA,EAAAA,KACb,GAAA,IAAO,EAAAz8D,GAAA4zB,IAAA,SAAA,CAAA,EAAmB,OAAA,GAAA,EAAA9vC,GAAnB,I,K,C,ECpSVwzB,GAAa,SAAUxnB,CAAAA,EACzB,OAAO,SAAU,CAAA,EACf,OAAO,WACL,OAAO,CAAA,CAAKA,EAAZ,AACF,CACF,CACF,EAUuBwnB,GAAW,WACJA,GAAW,iBAClC,IAAM,GAAcA,GAAW,cACRA,GAAW,iBAQfA,GAAW,cACVA,GAAW,cACZA,GAAW,aACLA,GAAW,mBACpC,IAAM,GAAeA,GAAW,eAiGhC,SAAS,GAAY,CAAA,EAC1B,OAAO,SAAUomD,CAAAA,EACf,OAAO,WACLA,EAAO,WAAA,CAAY,EACrB,CACF,CACF,CAtG0BpmD,GAAW,aAUVA,GAAW,e,I,G,G,ICuCtCX,IACa,GAAAxrB,GAAA,IAAA,SAAA,CAAA,EAAA,OAAA,GAAA,GAAA,G,GAoCb,IACc,GAAAA,GAAA,IAAA,SAAA,CAAA,EAAA,OAAA,GAAA,GAAA,G,G,G,S,C,C,C,C,C,E,I,E,E,E,O,S,C,E,G,A,I,E,O,E,G,A,I,E,M,A,e,E,uD,E,U,E,I,E,G,O,E,E,E,I,E,E,C,C,E,G,G,I,G,G,I,G,G,I,I,G,K,G,G,I,G,G,G,G,M,G,G,I,G,G,I,G,G,I,G,G,I,G,G,ICuDdurB,GAAA,SAAA,CAAA,EACa,OACX,WADF,IAAA,EAAA,GAAA,EAAA,IAAA,IAEa,OAAA,GAAA,SAAA,CAAA,MF/Be,EE6B5B,MAAA,CF7B4B,EE6B5B,EAAA,IAAA,CF5BS,SAAUgnD,CAAAA,EACf,OAAO,WACLA,EAAO,WAAA,CAAY,EACrB,CACF,GE0BuC,EAAI,GAAA,I,C,EEjLE3mC,ADW/C,GAAA,GAAA,IAAA,IAEE,SAAA4oC,CAAAA,MDkHFzB,ECjH2ByB,ODiH3BzB,ECjH2ByB,EDwHzB,GAAA,GAAA,G1BxEF7C,I0BwEE,GAAA,IAAA,OAAA,SAAAniD,CAAAA,MH3BFklD,EG4BY,MAAA,CH5BZA,EGmCE,C,OAMA,SAAAn+C,CAAAA,EAAA,OAAA,SAAA,CAAA,EAAA,OAAA,SAAA,CAAA,EAOO,OACL,SAAA,CAAA,EACE,GAAA,aAAA,GACE,OAAA,WAHN,IArGF/G,EAsEE,EANA,EAqCA,EAAA,GAAA,KAK+C,EAAA,IA1GjDA,EAiFuBA,EAXrB,EAAA,ALzBFmiD,GK0B4B,SAAA,CAAA,EAAE,OAAA,EAAA,IAAA,A,GAP5B,EACO,SAAA,CAAA,SAEH,AADG,aAAA,GACE,GADF,EAAA,MAAA,EAEH,E,EA3DJ,CAAatiD,YAQb,SAAA,CAAA,EAkCE,IAAAia,EAAA,GAAA90B,IACqC,G,E,G,Q,sB,WAZ7B,OAAA,SAAA,CAAA,CAAAs+B,CAAAA,EAEJ,GADG,aAAA,GAAA,CAED,GADgBA,aAAA,GAAAA,OADf,GAAA,EAAA,MAAA,EACeA,EAAAA,KAAAA,EAAA,MAAA,EAIhB,GAJgBA,aAAA,GAAA,CADf,IAAA,EAAA,GAAA,EAAA,MAAA,CACeA,EAAA,MAAA,EAMsB,OAAA,AhJhFhD6+B,GgJgFgD,IAAA,GAAA,GAAA,GAAA,IAAA,GAAa,GAAA,EAAA,KAAa,G,CANhD7+B,MAAAA,AAAAA,MAAAA,2FAAAA,CAAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,CAOlB,OAAA,EAAA,KAA6BA,E,C,G,E,G,S,sB,WArBxB,OAAA,SAAAA,CAAAA,EAEL,GADGA,aAAA,GACW,OAAA,EAAA,IADXA,EAAA,MAAA,EAGH,GAHGA,aAAA,GAAA,CAIwBxJ,IAAAA,EAAAA,EAJxBwJ,EAAA,MAAA,EAKmChqB,OAAAA,AhJlE9C6oD,GgJkE8C7oD,IAAAA,GAAAA,GAAAA,GAAA,IAAA,GAAYA,GAAA,EAAA,IAAY,G,CAL3DgqB,MAAAA,AAAAA,MAAAA,yFAAAA,CAAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,G,E,G,sB,sB,WA6Be,OAAA,SAAA,CAAA,EAIK,OAAA,AhJ9F/B6+B,GgJ8F+B,IAAA,GADd,EADJ,AADiB,GA8CI,KA7CT,MAEM,GAAA,KAAA,CAAA,EAAA,KAAmB,G,C,GA1B9C,EAAA,IATA,IAAA,EAAA,EAAA,IAHiB,OA8BjB,EAAA,KA9BiB,C,E,gBnHTrB,SAAA,CAAA,EAsCE,IAAA,EAAS,SAAA,CAAA,SACP,AAAA,aAAA,GAAS,AmH+CXp7C,EnH/CW,EAAA,MAAA,IACT,E,EARF,EAAW,SAAAloB,CAAAA,EAhCb,IAAA,EAAA4T,GAiCuB,OAAM5T,EAAA,KAAA,SACvB,AAlCN,aAAA,IAAA,EAAA,MAAA,YAAA,GAmCyB,EAnCzB,EAAA,MAAA,CAAA,MAAA,CAAA,IAAA,GAmC4C,KACtC,E,EAMJ,EAAA,SAAA,CAAA,EAAmB,OAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAEf,GADG,aAAA,GAGI,OAHJ,GAAA,GAAA,EAAA,MAAA,EAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAE2D,GACvD,EACP,GAJG,aAAA,GAMI,K3B5GgB,EAAK,E2B4GrB,O3B5GgB,E2BsGpB,EAAA,MAAA,C3BtGyB,E2BsGzB,EAAA,MAAA,C3BrGL,A2B0G0C,C3B1G1C,CAAI,EAAG,CAAI,E2B2GF,CAAA,CACP,GAPG,aAAA,GAAA,CA3CT,I3B3D6B,EAAK,EAJL,E2B+D7B,E3BlES,A2BqHmC,C3BrHnC,C2B6GA,EAAA,MAAA,C3B7GP,C2BsHQ,G3BnHmB,E2B0GpB,EAAA,MAAA,C3BzGA,A2BkH0C,E3BlHtC,cAAA,CAAe,G2BoHX,OAXR,GAAA,EAAA,MAAA,EAAA,GA3CT,MAsDiB,EAXR,IAAA,EAAA,GAAA,EAAA,MAAA,IAcgC,EAAA,GAAA,SAAA,CAAA,EAC3B,OAAA,WACiB,OAAA,EAAQ,AADXijE,GAAAA,KACc,G,C,KAGzB,O3BzHY,E2BsGpB,EAAA,MAAA,C3BtGyB,E2BsGzB,IAAA,GAiB8C,EAASA,G3BtH5D,A2BsHiE,C3BtHjE,CAAI,EAAG,CAAI,E2BqGN,A3B+CF,SAA0B,CAAA,CAAI,CAAA,CAAU,CAAA,EAC7C,EAAG,gBAAA,CAAiB,EAAI,EAAU,CAAA,EACpC,E2BjDS,EAAA,MAAA,CAkB6C,EAAS,GAC9C,C,CACX,GApBG,aAAA,GAsBI,OADY,EArBhB,EAAA,MAAA,CAAA,IAAA,GAqBmC,KAC/B,CAtBJ,OAAA,AAAA,MAAA,6FAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,C,E,E,G,Y,wB,WA1BK,OAAA,SAAAjjE,CAAAA,CAAA,CAAA,E,IAiFZ,EA/BW,E,E,KA7CP,GA4EJ,EA9EyCA,EAAA,MAAA,CA8EjB,SAAA,CAAA,CAAA,CAAA,EAEpB,GADG,aAAA,GACO,OAAA,GAAA,GADP,EAAA,MAAA,EAAA,EAAA,MAAA,CAE0D,GAC7D,GAHG,aAAA,GAGM,KAwBE,EAAA,EAxBF,OAwBE,EA3BR,EAAA,MAAA,CA4B4C,A3BzC1C,C2BwCM,EAvB4B,G3BjB/B,YAAA,C2ByC4B,GACU,G/BnMnC,K+BmMmC,EAAI,GAHxD,AAAA,UjBjMS,OVEA,A2BmM6C,C3BnM7C,C2BmMyC,E3BnMhD,KAQE,CAAA,A2B4LuD,C3B5LvD,C2B4LgD,E3B5LzC,C2B4L6C,E3B5LpD,E2B6LkB,YAAA,GAAA,AAAA,YAAA,M3B7LlB,CAAA,A2B8LyD,C3B9LzD,C2B8LmD,E3B9L5C,C2B8LgD,C3B9LvD,MAAA,CAAA,A2BgMgE,C3BhMhE,C2BgM2C,E3BhMpC,C2BgMoC,E3BhM3C,C2BgKE,CAEA,GALG,aAAA,GAAA,CAOC,IAAAkoB,E3B5KD,A2B4K0C,C3B5K1C,C2BqKA,EAAA,MAAA,C3BrKP,C2BqKO,OAAA,A3BLF,SAA6B,CAAA,CAAI,CAAA,CAAU,CAAA,EAChD,EAAG,mBAAA,CAAoB,EAAI,EAAU,CAAA,EACvC,E2BGS,EAAA,MAAA,CAAA,GAQiDA,GAAS,E,CAC7D,GATG,aAAA,GASC,OAAA,EATD,OAAA,AAAA,MAAA,6FAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,GA9EH,GA8CO,EA/C8BloB,EAAA,MAAA,CA+CA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAErC,GADG,aAAA,IAAI,aAAA,UAAJ,EAAA,MAAA,GAAI,EAAA,MAAJ,EAAI,GAAA,GAAA,EAAA,MAAA,EAAA,EAAA,MAAA,CAAA,EAAA,MAAA,CAK8D,GAFvD,EAId,GAPG,aAAA,IAAI,aAAA,GAAA,K3B/HgB,EAAK,EAAL,EAAK,S2BwIxB,A3B/CD89B,A2BsCA,EAAA,MAAA,GAAI,EAAA,MAAA,CAUI,EAVJ,AAAA,UAAA,EAAA,MAAA,E3BtIJ,A2BkJmD,EAAR,K3BlJlD,G2BsIW,EAAA,MAAA,G3B/HgB,E2B+HhB,EAAA,MAAA,C3B/HqB,E2B+HrB,EAAA,MAAA,C3B9HT,A2B8IoD,C3B9IpD,CAAI,EAAG,CAAI,G2B4IS,I3B7IK,E2B+HhB,EAAA,MAAA,C3B/HqB,E2B+HrB,EAAA,MAAA,C3B9HT,A2BiJgD,C3BjJhD,CAAI,EAAG,CAAI,E2BkJE,E,CACX,GArBG,aAAA,IAAI,aAAA,GAAA,CAuBH,IAAA5V,E3B7JD,A2B6J0C,C3B7J1C,C2BsII,EAAA,MAAA,C3BtIX,C2BsIW,GAAA,EAAA,MAAA,EAAA,GAwBYA,M3BtJrB,A2B+E0C,C3B/E1C,C2B8HS,EAAA,MAAA,C3B9HF,C2BuJiCA,C,CAEtC,OACO,C,GAzEP,EAAS,EAAU,GAHkBloB,EAAAA,GAAAA,EAAA,KAAA,CAIa,EAAI,GAAa,EAAQ,EAAO,GAElF,EACE,CAA4B,OAAA,AzBrCpCsjE,GyBqCoC,G,M,C,EAGN,OAAA,A7B7E9BA,G6B6E8B,IAAA,GAAA,GAAA,EAAA,EAAA,KAAoB,G,C,GAbhD,EAAA,EAAA,IAZkB,OAEL,SAAA,CAAA,E,I,E,KAEgC,EAAA,GAAA,EAAI,GAAc,EAAU,IAErEtjE,EACE,CAA4B,OAAA,AzBtBpCsjE,GyBsBoC,GACnB,MAAA,C,EAEatjE,OAAAA,A7B9D9BsjE,G6B8D8BtjE,IAAAA,GAAAA,GAAAA,EAAM,EAAU,G,C,EmHrBDmhB,SAAAA,C,IA4F3C,GAMU,EAAA4iD,GAAiB,GAEd,OADgB,GAAA,GAAA,GAAAtiD,A1ElF/B6hD,G0EuDgCoB,OA4BjB,C,Q,E,K,E,e,C,C,EACT,GAAA,aAAA,GAAM,OACJ,WAVN,GAAA,GAAA,EAAA,MAAA,CAAA,cAAA,I,I,E,G,E,M,C,I,I,E,G,E,M,C,I,IAAA,EAAA,GAAA,EAAA,MAAA,CAAA,OAAA,CAAA,GAcU,EAAAX,GAAoB,GAGjB,OAFoB,GAAA,GAAA,IAAA,EAAA,MAAA,CAAA,IAAA,EAAA,IACzB,AAQV,SAAA,CAAA,EACc,GAAd,AATgC,aAShC,IAAA,aAAA,GAAuC,KF7DpB,EE6DoB,OAAA7uE,GAAA,CF7DpB,EE6DnB,AATgC,EAShC,MAAA,CF5DW,SAAUgvE,CAAAA,EACf,OAAO,WACLA,EAAO,YAAA,CEiDS,EFjDW,EAC7B,CACF,GEwDJ,EAAA,MAAA,EAAc,QACA,AADd,AATgC,aAShC,IAAA,aAAA,GACoChvE,GAAA,GAVZ,GASxB,EAAA,MAAA,GAEce,GAAA,G,EAX0BiuE,MACzB,CAAuB,QAAA,EAAgB,KAAA,E,e,E,M,C,c,A,C,C,O,A,M,2F,C,E,W,C,I,C,C,C,C,C,E,Y,GA5BlDhnD,YAAAA,GACSA,QAAAA,E,EHtCb,SAAAinB,CAAAA,EAAA,OAAA,SAAA/G,CAAAA,EA4BE,IAAA,EAAA,SAAA,CAAA,EAAA,OAAA,SAAAlV,CAAAA,EAAA,OAAA,SAAA,CAAA,EAO0C,OAAA,A5F7C5Co7C,G4F6C4C,SAAA,CAAA,EACxC,OAAA,WAAS,IFpBbp7C,EE2GE,EAnFkB,EAJP,EAAA,KACc,EAAA,CFrB3BA,EEqB+BA,EFrB/B,SAAA,CAAA,EAQE,OAAA,WAAiC,IAAA,EAAA,GAAA,CAAA,K,E,GnJjFnCviB,M,E,GAAAA,MmJoFwBuiB,EAAAA,GAAAA,K,E,G,I,G,G,K,K,E,G,I,G,G,K,K,E,G,G,K,IAIL,EAAA,GAAA,K,E,G,I,G,O,E,G,MAwBV,OADI,GAjBP,CAAEic,UEAmB,EFCZA,MAAAA,AEDY,EFCZ,YAAA,CEDc,G,K,G,SrJ9F7Bx+B,G,W,E,Y,E,Q,E,W,E,e,E,Y,E,gB,E,U,G,K,CmJ0GQyyD,MAAAA,E,c,E,M,EAGmB,kBAAA,C,GAEE,KACpB,AAtFTkL,GAsF2B,E,C,GElBY,KACnB,EAAA,GAAA,KAIXiD,OAHK,GAAA,C,a,G,K,CAAmCD,WAAAA,EAAA,UAAAA,AAAiB,GAAA,KAC9C,GAAA,AFjEpBhD,IEiEoB,EAAA,EAAO,GAAP,SAAA,CAAA,EAAA,OAAA,E,AAAA,E,O,C,KAAwCiD,GAAAA,MACxD,IAkFF,EAlF+BD,EAAA,YAAA,CAyFd,AF3JnBhD,GE2JmB,SAAA,CAAA,EACT,IAAA,EAAA,GAA+B,GAAO,EAAA,OAAA,EAAY,EAAA,SAAA,CAAA,IAAA,CAAA,IAAA,GAAA,MACnC,OAAA,GAAA,SAAA,CAAA,EACjB,MAAA,CAEgC,aAAA,IAAA,GAAA,GAAA,GAAA,GAAA,EAAA,YAAA,IAAxB,WACA,OAAA,GAAA,GAAA,WAEE,OAAA,GAAA,WACA,OADA,GAAc,EAAA,cAAA,IACd,GAAc,EAAA,WAAA,G,E,EAChB,GAAA,GACM,WAAA,EAAA,UAAA,A,CAThB,GA3FsB,E,KAAK,GAA8BiD,MACtDA,C,C,E,C,C,EAEP,EAAA,SAAA,CAAA,EAAA,OAAA,SAAAA,CAAAA,EAKmC,OAAA,WAARA,IA6C3B,EAhCc,EAAA,EAGK,EAhBQA,EAAAA,GAAAA,K,E,G,I,G,E,e,KAEpB,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,KAAA,GAAA,EAAA,eAAA,K,GrJ5GT5gE,I,E,W,I,G,E,Q,E,E,U,IqJsHM,IAAAuiB,GACU,EAAA,GAAA,EAAA,eAAA,EAAA,EAAA,GAAwD,GAAA,EAAA,OAAA,EAAxD,SAAA,CAAA,EAAA,OAAA,EAAAhzB,GAA6C,EAA7C,I,GAEV,GACe,EAAA,GAAA,EAAA,cAAA,EAAA,SAAA,CAAA,EAAA,OAAA,EAAmCgzB,EAAA,GAAA,MAAA,CAAnC,I,GAGfm+C,EAAAA,EAAA,MAAA,CACG,SAAA,CAAA,EAAmBn+C,OAAAA,GAAAA,EAAnB,GACA,GAAA,CAwBP,EAxBwB,EAAA,UAAA,CAwBxB,SAAA,CAAA,EASkB,OAAA,A5FsDpBo7C,G4FtDoB,SAAA7+B,CAAAA,EACd,OAAA,WAAcA,IFzGpBkK,EEyGoBlK,EAAAA,GAAAA,EAAA,GAAA,EAAA,GAAsB,M,E,WAElC,GADU,aAAA,GAAA,CAAA,GAAA,EAAA,MAAA,CAAA,MAAA,EAEc,KAFd,IASW,EATX,EAAA,GAAA,EAAA,MAAA,CAAA,MAAA,IAAA,OAIa,AFtI/B6+B,GEsI+B,SAAA,CAAA,EACnB,OAAA,WAAA,IAAA,EAC4B,OADb,GAAA,IAAA,EAAA,UAAA,GAAf,EAAA,GAAAhgB,GAAA,KAxCc,GAwCd,SAAA,CAAA,EAA+B,OAAA,EAA8B7e,EAAA,MAAA,CAA7D,G,MAC4B,GAAA,GAAA,GAAO,EAAA,OAAA,EAAY,EAAA,SAAA,CAAA,IAAA,CAAA,IAAA,GAA8BA,EAAA,KAAA,CAAA,Q,CAF/E,GAAA,KAJQ,EAAA,MAAA,CAAA,MAAA,A,CAQV,GARU,aAAA,GASR,OAAA,EA5CW,IA4CQ,EAAA,GAAA6e,GAAA,KA5CH,GA4CG,SAAA,CAAA,EAAA,OAAA,EAA8B7e,EAAA,MAAA,CAA9B,G,IAA2CA,EAAA,KAAA,EAAWA,EAAA,SAAA,GATjE,OAAA,AAAA,MAAA,2FAAA,CAAA,EAAA,WAAA,CAAA,IAAA,CAAA,C,IAcH8hC,OAHJ,GADU,GAAA,SAAA,CAAA,EAAW9hC,OAAAA,GAAAA,EAAA,GAAA,CAAX,GAAiC,GAAA,GAAA,OXvN7C,WACL,QAAQ,IAAA,CWwNG,8FXvNb,KWwNiBA,GAAAA,EAAA,GAAA,CAAW8hC,IAAoB,KACnCA,GAAAA,GAAAA,KFxHf53B,EEwHoC,SAAA,CAAA,EAC5B,GAAA,aAAA,GAAiB,OlMlJjB,GAAA,GkMkJiB,qEACjB,GAAA,aAAA,GAAK,OAAA14C,GAAWowE,EAAA,WAAA,CAAA,EAAA,MAAA,E,O,A,M,2F,C,E,W,C,I,C,C,EFpHP,AA9BjB/C,GA8BgC,SAAA,CAAA,EAC9B,OAAA,AApBFA,GAoBkB30B,EAAE,EAAA,SAAA,E,M,C,E,GEgEM,EAAA,WAAA,GAAA,EAAA,SAAA,CAAA,MAAA,CAAA,EAAA,KAAA,GAAA,EAAA,SAAA,I,E,G,E,W,IAejB,OARY,G,G,E,U,KAAW,SAAA,CAAA,EAAE,OAC5B,W,I,E,G,KAEA,OADc03B,GAAAA,EAAA,WAAA,EAAuB,KACrC,EAAS,GAAK,I,C,KAE6B,GAAA,IAAA,EAAA,OAAA,EAAA,GAAA,SAAA,CAAA,EAC3C,MAAA,CAAA,UAAA,EAAA,SAAA,CAAA,MAAA,EAAA,KAAA,CAAA,KAAA,EAAA,IAAA,CAAA,WAAA,EAAA,UAAA,CAAA,YAAA,EAAA,WAAA,CAAA,QAAA,EAAA,OAAA,CAAA,WAAA,EAAA,UAAA,CAAA,eAAA,EAAA,cAAA,CAAA,YAAA,EAAA,WAAA,CAAA,gBAAA,EAAA,eAAA,CAAA,MAAA,EAAA,KAAA,CAAA,cAAA,EAAA,aAAA,CAAA,MAAA,EAAA,KAAA,CAAA,kBAAA,EAAA,iBAAA,CAAuB,UAAA,IAAA,GAAA,GAAsBtmD,SAAAA,C,C,MAE1C,GAAA,GAAA,GAAApf,IAAA,IACgB,SAAA,CAAA,EACjB,OAAA,W,IAEW,E,E,G,E,e,I,G,I,G,G,K,G,E,e,IAAA,IAAA,EAAA6F,GAAA4zB,IAAA,SAAA,CAAA,EAAmB,OAAA,GAAA,EAAA9vC,GAAnB,I,IAAiD,K,I,E,G,E,e,WAE5D,AAAS,GAAA,CAAA,GAAAwgB,IAAa,G,G,G,G,K,E,E,e,G,I,G,OAAtB,IAAA,GAAA,G,C,K,C,C,EAqDN,EAAA,SAAA,CAAA,EAMiB,OAAA,AF/KnBw4D,GE+KmB,SAAA,CAAA,EACb,OAAA,WAwCN,GAAA,GAAA,GAAA,MAAA,GAAA,AAxCoC,EAwCpC,aAAA,KAAA,GAAA,GAAA,KAAA,EAAA,AAxCoC,EAwCpC,aAAA,IAGa,GAAA,IAAA,EAAA,GAAA,GAAoC,cAApC,SAAA,CAAA,EAAmB,OAAA,GAAA,EAAnB,G,KAHb,GAAA,AAxCoC,EAwCpC,KAAA,KAAA,GAAA,IAAA,AAxCoC,EAwCpC,KAAA,IAvCU,IA0CG,EA1CH30B,EAAA,GAAe,GAAO,EAAA,OAAA,EAAY,EAAA,SAAA,CAAA,IAAA,CAAA,IAAA,GAAA,MAKrB,OAJE,GAAA,SAAA,CAAA,EACjB,MAAA,CAAgB,aAAA,EAAA,YAAA,CACFA,WAAAA,IAAAA,GAAAA,EAAI,EAAA,UAAA,C,CAFpB,GAAA,KAIiB,GAAA,EAAA,QAAA,EAAY,SAAA,CAAA,EAAE,OAC7B,W,I,E,G,KACA,OAAA,EAAS,GAAK,I,C,I,C,E,EAxJD,OAAA,GAAA,GAAA,KAAnB,SAAA,CAAA,EACiC,OAAA,GAAA,GAAA,GAAA,CAAA,KAAjC,SAAA,CAAA,EACqB,OAAA,GAAA,GACnB,W,IACuC,E,E,KAAnB,EAAA,GAAA,IAAA,EAAa,IAAM,EAAA,GAAyB,EAAA,QAAA,EAAzB,SAAA,CAAA,EAAe,OAAA,GAAA,EAAf,G,IAAuCvR,GAAE+G,MAC3D,OAAA,AFrCzBm/B,GEqCyB,SAAA,CAAA,MAMvBL,EA+IA,EApJI,OAAA,GAAA,CAAS,KAAA,EAKbA,EALiC,EAAA,OAAA,CAKjC,SAAAV,CAAAA,EAMuB,OAAA,GAAA,GAAA,GAXC,KAYpB,SAAA,CAAA,SAAA,AAAA,E,G,G,K,EAAA,GACgB,GAAOU,GAAIV,E,E,GAZf,SAAA,EAAA,OAAA,CACD,OAAA,EAkJf,EAlJqC,EAwJY,GAxJjB,GA0J5B,kBAAA,AADO,GAzJY,K,IA6JP,GAAA,CAAA,GA7JO,KA8JjB,EA9J0B,GA8JZ,KACO,AFvM7Be,GEuM6B,SAAA,CAAA,EAAC,OACpB,WAAC,OAAAz8D,GAAD,A,G,G,E,O,KAAA,SAAA,EACkBw/D,EAAA,OAAA,G,CAFpB,GAAA,K,G,EAlKJ,GAAA,I,E,E,E,C,GIzGuBF,IAAAA,G,E,K,C","sources":["<anon>","bundle/app.js","node_modules/big-integer/BigInteger.js","output/Control.Apply/foreign.js",".spago/p/prelude-6.0.1/src/Control/Semigroupoid.purs",".spago/p/prelude-6.0.1/src/Control/Category.purs",".spago/p/prelude-6.0.1/src/Data/Boolean.purs",".spago/p/prelude-6.0.1/src/Data/Function.purs","output/Data.Functor/foreign.js","output/Data.Unit/foreign.js",".spago/p/prelude-6.0.1/src/Type/Proxy.purs",".spago/p/prelude-6.0.1/src/Data/Functor.purs",".spago/p/prelude-6.0.1/src/Control/Apply.purs",".spago/p/prelude-6.0.1/src/Control/Applicative.purs","output/Control.Bind/foreign.js",".spago/p/prelude-6.0.1/src/Control/Bind.purs",".spago/p/prelude-6.0.1/src/Control/Monad.purs","output/Data.Semigroup/foreign.js",".spago/p/prelude-6.0.1/src/Data/Symbol.purs","output/Record.Unsafe/foreign.js",".spago/p/prelude-6.0.1/src/Data/Semigroup.purs",".spago/p/control-6.0.0/src/Control/Alt.purs","output/Data.Bounded/foreign.js","output/Data.Ord/foreign.js","output/Data.Eq/foreign.js",".spago/p/prelude-6.0.1/src/Data/Eq.purs",".spago/p/prelude-6.0.1/src/Data/Ordering.purs","output/Data.Ring/foreign.js","output/Data.Semiring/foreign.js",".spago/p/prelude-6.0.1/src/Data/Semiring.purs",".spago/p/prelude-6.0.1/src/Data/Ring.purs",".spago/p/prelude-6.0.1/src/Data/Ord.purs",".spago/p/prelude-6.0.1/src/Data/Bounded.purs","output/Data.Show/foreign.js",".spago/p/prelude-6.0.1/src/Data/Show.purs",".spago/p/prelude-6.0.1/src/Data/Generic/Rep.purs",".spago/p/maybe-6.0.0/src/Data/Maybe.purs",".spago/p/either-6.1.0/src/Data/Either.purs","output/Effect/foreign.js","output/Data.EuclideanRing/foreign.js",".spago/p/prelude-6.0.1/src/Data/CommutativeRing.purs",".spago/p/prelude-6.0.1/src/Data/EuclideanRing.purs",".spago/p/prelude-6.0.1/src/Data/Monoid.purs",".spago/p/effect-4.0.0/src/Effect.purs","output/Effect.Exception/foreign.js",".spago/p/exceptions-6.0.0/src/Effect/Exception.purs",".spago/p/transformers-6.0.0/src/Control/Monad/Error/Class.purs",".spago/p/identity-6.0.0/src/Data/Identity.purs","output/Effect.Ref/foreign.js",".spago/p/refs-6.0.0/src/Effect/Ref.purs",".spago/p/tailrec-6.1.0/src/Control/Monad/Rec/Class.purs","output/Data.HeytingAlgebra/foreign.js",".spago/p/prelude-6.0.1/src/Data/HeytingAlgebra.purs",".spago/p/tuples-7.0.0/src/Data/Tuple.purs",".spago/p/transformers-6.0.0/src/Control/Monad/State/Class.purs",".spago/p/transformers-6.0.0/src/Control/Monad/Trans/Class.purs",".spago/p/effect-4.0.0/src/Effect/Class.purs",".spago/p/transformers-6.0.0/src/Control/Monad/Maybe/Trans.purs","output/Data.Array/foreign.js","output/Control.Monad.ST.Internal/foreign.js",".spago/p/st-6.2.0/src/Control/Monad/ST/Internal.purs","output/Data.Array.ST/foreign.js","output/Control.Monad.ST.Uncurried/foreign.js",".spago/p/arrays-7.3.0/src/Data/Array/ST.purs","output/Data.Foldable/foreign.js",".spago/p/control-6.0.0/src/Control/Plus.purs",".spago/p/bifunctors-6.0.0/src/Data/Bifunctor.purs","output/Unsafe.Coerce/foreign.js",".spago/p/safe-coerce-2.0.0/src/Safe/Coerce.purs",".spago/p/newtype-5.0.0/src/Data/Newtype.purs",".spago/p/foldable-traversable-6.0.0/src/Data/Foldable.purs","output/Data.Function.Uncurried/foreign.js","output/Data.FunctorWithIndex/foreign.js",".spago/p/prelude-6.0.1/src/Data/Monoid/Additive.purs",".spago/p/foldable-traversable-6.0.0/src/Data/FunctorWithIndex.purs","output/Data.Traversable/foreign.js",".spago/p/foldable-traversable-6.0.0/src/Data/Traversable.purs","output/Data.Unfoldable1/foreign.js",".spago/p/foldable-traversable-6.0.0/src/Data/Semigroup/Foldable.purs",".spago/p/unfoldable-6.0.0/src/Data/Unfoldable1.purs",".spago/p/arrays-7.3.0/src/Data/Array.purs",".spago/p/exists-6.0.0/src/Data/Exists.purs",".spago/p/free-7.1.0/src/Data/Coyoneda.purs",".spago/p/foldable-traversable-6.0.0/src/Data/FoldableWithIndex.purs",".spago/p/foldable-traversable-6.0.0/src/Data/TraversableWithIndex.purs",".spago/p/nonempty-7.0.0/src/Data/NonEmpty.purs",".spago/p/lists-7.0.0/src/Data/List/Types.purs",".spago/p/ordered-collections-3.1.1/src/Data/Map/Internal.purs",".spago/p/control-6.0.0/src/Data/Monoid/Alternate.purs",".spago/p/halogen-7.0.0/src/Halogen/Data/OrdBox.purs",".spago/p/halogen-7.0.0/src/Halogen/Data/Slot.purs","output/Data.String.Common/foreign.js",".spago/p/strings-6.0.1/src/Data/String/Common.purs",".spago/p/dom-indexed-12.0.0/src/DOM/HTML/Indexed/InputType.purs",".spago/p/dom-indexed-12.0.0/src/DOM/HTML/Indexed/StepValue.purs",".spago/p/halogen-7.0.0/src/Halogen/Query/Input.purs","output/Data.Nullable/foreign.js",".spago/p/nullable-6.0.0/src/Data/Nullable.purs",".spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Machine.purs",".spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Types.purs","output/Halogen.VDom.Util/foreign.js","output/Foreign.Object.ST/foreign.js",".spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Util.purs","output/Web.DOM.Element/foreign.js","output/Web.DOM.ParentNode/foreign.js",".spago/p/web-dom-6.0.0/src/Web/DOM/ParentNode.purs","output/Web.Internal.FFI/foreign.js",".spago/p/web-events-4.0.0/src/Web/Internal/FFI.purs",".spago/p/web-dom-6.0.0/src/Web/DOM/Element.purs",".spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/DOM.purs","output/Foreign/foreign.js",".spago/p/transformers-6.0.0/src/Control/Monad/Except/Trans.purs","output/Data.Int/foreign.js","output/Data.Number/foreign.js",".spago/p/integers-6.0.0/src/Data/Int.purs",".spago/p/lists-7.0.0/src/Data/List.purs","output/Partial.Unsafe/foreign.js","output/Partial/foreign.js",".spago/p/partial-4.0.0/src/Partial.purs",".spago/p/partial-4.0.0/src/Partial/Unsafe.purs",".spago/p/lists-7.0.0/src/Data/List/NonEmpty.purs","output/Data.String.CodeUnits/foreign.js",".spago/p/strings-6.0.1/src/Data/String/CodeUnits.purs",".spago/p/foreign-7.0.0/src/Foreign.purs","output/Foreign.Object/foreign.js",".spago/p/foreign-object-4.1.0/src/Foreign/Object.purs","output/Web.Event.EventTarget/foreign.js",".spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/DOM/Prop.purs",".spago/p/web-html-4.1.0/src/Web/HTML/Common.purs",".spago/p/halogen-7.0.0/src/Halogen/HTML/Core.purs",".spago/p/freeap-7.0.0/src/Control/Applicative/Free.purs",".spago/p/catenable-lists-7.0.0/src/Data/CatQueue.purs",".spago/p/catenable-lists-7.0.0/src/Data/CatList.purs",".spago/p/free-7.1.0/src/Control/Monad/Free.purs","output/Effect.Aff/foreign.js",".spago/p/parallel-7.0.0/src/Control/Parallel/Class.purs",".spago/p/parallel-7.0.0/src/Control/Parallel.purs","output/Effect.Unsafe/foreign.js",".spago/p/aff-7.1.0/src/Effect/Aff.purs",".spago/p/aff-7.1.0/src/Effect/Aff/Class.purs",".spago/p/halogen-7.0.0/src/Halogen/Query/ChildQuery.purs","output/Unsafe.Reference/foreign.js",".spago/p/unsafe-reference-5.0.0/src/Unsafe/Reference.purs",".spago/p/halogen-subscriptions-2.0.0/src/Halogen/Subscription.purs",".spago/p/halogen-7.0.0/src/Halogen/Query/HalogenM.purs",".spago/p/halogen-7.0.0/src/Halogen/Query/HalogenQ.purs",".spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Thunk.purs",".spago/p/halogen-7.0.0/src/Halogen/Component.purs",".spago/p/halogen-7.0.0/src/Halogen/HTML/Elements.purs",".spago/p/transformers-6.0.0/src/Control/Monad/Except.purs","output/Foreign.Index/foreign.js",".spago/p/foreign-7.0.0/src/Foreign/Index.purs","output/Web.Event.Event/foreign.js",".spago/p/control-6.0.0/src/Control/Alternative.purs",".spago/p/web-events-4.0.0/src/Web/Event/Event.purs",".spago/p/web-html-4.1.0/src/Web/HTML/Event/DragEvent/EventTypes.purs",".spago/p/web-html-4.1.0/src/Web/HTML/Event/EventTypes.purs","output/Web.HTML.HTMLInputElement/foreign.js",".spago/p/web-html-4.1.0/src/Web/HTML/HTMLInputElement.purs",".spago/p/web-uievents-5.0.0/src/Web/UIEvent/FocusEvent/EventTypes.purs",".spago/p/web-uievents-5.0.0/src/Web/UIEvent/MouseEvent/EventTypes.purs",".spago/p/halogen-7.0.0/src/Halogen/HTML/Events.purs",".spago/p/halogen-7.0.0/src/Halogen/HTML/Properties.purs",".spago/p/record-4.0.0/src/Record.purs","src/Util/Halogen.purs","src/App/Selector.purs",".spago/p/halogen-7.0.0/src/Halogen/HTML.purs","output/Web.HTML.HTMLElement/foreign.js",".spago/p/web-html-4.1.0/src/Web/HTML/HTMLElement.purs",".spago/p/halogen-7.0.0/src/Halogen/Query.purs","output/Data.Argonaut.Core/foreign.js",".spago/p/argonaut-core-7.0.0/src/Data/Argonaut/Core.purs",".spago/p/argonaut-codecs-9.1.0/src/Data/Argonaut/Decode/Error.purs",".spago/p/arrays-7.3.0/src/Data/Array/NonEmpty/Internal.purs",".spago/p/arrays-7.3.0/src/Data/Array/NonEmpty.purs","output/Data.String.CodePoints/foreign.js",".spago/p/argonaut-codecs-9.1.0/src/Data/Argonaut/Decode/Decoders.purs",".spago/p/argonaut-codecs-9.1.0/src/Data/Argonaut/Decode/Class.purs",".spago/p/argonaut-codecs-9.1.0/src/Data/Argonaut/Encode/Encoders.purs",".spago/p/argonaut-codecs-9.1.0/src/Data/Argonaut/Encode/Class.purs","output/Data.Show.Generic/foreign.js",".spago/p/prelude-6.0.1/src/Data/Show/Generic.purs","node_modules/uuid/dist/esm-browser/rng.js","node_modules/uuid/dist/esm-browser/regex.js","node_modules/uuid/dist/esm-browser/validate.js","node_modules/uuid/dist/esm-browser/stringify.js","node_modules/uuid/dist/esm-browser/parse.js","node_modules/uuid/dist/esm-browser/v35.js","node_modules/uuid/dist/esm-browser/native.js","node_modules/uuid/dist/esm-browser/v4.js","node_modules/uuid/dist/esm-browser/sha1.js","node_modules/uuid/dist/esm-browser/v5.js","output/Data.UUID/foreign.js",".spago/p/uuid-9.0.0/src/Data/UUID.purs","src/TcgCalculator/Types/Id.purs","src/TcgCalculator/Types.purs",".spago/p/web-uievents-5.0.0/src/Web/UIEvent/FocusEvent.purs","src/App/ConditionLine.purs","output/Data.BigInt/foreign.js",".spago/p/bigints-7.0.1/src/Data/BigInt.purs","output/Web.HTML.Event.ErrorEvent/foreign.js",".spago/p/web-html-4.1.0/src/Web/HTML/Event/ErrorEvent.purs","output/Web.Worker.MessageEvent/foreign.js","output/Web.Worker.Worker/foreign.js",".spago/p/web-workers-1.1.0/src/Web/Worker/Worker.purs","src/App/Worker.purs","output/Data.Number.Format/foreign.js",".spago/p/numbers-9.0.1/src/Data/Number/Format.purs","src/Util/Array.purs","src/TcgCalculator/Math.purs","src/TcgCalculator.purs","src/App/Result.purs","src/App/Condition.purs","output/Web.HTML/foreign.js","output/Web.HTML.HTMLDocument/foreign.js",".spago/p/web-html-4.1.0/src/Web/HTML/HTMLDocument/ReadyState.purs",".spago/p/web-html-4.1.0/src/Web/HTML/HTMLDocument.purs","output/Web.HTML.Location/foreign.js","output/Web.HTML.Window/foreign.js",".spago/p/web-html-4.1.0/src/Web/HTML/Window.purs","output/Web.HTML.Event.DataTransfer/foreign.js",".spago/p/web-html-4.1.0/src/Web/HTML/Event/DataTransfer.purs","output/Web.HTML.Event.DragEvent/foreign.js",".spago/p/web-html-4.1.0/src/Web/HTML/Event/DragEvent.purs","src/App/Deck.purs","output/Data.Argonaut.Parser/foreign.js",".spago/p/argonaut-core-7.0.0/src/Data/Argonaut/Parser.purs",".spago/p/argonaut-codecs-9.1.0/src/Data/Argonaut/Decode/Parser.purs","output/Effect.Console/foreign.js",".spago/p/console-6.1.0/src/Effect/Class/Console.purs","output/JSURI/foreign.js",".spago/p/js-uri-3.1.0/src/JSURI.purs",".spago/p/web-html-4.1.0/src/Web/HTML/Event/HashChangeEvent/EventTypes.purs",".spago/p/routing-11.0.0/src/Routing/Hash.purs","src/App/App.purs",".spago/p/halogen-7.0.0/src/Halogen/Aff/Util.purs",".spago/p/fork-6.0.0/src/Control/Monad/Fork/Class.purs",".spago/p/halogen-7.0.0/src/Halogen/Aff/Driver/State.purs",".spago/p/halogen-7.0.0/src/Halogen/Aff/Driver/Eval.purs",".spago/p/halogen-7.0.0/src/Halogen/Aff/Driver.purs","output/Web.DOM.Node/foreign.js",".spago/p/web-dom-6.0.0/src/Web/DOM/Node.purs",".spago/p/halogen-7.0.0/src/Halogen/VDom/Driver.purs","src/Main.purs","bundle/<stdin>"],"sourcesContent":["var $6795e3cd1d9397b2$exports = {};\n(()=>{\n    var __create = Object.create;\n    var __defProp = Object.defineProperty;\n    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames = Object.getOwnPropertyNames;\n    var __getProtoOf = Object.getPrototypeOf;\n    var __hasOwnProp = Object.prototype.hasOwnProperty;\n    var __commonJS = (cb, mod2)=>function __require() {\n            return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = {\n                exports: {}\n            }).exports, mod2), mod2.exports;\n        };\n    var __copyProps = (to, from3, except2, desc)=>{\n        if (from3 && typeof from3 === \"object\" || typeof from3 === \"function\") {\n            for (let key of __getOwnPropNames(from3))if (!__hasOwnProp.call(to, key) && key !== except2) __defProp(to, key, {\n                get: ()=>from3[key],\n                enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable\n            });\n        }\n        return to;\n    };\n    var __toESM = (mod2, isNodeMode, target7)=>(target7 = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n        // file that has been converted to a CommonJS file using a Babel-\n        // compatible transform (i.e. \"__esModule\" has not been set), then set\n        // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n        isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target7, \"default\", {\n            value: mod2,\n            enumerable: true\n        }) : target7, mod2));\n    // node_modules/big-integer/BigInteger.js\n    var require_BigInteger = __commonJS({\n        \"node_modules/big-integer/BigInteger.js\" (exports, module) {\n            var bigInt2 = function(undefined2) {\n                \"use strict\";\n                var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n                var supportsNativeBigInt = typeof BigInt === \"function\";\n                function Integer(v, radix, alphabet, caseSensitive) {\n                    if (typeof v === \"undefined\") return Integer[0];\n                    if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\n                    return parseValue(v);\n                }\n                function BigInteger(value15, sign2) {\n                    this.value = value15;\n                    this.sign = sign2;\n                    this.isSmall = false;\n                }\n                BigInteger.prototype = Object.create(Integer.prototype);\n                function SmallInteger(value15) {\n                    this.value = value15;\n                    this.sign = value15 < 0;\n                    this.isSmall = true;\n                }\n                SmallInteger.prototype = Object.create(Integer.prototype);\n                function NativeBigInt(value15) {\n                    this.value = value15;\n                }\n                NativeBigInt.prototype = Object.create(Integer.prototype);\n                function isPrecise(n) {\n                    return -MAX_INT < n && n < MAX_INT;\n                }\n                function smallToArray(n) {\n                    if (n < 1e7) return [\n                        n\n                    ];\n                    if (n < 1e14) return [\n                        n % 1e7,\n                        Math.floor(n / 1e7)\n                    ];\n                    return [\n                        n % 1e7,\n                        Math.floor(n / 1e7) % 1e7,\n                        Math.floor(n / 1e14)\n                    ];\n                }\n                function arrayToSmall(arr) {\n                    trim2(arr);\n                    var length8 = arr.length;\n                    if (length8 < 4 && compareAbs(arr, MAX_INT_ARR) < 0) switch(length8){\n                        case 0:\n                            return 0;\n                        case 1:\n                            return arr[0];\n                        case 2:\n                            return arr[0] + arr[1] * BASE;\n                        default:\n                            return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\n                    }\n                    return arr;\n                }\n                function trim2(v) {\n                    var i3 = v.length;\n                    while(v[--i3] === 0);\n                    v.length = i3 + 1;\n                }\n                function createArray(length8) {\n                    var x = new Array(length8);\n                    var i3 = -1;\n                    while(++i3 < length8)x[i3] = 0;\n                    return x;\n                }\n                function truncate(n) {\n                    if (n > 0) return Math.floor(n);\n                    return Math.ceil(n);\n                }\n                function add3(a2, b2) {\n                    var l_a = a2.length, l_b = b2.length, r = new Array(l_a), carry = 0, base2 = BASE, sum2, i3;\n                    for(i3 = 0; i3 < l_b; i3++){\n                        sum2 = a2[i3] + b2[i3] + carry;\n                        carry = sum2 >= base2 ? 1 : 0;\n                        r[i3] = sum2 - carry * base2;\n                    }\n                    while(i3 < l_a){\n                        sum2 = a2[i3] + carry;\n                        carry = sum2 === base2 ? 1 : 0;\n                        r[i3++] = sum2 - carry * base2;\n                    }\n                    if (carry > 0) r.push(carry);\n                    return r;\n                }\n                function addAny(a2, b2) {\n                    if (a2.length >= b2.length) return add3(a2, b2);\n                    return add3(b2, a2);\n                }\n                function addSmall(a2, carry) {\n                    var l = a2.length, r = new Array(l), base2 = BASE, sum2, i3;\n                    for(i3 = 0; i3 < l; i3++){\n                        sum2 = a2[i3] - base2 + carry;\n                        carry = Math.floor(sum2 / base2);\n                        r[i3] = sum2 - carry * base2;\n                        carry += 1;\n                    }\n                    while(carry > 0){\n                        r[i3++] = carry % base2;\n                        carry = Math.floor(carry / base2);\n                    }\n                    return r;\n                }\n                BigInteger.prototype.add = function(v) {\n                    var n = parseValue(v);\n                    if (this.sign !== n.sign) return this.subtract(n.negate());\n                    var a2 = this.value, b2 = n.value;\n                    if (n.isSmall) return new BigInteger(addSmall(a2, Math.abs(b2)), this.sign);\n                    return new BigInteger(addAny(a2, b2), this.sign);\n                };\n                BigInteger.prototype.plus = BigInteger.prototype.add;\n                SmallInteger.prototype.add = function(v) {\n                    var n = parseValue(v);\n                    var a2 = this.value;\n                    if (a2 < 0 !== n.sign) return this.subtract(n.negate());\n                    var b2 = n.value;\n                    if (n.isSmall) {\n                        if (isPrecise(a2 + b2)) return new SmallInteger(a2 + b2);\n                        b2 = smallToArray(Math.abs(b2));\n                    }\n                    return new BigInteger(addSmall(b2, Math.abs(a2)), a2 < 0);\n                };\n                SmallInteger.prototype.plus = SmallInteger.prototype.add;\n                NativeBigInt.prototype.add = function(v) {\n                    return new NativeBigInt(this.value + parseValue(v).value);\n                };\n                NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\n                function subtract(a2, b2) {\n                    var a_l = a2.length, b_l = b2.length, r = new Array(a_l), borrow = 0, base2 = BASE, i3, difference3;\n                    for(i3 = 0; i3 < b_l; i3++){\n                        difference3 = a2[i3] - borrow - b2[i3];\n                        if (difference3 < 0) {\n                            difference3 += base2;\n                            borrow = 1;\n                        } else borrow = 0;\n                        r[i3] = difference3;\n                    }\n                    for(i3 = b_l; i3 < a_l; i3++){\n                        difference3 = a2[i3] - borrow;\n                        if (difference3 < 0) difference3 += base2;\n                        else {\n                            r[i3++] = difference3;\n                            break;\n                        }\n                        r[i3] = difference3;\n                    }\n                    for(; i3 < a_l; i3++)r[i3] = a2[i3];\n                    trim2(r);\n                    return r;\n                }\n                function subtractAny(a2, b2, sign2) {\n                    var value15;\n                    if (compareAbs(a2, b2) >= 0) value15 = subtract(a2, b2);\n                    else {\n                        value15 = subtract(b2, a2);\n                        sign2 = !sign2;\n                    }\n                    value15 = arrayToSmall(value15);\n                    if (typeof value15 === \"number\") {\n                        if (sign2) value15 = -value15;\n                        return new SmallInteger(value15);\n                    }\n                    return new BigInteger(value15, sign2);\n                }\n                function subtractSmall(a2, b2, sign2) {\n                    var l = a2.length, r = new Array(l), carry = -b2, base2 = BASE, i3, difference3;\n                    for(i3 = 0; i3 < l; i3++){\n                        difference3 = a2[i3] + carry;\n                        carry = Math.floor(difference3 / base2);\n                        difference3 %= base2;\n                        r[i3] = difference3 < 0 ? difference3 + base2 : difference3;\n                    }\n                    r = arrayToSmall(r);\n                    if (typeof r === \"number\") {\n                        if (sign2) r = -r;\n                        return new SmallInteger(r);\n                    }\n                    return new BigInteger(r, sign2);\n                }\n                BigInteger.prototype.subtract = function(v) {\n                    var n = parseValue(v);\n                    if (this.sign !== n.sign) return this.add(n.negate());\n                    var a2 = this.value, b2 = n.value;\n                    if (n.isSmall) return subtractSmall(a2, Math.abs(b2), this.sign);\n                    return subtractAny(a2, b2, this.sign);\n                };\n                BigInteger.prototype.minus = BigInteger.prototype.subtract;\n                SmallInteger.prototype.subtract = function(v) {\n                    var n = parseValue(v);\n                    var a2 = this.value;\n                    if (a2 < 0 !== n.sign) return this.add(n.negate());\n                    var b2 = n.value;\n                    if (n.isSmall) return new SmallInteger(a2 - b2);\n                    return subtractSmall(b2, Math.abs(a2), a2 >= 0);\n                };\n                SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\n                NativeBigInt.prototype.subtract = function(v) {\n                    return new NativeBigInt(this.value - parseValue(v).value);\n                };\n                NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\n                BigInteger.prototype.negate = function() {\n                    return new BigInteger(this.value, !this.sign);\n                };\n                SmallInteger.prototype.negate = function() {\n                    var sign2 = this.sign;\n                    var small2 = new SmallInteger(-this.value);\n                    small2.sign = !sign2;\n                    return small2;\n                };\n                NativeBigInt.prototype.negate = function() {\n                    return new NativeBigInt(-this.value);\n                };\n                BigInteger.prototype.abs = function() {\n                    return new BigInteger(this.value, false);\n                };\n                SmallInteger.prototype.abs = function() {\n                    return new SmallInteger(Math.abs(this.value));\n                };\n                NativeBigInt.prototype.abs = function() {\n                    return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\n                };\n                function multiplyLong(a2, b2) {\n                    var a_l = a2.length, b_l = b2.length, l = a_l + b_l, r = createArray(l), base2 = BASE, product4, carry, i3, a_i, b_j;\n                    for(i3 = 0; i3 < a_l; ++i3){\n                        a_i = a2[i3];\n                        for(var j = 0; j < b_l; ++j){\n                            b_j = b2[j];\n                            product4 = a_i * b_j + r[i3 + j];\n                            carry = Math.floor(product4 / base2);\n                            r[i3 + j] = product4 - carry * base2;\n                            r[i3 + j + 1] += carry;\n                        }\n                    }\n                    trim2(r);\n                    return r;\n                }\n                function multiplySmall(a2, b2) {\n                    var l = a2.length, r = new Array(l), base2 = BASE, carry = 0, product4, i3;\n                    for(i3 = 0; i3 < l; i3++){\n                        product4 = a2[i3] * b2 + carry;\n                        carry = Math.floor(product4 / base2);\n                        r[i3] = product4 - carry * base2;\n                    }\n                    while(carry > 0){\n                        r[i3++] = carry % base2;\n                        carry = Math.floor(carry / base2);\n                    }\n                    return r;\n                }\n                function shiftLeft(x, n) {\n                    var r = [];\n                    while(n-- > 0)r.push(0);\n                    return r.concat(x);\n                }\n                function multiplyKaratsuba(x, y) {\n                    var n = Math.max(x.length, y.length);\n                    if (n <= 30) return multiplyLong(x, y);\n                    n = Math.ceil(n / 2);\n                    var b2 = x.slice(n), a2 = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);\n                    var ac = multiplyKaratsuba(a2, c), bd = multiplyKaratsuba(b2, d), abcd = multiplyKaratsuba(addAny(a2, b2), addAny(c, d));\n                    var product4 = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\n                    trim2(product4);\n                    return product4;\n                }\n                function useKaratsuba(l1, l2) {\n                    return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;\n                }\n                BigInteger.prototype.multiply = function(v) {\n                    var n = parseValue(v), a2 = this.value, b2 = n.value, sign2 = this.sign !== n.sign, abs4;\n                    if (n.isSmall) {\n                        if (b2 === 0) return Integer[0];\n                        if (b2 === 1) return this;\n                        if (b2 === -1) return this.negate();\n                        abs4 = Math.abs(b2);\n                        if (abs4 < BASE) return new BigInteger(multiplySmall(a2, abs4), sign2);\n                        b2 = smallToArray(abs4);\n                    }\n                    if (useKaratsuba(a2.length, b2.length)) return new BigInteger(multiplyKaratsuba(a2, b2), sign2);\n                    return new BigInteger(multiplyLong(a2, b2), sign2);\n                };\n                BigInteger.prototype.times = BigInteger.prototype.multiply;\n                function multiplySmallAndArray(a2, b2, sign2) {\n                    if (a2 < BASE) return new BigInteger(multiplySmall(b2, a2), sign2);\n                    return new BigInteger(multiplyLong(b2, smallToArray(a2)), sign2);\n                }\n                SmallInteger.prototype._multiplyBySmall = function(a2) {\n                    if (isPrecise(a2.value * this.value)) return new SmallInteger(a2.value * this.value);\n                    return multiplySmallAndArray(Math.abs(a2.value), smallToArray(Math.abs(this.value)), this.sign !== a2.sign);\n                };\n                BigInteger.prototype._multiplyBySmall = function(a2) {\n                    if (a2.value === 0) return Integer[0];\n                    if (a2.value === 1) return this;\n                    if (a2.value === -1) return this.negate();\n                    return multiplySmallAndArray(Math.abs(a2.value), this.value, this.sign !== a2.sign);\n                };\n                SmallInteger.prototype.multiply = function(v) {\n                    return parseValue(v)._multiplyBySmall(this);\n                };\n                SmallInteger.prototype.times = SmallInteger.prototype.multiply;\n                NativeBigInt.prototype.multiply = function(v) {\n                    return new NativeBigInt(this.value * parseValue(v).value);\n                };\n                NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\n                function square(a2) {\n                    var l = a2.length, r = createArray(l + l), base2 = BASE, product4, carry, i3, a_i, a_j;\n                    for(i3 = 0; i3 < l; i3++){\n                        a_i = a2[i3];\n                        carry = 0 - a_i * a_i;\n                        for(var j = i3; j < l; j++){\n                            a_j = a2[j];\n                            product4 = 2 * (a_i * a_j) + r[i3 + j] + carry;\n                            carry = Math.floor(product4 / base2);\n                            r[i3 + j] = product4 - carry * base2;\n                        }\n                        r[i3 + l] = carry;\n                    }\n                    trim2(r);\n                    return r;\n                }\n                BigInteger.prototype.square = function() {\n                    return new BigInteger(square(this.value), false);\n                };\n                SmallInteger.prototype.square = function() {\n                    var value15 = this.value * this.value;\n                    if (isPrecise(value15)) return new SmallInteger(value15);\n                    return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\n                };\n                NativeBigInt.prototype.square = function(v) {\n                    return new NativeBigInt(this.value * this.value);\n                };\n                function divMod1(a2, b2) {\n                    var a_l = a2.length, b_l = b2.length, base2 = BASE, result = createArray(b2.length), divisorMostSignificantDigit = b2[b_l - 1], lambda = Math.ceil(base2 / (2 * divisorMostSignificantDigit)), remainder2 = multiplySmall(a2, lambda), divisor = multiplySmall(b2, lambda), quotientDigit, shift, carry, borrow, i3, l, q2;\n                    if (remainder2.length <= a_l) remainder2.push(0);\n                    divisor.push(0);\n                    divisorMostSignificantDigit = divisor[b_l - 1];\n                    for(shift = a_l - b_l; shift >= 0; shift--){\n                        quotientDigit = base2 - 1;\n                        if (remainder2[shift + b_l] !== divisorMostSignificantDigit) quotientDigit = Math.floor((remainder2[shift + b_l] * base2 + remainder2[shift + b_l - 1]) / divisorMostSignificantDigit);\n                        carry = 0;\n                        borrow = 0;\n                        l = divisor.length;\n                        for(i3 = 0; i3 < l; i3++){\n                            carry += quotientDigit * divisor[i3];\n                            q2 = Math.floor(carry / base2);\n                            borrow += remainder2[shift + i3] - (carry - q2 * base2);\n                            carry = q2;\n                            if (borrow < 0) {\n                                remainder2[shift + i3] = borrow + base2;\n                                borrow = -1;\n                            } else {\n                                remainder2[shift + i3] = borrow;\n                                borrow = 0;\n                            }\n                        }\n                        while(borrow !== 0){\n                            quotientDigit -= 1;\n                            carry = 0;\n                            for(i3 = 0; i3 < l; i3++){\n                                carry += remainder2[shift + i3] - base2 + divisor[i3];\n                                if (carry < 0) {\n                                    remainder2[shift + i3] = carry + base2;\n                                    carry = 0;\n                                } else {\n                                    remainder2[shift + i3] = carry;\n                                    carry = 1;\n                                }\n                            }\n                            borrow += carry;\n                        }\n                        result[shift] = quotientDigit;\n                    }\n                    remainder2 = divModSmall(remainder2, lambda)[0];\n                    return [\n                        arrayToSmall(result),\n                        arrayToSmall(remainder2)\n                    ];\n                }\n                function divMod2(a2, b2) {\n                    var a_l = a2.length, b_l = b2.length, result = [], part = [], base2 = BASE, guess, xlen, highx, highy, check;\n                    while(a_l){\n                        part.unshift(a2[--a_l]);\n                        trim2(part);\n                        if (compareAbs(part, b2) < 0) {\n                            result.push(0);\n                            continue;\n                        }\n                        xlen = part.length;\n                        highx = part[xlen - 1] * base2 + part[xlen - 2];\n                        highy = b2[b_l - 1] * base2 + b2[b_l - 2];\n                        if (xlen > b_l) highx = (highx + 1) * base2;\n                        guess = Math.ceil(highx / highy);\n                        do {\n                            check = multiplySmall(b2, guess);\n                            if (compareAbs(check, part) <= 0) break;\n                            guess--;\n                        }while (guess);\n                        result.push(guess);\n                        part = subtract(part, check);\n                    }\n                    result.reverse();\n                    return [\n                        arrayToSmall(result),\n                        arrayToSmall(part)\n                    ];\n                }\n                function divModSmall(value15, lambda) {\n                    var length8 = value15.length, quotient = createArray(length8), base2 = BASE, i3, q2, remainder2, divisor;\n                    remainder2 = 0;\n                    for(i3 = length8 - 1; i3 >= 0; --i3){\n                        divisor = remainder2 * base2 + value15[i3];\n                        q2 = truncate(divisor / lambda);\n                        remainder2 = divisor - q2 * lambda;\n                        quotient[i3] = q2 | 0;\n                    }\n                    return [\n                        quotient,\n                        remainder2 | 0\n                    ];\n                }\n                function divModAny(self, v) {\n                    var value15, n = parseValue(v);\n                    if (supportsNativeBigInt) return [\n                        new NativeBigInt(self.value / n.value),\n                        new NativeBigInt(self.value % n.value)\n                    ];\n                    var a2 = self.value, b2 = n.value;\n                    var quotient;\n                    if (b2 === 0) throw new Error(\"Cannot divide by zero\");\n                    if (self.isSmall) {\n                        if (n.isSmall) return [\n                            new SmallInteger(truncate(a2 / b2)),\n                            new SmallInteger(a2 % b2)\n                        ];\n                        return [\n                            Integer[0],\n                            self\n                        ];\n                    }\n                    if (n.isSmall) {\n                        if (b2 === 1) return [\n                            self,\n                            Integer[0]\n                        ];\n                        if (b2 == -1) return [\n                            self.negate(),\n                            Integer[0]\n                        ];\n                        var abs4 = Math.abs(b2);\n                        if (abs4 < BASE) {\n                            value15 = divModSmall(a2, abs4);\n                            quotient = arrayToSmall(value15[0]);\n                            var remainder2 = value15[1];\n                            if (self.sign) remainder2 = -remainder2;\n                            if (typeof quotient === \"number\") {\n                                if (self.sign !== n.sign) quotient = -quotient;\n                                return [\n                                    new SmallInteger(quotient),\n                                    new SmallInteger(remainder2)\n                                ];\n                            }\n                            return [\n                                new BigInteger(quotient, self.sign !== n.sign),\n                                new SmallInteger(remainder2)\n                            ];\n                        }\n                        b2 = smallToArray(abs4);\n                    }\n                    var comparison = compareAbs(a2, b2);\n                    if (comparison === -1) return [\n                        Integer[0],\n                        self\n                    ];\n                    if (comparison === 0) return [\n                        Integer[self.sign === n.sign ? 1 : -1],\n                        Integer[0]\n                    ];\n                    if (a2.length + b2.length <= 200) value15 = divMod1(a2, b2);\n                    else value15 = divMod2(a2, b2);\n                    quotient = value15[0];\n                    var qSign = self.sign !== n.sign, mod2 = value15[1], mSign = self.sign;\n                    if (typeof quotient === \"number\") {\n                        if (qSign) quotient = -quotient;\n                        quotient = new SmallInteger(quotient);\n                    } else quotient = new BigInteger(quotient, qSign);\n                    if (typeof mod2 === \"number\") {\n                        if (mSign) mod2 = -mod2;\n                        mod2 = new SmallInteger(mod2);\n                    } else mod2 = new BigInteger(mod2, mSign);\n                    return [\n                        quotient,\n                        mod2\n                    ];\n                }\n                BigInteger.prototype.divmod = function(v) {\n                    var result = divModAny(this, v);\n                    return {\n                        quotient: result[0],\n                        remainder: result[1]\n                    };\n                };\n                NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\n                BigInteger.prototype.divide = function(v) {\n                    return divModAny(this, v)[0];\n                };\n                NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {\n                    return new NativeBigInt(this.value / parseValue(v).value);\n                };\n                SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\n                BigInteger.prototype.mod = function(v) {\n                    return divModAny(this, v)[1];\n                };\n                NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {\n                    return new NativeBigInt(this.value % parseValue(v).value);\n                };\n                SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\n                BigInteger.prototype.pow = function(v) {\n                    var n = parseValue(v), a2 = this.value, b2 = n.value, value15, x, y;\n                    if (b2 === 0) return Integer[1];\n                    if (a2 === 0) return Integer[0];\n                    if (a2 === 1) return Integer[1];\n                    if (a2 === -1) return n.isEven() ? Integer[1] : Integer[-1];\n                    if (n.sign) return Integer[0];\n                    if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\n                    if (this.isSmall) {\n                        if (isPrecise(value15 = Math.pow(a2, b2))) return new SmallInteger(truncate(value15));\n                    }\n                    x = this;\n                    y = Integer[1];\n                    while(true){\n                        if (b2 & true) {\n                            y = y.times(x);\n                            --b2;\n                        }\n                        if (b2 === 0) break;\n                        b2 /= 2;\n                        x = x.square();\n                    }\n                    return y;\n                };\n                SmallInteger.prototype.pow = BigInteger.prototype.pow;\n                NativeBigInt.prototype.pow = function(v) {\n                    var n = parseValue(v);\n                    var a2 = this.value, b2 = n.value;\n                    var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\n                    if (b2 === _0) return Integer[1];\n                    if (a2 === _0) return Integer[0];\n                    if (a2 === _1) return Integer[1];\n                    if (a2 === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\n                    if (n.isNegative()) return new NativeBigInt(_0);\n                    var x = this;\n                    var y = Integer[1];\n                    while(true){\n                        if ((b2 & _1) === _1) {\n                            y = y.times(x);\n                            --b2;\n                        }\n                        if (b2 === _0) break;\n                        b2 /= _2;\n                        x = x.square();\n                    }\n                    return y;\n                };\n                BigInteger.prototype.modPow = function(exp2, mod2) {\n                    exp2 = parseValue(exp2);\n                    mod2 = parseValue(mod2);\n                    if (mod2.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\n                    var r = Integer[1], base2 = this.mod(mod2);\n                    if (exp2.isNegative()) {\n                        exp2 = exp2.multiply(Integer[-1]);\n                        base2 = base2.modInv(mod2);\n                    }\n                    while(exp2.isPositive()){\n                        if (base2.isZero()) return Integer[0];\n                        if (exp2.isOdd()) r = r.multiply(base2).mod(mod2);\n                        exp2 = exp2.divide(2);\n                        base2 = base2.square().mod(mod2);\n                    }\n                    return r;\n                };\n                NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\n                function compareAbs(a2, b2) {\n                    if (a2.length !== b2.length) return a2.length > b2.length ? 1 : -1;\n                    for(var i3 = a2.length - 1; i3 >= 0; i3--){\n                        if (a2[i3] !== b2[i3]) return a2[i3] > b2[i3] ? 1 : -1;\n                    }\n                    return 0;\n                }\n                BigInteger.prototype.compareAbs = function(v) {\n                    var n = parseValue(v), a2 = this.value, b2 = n.value;\n                    if (n.isSmall) return 1;\n                    return compareAbs(a2, b2);\n                };\n                SmallInteger.prototype.compareAbs = function(v) {\n                    var n = parseValue(v), a2 = Math.abs(this.value), b2 = n.value;\n                    if (n.isSmall) {\n                        b2 = Math.abs(b2);\n                        return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;\n                    }\n                    return -1;\n                };\n                NativeBigInt.prototype.compareAbs = function(v) {\n                    var a2 = this.value;\n                    var b2 = parseValue(v).value;\n                    a2 = a2 >= 0 ? a2 : -a2;\n                    b2 = b2 >= 0 ? b2 : -b2;\n                    return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;\n                };\n                BigInteger.prototype.compare = function(v) {\n                    if (v === Infinity) return -1;\n                    if (v === -Infinity) return 1;\n                    var n = parseValue(v), a2 = this.value, b2 = n.value;\n                    if (this.sign !== n.sign) return n.sign ? 1 : -1;\n                    if (n.isSmall) return this.sign ? -1 : 1;\n                    return compareAbs(a2, b2) * (this.sign ? -1 : 1);\n                };\n                BigInteger.prototype.compareTo = BigInteger.prototype.compare;\n                SmallInteger.prototype.compare = function(v) {\n                    if (v === Infinity) return -1;\n                    if (v === -Infinity) return 1;\n                    var n = parseValue(v), a2 = this.value, b2 = n.value;\n                    if (n.isSmall) return a2 == b2 ? 0 : a2 > b2 ? 1 : -1;\n                    if (a2 < 0 !== n.sign) return a2 < 0 ? -1 : 1;\n                    return a2 < 0 ? 1 : -1;\n                };\n                SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\n                NativeBigInt.prototype.compare = function(v) {\n                    if (v === Infinity) return -1;\n                    if (v === -Infinity) return 1;\n                    var a2 = this.value;\n                    var b2 = parseValue(v).value;\n                    return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;\n                };\n                NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\n                BigInteger.prototype.equals = function(v) {\n                    return this.compare(v) === 0;\n                };\n                NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\n                BigInteger.prototype.notEquals = function(v) {\n                    return this.compare(v) !== 0;\n                };\n                NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\n                BigInteger.prototype.greater = function(v) {\n                    return this.compare(v) > 0;\n                };\n                NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\n                BigInteger.prototype.lesser = function(v) {\n                    return this.compare(v) < 0;\n                };\n                NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\n                BigInteger.prototype.greaterOrEquals = function(v) {\n                    return this.compare(v) >= 0;\n                };\n                NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\n                BigInteger.prototype.lesserOrEquals = function(v) {\n                    return this.compare(v) <= 0;\n                };\n                NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\n                BigInteger.prototype.isEven = function() {\n                    return (this.value[0] & 1) === 0;\n                };\n                SmallInteger.prototype.isEven = function() {\n                    return (this.value & 1) === 0;\n                };\n                NativeBigInt.prototype.isEven = function() {\n                    return (this.value & BigInt(1)) === BigInt(0);\n                };\n                BigInteger.prototype.isOdd = function() {\n                    return (this.value[0] & 1) === 1;\n                };\n                SmallInteger.prototype.isOdd = function() {\n                    return (this.value & 1) === 1;\n                };\n                NativeBigInt.prototype.isOdd = function() {\n                    return (this.value & BigInt(1)) === BigInt(1);\n                };\n                BigInteger.prototype.isPositive = function() {\n                    return !this.sign;\n                };\n                SmallInteger.prototype.isPositive = function() {\n                    return this.value > 0;\n                };\n                NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\n                BigInteger.prototype.isNegative = function() {\n                    return this.sign;\n                };\n                SmallInteger.prototype.isNegative = function() {\n                    return this.value < 0;\n                };\n                NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\n                BigInteger.prototype.isUnit = function() {\n                    return false;\n                };\n                SmallInteger.prototype.isUnit = function() {\n                    return Math.abs(this.value) === 1;\n                };\n                NativeBigInt.prototype.isUnit = function() {\n                    return this.abs().value === BigInt(1);\n                };\n                BigInteger.prototype.isZero = function() {\n                    return false;\n                };\n                SmallInteger.prototype.isZero = function() {\n                    return this.value === 0;\n                };\n                NativeBigInt.prototype.isZero = function() {\n                    return this.value === BigInt(0);\n                };\n                BigInteger.prototype.isDivisibleBy = function(v) {\n                    var n = parseValue(v);\n                    if (n.isZero()) return false;\n                    if (n.isUnit()) return true;\n                    if (n.compareAbs(2) === 0) return this.isEven();\n                    return this.mod(n).isZero();\n                };\n                NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\n                function isBasicPrime(v) {\n                    var n = v.abs();\n                    if (n.isUnit()) return false;\n                    if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\n                    if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\n                    if (n.lesser(49)) return true;\n                }\n                function millerRabinTest(n, a2) {\n                    var nPrev = n.prev(), b2 = nPrev, r = 0, d, t, i3, x;\n                    while(b2.isEven())b2 = b2.divide(2), r++;\n                    next: for(i3 = 0; i3 < a2.length; i3++){\n                        if (n.lesser(a2[i3])) continue;\n                        x = bigInt2(a2[i3]).modPow(b2, n);\n                        if (x.isUnit() || x.equals(nPrev)) continue;\n                        for(d = r - 1; d != 0; d--){\n                            x = x.square().mod(n);\n                            if (x.isUnit()) return false;\n                            if (x.equals(nPrev)) continue next;\n                        }\n                        return false;\n                    }\n                    return true;\n                }\n                BigInteger.prototype.isPrime = function(strict) {\n                    var isPrime = isBasicPrime(this);\n                    if (isPrime !== undefined2) return isPrime;\n                    var n = this.abs();\n                    var bits = n.bitLength();\n                    if (bits <= 64) return millerRabinTest(n, [\n                        2,\n                        3,\n                        5,\n                        7,\n                        11,\n                        13,\n                        17,\n                        19,\n                        23,\n                        29,\n                        31,\n                        37\n                    ]);\n                    var logN = Math.log(2) * bits.toJSNumber();\n                    var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);\n                    for(var a2 = [], i3 = 0; i3 < t; i3++)a2.push(bigInt2(i3 + 2));\n                    return millerRabinTest(n, a2);\n                };\n                NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\n                BigInteger.prototype.isProbablePrime = function(iterations, rng2) {\n                    var isPrime = isBasicPrime(this);\n                    if (isPrime !== undefined2) return isPrime;\n                    var n = this.abs();\n                    var t = iterations === undefined2 ? 5 : iterations;\n                    for(var a2 = [], i3 = 0; i3 < t; i3++)a2.push(bigInt2.randBetween(2, n.minus(2), rng2));\n                    return millerRabinTest(n, a2);\n                };\n                NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\n                BigInteger.prototype.modInv = function(n) {\n                    var t = bigInt2.zero, newT = bigInt2.one, r = parseValue(n), newR = this.abs(), q2, lastT, lastR;\n                    while(!newR.isZero()){\n                        q2 = r.divide(newR);\n                        lastT = t;\n                        lastR = r;\n                        t = newT;\n                        r = newR;\n                        newT = lastT.subtract(q2.multiply(newT));\n                        newR = lastR.subtract(q2.multiply(newR));\n                    }\n                    if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\n                    if (t.compare(0) === -1) t = t.add(n);\n                    if (this.isNegative()) return t.negate();\n                    return t;\n                };\n                NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\n                BigInteger.prototype.next = function() {\n                    var value15 = this.value;\n                    if (this.sign) return subtractSmall(value15, 1, this.sign);\n                    return new BigInteger(addSmall(value15, 1), this.sign);\n                };\n                SmallInteger.prototype.next = function() {\n                    var value15 = this.value;\n                    if (value15 + 1 < MAX_INT) return new SmallInteger(value15 + 1);\n                    return new BigInteger(MAX_INT_ARR, false);\n                };\n                NativeBigInt.prototype.next = function() {\n                    return new NativeBigInt(this.value + BigInt(1));\n                };\n                BigInteger.prototype.prev = function() {\n                    var value15 = this.value;\n                    if (this.sign) return new BigInteger(addSmall(value15, 1), true);\n                    return subtractSmall(value15, 1, this.sign);\n                };\n                SmallInteger.prototype.prev = function() {\n                    var value15 = this.value;\n                    if (value15 - 1 > -MAX_INT) return new SmallInteger(value15 - 1);\n                    return new BigInteger(MAX_INT_ARR, true);\n                };\n                NativeBigInt.prototype.prev = function() {\n                    return new NativeBigInt(this.value - BigInt(1));\n                };\n                var powersOfTwo = [\n                    1\n                ];\n                while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\n                var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\n                function shift_isSmall(n) {\n                    return Math.abs(n) <= BASE;\n                }\n                BigInteger.prototype.shiftLeft = function(v) {\n                    var n = parseValue(v).toJSNumber();\n                    if (!shift_isSmall(n)) throw new Error(String(n) + \" is too large for shifting.\");\n                    if (n < 0) return this.shiftRight(-n);\n                    var result = this;\n                    if (result.isZero()) return result;\n                    while(n >= powers2Length){\n                        result = result.multiply(highestPower2);\n                        n -= powers2Length - 1;\n                    }\n                    return result.multiply(powersOfTwo[n]);\n                };\n                NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\n                BigInteger.prototype.shiftRight = function(v) {\n                    var remQuo;\n                    var n = parseValue(v).toJSNumber();\n                    if (!shift_isSmall(n)) throw new Error(String(n) + \" is too large for shifting.\");\n                    if (n < 0) return this.shiftLeft(-n);\n                    var result = this;\n                    while(n >= powers2Length){\n                        if (result.isZero() || result.isNegative() && result.isUnit()) return result;\n                        remQuo = divModAny(result, highestPower2);\n                        result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n                        n -= powers2Length - 1;\n                    }\n                    remQuo = divModAny(result, powersOfTwo[n]);\n                    return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n                };\n                NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\n                function bitwise(x, y, fn) {\n                    y = parseValue(y);\n                    var xSign = x.isNegative(), ySign = y.isNegative();\n                    var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;\n                    var xDigit = 0, yDigit = 0;\n                    var xDivMod = null, yDivMod = null;\n                    var result = [];\n                    while(!xRem.isZero() || !yRem.isZero()){\n                        xDivMod = divModAny(xRem, highestPower2);\n                        xDigit = xDivMod[1].toJSNumber();\n                        if (xSign) xDigit = highestPower2 - 1 - xDigit;\n                        yDivMod = divModAny(yRem, highestPower2);\n                        yDigit = yDivMod[1].toJSNumber();\n                        if (ySign) yDigit = highestPower2 - 1 - yDigit;\n                        xRem = xDivMod[0];\n                        yRem = yDivMod[0];\n                        result.push(fn(xDigit, yDigit));\n                    }\n                    var sum2 = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);\n                    for(var i3 = result.length - 1; i3 >= 0; i3 -= 1)sum2 = sum2.multiply(highestPower2).add(bigInt2(result[i3]));\n                    return sum2;\n                }\n                BigInteger.prototype.not = function() {\n                    return this.negate().prev();\n                };\n                NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\n                BigInteger.prototype.and = function(n) {\n                    return bitwise(this, n, function(a2, b2) {\n                        return a2 & b2;\n                    });\n                };\n                NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\n                BigInteger.prototype.or = function(n) {\n                    return bitwise(this, n, function(a2, b2) {\n                        return a2 | b2;\n                    });\n                };\n                NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\n                BigInteger.prototype.xor = function(n) {\n                    return bitwise(this, n, function(a2, b2) {\n                        return a2 ^ b2;\n                    });\n                };\n                NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\n                var LOBMASK_I = 1073741824, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\n                function roughLOB(n) {\n                    var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;\n                    return x & -x;\n                }\n                function integerLogarithm(value15, base2) {\n                    if (base2.compareTo(value15) <= 0) {\n                        var tmp = integerLogarithm(value15, base2.square(base2));\n                        var p2 = tmp.p;\n                        var e = tmp.e;\n                        var t = p2.multiply(base2);\n                        return t.compareTo(value15) <= 0 ? {\n                            p: t,\n                            e: e * 2 + 1\n                        } : {\n                            p: p2,\n                            e: e * 2\n                        };\n                    }\n                    return {\n                        p: bigInt2(1),\n                        e: 0\n                    };\n                }\n                BigInteger.prototype.bitLength = function() {\n                    var n = this;\n                    if (n.compareTo(bigInt2(0)) < 0) n = n.negate().subtract(bigInt2(1));\n                    if (n.compareTo(bigInt2(0)) === 0) return bigInt2(0);\n                    return bigInt2(integerLogarithm(n, bigInt2(2)).e).add(bigInt2(1));\n                };\n                NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\n                function max7(a2, b2) {\n                    a2 = parseValue(a2);\n                    b2 = parseValue(b2);\n                    return a2.greater(b2) ? a2 : b2;\n                }\n                function min8(a2, b2) {\n                    a2 = parseValue(a2);\n                    b2 = parseValue(b2);\n                    return a2.lesser(b2) ? a2 : b2;\n                }\n                function gcd(a2, b2) {\n                    a2 = parseValue(a2).abs();\n                    b2 = parseValue(b2).abs();\n                    if (a2.equals(b2)) return a2;\n                    if (a2.isZero()) return b2;\n                    if (b2.isZero()) return a2;\n                    var c = Integer[1], d, t;\n                    while(a2.isEven() && b2.isEven()){\n                        d = min8(roughLOB(a2), roughLOB(b2));\n                        a2 = a2.divide(d);\n                        b2 = b2.divide(d);\n                        c = c.multiply(d);\n                    }\n                    while(a2.isEven())a2 = a2.divide(roughLOB(a2));\n                    do {\n                        while(b2.isEven())b2 = b2.divide(roughLOB(b2));\n                        if (a2.greater(b2)) {\n                            t = b2;\n                            b2 = a2;\n                            a2 = t;\n                        }\n                        b2 = b2.subtract(a2);\n                    }while (!b2.isZero());\n                    return c.isUnit() ? a2 : a2.multiply(c);\n                }\n                function lcm(a2, b2) {\n                    a2 = parseValue(a2).abs();\n                    b2 = parseValue(b2).abs();\n                    return a2.divide(gcd(a2, b2)).multiply(b2);\n                }\n                function randBetween(a2, b2, rng2) {\n                    a2 = parseValue(a2);\n                    b2 = parseValue(b2);\n                    var usedRNG = rng2 || Math.random;\n                    var low2 = min8(a2, b2), high2 = max7(a2, b2);\n                    var range3 = high2.subtract(low2).add(1);\n                    if (range3.isSmall) return low2.add(Math.floor(usedRNG() * range3));\n                    var digits = toBase2(range3, BASE).value;\n                    var result = [], restricted = true;\n                    for(var i3 = 0; i3 < digits.length; i3++){\n                        var top3 = restricted ? digits[i3] + (i3 + 1 < digits.length ? digits[i3 + 1] / BASE : 0) : BASE;\n                        var digit = truncate(usedRNG() * top3);\n                        result.push(digit);\n                        if (digit < digits[i3]) restricted = false;\n                    }\n                    return low2.add(Integer.fromArray(result, BASE, false));\n                }\n                var parseBase = function(text6, base2, alphabet, caseSensitive) {\n                    alphabet = alphabet || DEFAULT_ALPHABET;\n                    text6 = String(text6);\n                    if (!caseSensitive) {\n                        text6 = text6.toLowerCase();\n                        alphabet = alphabet.toLowerCase();\n                    }\n                    var length8 = text6.length;\n                    var i3;\n                    var absBase = Math.abs(base2);\n                    var alphabetValues = {};\n                    for(i3 = 0; i3 < alphabet.length; i3++)alphabetValues[alphabet[i3]] = i3;\n                    for(i3 = 0; i3 < length8; i3++){\n                        var c = text6[i3];\n                        if (c === \"-\") continue;\n                        if (c in alphabetValues) {\n                            if (alphabetValues[c] >= absBase) {\n                                if (c === \"1\" && absBase === 1) continue;\n                                throw new Error(c + \" is not a valid digit in base \" + base2 + \".\");\n                            }\n                        }\n                    }\n                    base2 = parseValue(base2);\n                    var digits = [];\n                    var isNegative = text6[0] === \"-\";\n                    for(i3 = isNegative ? 1 : 0; i3 < text6.length; i3++){\n                        var c = text6[i3];\n                        if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\n                        else if (c === \"<\") {\n                            var start2 = i3;\n                            do i3++;\n                            while (text6[i3] !== \">\" && i3 < text6.length);\n                            digits.push(parseValue(text6.slice(start2 + 1, i3)));\n                        } else throw new Error(c + \" is not a valid character\");\n                    }\n                    return parseBaseFromArray(digits, base2, isNegative);\n                };\n                function parseBaseFromArray(digits, base2, isNegative) {\n                    var val = Integer[0], pow4 = Integer[1], i3;\n                    for(i3 = digits.length - 1; i3 >= 0; i3--){\n                        val = val.add(digits[i3].times(pow4));\n                        pow4 = pow4.times(base2);\n                    }\n                    return isNegative ? val.negate() : val;\n                }\n                function stringify2(digit, alphabet) {\n                    alphabet = alphabet || DEFAULT_ALPHABET;\n                    if (digit < alphabet.length) return alphabet[digit];\n                    return \"<\" + digit + \">\";\n                }\n                function toBase2(n, base2) {\n                    base2 = bigInt2(base2);\n                    if (base2.isZero()) {\n                        if (n.isZero()) return {\n                            value: [\n                                0\n                            ],\n                            isNegative: false\n                        };\n                        throw new Error(\"Cannot convert nonzero numbers to base 0.\");\n                    }\n                    if (base2.equals(-1)) {\n                        if (n.isZero()) return {\n                            value: [\n                                0\n                            ],\n                            isNegative: false\n                        };\n                        if (n.isNegative()) return {\n                            value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [\n                                1,\n                                0\n                            ])),\n                            isNegative: false\n                        };\n                        var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [\n                            0,\n                            1\n                        ]);\n                        arr.unshift([\n                            1\n                        ]);\n                        return {\n                            value: [].concat.apply([], arr),\n                            isNegative: false\n                        };\n                    }\n                    var neg = false;\n                    if (n.isNegative() && base2.isPositive()) {\n                        neg = true;\n                        n = n.abs();\n                    }\n                    if (base2.isUnit()) {\n                        if (n.isZero()) return {\n                            value: [\n                                0\n                            ],\n                            isNegative: false\n                        };\n                        return {\n                            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),\n                            isNegative: neg\n                        };\n                    }\n                    var out = [];\n                    var left = n, divmod;\n                    while(left.isNegative() || left.compareAbs(base2) >= 0){\n                        divmod = left.divmod(base2);\n                        left = divmod.quotient;\n                        var digit = divmod.remainder;\n                        if (digit.isNegative()) {\n                            digit = base2.minus(digit).abs();\n                            left = left.next();\n                        }\n                        out.push(digit.toJSNumber());\n                    }\n                    out.push(left.toJSNumber());\n                    return {\n                        value: out.reverse(),\n                        isNegative: neg\n                    };\n                }\n                function toBaseString(n, base2, alphabet) {\n                    var arr = toBase2(n, base2);\n                    return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function(x) {\n                        return stringify2(x, alphabet);\n                    }).join(\"\");\n                }\n                BigInteger.prototype.toArray = function(radix) {\n                    return toBase2(this, radix);\n                };\n                SmallInteger.prototype.toArray = function(radix) {\n                    return toBase2(this, radix);\n                };\n                NativeBigInt.prototype.toArray = function(radix) {\n                    return toBase2(this, radix);\n                };\n                BigInteger.prototype.toString = function(radix, alphabet) {\n                    if (radix === undefined2) radix = 10;\n                    if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);\n                    var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\n                    while(--l >= 0){\n                        digit = String(v[l]);\n                        str += zeros.slice(digit.length) + digit;\n                    }\n                    var sign2 = this.sign ? \"-\" : \"\";\n                    return sign2 + str;\n                };\n                SmallInteger.prototype.toString = function(radix, alphabet) {\n                    if (radix === undefined2) radix = 10;\n                    if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);\n                    return String(this.value);\n                };\n                NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\n                NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {\n                    return this.toString();\n                };\n                BigInteger.prototype.valueOf = function() {\n                    return parseInt(this.toString(), 10);\n                };\n                BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\n                SmallInteger.prototype.valueOf = function() {\n                    return this.value;\n                };\n                SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\n                NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {\n                    return parseInt(this.toString(), 10);\n                };\n                function parseStringValue(v) {\n                    if (isPrecise(+v)) {\n                        var x = +v;\n                        if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\n                        throw new Error(\"Invalid integer: \" + v);\n                    }\n                    var sign2 = v[0] === \"-\";\n                    if (sign2) v = v.slice(1);\n                    var split2 = v.split(/e/i);\n                    if (split2.length > 2) throw new Error(\"Invalid integer: \" + split2.join(\"e\"));\n                    if (split2.length === 2) {\n                        var exp2 = split2[1];\n                        if (exp2[0] === \"+\") exp2 = exp2.slice(1);\n                        exp2 = +exp2;\n                        if (exp2 !== truncate(exp2) || !isPrecise(exp2)) throw new Error(\"Invalid integer: \" + exp2 + \" is not a valid exponent.\");\n                        var text6 = split2[0];\n                        var decimalPlace = text6.indexOf(\".\");\n                        if (decimalPlace >= 0) {\n                            exp2 -= text6.length - decimalPlace - 1;\n                            text6 = text6.slice(0, decimalPlace) + text6.slice(decimalPlace + 1);\n                        }\n                        if (exp2 < 0) throw new Error(\"Cannot include negative exponent part for integers\");\n                        text6 += new Array(exp2 + 1).join(\"0\");\n                        v = text6;\n                    }\n                    var isValid = /^([0-9][0-9]*)$/.test(v);\n                    if (!isValid) throw new Error(\"Invalid integer: \" + v);\n                    if (supportsNativeBigInt) return new NativeBigInt(BigInt(sign2 ? \"-\" + v : v));\n                    var r = [], max8 = v.length, l = LOG_BASE, min9 = max8 - l;\n                    while(max8 > 0){\n                        r.push(+v.slice(min9, max8));\n                        min9 -= l;\n                        if (min9 < 0) min9 = 0;\n                        max8 -= l;\n                    }\n                    trim2(r);\n                    return new BigInteger(r, sign2);\n                }\n                function parseNumberValue(v) {\n                    if (supportsNativeBigInt) return new NativeBigInt(BigInt(v));\n                    if (isPrecise(v)) {\n                        if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\n                        return new SmallInteger(v);\n                    }\n                    return parseStringValue(v.toString());\n                }\n                function parseValue(v) {\n                    if (typeof v === \"number\") return parseNumberValue(v);\n                    if (typeof v === \"string\") return parseStringValue(v);\n                    if (typeof v === \"bigint\") return new NativeBigInt(v);\n                    return v;\n                }\n                for(var i2 = 0; i2 < 1e3; i2++){\n                    Integer[i2] = parseValue(i2);\n                    if (i2 > 0) Integer[-i2] = parseValue(-i2);\n                }\n                Integer.one = Integer[1];\n                Integer.zero = Integer[0];\n                Integer.minusOne = Integer[-1];\n                Integer.max = max7;\n                Integer.min = min8;\n                Integer.gcd = gcd;\n                Integer.lcm = lcm;\n                Integer.isInstance = function(x) {\n                    return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;\n                };\n                Integer.randBetween = randBetween;\n                Integer.fromArray = function(digits, base2, isNegative) {\n                    return parseBaseFromArray(digits.map(parseValue), parseValue(base2 || 10), isNegative);\n                };\n                return Integer;\n            }();\n            if (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) module.exports = bigInt2;\n            if (typeof define === \"function\" && define.amd) define(function() {\n                return bigInt2;\n            });\n        }\n    });\n    // output/Control.Apply/foreign.js\n    var arrayApply = function(fs) {\n        return function(xs) {\n            var l = fs.length;\n            var k = xs.length;\n            var result = new Array(l * k);\n            var n = 0;\n            for(var i2 = 0; i2 < l; i2++){\n                var f2 = fs[i2];\n                for(var j = 0; j < k; j++)result[n++] = f2(xs[j]);\n            }\n            return result;\n        };\n    };\n    // output/Control.Semigroupoid/index.js\n    var semigroupoidFn = {\n        compose: function(f2) {\n            return function(g) {\n                return function(x) {\n                    return f2(g(x));\n                };\n            };\n        }\n    };\n    var compose = function(dict) {\n        return dict.compose;\n    };\n    // output/Control.Category/index.js\n    var identity = function(dict) {\n        return dict.identity;\n    };\n    var categoryFn = {\n        identity: function(x) {\n            return x;\n        },\n        Semigroupoid0: function() {\n            return semigroupoidFn;\n        }\n    };\n    // output/Data.Boolean/index.js\n    var otherwise = true;\n    // output/Data.Function/index.js\n    var on = function(f2) {\n        return function(g) {\n            return function(x) {\n                return function(y) {\n                    return f2(g(x))(g(y));\n                };\n            };\n        };\n    };\n    var flip = function(f2) {\n        return function(b2) {\n            return function(a2) {\n                return f2(a2)(b2);\n            };\n        };\n    };\n    var $$const = function(a2) {\n        return function(v) {\n            return a2;\n        };\n    };\n    // output/Data.Functor/foreign.js\n    var arrayMap = function(f2) {\n        return function(arr) {\n            var l = arr.length;\n            var result = new Array(l);\n            for(var i2 = 0; i2 < l; i2++)result[i2] = f2(arr[i2]);\n            return result;\n        };\n    };\n    // output/Data.Unit/foreign.js\n    var unit = void 0;\n    // output/Type.Proxy/index.js\n    var $$Proxy = /* @__PURE__ */ function() {\n        function $$Proxy2() {}\n        $$Proxy2.value = new $$Proxy2();\n        return $$Proxy2;\n    }();\n    // output/Data.Functor/index.js\n    var map = function(dict) {\n        return dict.map;\n    };\n    var mapFlipped = function(dictFunctor) {\n        var map112 = map(dictFunctor);\n        return function(fa2) {\n            return function(f2) {\n                return map112(f2)(fa2);\n            };\n        };\n    };\n    var $$void = function(dictFunctor) {\n        return map(dictFunctor)($$const(unit));\n    };\n    var voidLeft = function(dictFunctor) {\n        var map112 = map(dictFunctor);\n        return function(f2) {\n            return function(x) {\n                return map112($$const(x))(f2);\n            };\n        };\n    };\n    var voidRight = function(dictFunctor) {\n        var map112 = map(dictFunctor);\n        return function(x) {\n            return map112($$const(x));\n        };\n    };\n    var functorFn = {\n        map: /* @__PURE__ */ compose(semigroupoidFn)\n    };\n    var functorArray = {\n        map: arrayMap\n    };\n    var flap = function(dictFunctor) {\n        var map112 = map(dictFunctor);\n        return function(ff2) {\n            return function(x) {\n                return map112(function(f2) {\n                    return f2(x);\n                })(ff2);\n            };\n        };\n    };\n    // output/Control.Apply/index.js\n    var identity2 = /* @__PURE__ */ identity(categoryFn);\n    var applyFn = {\n        apply: function(f2) {\n            return function(g) {\n                return function(x) {\n                    return f2(x)(g(x));\n                };\n            };\n        },\n        Functor0: function() {\n            return functorFn;\n        }\n    };\n    var applyArray = {\n        apply: arrayApply,\n        Functor0: function() {\n            return functorArray;\n        }\n    };\n    var apply = function(dict) {\n        return dict.apply;\n    };\n    var applySecond = function(dictApply) {\n        var apply12 = apply(dictApply);\n        var map35 = map(dictApply.Functor0());\n        return function(a2) {\n            return function(b2) {\n                return apply12(map35($$const(identity2))(a2))(b2);\n            };\n        };\n    };\n    var lift2 = function(dictApply) {\n        var apply12 = apply(dictApply);\n        var map35 = map(dictApply.Functor0());\n        return function(f2) {\n            return function(a2) {\n                return function(b2) {\n                    return apply12(map35(f2)(a2))(b2);\n                };\n            };\n        };\n    };\n    // output/Control.Applicative/index.js\n    var pure = function(dict) {\n        return dict.pure;\n    };\n    var unless = function(dictApplicative) {\n        var pure18 = pure(dictApplicative);\n        return function(v) {\n            return function(v1) {\n                if (!v) return v1;\n                if (v) return pure18(unit);\n                throw new Error(\"Failed pattern match at Control.Applicative (line 68, column 1 - line 68, column 65): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        };\n    };\n    var when = function(dictApplicative) {\n        var pure18 = pure(dictApplicative);\n        return function(v) {\n            return function(v1) {\n                if (v) return v1;\n                if (!v) return pure18(unit);\n                throw new Error(\"Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        };\n    };\n    var liftA1 = function(dictApplicative) {\n        var apply4 = apply(dictApplicative.Apply0());\n        var pure18 = pure(dictApplicative);\n        return function(f2) {\n            return function(a2) {\n                return apply4(pure18(f2))(a2);\n            };\n        };\n    };\n    // output/Control.Bind/foreign.js\n    var arrayBind = function(arr) {\n        return function(f2) {\n            var result = [];\n            for(var i2 = 0, l = arr.length; i2 < l; i2++)Array.prototype.push.apply(result, f2(arr[i2]));\n            return result;\n        };\n    };\n    // output/Control.Bind/index.js\n    var identity3 = /* @__PURE__ */ identity(categoryFn);\n    var discard = function(dict) {\n        return dict.discard;\n    };\n    var bindFn = {\n        bind: function(m) {\n            return function(f2) {\n                return function(x) {\n                    return f2(m(x))(x);\n                };\n            };\n        },\n        Apply0: function() {\n            return applyFn;\n        }\n    };\n    var bindArray = {\n        bind: arrayBind,\n        Apply0: function() {\n            return applyArray;\n        }\n    };\n    var bind = function(dict) {\n        return dict.bind;\n    };\n    var bindFlipped = function(dictBind) {\n        return flip(bind(dictBind));\n    };\n    var composeKleisliFlipped = function(dictBind) {\n        var bindFlipped13 = bindFlipped(dictBind);\n        return function(f2) {\n            return function(g) {\n                return function(a2) {\n                    return bindFlipped13(f2)(g(a2));\n                };\n            };\n        };\n    };\n    var composeKleisli = function(dictBind) {\n        var bind112 = bind(dictBind);\n        return function(f2) {\n            return function(g) {\n                return function(a2) {\n                    return bind112(f2(a2))(g);\n                };\n            };\n        };\n    };\n    var discardUnit = {\n        discard: function(dictBind) {\n            return bind(dictBind);\n        }\n    };\n    var join = function(dictBind) {\n        var bind112 = bind(dictBind);\n        return function(m) {\n            return bind112(m)(identity3);\n        };\n    };\n    // output/Control.Monad/index.js\n    var whenM = function(dictMonad) {\n        var bind20 = bind(dictMonad.Bind1());\n        var when8 = when(dictMonad.Applicative0());\n        return function(mb) {\n            return function(m) {\n                return bind20(mb)(function(b2) {\n                    return when8(b2)(m);\n                });\n            };\n        };\n    };\n    var unlessM = function(dictMonad) {\n        var bind20 = bind(dictMonad.Bind1());\n        var unless3 = unless(dictMonad.Applicative0());\n        return function(mb) {\n            return function(m) {\n                return bind20(mb)(function(b2) {\n                    return unless3(b2)(m);\n                });\n            };\n        };\n    };\n    var liftM1 = function(dictMonad) {\n        var bind20 = bind(dictMonad.Bind1());\n        var pure18 = pure(dictMonad.Applicative0());\n        return function(f2) {\n            return function(a2) {\n                return bind20(a2)(function(a$prime) {\n                    return pure18(f2(a$prime));\n                });\n            };\n        };\n    };\n    var ap = function(dictMonad) {\n        var bind20 = bind(dictMonad.Bind1());\n        var pure18 = pure(dictMonad.Applicative0());\n        return function(f2) {\n            return function(a2) {\n                return bind20(f2)(function(f$prime) {\n                    return bind20(a2)(function(a$prime) {\n                        return pure18(f$prime(a$prime));\n                    });\n                });\n            };\n        };\n    };\n    // output/Data.Semigroup/foreign.js\n    var concatString = function(s1) {\n        return function(s2) {\n            return s1 + s2;\n        };\n    };\n    var concatArray = function(xs) {\n        return function(ys) {\n            if (xs.length === 0) return ys;\n            if (ys.length === 0) return xs;\n            return xs.concat(ys);\n        };\n    };\n    // output/Data.Symbol/index.js\n    var reflectSymbol = function(dict) {\n        return dict.reflectSymbol;\n    };\n    // output/Record.Unsafe/foreign.js\n    var unsafeGet = function(label5) {\n        return function(rec) {\n            return rec[label5];\n        };\n    };\n    var unsafeSet = function(label5) {\n        return function(value15) {\n            return function(rec) {\n                var copy2 = {};\n                for(var key in rec)if (({}).hasOwnProperty.call(rec, key)) copy2[key] = rec[key];\n                copy2[label5] = value15;\n                return copy2;\n            };\n        };\n    };\n    // output/Data.Semigroup/index.js\n    var semigroupUnit = {\n        append: function(v) {\n            return function(v1) {\n                return unit;\n            };\n        }\n    };\n    var semigroupString = {\n        append: concatString\n    };\n    var semigroupArray = {\n        append: concatArray\n    };\n    var append = function(dict) {\n        return dict.append;\n    };\n    // output/Control.Alt/index.js\n    var alt = function(dict) {\n        return dict.alt;\n    };\n    // output/Data.Bounded/foreign.js\n    var topInt = 2147483647;\n    var bottomInt = -2147483648;\n    var topChar = String.fromCharCode(65535);\n    var bottomChar = String.fromCharCode(0);\n    var topNumber = Number.POSITIVE_INFINITY;\n    var bottomNumber = Number.NEGATIVE_INFINITY;\n    // output/Data.Ord/foreign.js\n    var unsafeCompareImpl = function(lt) {\n        return function(eq8) {\n            return function(gt) {\n                return function(x) {\n                    return function(y) {\n                        return x < y ? lt : x === y ? eq8 : gt;\n                    };\n                };\n            };\n        };\n    };\n    var ordIntImpl = unsafeCompareImpl;\n    var ordStringImpl = unsafeCompareImpl;\n    // output/Data.Eq/foreign.js\n    var refEq = function(r1) {\n        return function(r2) {\n            return r1 === r2;\n        };\n    };\n    var eqBooleanImpl = refEq;\n    var eqIntImpl = refEq;\n    var eqStringImpl = refEq;\n    var eqArrayImpl = function(f2) {\n        return function(xs) {\n            return function(ys) {\n                if (xs.length !== ys.length) return false;\n                for(var i2 = 0; i2 < xs.length; i2++){\n                    if (!f2(xs[i2])(ys[i2])) return false;\n                }\n                return true;\n            };\n        };\n    };\n    // output/Data.Eq/index.js\n    var eqUnit = {\n        eq: function(v) {\n            return function(v1) {\n                return true;\n            };\n        }\n    };\n    var eqString = {\n        eq: eqStringImpl\n    };\n    var eqRowNil = {\n        eqRecord: function(v) {\n            return function(v1) {\n                return function(v2) {\n                    return true;\n                };\n            };\n        }\n    };\n    var eqRecord = function(dict) {\n        return dict.eqRecord;\n    };\n    var eqRec = function() {\n        return function(dictEqRecord) {\n            return {\n                eq: eqRecord(dictEqRecord)($$Proxy.value)\n            };\n        };\n    };\n    var eqInt = {\n        eq: eqIntImpl\n    };\n    var eqBoolean = {\n        eq: eqBooleanImpl\n    };\n    var eq = function(dict) {\n        return dict.eq;\n    };\n    var eq2 = /* @__PURE__ */ eq(eqBoolean);\n    var eqArray = function(dictEq) {\n        return {\n            eq: eqArrayImpl(eq(dictEq))\n        };\n    };\n    var eqRowCons = function(dictEqRecord) {\n        var eqRecord1 = eqRecord(dictEqRecord);\n        return function() {\n            return function(dictIsSymbol) {\n                var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n                return function(dictEq) {\n                    var eq32 = eq(dictEq);\n                    return {\n                        eqRecord: function(v) {\n                            return function(ra) {\n                                return function(rb) {\n                                    var tail2 = eqRecord1($$Proxy.value)(ra)(rb);\n                                    var key = reflectSymbol2($$Proxy.value);\n                                    var get7 = unsafeGet(key);\n                                    return eq32(get7(ra))(get7(rb)) && tail2;\n                                };\n                            };\n                        }\n                    };\n                };\n            };\n        };\n    };\n    var notEq = function(dictEq) {\n        var eq32 = eq(dictEq);\n        return function(x) {\n            return function(y) {\n                return eq2(eq32(x)(y))(false);\n            };\n        };\n    };\n    // output/Data.Ordering/index.js\n    var LT = /* @__PURE__ */ function() {\n        function LT2() {}\n        LT2.value = new LT2();\n        return LT2;\n    }();\n    var GT = /* @__PURE__ */ function() {\n        function GT2() {}\n        GT2.value = new GT2();\n        return GT2;\n    }();\n    var EQ = /* @__PURE__ */ function() {\n        function EQ2() {}\n        EQ2.value = new EQ2();\n        return EQ2;\n    }();\n    // output/Data.Ring/foreign.js\n    var numSub = function(n1) {\n        return function(n2) {\n            return n1 - n2;\n        };\n    };\n    // output/Data.Semiring/foreign.js\n    var intAdd = function(x) {\n        return function(y) {\n            return x + y | 0;\n        };\n    };\n    var intMul = function(x) {\n        return function(y) {\n            return x * y | 0;\n        };\n    };\n    var numAdd = function(n1) {\n        return function(n2) {\n            return n1 + n2;\n        };\n    };\n    var numMul = function(n1) {\n        return function(n2) {\n            return n1 * n2;\n        };\n    };\n    // output/Data.Semiring/index.js\n    var zero = function(dict) {\n        return dict.zero;\n    };\n    var semiringNumber = {\n        add: numAdd,\n        zero: 0,\n        mul: numMul,\n        one: 1\n    };\n    var semiringInt = {\n        add: intAdd,\n        zero: 0,\n        mul: intMul,\n        one: 1\n    };\n    var one = function(dict) {\n        return dict.one;\n    };\n    var mul = function(dict) {\n        return dict.mul;\n    };\n    var add = function(dict) {\n        return dict.add;\n    };\n    // output/Data.Ring/index.js\n    var sub = function(dict) {\n        return dict.sub;\n    };\n    var ringNumber = {\n        sub: numSub,\n        Semiring0: function() {\n            return semiringNumber;\n        }\n    };\n    // output/Data.Ord/index.js\n    var ordUnit = {\n        compare: function(v) {\n            return function(v1) {\n                return EQ.value;\n            };\n        },\n        Eq0: function() {\n            return eqUnit;\n        }\n    };\n    var ordString = /* @__PURE__ */ function() {\n        return {\n            compare: ordStringImpl(LT.value)(EQ.value)(GT.value),\n            Eq0: function() {\n                return eqString;\n            }\n        };\n    }();\n    var ordInt = /* @__PURE__ */ function() {\n        return {\n            compare: ordIntImpl(LT.value)(EQ.value)(GT.value),\n            Eq0: function() {\n                return eqInt;\n            }\n        };\n    }();\n    var compare = function(dict) {\n        return dict.compare;\n    };\n    var greaterThan = function(dictOrd) {\n        var compare32 = compare(dictOrd);\n        return function(a1) {\n            return function(a2) {\n                var v = compare32(a1)(a2);\n                if (v instanceof GT) return true;\n                return false;\n            };\n        };\n    };\n    var lessThan = function(dictOrd) {\n        var compare32 = compare(dictOrd);\n        return function(a1) {\n            return function(a2) {\n                var v = compare32(a1)(a2);\n                if (v instanceof LT) return true;\n                return false;\n            };\n        };\n    };\n    var lessThanOrEq = function(dictOrd) {\n        var compare32 = compare(dictOrd);\n        return function(a1) {\n            return function(a2) {\n                var v = compare32(a1)(a2);\n                if (v instanceof GT) return false;\n                return true;\n            };\n        };\n    };\n    var max = function(dictOrd) {\n        var compare32 = compare(dictOrd);\n        return function(x) {\n            return function(y) {\n                var v = compare32(x)(y);\n                if (v instanceof LT) return y;\n                if (v instanceof EQ) return x;\n                if (v instanceof GT) return x;\n                throw new Error(\"Failed pattern match at Data.Ord (line 181, column 3 - line 184, column 12): \" + [\n                    v.constructor.name\n                ]);\n            };\n        };\n    };\n    var min = function(dictOrd) {\n        var compare32 = compare(dictOrd);\n        return function(x) {\n            return function(y) {\n                var v = compare32(x)(y);\n                if (v instanceof LT) return x;\n                if (v instanceof EQ) return x;\n                if (v instanceof GT) return y;\n                throw new Error(\"Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): \" + [\n                    v.constructor.name\n                ]);\n            };\n        };\n    };\n    var clamp = function(dictOrd) {\n        var min1 = min(dictOrd);\n        var max1 = max(dictOrd);\n        return function(low2) {\n            return function(hi) {\n                return function(x) {\n                    return min1(hi)(max1(low2)(x));\n                };\n            };\n        };\n    };\n    // output/Data.Bounded/index.js\n    var top = function(dict) {\n        return dict.top;\n    };\n    var boundedInt = {\n        top: topInt,\n        bottom: bottomInt,\n        Ord0: function() {\n            return ordInt;\n        }\n    };\n    var bottom = function(dict) {\n        return dict.bottom;\n    };\n    // output/Data.Show/foreign.js\n    var showIntImpl = function(n) {\n        return n.toString();\n    };\n    var showNumberImpl = function(n) {\n        var str = n.toString();\n        return isNaN(str + \".0\") ? str : str + \".0\";\n    };\n    var showStringImpl = function(s) {\n        var l = s.length;\n        return '\"' + s.replace(/[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n        function(c, i2) {\n            switch(c){\n                case '\"':\n                case \"\\\\\":\n                    return \"\\\\\" + c;\n                case \"\\x07\":\n                    return \"\\\\a\";\n                case \"\\b\":\n                    return \"\\\\b\";\n                case \"\\f\":\n                    return \"\\\\f\";\n                case \"\\n\":\n                    return \"\\\\n\";\n                case \"\\r\":\n                    return \"\\\\r\";\n                case \"\t\":\n                    return \"\\\\t\";\n                case \"\\v\":\n                    return \"\\\\v\";\n            }\n            var k = i2 + 1;\n            var empty8 = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n            return \"\\\\\" + c.charCodeAt(0).toString(10) + empty8;\n        }) + '\"';\n    };\n    // output/Data.Show/index.js\n    var showString = {\n        show: showStringImpl\n    };\n    var showNumber = {\n        show: showNumberImpl\n    };\n    var showInt = {\n        show: showIntImpl\n    };\n    var show = function(dict) {\n        return dict.show;\n    };\n    // output/Data.Generic.Rep/index.js\n    var Inl = /* @__PURE__ */ function() {\n        function Inl2(value0) {\n            this.value0 = value0;\n        }\n        Inl2.create = function(value0) {\n            return new Inl2(value0);\n        };\n        return Inl2;\n    }();\n    var Inr = /* @__PURE__ */ function() {\n        function Inr2(value0) {\n            this.value0 = value0;\n        }\n        Inr2.create = function(value0) {\n            return new Inr2(value0);\n        };\n        return Inr2;\n    }();\n    var NoArguments = /* @__PURE__ */ function() {\n        function NoArguments2() {}\n        NoArguments2.value = new NoArguments2();\n        return NoArguments2;\n    }();\n    var from = function(dict) {\n        return dict.from;\n    };\n    // output/Data.Maybe/index.js\n    var identity4 = /* @__PURE__ */ identity(categoryFn);\n    var Nothing = /* @__PURE__ */ function() {\n        function Nothing2() {}\n        Nothing2.value = new Nothing2();\n        return Nothing2;\n    }();\n    var Just = /* @__PURE__ */ function() {\n        function Just2(value0) {\n            this.value0 = value0;\n        }\n        Just2.create = function(value0) {\n            return new Just2(value0);\n        };\n        return Just2;\n    }();\n    var maybe$prime = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v2 instanceof Nothing) return v(unit);\n                if (v2 instanceof Just) return v1(v2.value0);\n                throw new Error(\"Failed pattern match at Data.Maybe (line 250, column 1 - line 250, column 62): \" + [\n                    v.constructor.name,\n                    v1.constructor.name,\n                    v2.constructor.name\n                ]);\n            };\n        };\n    };\n    var maybe = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v2 instanceof Nothing) return v;\n                if (v2 instanceof Just) return v1(v2.value0);\n                throw new Error(\"Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): \" + [\n                    v.constructor.name,\n                    v1.constructor.name,\n                    v2.constructor.name\n                ]);\n            };\n        };\n    };\n    var isNothing = /* @__PURE__ */ maybe(true)(/* @__PURE__ */ $$const(false));\n    var isJust = /* @__PURE__ */ maybe(false)(/* @__PURE__ */ $$const(true));\n    var functorMaybe = {\n        map: function(v) {\n            return function(v1) {\n                if (v1 instanceof Just) return new Just(v(v1.value0));\n                return Nothing.value;\n            };\n        }\n    };\n    var map2 = /* @__PURE__ */ map(functorMaybe);\n    var fromMaybe = function(a2) {\n        return maybe(a2)(identity4);\n    };\n    var fromJust = function() {\n        return function(v) {\n            if (v instanceof Just) return v.value0;\n            throw new Error(\"Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): \" + [\n                v.constructor.name\n            ]);\n        };\n    };\n    var applyMaybe = {\n        apply: function(v) {\n            return function(v1) {\n                if (v instanceof Just) return map2(v.value0)(v1);\n                if (v instanceof Nothing) return Nothing.value;\n                throw new Error(\"Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        },\n        Functor0: function() {\n            return functorMaybe;\n        }\n    };\n    var bindMaybe = {\n        bind: function(v) {\n            return function(v1) {\n                if (v instanceof Just) return v1(v.value0);\n                if (v instanceof Nothing) return Nothing.value;\n                throw new Error(\"Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        },\n        Apply0: function() {\n            return applyMaybe;\n        }\n    };\n    var applicativeMaybe = /* @__PURE__ */ function() {\n        return {\n            pure: Just.create,\n            Apply0: function() {\n                return applyMaybe;\n            }\n        };\n    }();\n    // output/Data.Either/index.js\n    var Left = /* @__PURE__ */ function() {\n        function Left2(value0) {\n            this.value0 = value0;\n        }\n        Left2.create = function(value0) {\n            return new Left2(value0);\n        };\n        return Left2;\n    }();\n    var Right = /* @__PURE__ */ function() {\n        function Right2(value0) {\n            this.value0 = value0;\n        }\n        Right2.create = function(value0) {\n            return new Right2(value0);\n        };\n        return Right2;\n    }();\n    var note = function(a2) {\n        return maybe(new Left(a2))(Right.create);\n    };\n    var functorEither = {\n        map: function(f2) {\n            return function(m) {\n                if (m instanceof Left) return new Left(m.value0);\n                if (m instanceof Right) return new Right(f2(m.value0));\n                throw new Error(\"Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): \" + [\n                    m.constructor.name\n                ]);\n            };\n        }\n    };\n    var map3 = /* @__PURE__ */ map(functorEither);\n    var either = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v2 instanceof Left) return v(v2.value0);\n                if (v2 instanceof Right) return v1(v2.value0);\n                throw new Error(\"Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): \" + [\n                    v.constructor.name,\n                    v1.constructor.name,\n                    v2.constructor.name\n                ]);\n            };\n        };\n    };\n    var applyEither = {\n        apply: function(v) {\n            return function(v1) {\n                if (v instanceof Left) return new Left(v.value0);\n                if (v instanceof Right) return map3(v.value0)(v1);\n                throw new Error(\"Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): \" + [\n                    v.constructor.name,\n                    v1.constructor.name\n                ]);\n            };\n        },\n        Functor0: function() {\n            return functorEither;\n        }\n    };\n    var bindEither = {\n        bind: /* @__PURE__ */ either(function(e) {\n            return function(v) {\n                return new Left(e);\n            };\n        })(function(a2) {\n            return function(f2) {\n                return f2(a2);\n            };\n        }),\n        Apply0: function() {\n            return applyEither;\n        }\n    };\n    var applicativeEither = /* @__PURE__ */ function() {\n        return {\n            pure: Right.create,\n            Apply0: function() {\n                return applyEither;\n            }\n        };\n    }();\n    // output/Effect/foreign.js\n    var pureE = function(a2) {\n        return function() {\n            return a2;\n        };\n    };\n    var bindE = function(a2) {\n        return function(f2) {\n            return function() {\n                return f2(a2())();\n            };\n        };\n    };\n    // output/Data.EuclideanRing/foreign.js\n    var numDiv = function(n1) {\n        return function(n2) {\n            return n1 / n2;\n        };\n    };\n    // output/Data.CommutativeRing/index.js\n    var commutativeRingNumber = {\n        Ring0: function() {\n            return ringNumber;\n        }\n    };\n    // output/Data.EuclideanRing/index.js\n    var mod = function(dict) {\n        return dict.mod;\n    };\n    var euclideanRingNumber = {\n        degree: function(v) {\n            return 1;\n        },\n        div: numDiv,\n        mod: function(v) {\n            return function(v1) {\n                return 0;\n            };\n        },\n        CommutativeRing0: function() {\n            return commutativeRingNumber;\n        }\n    };\n    var div = function(dict) {\n        return dict.div;\n    };\n    // output/Data.Monoid/index.js\n    var monoidUnit = {\n        mempty: unit,\n        Semigroup0: function() {\n            return semigroupUnit;\n        }\n    };\n    var monoidString = {\n        mempty: \"\",\n        Semigroup0: function() {\n            return semigroupString;\n        }\n    };\n    var monoidArray = {\n        mempty: [],\n        Semigroup0: function() {\n            return semigroupArray;\n        }\n    };\n    var mempty = function(dict) {\n        return dict.mempty;\n    };\n    // output/Effect/index.js\n    var $runtime_lazy = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var monadEffect = {\n        Applicative0: function() {\n            return applicativeEffect;\n        },\n        Bind1: function() {\n            return bindEffect;\n        }\n    };\n    var bindEffect = {\n        bind: bindE,\n        Apply0: function() {\n            return $lazy_applyEffect(0);\n        }\n    };\n    var applicativeEffect = {\n        pure: pureE,\n        Apply0: function() {\n            return $lazy_applyEffect(0);\n        }\n    };\n    var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy(\"functorEffect\", \"Effect\", function() {\n        return {\n            map: liftA1(applicativeEffect)\n        };\n    });\n    var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy(\"applyEffect\", \"Effect\", function() {\n        return {\n            apply: ap(monadEffect),\n            Functor0: function() {\n                return $lazy_functorEffect(0);\n            }\n        };\n    });\n    var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);\n    var applyEffect = /* @__PURE__ */ $lazy_applyEffect(23);\n    // output/Effect.Exception/foreign.js\n    function error(msg) {\n        return new Error(msg);\n    }\n    function throwException(e) {\n        return function() {\n            throw e;\n        };\n    }\n    // output/Effect.Exception/index.js\n    var $$throw = function($4) {\n        return throwException(error($4));\n    };\n    // output/Control.Monad.Error.Class/index.js\n    var throwError = function(dict) {\n        return dict.throwError;\n    };\n    var catchError = function(dict) {\n        return dict.catchError;\n    };\n    var $$try = function(dictMonadError) {\n        var catchError1 = catchError(dictMonadError);\n        var Monad0 = dictMonadError.MonadThrow0().Monad0();\n        var map35 = map(Monad0.Bind1().Apply0().Functor0());\n        var pure18 = pure(Monad0.Applicative0());\n        return function(a2) {\n            return catchError1(map35(Right.create)(a2))(function($52) {\n                return pure18(Left.create($52));\n            });\n        };\n    };\n    // output/Data.Identity/index.js\n    var Identity = function(x) {\n        return x;\n    };\n    var functorIdentity = {\n        map: function(f2) {\n            return function(m) {\n                return f2(m);\n            };\n        }\n    };\n    var applyIdentity = {\n        apply: function(v) {\n            return function(v1) {\n                return v(v1);\n            };\n        },\n        Functor0: function() {\n            return functorIdentity;\n        }\n    };\n    var bindIdentity = {\n        bind: function(v) {\n            return function(f2) {\n                return f2(v);\n            };\n        },\n        Apply0: function() {\n            return applyIdentity;\n        }\n    };\n    var applicativeIdentity = {\n        pure: Identity,\n        Apply0: function() {\n            return applyIdentity;\n        }\n    };\n    var monadIdentity = {\n        Applicative0: function() {\n            return applicativeIdentity;\n        },\n        Bind1: function() {\n            return bindIdentity;\n        }\n    };\n    // output/Effect.Ref/foreign.js\n    var _new = function(val) {\n        return function() {\n            return {\n                value: val\n            };\n        };\n    };\n    var read = function(ref3) {\n        return function() {\n            return ref3.value;\n        };\n    };\n    var modifyImpl = function(f2) {\n        return function(ref3) {\n            return function() {\n                var t = f2(ref3.value);\n                ref3.value = t.state;\n                return t.value;\n            };\n        };\n    };\n    var write = function(val) {\n        return function(ref3) {\n            return function() {\n                ref3.value = val;\n            };\n        };\n    };\n    // output/Effect.Ref/index.js\n    var $$void2 = /* @__PURE__ */ $$void(functorEffect);\n    var $$new = _new;\n    var modify$prime = modifyImpl;\n    var modify = function(f2) {\n        return modify$prime(function(s) {\n            var s$prime = f2(s);\n            return {\n                state: s$prime,\n                value: s$prime\n            };\n        });\n    };\n    var modify_ = function(f2) {\n        return function(s) {\n            return $$void2(modify(f2)(s));\n        };\n    };\n    // output/Control.Monad.Rec.Class/index.js\n    var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindEffect);\n    var map4 = /* @__PURE__ */ map(functorEffect);\n    var Loop = /* @__PURE__ */ function() {\n        function Loop2(value0) {\n            this.value0 = value0;\n        }\n        Loop2.create = function(value0) {\n            return new Loop2(value0);\n        };\n        return Loop2;\n    }();\n    var Done = /* @__PURE__ */ function() {\n        function Done2(value0) {\n            this.value0 = value0;\n        }\n        Done2.create = function(value0) {\n            return new Done2(value0);\n        };\n        return Done2;\n    }();\n    var tailRecM = function(dict) {\n        return dict.tailRecM;\n    };\n    var monadRecEffect = {\n        tailRecM: function(f2) {\n            return function(a2) {\n                var fromDone = function(v) {\n                    if (v instanceof Done) return v.value0;\n                    throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 137, column 30 - line 137, column 44): \" + [\n                        v.constructor.name\n                    ]);\n                };\n                return function __do2() {\n                    var r = bindFlipped2($$new)(f2(a2))();\n                    (function() {\n                        while(!function __do3() {\n                            var v = read(r)();\n                            if (v instanceof Loop) {\n                                var e = f2(v.value0)();\n                                write(e)(r)();\n                                return false;\n                            }\n                            if (v instanceof Done) return true;\n                            throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 128, column 22 - line 133, column 28): \" + [\n                                v.constructor.name\n                            ]);\n                        }());\n                        return {};\n                    })();\n                    return map4(fromDone)(read(r))();\n                };\n            };\n        },\n        Monad0: function() {\n            return monadEffect;\n        }\n    };\n    // output/Data.HeytingAlgebra/foreign.js\n    var boolConj = function(b1) {\n        return function(b2) {\n            return b1 && b2;\n        };\n    };\n    var boolDisj = function(b1) {\n        return function(b2) {\n            return b1 || b2;\n        };\n    };\n    var boolNot = function(b2) {\n        return !b2;\n    };\n    // output/Data.HeytingAlgebra/index.js\n    var tt = function(dict) {\n        return dict.tt;\n    };\n    var not = function(dict) {\n        return dict.not;\n    };\n    var implies = function(dict) {\n        return dict.implies;\n    };\n    var ff = function(dict) {\n        return dict.ff;\n    };\n    var disj = function(dict) {\n        return dict.disj;\n    };\n    var heytingAlgebraBoolean = {\n        ff: false,\n        tt: true,\n        implies: function(a2) {\n            return function(b2) {\n                return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a2))(b2);\n            };\n        },\n        conj: boolConj,\n        disj: boolDisj,\n        not: boolNot\n    };\n    var conj = function(dict) {\n        return dict.conj;\n    };\n    var heytingAlgebraFunction = function(dictHeytingAlgebra) {\n        var ff1 = ff(dictHeytingAlgebra);\n        var tt1 = tt(dictHeytingAlgebra);\n        var implies1 = implies(dictHeytingAlgebra);\n        var conj1 = conj(dictHeytingAlgebra);\n        var disj1 = disj(dictHeytingAlgebra);\n        var not1 = not(dictHeytingAlgebra);\n        return {\n            ff: function(v) {\n                return ff1;\n            },\n            tt: function(v) {\n                return tt1;\n            },\n            implies: function(f2) {\n                return function(g) {\n                    return function(a2) {\n                        return implies1(f2(a2))(g(a2));\n                    };\n                };\n            },\n            conj: function(f2) {\n                return function(g) {\n                    return function(a2) {\n                        return conj1(f2(a2))(g(a2));\n                    };\n                };\n            },\n            disj: function(f2) {\n                return function(g) {\n                    return function(a2) {\n                        return disj1(f2(a2))(g(a2));\n                    };\n                };\n            },\n            not: function(f2) {\n                return function(a2) {\n                    return not1(f2(a2));\n                };\n            }\n        };\n    };\n    // output/Data.Tuple/index.js\n    var Tuple = /* @__PURE__ */ function() {\n        function Tuple2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Tuple2.create = function(value0) {\n            return function(value1) {\n                return new Tuple2(value0, value1);\n            };\n        };\n        return Tuple2;\n    }();\n    var snd = function(v) {\n        return v.value1;\n    };\n    var functorTuple = {\n        map: function(f2) {\n            return function(m) {\n                return new Tuple(m.value0, f2(m.value1));\n            };\n        }\n    };\n    var fst = function(v) {\n        return v.value0;\n    };\n    var eqTuple = function(dictEq) {\n        var eq8 = eq(dictEq);\n        return function(dictEq1) {\n            var eq13 = eq(dictEq1);\n            return {\n                eq: function(x) {\n                    return function(y) {\n                        return eq8(x.value0)(y.value0) && eq13(x.value1)(y.value1);\n                    };\n                }\n            };\n        };\n    };\n    var ordTuple = function(dictOrd) {\n        var compare4 = compare(dictOrd);\n        var eqTuple1 = eqTuple(dictOrd.Eq0());\n        return function(dictOrd1) {\n            var compare12 = compare(dictOrd1);\n            var eqTuple2 = eqTuple1(dictOrd1.Eq0());\n            return {\n                compare: function(x) {\n                    return function(y) {\n                        var v = compare4(x.value0)(y.value0);\n                        if (v instanceof LT) return LT.value;\n                        if (v instanceof GT) return GT.value;\n                        return compare12(x.value1)(y.value1);\n                    };\n                },\n                Eq0: function() {\n                    return eqTuple2;\n                }\n            };\n        };\n    };\n    // output/Control.Monad.State.Class/index.js\n    var state = function(dict) {\n        return dict.state;\n    };\n    var put = function(dictMonadState) {\n        var state1 = state(dictMonadState);\n        return function(s) {\n            return state1(function(v) {\n                return new Tuple(unit, s);\n            });\n        };\n    };\n    var modify_2 = function(dictMonadState) {\n        var state1 = state(dictMonadState);\n        return function(f2) {\n            return state1(function(s) {\n                return new Tuple(unit, f2(s));\n            });\n        };\n    };\n    var modify2 = function(dictMonadState) {\n        var state1 = state(dictMonadState);\n        return function(f2) {\n            return state1(function(s) {\n                var s$prime = f2(s);\n                return new Tuple(s$prime, s$prime);\n            });\n        };\n    };\n    var gets = function(dictMonadState) {\n        var state1 = state(dictMonadState);\n        return function(f2) {\n            return state1(function(s) {\n                return new Tuple(f2(s), s);\n            });\n        };\n    };\n    var get = function(dictMonadState) {\n        return state(dictMonadState)(function(s) {\n            return new Tuple(s, s);\n        });\n    };\n    // output/Control.Monad.Trans.Class/index.js\n    var lift = function(dict) {\n        return dict.lift;\n    };\n    // output/Effect.Class/index.js\n    var monadEffectEffect = {\n        liftEffect: /* @__PURE__ */ identity(categoryFn),\n        Monad0: function() {\n            return monadEffect;\n        }\n    };\n    var liftEffect = function(dict) {\n        return dict.liftEffect;\n    };\n    // output/Control.Monad.Maybe.Trans/index.js\n    var map5 = /* @__PURE__ */ map(functorMaybe);\n    var MaybeT = function(x) {\n        return x;\n    };\n    var runMaybeT = function(v) {\n        return v;\n    };\n    var monadTransMaybeT = {\n        lift: function(dictMonad) {\n            var $157 = liftM1(dictMonad)(Just.create);\n            return function($158) {\n                return MaybeT($157($158));\n            };\n        }\n    };\n    var lift3 = /* @__PURE__ */ lift(monadTransMaybeT);\n    var functorMaybeT = function(dictFunctor) {\n        var map112 = map(dictFunctor);\n        return {\n            map: function(f2) {\n                return function(v) {\n                    return map112(map5(f2))(v);\n                };\n            }\n        };\n    };\n    var monadMaybeT = function(dictMonad) {\n        return {\n            Applicative0: function() {\n                return applicativeMaybeT(dictMonad);\n            },\n            Bind1: function() {\n                return bindMaybeT(dictMonad);\n            }\n        };\n    };\n    var bindMaybeT = function(dictMonad) {\n        var bind20 = bind(dictMonad.Bind1());\n        var pure18 = pure(dictMonad.Applicative0());\n        return {\n            bind: function(v) {\n                return function(f2) {\n                    return bind20(v)(function(v1) {\n                        if (v1 instanceof Nothing) return pure18(Nothing.value);\n                        if (v1 instanceof Just) {\n                            var v2 = f2(v1.value0);\n                            return v2;\n                        }\n                        throw new Error(\"Failed pattern match at Control.Monad.Maybe.Trans (line 54, column 11 - line 56, column 42): \" + [\n                            v1.constructor.name\n                        ]);\n                    });\n                };\n            },\n            Apply0: function() {\n                return applyMaybeT(dictMonad);\n            }\n        };\n    };\n    var applyMaybeT = function(dictMonad) {\n        var functorMaybeT1 = functorMaybeT(dictMonad.Bind1().Apply0().Functor0());\n        return {\n            apply: ap(monadMaybeT(dictMonad)),\n            Functor0: function() {\n                return functorMaybeT1;\n            }\n        };\n    };\n    var applicativeMaybeT = function(dictMonad) {\n        return {\n            pure: function() {\n                var $159 = pure(dictMonad.Applicative0());\n                return function($160) {\n                    return MaybeT($159(Just.create($160)));\n                };\n            }(),\n            Apply0: function() {\n                return applyMaybeT(dictMonad);\n            }\n        };\n    };\n    var monadStateMaybeT = function(dictMonadState) {\n        var Monad0 = dictMonadState.Monad0();\n        var lift1 = lift3(Monad0);\n        var state3 = state(dictMonadState);\n        var monadMaybeT1 = monadMaybeT(Monad0);\n        return {\n            state: function(f2) {\n                return lift1(state3(f2));\n            },\n            Monad0: function() {\n                return monadMaybeT1;\n            }\n        };\n    };\n    var altMaybeT = function(dictMonad) {\n        var Bind1 = dictMonad.Bind1();\n        var bind20 = bind(Bind1);\n        var pure18 = pure(dictMonad.Applicative0());\n        var functorMaybeT1 = functorMaybeT(Bind1.Apply0().Functor0());\n        return {\n            alt: function(v) {\n                return function(v1) {\n                    return bind20(v)(function(m) {\n                        if (m instanceof Nothing) return v1;\n                        return pure18(m);\n                    });\n                };\n            },\n            Functor0: function() {\n                return functorMaybeT1;\n            }\n        };\n    };\n    var plusMaybeT = function(dictMonad) {\n        var altMaybeT1 = altMaybeT(dictMonad);\n        return {\n            empty: pure(dictMonad.Applicative0())(Nothing.value),\n            Alt0: function() {\n                return altMaybeT1;\n            }\n        };\n    };\n    var alternativeMaybeT = function(dictMonad) {\n        var applicativeMaybeT1 = applicativeMaybeT(dictMonad);\n        var plusMaybeT1 = plusMaybeT(dictMonad);\n        return {\n            Applicative0: function() {\n                return applicativeMaybeT1;\n            },\n            Plus1: function() {\n                return plusMaybeT1;\n            }\n        };\n    };\n    // output/Data.Array/foreign.js\n    var rangeImpl = function(start2, end) {\n        var step4 = start2 > end ? -1 : 1;\n        var result = new Array(step4 * (end - start2) + 1);\n        var i2 = start2, n = 0;\n        while(i2 !== end){\n            result[n++] = i2;\n            i2 += step4;\n        }\n        result[n] = i2;\n        return result;\n    };\n    var replicateFill = function(count, value15) {\n        if (count < 1) return [];\n        var result = new Array(count);\n        return result.fill(value15);\n    };\n    var replicatePolyfill = function(count, value15) {\n        var result = [];\n        var n = 0;\n        for(var i2 = 0; i2 < count; i2++)result[n++] = value15;\n        return result;\n    };\n    var replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n    var fromFoldableImpl = /* @__PURE__ */ function() {\n        function Cons2(head4, tail2) {\n            this.head = head4;\n            this.tail = tail2;\n        }\n        var emptyList = {};\n        function curryCons(head4) {\n            return function(tail2) {\n                return new Cons2(head4, tail2);\n            };\n        }\n        function listToArray(list) {\n            var result = [];\n            var count = 0;\n            var xs = list;\n            while(xs !== emptyList){\n                result[count++] = xs.head;\n                xs = xs.tail;\n            }\n            return result;\n        }\n        return function(foldr5, xs) {\n            return listToArray(foldr5(curryCons)(emptyList)(xs));\n        };\n    }();\n    var length = function(xs) {\n        return xs.length;\n    };\n    var indexImpl = function(just, nothing, xs, i2) {\n        return i2 < 0 || i2 >= xs.length ? nothing : just(xs[i2]);\n    };\n    var findIndexImpl = function(just, nothing, f2, xs) {\n        for(var i2 = 0, l = xs.length; i2 < l; i2++){\n            if (f2(xs[i2])) return just(i2);\n        }\n        return nothing;\n    };\n    var _deleteAt = function(just, nothing, i2, l) {\n        if (i2 < 0 || i2 >= l.length) return nothing;\n        var l1 = l.slice();\n        l1.splice(i2, 1);\n        return just(l1);\n    };\n    var _updateAt = function(just, nothing, i2, a2, l) {\n        if (i2 < 0 || i2 >= l.length) return nothing;\n        var l1 = l.slice();\n        l1[i2] = a2;\n        return just(l1);\n    };\n    var filterImpl = function(f2, xs) {\n        return xs.filter(f2);\n    };\n    var zipWithImpl = function(f2, xs, ys) {\n        var l = xs.length < ys.length ? xs.length : ys.length;\n        var result = new Array(l);\n        for(var i2 = 0; i2 < l; i2++)result[i2] = f2(xs[i2])(ys[i2]);\n        return result;\n    };\n    var anyImpl = function(p2, xs) {\n        var len = xs.length;\n        for(var i2 = 0; i2 < len; i2++){\n            if (p2(xs[i2])) return true;\n        }\n        return false;\n    };\n    var allImpl = function(p2, xs) {\n        var len = xs.length;\n        for(var i2 = 0; i2 < len; i2++){\n            if (!p2(xs[i2])) return false;\n        }\n        return true;\n    };\n    var unsafeIndexImpl = function(xs, n) {\n        return xs[n];\n    };\n    // output/Control.Monad.ST.Internal/foreign.js\n    var map_ = function(f2) {\n        return function(a2) {\n            return function() {\n                return f2(a2());\n            };\n        };\n    };\n    var pure_ = function(a2) {\n        return function() {\n            return a2;\n        };\n    };\n    var bind_ = function(a2) {\n        return function(f2) {\n            return function() {\n                return f2(a2())();\n            };\n        };\n    };\n    var foreach = function(as) {\n        return function(f2) {\n            return function() {\n                for(var i2 = 0, l = as.length; i2 < l; i2++)f2(as[i2])();\n            };\n        };\n    };\n    // output/Control.Monad.ST.Internal/index.js\n    var $runtime_lazy2 = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var functorST = {\n        map: map_\n    };\n    var monadST = {\n        Applicative0: function() {\n            return applicativeST;\n        },\n        Bind1: function() {\n            return bindST;\n        }\n    };\n    var bindST = {\n        bind: bind_,\n        Apply0: function() {\n            return $lazy_applyST(0);\n        }\n    };\n    var applicativeST = {\n        pure: pure_,\n        Apply0: function() {\n            return $lazy_applyST(0);\n        }\n    };\n    var $lazy_applyST = /* @__PURE__ */ $runtime_lazy2(\"applyST\", \"Control.Monad.ST.Internal\", function() {\n        return {\n            apply: ap(monadST),\n            Functor0: function() {\n                return functorST;\n            }\n        };\n    });\n    var applyST = /* @__PURE__ */ $lazy_applyST(47);\n    // output/Data.Array.ST/foreign.js\n    function newSTArray() {\n        return [];\n    }\n    var peekImpl = function(just, nothing, i2, xs) {\n        return i2 >= 0 && i2 < xs.length ? just(xs[i2]) : nothing;\n    };\n    var pokeImpl = function(i2, a2, xs) {\n        var ret = i2 >= 0 && i2 < xs.length;\n        if (ret) xs[i2] = a2;\n        return ret;\n    };\n    var spliceImpl = function(i2, howMany, bs, xs) {\n        return xs.splice.apply(xs, [\n            i2,\n            howMany\n        ].concat(bs));\n    };\n    function unsafeFreezeThawImpl(xs) {\n        return xs;\n    }\n    var unsafeFreezeImpl = unsafeFreezeThawImpl;\n    function copyImpl(xs) {\n        return xs.slice();\n    }\n    var thawImpl = copyImpl;\n    var pushImpl = function(a2, xs) {\n        return xs.push(a2);\n    };\n    // output/Control.Monad.ST.Uncurried/foreign.js\n    var runSTFn1 = function runSTFn12(fn) {\n        return function(a2) {\n            return function() {\n                return fn(a2);\n            };\n        };\n    };\n    var runSTFn2 = function runSTFn22(fn) {\n        return function(a2) {\n            return function(b2) {\n                return function() {\n                    return fn(a2, b2);\n                };\n            };\n        };\n    };\n    var runSTFn3 = function runSTFn32(fn) {\n        return function(a2) {\n            return function(b2) {\n                return function(c) {\n                    return function() {\n                        return fn(a2, b2, c);\n                    };\n                };\n            };\n        };\n    };\n    var runSTFn4 = function runSTFn42(fn) {\n        return function(a2) {\n            return function(b2) {\n                return function(c) {\n                    return function(d) {\n                        return function() {\n                            return fn(a2, b2, c, d);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Array.ST/index.js\n    var bind2 = /* @__PURE__ */ bind(bindST);\n    var unsafeFreeze = /* @__PURE__ */ runSTFn1(unsafeFreezeImpl);\n    var thaw = /* @__PURE__ */ runSTFn1(thawImpl);\n    var withArray = function(f2) {\n        return function(xs) {\n            return function __do2() {\n                var result = thaw(xs)();\n                f2(result)();\n                return unsafeFreeze(result)();\n            };\n        };\n    };\n    var splice = /* @__PURE__ */ runSTFn4(spliceImpl);\n    var run2 = function(st) {\n        return bind2(st)(unsafeFreeze)();\n    };\n    var push = /* @__PURE__ */ runSTFn2(pushImpl);\n    var poke = /* @__PURE__ */ runSTFn3(pokeImpl);\n    var peek = /* @__PURE__ */ function() {\n        return runSTFn4(peekImpl)(Just.create)(Nothing.value);\n    }();\n    // output/Data.Foldable/foreign.js\n    var foldrArray = function(f2) {\n        return function(init3) {\n            return function(xs) {\n                var acc = init3;\n                var len = xs.length;\n                for(var i2 = len - 1; i2 >= 0; i2--)acc = f2(xs[i2])(acc);\n                return acc;\n            };\n        };\n    };\n    var foldlArray = function(f2) {\n        return function(init3) {\n            return function(xs) {\n                var acc = init3;\n                var len = xs.length;\n                for(var i2 = 0; i2 < len; i2++)acc = f2(acc)(xs[i2]);\n                return acc;\n            };\n        };\n    };\n    // output/Control.Plus/index.js\n    var empty = function(dict) {\n        return dict.empty;\n    };\n    // output/Data.Bifunctor/index.js\n    var identity5 = /* @__PURE__ */ identity(categoryFn);\n    var bimap = function(dict) {\n        return dict.bimap;\n    };\n    var lmap = function(dictBifunctor) {\n        var bimap1 = bimap(dictBifunctor);\n        return function(f2) {\n            return bimap1(f2)(identity5);\n        };\n    };\n    var bifunctorEither = {\n        bimap: function(v) {\n            return function(v1) {\n                return function(v2) {\n                    if (v2 instanceof Left) return new Left(v(v2.value0));\n                    if (v2 instanceof Right) return new Right(v1(v2.value0));\n                    throw new Error(\"Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): \" + [\n                        v.constructor.name,\n                        v1.constructor.name,\n                        v2.constructor.name\n                    ]);\n                };\n            };\n        }\n    };\n    // output/Unsafe.Coerce/foreign.js\n    var unsafeCoerce2 = function(x) {\n        return x;\n    };\n    // output/Safe.Coerce/index.js\n    var coerce = function() {\n        return unsafeCoerce2;\n    };\n    // output/Data.Newtype/index.js\n    var coerce2 = /* @__PURE__ */ coerce();\n    var unwrap = function() {\n        return coerce2;\n    };\n    var unwrap1 = /* @__PURE__ */ unwrap();\n    var un = function() {\n        return function(v) {\n            return unwrap1;\n        };\n    };\n    var collect = function() {\n        return function() {\n            return function(v) {\n                return coerce2;\n            };\n        };\n    };\n    var alaF = function() {\n        return function() {\n            return function() {\n                return function() {\n                    return function(v) {\n                        return coerce2;\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Foldable/index.js\n    var identity6 = /* @__PURE__ */ identity(categoryFn);\n    var foldr = function(dict) {\n        return dict.foldr;\n    };\n    var traverse_ = function(dictApplicative) {\n        var applySecond3 = applySecond(dictApplicative.Apply0());\n        var pure18 = pure(dictApplicative);\n        return function(dictFoldable) {\n            var foldr22 = foldr(dictFoldable);\n            return function(f2) {\n                return foldr22(function($454) {\n                    return applySecond3(f2($454));\n                })(pure18(unit));\n            };\n        };\n    };\n    var for_ = function(dictApplicative) {\n        var traverse_15 = traverse_(dictApplicative);\n        return function(dictFoldable) {\n            return flip(traverse_15(dictFoldable));\n        };\n    };\n    var foldl = function(dict) {\n        return dict.foldl;\n    };\n    var indexl = function(dictFoldable) {\n        var foldl2 = foldl(dictFoldable);\n        return function(idx) {\n            var go2 = function(cursor) {\n                return function(a2) {\n                    if (cursor.elem instanceof Just) return cursor;\n                    var $296 = cursor.pos === idx;\n                    if ($296) return {\n                        elem: new Just(a2),\n                        pos: cursor.pos\n                    };\n                    return {\n                        pos: cursor.pos + 1 | 0,\n                        elem: cursor.elem\n                    };\n                };\n            };\n            var $455 = foldl2(go2)({\n                elem: Nothing.value,\n                pos: 0\n            });\n            return function($456) {\n                return function(v) {\n                    return v.elem;\n                }($455($456));\n            };\n        };\n    };\n    var product = function(dictFoldable) {\n        var foldl2 = foldl(dictFoldable);\n        return function(dictSemiring) {\n            return foldl2(mul(dictSemiring))(one(dictSemiring));\n        };\n    };\n    var foldableMaybe = {\n        foldr: function(v) {\n            return function(v1) {\n                return function(v2) {\n                    if (v2 instanceof Nothing) return v1;\n                    if (v2 instanceof Just) return v(v2.value0)(v1);\n                    throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [\n                        v.constructor.name,\n                        v1.constructor.name,\n                        v2.constructor.name\n                    ]);\n                };\n            };\n        },\n        foldl: function(v) {\n            return function(v1) {\n                return function(v2) {\n                    if (v2 instanceof Nothing) return v1;\n                    if (v2 instanceof Just) return v(v1)(v2.value0);\n                    throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [\n                        v.constructor.name,\n                        v1.constructor.name,\n                        v2.constructor.name\n                    ]);\n                };\n            };\n        },\n        foldMap: function(dictMonoid) {\n            var mempty2 = mempty(dictMonoid);\n            return function(v) {\n                return function(v1) {\n                    if (v1 instanceof Nothing) return mempty2;\n                    if (v1 instanceof Just) return v(v1.value0);\n                    throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [\n                        v.constructor.name,\n                        v1.constructor.name\n                    ]);\n                };\n            };\n        }\n    };\n    var foldMapDefaultR = function(dictFoldable) {\n        var foldr22 = foldr(dictFoldable);\n        return function(dictMonoid) {\n            var append7 = append(dictMonoid.Semigroup0());\n            var mempty2 = mempty(dictMonoid);\n            return function(f2) {\n                return foldr22(function(x) {\n                    return function(acc) {\n                        return append7(f2(x))(acc);\n                    };\n                })(mempty2);\n            };\n        };\n    };\n    var foldableArray = {\n        foldr: foldrArray,\n        foldl: foldlArray,\n        foldMap: function(dictMonoid) {\n            return foldMapDefaultR(foldableArray)(dictMonoid);\n        }\n    };\n    var foldMap = function(dict) {\n        return dict.foldMap;\n    };\n    var fold = function(dictFoldable) {\n        var foldMap22 = foldMap(dictFoldable);\n        return function(dictMonoid) {\n            return foldMap22(dictMonoid)(identity6);\n        };\n    };\n    // output/Data.Function.Uncurried/foreign.js\n    var runFn2 = function(fn) {\n        return function(a2) {\n            return function(b2) {\n                return fn(a2, b2);\n            };\n        };\n    };\n    var runFn3 = function(fn) {\n        return function(a2) {\n            return function(b2) {\n                return function(c) {\n                    return fn(a2, b2, c);\n                };\n            };\n        };\n    };\n    var runFn4 = function(fn) {\n        return function(a2) {\n            return function(b2) {\n                return function(c) {\n                    return function(d) {\n                        return fn(a2, b2, c, d);\n                    };\n                };\n            };\n        };\n    };\n    var runFn5 = function(fn) {\n        return function(a2) {\n            return function(b2) {\n                return function(c) {\n                    return function(d) {\n                        return function(e) {\n                            return fn(a2, b2, c, d, e);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.FunctorWithIndex/foreign.js\n    var mapWithIndexArray = function(f2) {\n        return function(xs) {\n            var l = xs.length;\n            var result = Array(l);\n            for(var i2 = 0; i2 < l; i2++)result[i2] = f2(i2)(xs[i2]);\n            return result;\n        };\n    };\n    // output/Data.Monoid.Additive/index.js\n    var Additive = function(x) {\n        return x;\n    };\n    var semigroupAdditive = function(dictSemiring) {\n        var add3 = add(dictSemiring);\n        return {\n            append: function(v) {\n                return function(v1) {\n                    return add3(v)(v1);\n                };\n            }\n        };\n    };\n    var monoidAdditive = function(dictSemiring) {\n        var semigroupAdditive1 = semigroupAdditive(dictSemiring);\n        return {\n            mempty: zero(dictSemiring),\n            Semigroup0: function() {\n                return semigroupAdditive1;\n            }\n        };\n    };\n    // output/Data.FunctorWithIndex/index.js\n    var mapWithIndex = function(dict) {\n        return dict.mapWithIndex;\n    };\n    var functorWithIndexArray = {\n        mapWithIndex: mapWithIndexArray,\n        Functor0: function() {\n            return functorArray;\n        }\n    };\n    // output/Data.Traversable/foreign.js\n    var traverseArrayImpl = /* @__PURE__ */ function() {\n        function array1(a2) {\n            return [\n                a2\n            ];\n        }\n        function array2(a2) {\n            return function(b2) {\n                return [\n                    a2,\n                    b2\n                ];\n            };\n        }\n        function array3(a2) {\n            return function(b2) {\n                return function(c) {\n                    return [\n                        a2,\n                        b2,\n                        c\n                    ];\n                };\n            };\n        }\n        function concat2(xs) {\n            return function(ys) {\n                return xs.concat(ys);\n            };\n        }\n        return function(apply4) {\n            return function(map35) {\n                return function(pure18) {\n                    return function(f2) {\n                        return function(array) {\n                            function go2(bot, top3) {\n                                switch(top3 - bot){\n                                    case 0:\n                                        return pure18([]);\n                                    case 1:\n                                        return map35(array1)(f2(array[bot]));\n                                    case 2:\n                                        return apply4(map35(array2)(f2(array[bot])))(f2(array[bot + 1]));\n                                    case 3:\n                                        return apply4(apply4(map35(array3)(f2(array[bot])))(f2(array[bot + 1])))(f2(array[bot + 2]));\n                                    default:\n                                        var pivot = bot + Math.floor((top3 - bot) / 4) * 2;\n                                        return apply4(map35(concat2)(go2(bot, pivot)))(go2(pivot, top3));\n                                }\n                            }\n                            return go2(0, array.length);\n                        };\n                    };\n                };\n            };\n        };\n    }();\n    // output/Data.Traversable/index.js\n    var identity7 = /* @__PURE__ */ identity(categoryFn);\n    var traverse = function(dict) {\n        return dict.traverse;\n    };\n    var sequenceDefault = function(dictTraversable) {\n        var traverse22 = traverse(dictTraversable);\n        return function(dictApplicative) {\n            return traverse22(dictApplicative)(identity7);\n        };\n    };\n    var traversableArray = {\n        traverse: function(dictApplicative) {\n            var Apply0 = dictApplicative.Apply0();\n            return traverseArrayImpl(apply(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));\n        },\n        sequence: function(dictApplicative) {\n            return sequenceDefault(traversableArray)(dictApplicative);\n        },\n        Functor0: function() {\n            return functorArray;\n        },\n        Foldable1: function() {\n            return foldableArray;\n        }\n    };\n    var sequence = function(dict) {\n        return dict.sequence;\n    };\n    var $$for = function(dictApplicative) {\n        return function(dictTraversable) {\n            var traverse22 = traverse(dictTraversable)(dictApplicative);\n            return function(x) {\n                return function(f2) {\n                    return traverse22(f2)(x);\n                };\n            };\n        };\n    };\n    // output/Data.Unfoldable1/foreign.js\n    var unfoldr1ArrayImpl = function(isNothing2) {\n        return function(fromJust4) {\n            return function(fst2) {\n                return function(snd2) {\n                    return function(f2) {\n                        return function(b2) {\n                            var result = [];\n                            var value15 = b2;\n                            while(true){\n                                var tuple = f2(value15);\n                                result.push(fst2(tuple));\n                                var maybe2 = snd2(tuple);\n                                if (isNothing2(maybe2)) return result;\n                                value15 = fromJust4(maybe2);\n                            }\n                        };\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Semigroup.Foldable/index.js\n    var JoinWith = function(x) {\n        return x;\n    };\n    var semigroupJoinWith = function(dictSemigroup) {\n        var append7 = append(dictSemigroup);\n        return {\n            append: function(v) {\n                return function(v1) {\n                    return function(j) {\n                        return append7(v(j))(append7(j)(v1(j)));\n                    };\n                };\n            }\n        };\n    };\n    var joinee = function(v) {\n        return v;\n    };\n    var foldMap1 = function(dict) {\n        return dict.foldMap1;\n    };\n    var intercalateMap = function(dictFoldable1) {\n        var foldMap11 = foldMap1(dictFoldable1);\n        return function(dictSemigroup) {\n            var foldMap122 = foldMap11(semigroupJoinWith(dictSemigroup));\n            return function(j) {\n                return function(f2) {\n                    return function(foldable) {\n                        return joinee(foldMap122(function($171) {\n                            return JoinWith($$const(f2($171)));\n                        })(foldable))(j);\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Unfoldable1/index.js\n    var fromJust2 = /* @__PURE__ */ fromJust();\n    var unfoldr1 = function(dict) {\n        return dict.unfoldr1;\n    };\n    var unfoldable1Array = {\n        unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust2)(fst)(snd)\n    };\n    var iterateN = function(dictUnfoldable1) {\n        var unfoldr11 = unfoldr1(dictUnfoldable1);\n        return function(n) {\n            return function(f2) {\n                return function(s) {\n                    var go2 = function(v) {\n                        return new Tuple(v.value0, function() {\n                            var $28 = v.value1 > 0;\n                            if ($28) return new Just(new Tuple(f2(v.value0), v.value1 - 1 | 0));\n                            return Nothing.value;\n                        }());\n                    };\n                    return unfoldr11(go2)(new Tuple(s, n - 1 | 0));\n                };\n            };\n        };\n    };\n    // output/Data.Array/index.js\n    var $$void3 = /* @__PURE__ */ $$void(functorST);\n    var map6 = /* @__PURE__ */ map(functorMaybe);\n    var map22 = /* @__PURE__ */ map(functorST);\n    var fromJust3 = /* @__PURE__ */ fromJust();\n    var when2 = /* @__PURE__ */ when(applicativeST);\n    var foldMap12 = /* @__PURE__ */ foldMap(foldableArray);\n    var zipWith = /* @__PURE__ */ runFn3(zipWithImpl);\n    var updateAt = /* @__PURE__ */ function() {\n        return runFn5(_updateAt)(Just.create)(Nothing.value);\n    }();\n    var unsafeIndex = function() {\n        return runFn2(unsafeIndexImpl);\n    };\n    var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();\n    var snoc = function(xs) {\n        return function(x) {\n            return withArray(push(x))(xs)();\n        };\n    };\n    var singleton2 = function(a2) {\n        return [\n            a2\n        ];\n    };\n    var range2 = /* @__PURE__ */ runFn2(rangeImpl);\n    var $$null = function(xs) {\n        return length(xs) === 0;\n    };\n    var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);\n    var index = /* @__PURE__ */ function() {\n        return runFn4(indexImpl)(Just.create)(Nothing.value);\n    }();\n    var modifyAt = function(i2) {\n        return function(f2) {\n            return function(xs) {\n                var go2 = function(x) {\n                    return updateAt(i2)(f2(x))(xs);\n                };\n                return maybe(Nothing.value)(go2)(index(xs)(i2));\n            };\n        };\n    };\n    var fromFoldable = function(dictFoldable) {\n        return runFn2(fromFoldableImpl)(foldr(dictFoldable));\n    };\n    var foldr2 = /* @__PURE__ */ foldr(foldableArray);\n    var foldMap2 = function(dictMonoid) {\n        return foldMap12(dictMonoid);\n    };\n    var findIndex = /* @__PURE__ */ function() {\n        return runFn4(findIndexImpl)(Just.create)(Nothing.value);\n    }();\n    var find2 = function(f2) {\n        return function(xs) {\n            return map6(unsafeIndex1(xs))(findIndex(f2)(xs));\n        };\n    };\n    var filter = /* @__PURE__ */ runFn2(filterImpl);\n    var elemIndex = function(dictEq) {\n        var eq22 = eq(dictEq);\n        return function(x) {\n            return findIndex(function(v) {\n                return eq22(v)(x);\n            });\n        };\n    };\n    var notElem2 = function(dictEq) {\n        var elemIndex1 = elemIndex(dictEq);\n        return function(a2) {\n            return function(arr) {\n                return isNothing(elemIndex1(a2)(arr));\n            };\n        };\n    };\n    var elem2 = function(dictEq) {\n        var elemIndex1 = elemIndex(dictEq);\n        return function(a2) {\n            return function(arr) {\n                return isJust(elemIndex1(a2)(arr));\n            };\n        };\n    };\n    var deleteAt = /* @__PURE__ */ function() {\n        return runFn4(_deleteAt)(Just.create)(Nothing.value);\n    }();\n    var deleteBy = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v2.length === 0) return [];\n                return maybe(v2)(function(i2) {\n                    return fromJust3(deleteAt(i2)(v2));\n                })(findIndex(v(v1))(v2));\n            };\n        };\n    };\n    var concatMap = /* @__PURE__ */ flip(/* @__PURE__ */ bind(bindArray));\n    var mapMaybe = function(f2) {\n        return concatMap(function() {\n            var $189 = maybe([])(singleton2);\n            return function($190) {\n                return $189(f2($190));\n            };\n        }());\n    };\n    var any2 = /* @__PURE__ */ runFn2(anyImpl);\n    var nubByEq = function(eq22) {\n        return function(xs) {\n            return function __do2() {\n                var arr = newSTArray();\n                foreach(xs)(function(x) {\n                    return function __do3() {\n                        var e = map22(function() {\n                            var $194 = any2(function(v) {\n                                return eq22(v)(x);\n                            });\n                            return function($195) {\n                                return !$194($195);\n                            };\n                        }())(unsafeFreeze(arr))();\n                        return when2(e)($$void3(push(x)(arr)))();\n                    };\n                })();\n                return unsafeFreeze(arr)();\n            }();\n        };\n    };\n    var all2 = /* @__PURE__ */ runFn2(allImpl);\n    // output/Data.Exists/index.js\n    var runExists = unsafeCoerce2;\n    var mkExists = unsafeCoerce2;\n    // output/Data.Coyoneda/index.js\n    var CoyonedaF = /* @__PURE__ */ function() {\n        function CoyonedaF2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        CoyonedaF2.create = function(value0) {\n            return function(value1) {\n                return new CoyonedaF2(value0, value1);\n            };\n        };\n        return CoyonedaF2;\n    }();\n    var unCoyoneda = function(f2) {\n        return function(v) {\n            return runExists(function(v1) {\n                return f2(v1.value0)(v1.value1);\n            })(v);\n        };\n    };\n    var coyoneda = function(k) {\n        return function(fi) {\n            return mkExists(new CoyonedaF(k, fi));\n        };\n    };\n    var functorCoyoneda = {\n        map: function(f2) {\n            return function(v) {\n                return runExists(function(v1) {\n                    return coyoneda(function($180) {\n                        return f2(v1.value0($180));\n                    })(v1.value1);\n                })(v);\n            };\n        }\n    };\n    var liftCoyoneda = /* @__PURE__ */ coyoneda(/* @__PURE__ */ identity(categoryFn));\n    // output/Data.FoldableWithIndex/index.js\n    var foldr8 = /* @__PURE__ */ foldr(foldableArray);\n    var mapWithIndex3 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);\n    var foldl8 = /* @__PURE__ */ foldl(foldableArray);\n    var foldrWithIndex = function(dict) {\n        return dict.foldrWithIndex;\n    };\n    var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {\n        var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);\n        return function(dictMonoid) {\n            var append7 = append(dictMonoid.Semigroup0());\n            var mempty2 = mempty(dictMonoid);\n            return function(f2) {\n                return foldrWithIndex1(function(i2) {\n                    return function(x) {\n                        return function(acc) {\n                            return append7(f2(i2)(x))(acc);\n                        };\n                    };\n                })(mempty2);\n            };\n        };\n    };\n    var foldableWithIndexArray = {\n        foldrWithIndex: function(f2) {\n            return function(z) {\n                var $291 = foldr8(function(v) {\n                    return function(y) {\n                        return f2(v.value0)(v.value1)(y);\n                    };\n                })(z);\n                var $292 = mapWithIndex3(Tuple.create);\n                return function($293) {\n                    return $291($292($293));\n                };\n            };\n        },\n        foldlWithIndex: function(f2) {\n            return function(z) {\n                var $294 = foldl8(function(y) {\n                    return function(v) {\n                        return f2(v.value0)(y)(v.value1);\n                    };\n                })(z);\n                var $295 = mapWithIndex3(Tuple.create);\n                return function($296) {\n                    return $294($295($296));\n                };\n            };\n        },\n        foldMapWithIndex: function(dictMonoid) {\n            return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);\n        },\n        Foldable0: function() {\n            return foldableArray;\n        }\n    };\n    // output/Data.TraversableWithIndex/index.js\n    var traverseWithIndexDefault = function(dictTraversableWithIndex) {\n        var sequence2 = sequence(dictTraversableWithIndex.Traversable2());\n        var mapWithIndex4 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());\n        return function(dictApplicative) {\n            var sequence12 = sequence2(dictApplicative);\n            return function(f2) {\n                var $174 = mapWithIndex4(f2);\n                return function($175) {\n                    return sequence12($174($175));\n                };\n            };\n        };\n    };\n    var traverseWithIndex = function(dict) {\n        return dict.traverseWithIndex;\n    };\n    var traversableWithIndexArray = {\n        traverseWithIndex: function(dictApplicative) {\n            return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);\n        },\n        FunctorWithIndex0: function() {\n            return functorWithIndexArray;\n        },\n        FoldableWithIndex1: function() {\n            return foldableWithIndexArray;\n        },\n        Traversable2: function() {\n            return traversableArray;\n        }\n    };\n    // output/Data.NonEmpty/index.js\n    var NonEmpty = /* @__PURE__ */ function() {\n        function NonEmpty2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        NonEmpty2.create = function(value0) {\n            return function(value1) {\n                return new NonEmpty2(value0, value1);\n            };\n        };\n        return NonEmpty2;\n    }();\n    var singleton3 = function(dictPlus) {\n        var empty8 = empty(dictPlus);\n        return function(a2) {\n            return new NonEmpty(a2, empty8);\n        };\n    };\n    var foldableNonEmpty = function(dictFoldable) {\n        var foldMap4 = foldMap(dictFoldable);\n        var foldl2 = foldl(dictFoldable);\n        var foldr5 = foldr(dictFoldable);\n        return {\n            foldMap: function(dictMonoid) {\n                var append13 = append(dictMonoid.Semigroup0());\n                var foldMap13 = foldMap4(dictMonoid);\n                return function(f2) {\n                    return function(v) {\n                        return append13(f2(v.value0))(foldMap13(f2)(v.value1));\n                    };\n                };\n            },\n            foldl: function(f2) {\n                return function(b2) {\n                    return function(v) {\n                        return foldl2(f2)(f2(b2)(v.value0))(v.value1);\n                    };\n                };\n            },\n            foldr: function(f2) {\n                return function(b2) {\n                    return function(v) {\n                        return f2(v.value0)(foldr5(f2)(b2)(v.value1));\n                    };\n                };\n            }\n        };\n    };\n    var foldable1NonEmpty = function(dictFoldable) {\n        var foldl2 = foldl(dictFoldable);\n        var foldr5 = foldr(dictFoldable);\n        var foldableNonEmpty1 = foldableNonEmpty(dictFoldable);\n        return {\n            foldMap1: function(dictSemigroup) {\n                var append13 = append(dictSemigroup);\n                return function(f2) {\n                    return function(v) {\n                        return foldl2(function(s) {\n                            return function(a1) {\n                                return append13(s)(f2(a1));\n                            };\n                        })(f2(v.value0))(v.value1);\n                    };\n                };\n            },\n            foldr1: function(f2) {\n                return function(v) {\n                    return maybe(v.value0)(f2(v.value0))(foldr5(function(a1) {\n                        var $250 = maybe(a1)(f2(a1));\n                        return function($251) {\n                            return Just.create($250($251));\n                        };\n                    })(Nothing.value)(v.value1));\n                };\n            },\n            foldl1: function(f2) {\n                return function(v) {\n                    return foldl2(f2)(v.value0)(v.value1);\n                };\n            },\n            Foldable0: function() {\n                return foldableNonEmpty1;\n            }\n        };\n    };\n    // output/Data.List.Types/index.js\n    var Nil = /* @__PURE__ */ function() {\n        function Nil2() {}\n        Nil2.value = new Nil2();\n        return Nil2;\n    }();\n    var Cons = /* @__PURE__ */ function() {\n        function Cons2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Cons2.create = function(value0) {\n            return function(value1) {\n                return new Cons2(value0, value1);\n            };\n        };\n        return Cons2;\n    }();\n    var NonEmptyList = function(x) {\n        return x;\n    };\n    var listMap = function(f2) {\n        var chunkedRevMap = function($copy_v) {\n            return function($copy_v1) {\n                var $tco_var_v = $copy_v;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(v, v1) {\n                    if (v1 instanceof Cons && v1.value1 instanceof Cons && v1.value1.value1 instanceof Cons) {\n                        $tco_var_v = new Cons(v1, v);\n                        $copy_v1 = v1.value1.value1.value1;\n                        return;\n                    }\n                    var unrolledMap = function(v2) {\n                        if (v2 instanceof Cons && v2.value1 instanceof Cons && v2.value1.value1 instanceof Nil) return new Cons(f2(v2.value0), new Cons(f2(v2.value1.value0), Nil.value));\n                        if (v2 instanceof Cons && v2.value1 instanceof Nil) return new Cons(f2(v2.value0), Nil.value);\n                        return Nil.value;\n                    };\n                    var reverseUnrolledMap = function($copy_v2) {\n                        return function($copy_v3) {\n                            var $tco_var_v2 = $copy_v2;\n                            var $tco_done1 = false;\n                            var $tco_result2;\n                            function $tco_loop2(v2, v3) {\n                                if (v2 instanceof Cons && v2.value0 instanceof Cons && v2.value0.value1 instanceof Cons && v2.value0.value1.value1 instanceof Cons) {\n                                    $tco_var_v2 = v2.value1;\n                                    $copy_v3 = new Cons(f2(v2.value0.value0), new Cons(f2(v2.value0.value1.value0), new Cons(f2(v2.value0.value1.value1.value0), v3)));\n                                    return;\n                                }\n                                $tco_done1 = true;\n                                return v3;\n                            }\n                            while(!$tco_done1)$tco_result2 = $tco_loop2($tco_var_v2, $copy_v3);\n                            return $tco_result2;\n                        };\n                    };\n                    $tco_done = true;\n                    return reverseUnrolledMap(v)(unrolledMap(v1));\n                }\n                while(!$tco_done)$tco_result = $tco_loop($tco_var_v, $copy_v1);\n                return $tco_result;\n            };\n        };\n        return chunkedRevMap(Nil.value);\n    };\n    var functorList = {\n        map: listMap\n    };\n    var foldableList = {\n        foldr: function(f2) {\n            return function(b2) {\n                var rev3 = function() {\n                    var go2 = function($copy_v) {\n                        return function($copy_v1) {\n                            var $tco_var_v = $copy_v;\n                            var $tco_done = false;\n                            var $tco_result;\n                            function $tco_loop(v, v1) {\n                                if (v1 instanceof Nil) {\n                                    $tco_done = true;\n                                    return v;\n                                }\n                                if (v1 instanceof Cons) {\n                                    $tco_var_v = new Cons(v1.value0, v);\n                                    $copy_v1 = v1.value1;\n                                    return;\n                                }\n                                throw new Error(\"Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): \" + [\n                                    v.constructor.name,\n                                    v1.constructor.name\n                                ]);\n                            }\n                            while(!$tco_done)$tco_result = $tco_loop($tco_var_v, $copy_v1);\n                            return $tco_result;\n                        };\n                    };\n                    return go2(Nil.value);\n                }();\n                var $284 = foldl(foldableList)(flip(f2))(b2);\n                return function($285) {\n                    return $284(rev3($285));\n                };\n            };\n        },\n        foldl: function(f2) {\n            var go2 = function($copy_b) {\n                return function($copy_v) {\n                    var $tco_var_b = $copy_b;\n                    var $tco_done1 = false;\n                    var $tco_result;\n                    function $tco_loop(b2, v) {\n                        if (v instanceof Nil) {\n                            $tco_done1 = true;\n                            return b2;\n                        }\n                        if (v instanceof Cons) {\n                            $tco_var_b = f2(b2)(v.value0);\n                            $copy_v = v.value1;\n                            return;\n                        }\n                        throw new Error(\"Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): \" + [\n                            v.constructor.name\n                        ]);\n                    }\n                    while(!$tco_done1)$tco_result = $tco_loop($tco_var_b, $copy_v);\n                    return $tco_result;\n                };\n            };\n            return go2;\n        },\n        foldMap: function(dictMonoid) {\n            var append22 = append(dictMonoid.Semigroup0());\n            var mempty2 = mempty(dictMonoid);\n            return function(f2) {\n                return foldl(foldableList)(function(acc) {\n                    var $286 = append22(acc);\n                    return function($287) {\n                        return $286(f2($287));\n                    };\n                })(mempty2);\n            };\n        }\n    };\n    var foldr3 = /* @__PURE__ */ foldr(foldableList);\n    var semigroupList = {\n        append: function(xs) {\n            return function(ys) {\n                return foldr3(Cons.create)(ys)(xs);\n            };\n        }\n    };\n    var append1 = /* @__PURE__ */ append(semigroupList);\n    var foldable1NonEmptyList = /* @__PURE__ */ foldable1NonEmpty(foldableList);\n    var altList = {\n        alt: append1,\n        Functor0: function() {\n            return functorList;\n        }\n    };\n    var plusList = /* @__PURE__ */ function() {\n        return {\n            empty: Nil.value,\n            Alt0: function() {\n                return altList;\n            }\n        };\n    }();\n    // output/Data.Map.Internal/index.js\n    var $runtime_lazy3 = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var map7 = /* @__PURE__ */ map(functorMaybe);\n    var identity8 = /* @__PURE__ */ identity(categoryFn);\n    var Leaf = /* @__PURE__ */ function() {\n        function Leaf2() {}\n        Leaf2.value = new Leaf2();\n        return Leaf2;\n    }();\n    var Node = /* @__PURE__ */ function() {\n        function Node2(value0, value1, value22, value32, value42, value52) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n            this.value3 = value32;\n            this.value4 = value42;\n            this.value5 = value52;\n        }\n        Node2.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return function(value32) {\n                        return function(value42) {\n                            return function(value52) {\n                                return new Node2(value0, value1, value22, value32, value42, value52);\n                            };\n                        };\n                    };\n                };\n            };\n        };\n        return Node2;\n    }();\n    var Split = /* @__PURE__ */ function() {\n        function Split2(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        Split2.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new Split2(value0, value1, value22);\n                };\n            };\n        };\n        return Split2;\n    }();\n    var SplitLast = /* @__PURE__ */ function() {\n        function SplitLast2(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        SplitLast2.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new SplitLast2(value0, value1, value22);\n                };\n            };\n        };\n        return SplitLast2;\n    }();\n    var unsafeNode = function(k, v, l, r) {\n        if (l instanceof Leaf) {\n            if (r instanceof Leaf) return new Node(1, 1, k, v, l, r);\n            if (r instanceof Node) return new Node(1 + r.value0 | 0, 1 + r.value1 | 0, k, v, l, r);\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 680, column 5 - line 684, column 39): \" + [\n                r.constructor.name\n            ]);\n        }\n        if (l instanceof Node) {\n            if (r instanceof Leaf) return new Node(1 + l.value0 | 0, 1 + l.value1 | 0, k, v, l, r);\n            if (r instanceof Node) return new Node(1 + function() {\n                var $277 = l.value0 > r.value0;\n                if ($277) return l.value0;\n                return r.value0;\n            }() | 0, (1 + l.value1 | 0) + r.value1 | 0, k, v, l, r);\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 686, column 5 - line 690, column 68): \" + [\n                r.constructor.name\n            ]);\n        }\n        throw new Error(\"Failed pattern match at Data.Map.Internal (line 678, column 32 - line 690, column 68): \" + [\n            l.constructor.name\n        ]);\n    };\n    var singleton4 = function(k) {\n        return function(v) {\n            return new Node(1, 1, k, v, Leaf.value, Leaf.value);\n        };\n    };\n    var unsafeBalancedNode = /* @__PURE__ */ function() {\n        var height8 = function(v) {\n            if (v instanceof Leaf) return 0;\n            if (v instanceof Node) return v.value0;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 735, column 12 - line 737, column 26): \" + [\n                v.constructor.name\n            ]);\n        };\n        var rotateLeft = function(k, v, l, rk, rv, rl, rr) {\n            if (rl instanceof Node && rl.value0 > height8(rr)) return unsafeNode(rl.value2, rl.value3, unsafeNode(k, v, l, rl.value4), unsafeNode(rk, rv, rl.value5, rr));\n            return unsafeNode(rk, rv, unsafeNode(k, v, l, rl), rr);\n        };\n        var rotateRight = function(k, v, lk, lv, ll, lr, r) {\n            if (lr instanceof Node && height8(ll) <= lr.value0) return unsafeNode(lr.value2, lr.value3, unsafeNode(lk, lv, ll, lr.value4), unsafeNode(k, v, lr.value5, r));\n            return unsafeNode(lk, lv, ll, unsafeNode(k, v, lr, r));\n        };\n        return function(k, v, l, r) {\n            if (l instanceof Leaf) {\n                if (r instanceof Leaf) return singleton4(k)(v);\n                if (r instanceof Node && r.value0 > 1) return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);\n                return unsafeNode(k, v, l, r);\n            }\n            if (l instanceof Node) {\n                if (r instanceof Node) {\n                    if (r.value0 > (l.value0 + 1 | 0)) return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);\n                    if (l.value0 > (r.value0 + 1 | 0)) return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);\n                }\n                if (r instanceof Leaf && l.value0 > 1) return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);\n                return unsafeNode(k, v, l, r);\n            }\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 695, column 40 - line 716, column 34): \" + [\n                l.constructor.name\n            ]);\n        };\n    }();\n    var $lazy_unsafeSplit = /* @__PURE__ */ $runtime_lazy3(\"unsafeSplit\", \"Data.Map.Internal\", function() {\n        return function(comp, k, m) {\n            if (m instanceof Leaf) return new Split(Nothing.value, Leaf.value, Leaf.value);\n            if (m instanceof Node) {\n                var v = comp(k)(m.value2);\n                if (v instanceof LT) {\n                    var v1 = $lazy_unsafeSplit(771)(comp, k, m.value4);\n                    return new Split(v1.value0, v1.value1, unsafeBalancedNode(m.value2, m.value3, v1.value2, m.value5));\n                }\n                if (v instanceof GT) {\n                    var v1 = $lazy_unsafeSplit(774)(comp, k, m.value5);\n                    return new Split(v1.value0, unsafeBalancedNode(m.value2, m.value3, m.value4, v1.value1), v1.value2);\n                }\n                if (v instanceof EQ) return new Split(new Just(m.value3), m.value4, m.value5);\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 769, column 5 - line 777, column 30): \" + [\n                    v.constructor.name\n                ]);\n            }\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 765, column 34 - line 777, column 30): \" + [\n                m.constructor.name\n            ]);\n        };\n    });\n    var unsafeSplit = /* @__PURE__ */ $lazy_unsafeSplit(764);\n    var $lazy_unsafeSplitLast = /* @__PURE__ */ $runtime_lazy3(\"unsafeSplitLast\", \"Data.Map.Internal\", function() {\n        return function(k, v, l, r) {\n            if (r instanceof Leaf) return new SplitLast(k, v, l);\n            if (r instanceof Node) {\n                var v1 = $lazy_unsafeSplitLast(757)(r.value2, r.value3, r.value4, r.value5);\n                return new SplitLast(v1.value0, v1.value1, unsafeBalancedNode(k, v, l, v1.value2));\n            }\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 754, column 37 - line 758, column 57): \" + [\n                r.constructor.name\n            ]);\n        };\n    });\n    var unsafeSplitLast = /* @__PURE__ */ $lazy_unsafeSplitLast(753);\n    var unsafeJoinNodes = function(v, v1) {\n        if (v instanceof Leaf) return v1;\n        if (v instanceof Node) {\n            var v2 = unsafeSplitLast(v.value2, v.value3, v.value4, v.value5);\n            return unsafeBalancedNode(v2.value0, v2.value1, v2.value2, v1);\n        }\n        throw new Error(\"Failed pattern match at Data.Map.Internal (line 742, column 25 - line 746, column 38): \" + [\n            v.constructor.name,\n            v1.constructor.name\n        ]);\n    };\n    var $lazy_unsafeUnionWith = /* @__PURE__ */ $runtime_lazy3(\"unsafeUnionWith\", \"Data.Map.Internal\", function() {\n        return function(comp, app, l, r) {\n            if (l instanceof Leaf) return r;\n            if (r instanceof Leaf) return l;\n            if (r instanceof Node) {\n                var v = unsafeSplit(comp, r.value2, l);\n                var l$prime = $lazy_unsafeUnionWith(787)(comp, app, v.value1, r.value4);\n                var r$prime = $lazy_unsafeUnionWith(788)(comp, app, v.value2, r.value5);\n                if (v.value0 instanceof Just) return unsafeBalancedNode(r.value2, app(v.value0.value0)(r.value3), l$prime, r$prime);\n                if (v.value0 instanceof Nothing) return unsafeBalancedNode(r.value2, r.value3, l$prime, r$prime);\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 789, column 5 - line 793, column 46): \" + [\n                    v.value0.constructor.name\n                ]);\n            }\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 782, column 42 - line 793, column 46): \" + [\n                l.constructor.name,\n                r.constructor.name\n            ]);\n        };\n    });\n    var unsafeUnionWith = /* @__PURE__ */ $lazy_unsafeUnionWith(781);\n    var unionWith = function(dictOrd) {\n        var compare4 = compare(dictOrd);\n        return function(app) {\n            return function(m1) {\n                return function(m2) {\n                    return unsafeUnionWith(compare4, app, m1, m2);\n                };\n            };\n        };\n    };\n    var union = function(dictOrd) {\n        return unionWith(dictOrd)($$const);\n    };\n    var pop = function(dictOrd) {\n        var compare4 = compare(dictOrd);\n        return function(k) {\n            return function(m) {\n                var v = unsafeSplit(compare4, k, m);\n                return map7(function(a2) {\n                    return new Tuple(a2, unsafeJoinNodes(v.value1, v.value2));\n                })(v.value0);\n            };\n        };\n    };\n    var lookup = function(dictOrd) {\n        var compare4 = compare(dictOrd);\n        return function(k) {\n            var go2 = function($copy_v) {\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(v) {\n                    if (v instanceof Leaf) {\n                        $tco_done = true;\n                        return Nothing.value;\n                    }\n                    if (v instanceof Node) {\n                        var v1 = compare4(k)(v.value2);\n                        if (v1 instanceof LT) {\n                            $copy_v = v.value4;\n                            return;\n                        }\n                        if (v1 instanceof GT) {\n                            $copy_v = v.value5;\n                            return;\n                        }\n                        if (v1 instanceof EQ) {\n                            $tco_done = true;\n                            return new Just(v.value3);\n                        }\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 281, column 7 - line 284, column 22): \" + [\n                            v1.constructor.name\n                        ]);\n                    }\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 278, column 8 - line 284, column 22): \" + [\n                        v.constructor.name\n                    ]);\n                }\n                while(!$tco_done)$tco_result = $tco_loop($copy_v);\n                return $tco_result;\n            };\n            return go2;\n        };\n    };\n    var insert = function(dictOrd) {\n        var compare4 = compare(dictOrd);\n        return function(k) {\n            return function(v) {\n                var go2 = function(v1) {\n                    if (v1 instanceof Leaf) return singleton4(k)(v);\n                    if (v1 instanceof Node) {\n                        var v2 = compare4(k)(v1.value2);\n                        if (v2 instanceof LT) return unsafeBalancedNode(v1.value2, v1.value3, go2(v1.value4), v1.value5);\n                        if (v2 instanceof GT) return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go2(v1.value5));\n                        if (v2 instanceof EQ) return new Node(v1.value0, v1.value1, k, v, v1.value4, v1.value5);\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 469, column 7 - line 472, column 35): \" + [\n                            v2.constructor.name\n                        ]);\n                    }\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 466, column 8 - line 472, column 35): \" + [\n                        v1.constructor.name\n                    ]);\n                };\n                return go2;\n            };\n        };\n    };\n    var functorMap = {\n        map: function(f2) {\n            var go2 = function(v) {\n                if (v instanceof Leaf) return Leaf.value;\n                if (v instanceof Node) return new Node(v.value0, v.value1, v.value2, f2(v.value3), go2(v.value4), go2(v.value5));\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 145, column 10 - line 148, column 39): \" + [\n                    v.constructor.name\n                ]);\n            };\n            return go2;\n        }\n    };\n    var foldableMap = {\n        foldr: function(f2) {\n            return function(z) {\n                var $lazy_go = $runtime_lazy3(\"go\", \"Data.Map.Internal\", function() {\n                    return function(m$prime, z$prime) {\n                        if (m$prime instanceof Leaf) return z$prime;\n                        if (m$prime instanceof Node) return $lazy_go(170)(m$prime.value4, f2(m$prime.value3)($lazy_go(170)(m$prime.value5, z$prime)));\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 167, column 26 - line 170, column 43): \" + [\n                            m$prime.constructor.name\n                        ]);\n                    };\n                });\n                var go2 = $lazy_go(167);\n                return function(m) {\n                    return go2(m, z);\n                };\n            };\n        },\n        foldl: function(f2) {\n            return function(z) {\n                var $lazy_go = $runtime_lazy3(\"go\", \"Data.Map.Internal\", function() {\n                    return function(z$prime, m$prime) {\n                        if (m$prime instanceof Leaf) return z$prime;\n                        if (m$prime instanceof Node) return $lazy_go(176)(f2($lazy_go(176)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 173, column 26 - line 176, column 43): \" + [\n                            m$prime.constructor.name\n                        ]);\n                    };\n                });\n                var go2 = $lazy_go(173);\n                return function(m) {\n                    return go2(z, m);\n                };\n            };\n        },\n        foldMap: function(dictMonoid) {\n            var mempty2 = mempty(dictMonoid);\n            var append13 = append(dictMonoid.Semigroup0());\n            return function(f2) {\n                var go2 = function(v) {\n                    if (v instanceof Leaf) return mempty2;\n                    if (v instanceof Node) return append13(go2(v.value4))(append13(f2(v.value3))(go2(v.value5)));\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 179, column 10 - line 182, column 28): \" + [\n                        v.constructor.name\n                    ]);\n                };\n                return go2;\n            };\n        }\n    };\n    var foldableWithIndexMap = {\n        foldrWithIndex: function(f2) {\n            return function(z) {\n                var $lazy_go = $runtime_lazy3(\"go\", \"Data.Map.Internal\", function() {\n                    return function(m$prime, z$prime) {\n                        if (m$prime instanceof Leaf) return z$prime;\n                        if (m$prime instanceof Node) return $lazy_go(190)(m$prime.value4, f2(m$prime.value2)(m$prime.value3)($lazy_go(190)(m$prime.value5, z$prime)));\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 187, column 26 - line 190, column 45): \" + [\n                            m$prime.constructor.name\n                        ]);\n                    };\n                });\n                var go2 = $lazy_go(187);\n                return function(m) {\n                    return go2(m, z);\n                };\n            };\n        },\n        foldlWithIndex: function(f2) {\n            return function(z) {\n                var $lazy_go = $runtime_lazy3(\"go\", \"Data.Map.Internal\", function() {\n                    return function(z$prime, m$prime) {\n                        if (m$prime instanceof Leaf) return z$prime;\n                        if (m$prime instanceof Node) return $lazy_go(196)(f2(m$prime.value2)($lazy_go(196)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 193, column 26 - line 196, column 45): \" + [\n                            m$prime.constructor.name\n                        ]);\n                    };\n                });\n                var go2 = $lazy_go(193);\n                return function(m) {\n                    return go2(z, m);\n                };\n            };\n        },\n        foldMapWithIndex: function(dictMonoid) {\n            var mempty2 = mempty(dictMonoid);\n            var append13 = append(dictMonoid.Semigroup0());\n            return function(f2) {\n                var go2 = function(v) {\n                    if (v instanceof Leaf) return mempty2;\n                    if (v instanceof Node) return append13(go2(v.value4))(append13(f2(v.value2)(v.value3))(go2(v.value5)));\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 199, column 10 - line 202, column 30): \" + [\n                        v.constructor.name\n                    ]);\n                };\n                return go2;\n            };\n        },\n        Foldable0: function() {\n            return foldableMap;\n        }\n    };\n    var traversableMap = {\n        traverse: function(dictApplicative) {\n            var pure18 = pure(dictApplicative);\n            var Apply0 = dictApplicative.Apply0();\n            var apply4 = apply(Apply0);\n            var map112 = map(Apply0.Functor0());\n            return function(f2) {\n                var go2 = function(v) {\n                    if (v instanceof Leaf) return pure18(Leaf.value);\n                    if (v instanceof Node) return apply4(apply4(map112(function(l$prime) {\n                        return function(v$prime) {\n                            return function(r$prime) {\n                                return new Node(v.value0, v.value1, v.value2, v$prime, l$prime, r$prime);\n                            };\n                        };\n                    })(go2(v.value4)))(f2(v.value3)))(go2(v.value5));\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 207, column 10 - line 213, column 19): \" + [\n                        v.constructor.name\n                    ]);\n                };\n                return go2;\n            };\n        },\n        sequence: function(dictApplicative) {\n            return traverse(traversableMap)(dictApplicative)(identity8);\n        },\n        Functor0: function() {\n            return functorMap;\n        },\n        Foldable1: function() {\n            return foldableMap;\n        }\n    };\n    var values = /* @__PURE__ */ function() {\n        return foldr(foldableMap)(Cons.create)(Nil.value);\n    }();\n    var foldSubmapBy = function(dictOrd) {\n        var lessThan1 = lessThan(dictOrd);\n        var greaterThan1 = greaterThan(dictOrd);\n        var lessThanOrEq1 = lessThanOrEq(dictOrd);\n        return function(appendFn) {\n            return function(memptyValue) {\n                return function(kmin) {\n                    return function(kmax) {\n                        return function(f2) {\n                            var tooSmall = function() {\n                                if (kmin instanceof Just) return function(k) {\n                                    return lessThan1(k)(kmin.value0);\n                                };\n                                if (kmin instanceof Nothing) return $$const(false);\n                                throw new Error(\"Failed pattern match at Data.Map.Internal (line 387, column 7 - line 391, column 22): \" + [\n                                    kmin.constructor.name\n                                ]);\n                            }();\n                            var tooLarge = function() {\n                                if (kmax instanceof Just) return function(k) {\n                                    return greaterThan1(k)(kmax.value0);\n                                };\n                                if (kmax instanceof Nothing) return $$const(false);\n                                throw new Error(\"Failed pattern match at Data.Map.Internal (line 394, column 7 - line 398, column 22): \" + [\n                                    kmax.constructor.name\n                                ]);\n                            }();\n                            var inBounds = function() {\n                                if (kmin instanceof Just && kmax instanceof Just) return function(k) {\n                                    return lessThanOrEq1(kmin.value0)(k) && lessThanOrEq1(k)(kmax.value0);\n                                };\n                                if (kmin instanceof Just && kmax instanceof Nothing) return function(k) {\n                                    return lessThanOrEq1(kmin.value0)(k);\n                                };\n                                if (kmin instanceof Nothing && kmax instanceof Just) return function(k) {\n                                    return lessThanOrEq1(k)(kmax.value0);\n                                };\n                                if (kmin instanceof Nothing && kmax instanceof Nothing) return $$const(true);\n                                throw new Error(\"Failed pattern match at Data.Map.Internal (line 401, column 7 - line 409, column 21): \" + [\n                                    kmin.constructor.name,\n                                    kmax.constructor.name\n                                ]);\n                            }();\n                            var go2 = function(v) {\n                                if (v instanceof Leaf) return memptyValue;\n                                if (v instanceof Node) return appendFn(appendFn(function() {\n                                    var $640 = tooSmall(v.value2);\n                                    if ($640) return memptyValue;\n                                    return go2(v.value4);\n                                }())(function() {\n                                    var $641 = inBounds(v.value2);\n                                    if ($641) return f2(v.value2)(v.value3);\n                                    return memptyValue;\n                                }()))(function() {\n                                    var $642 = tooLarge(v.value2);\n                                    if ($642) return memptyValue;\n                                    return go2(v.value5);\n                                }());\n                                throw new Error(\"Failed pattern match at Data.Map.Internal (line 411, column 10 - line 417, column 66): \" + [\n                                    v.constructor.name\n                                ]);\n                            };\n                            return go2;\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var foldSubmap = function(dictOrd) {\n        var foldSubmapBy1 = foldSubmapBy(dictOrd);\n        return function(dictMonoid) {\n            return foldSubmapBy1(append(dictMonoid.Semigroup0()))(mempty(dictMonoid));\n        };\n    };\n    var filterKeys = function(dictOrd) {\n        return function(f2) {\n            var go2 = function(v) {\n                if (v instanceof Leaf) return Leaf.value;\n                if (v instanceof Node) {\n                    if (f2(v.value2)) return unsafeBalancedNode(v.value2, v.value3, go2(v.value4), go2(v.value5));\n                    if (otherwise) return unsafeJoinNodes(go2(v.value4), go2(v.value5));\n                }\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 638, column 8 - line 644, column 47): \" + [\n                    v.constructor.name\n                ]);\n            };\n            return go2;\n        };\n    };\n    var empty2 = /* @__PURE__ */ function() {\n        return Leaf.value;\n    }();\n    var $$delete = function(dictOrd) {\n        var compare4 = compare(dictOrd);\n        return function(k) {\n            var go2 = function(v) {\n                if (v instanceof Leaf) return Leaf.value;\n                if (v instanceof Node) {\n                    var v1 = compare4(k)(v.value2);\n                    if (v1 instanceof LT) return unsafeBalancedNode(v.value2, v.value3, go2(v.value4), v.value5);\n                    if (v1 instanceof GT) return unsafeBalancedNode(v.value2, v.value3, v.value4, go2(v.value5));\n                    if (v1 instanceof EQ) return unsafeJoinNodes(v.value4, v.value5);\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 496, column 7 - line 499, column 43): \" + [\n                        v1.constructor.name\n                    ]);\n                }\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 493, column 8 - line 499, column 43): \" + [\n                    v.constructor.name\n                ]);\n            };\n            return go2;\n        };\n    };\n    var alter = function(dictOrd) {\n        var compare4 = compare(dictOrd);\n        return function(f2) {\n            return function(k) {\n                return function(m) {\n                    var v = unsafeSplit(compare4, k, m);\n                    var v2 = f2(v.value0);\n                    if (v2 instanceof Nothing) return unsafeJoinNodes(v.value1, v.value2);\n                    if (v2 instanceof Just) return unsafeBalancedNode(k, v2.value0, v.value1, v.value2);\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 512, column 3 - line 516, column 41): \" + [\n                        v2.constructor.name\n                    ]);\n                };\n            };\n        };\n    };\n    var altMap = function(dictOrd) {\n        return {\n            alt: union(dictOrd),\n            Functor0: function() {\n                return functorMap;\n            }\n        };\n    };\n    var plusMap = function(dictOrd) {\n        var altMap1 = altMap(dictOrd);\n        return {\n            empty: empty2,\n            Alt0: function() {\n                return altMap1;\n            }\n        };\n    };\n    // output/Data.Monoid.Alternate/index.js\n    var Alternate = function(x) {\n        return x;\n    };\n    var semigroupAlternate = function(dictAlt) {\n        var alt5 = alt(dictAlt);\n        return {\n            append: function(v) {\n                return function(v1) {\n                    return alt5(v)(v1);\n                };\n            }\n        };\n    };\n    var monoidAlternate = function(dictPlus) {\n        var semigroupAlternate1 = semigroupAlternate(dictPlus.Alt0());\n        return {\n            mempty: empty(dictPlus),\n            Semigroup0: function() {\n                return semigroupAlternate1;\n            }\n        };\n    };\n    // output/Halogen.Data.OrdBox/index.js\n    var OrdBox = /* @__PURE__ */ function() {\n        function OrdBox2(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        OrdBox2.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new OrdBox2(value0, value1, value22);\n                };\n            };\n        };\n        return OrdBox2;\n    }();\n    var unOrdBox = function(v) {\n        return v.value2;\n    };\n    var mkOrdBox = function(dictOrd) {\n        return OrdBox.create(eq(dictOrd.Eq0()))(compare(dictOrd));\n    };\n    var eqOrdBox = {\n        eq: function(v) {\n            return function(v1) {\n                return v.value0(v.value2)(v1.value2);\n            };\n        }\n    };\n    var ordOrdBox = {\n        compare: function(v) {\n            return function(v1) {\n                return v.value1(v.value2)(v1.value2);\n            };\n        },\n        Eq0: function() {\n            return eqOrdBox;\n        }\n    };\n    // output/Halogen.Data.Slot/index.js\n    var un2 = /* @__PURE__ */ un();\n    var ordTuple2 = /* @__PURE__ */ ordTuple(ordString)(ordOrdBox);\n    var foldSubmap2 = /* @__PURE__ */ foldSubmap(ordTuple2);\n    var pop1 = /* @__PURE__ */ pop(ordTuple2);\n    var lookup1 = /* @__PURE__ */ lookup(ordTuple2);\n    var insert1 = /* @__PURE__ */ insert(ordTuple2);\n    var slots = function() {\n        return function(dictIsSymbol) {\n            var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n            return function(dictOrd) {\n                var foldSubmap1 = foldSubmap2(monoidAlternate(plusMap(dictOrd)));\n                return function(sym) {\n                    return function(v) {\n                        var key = reflectSymbol2(sym);\n                        var go2 = function(v1) {\n                            return function(val) {\n                                if (key === v1.value0) return singleton4(unOrdBox(v1.value1))(val);\n                                if (otherwise) return empty2;\n                                throw new Error(\"Failed pattern match at Halogen.Data.Slot (line 121, column 3 - line 123, column 38): \" + [\n                                    v1.constructor.name,\n                                    val.constructor.name\n                                ]);\n                            };\n                        };\n                        return un2(Alternate)(foldSubmap1(Nothing.value)(Nothing.value)(go2)(v));\n                    };\n                };\n            };\n        };\n    };\n    var pop2 = function() {\n        return function(dictIsSymbol) {\n            var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n            return function(dictOrd) {\n                var mkOrdBox2 = mkOrdBox(dictOrd);\n                return function(sym) {\n                    return function(key) {\n                        return function(v) {\n                            return pop1(new Tuple(reflectSymbol2(sym), mkOrdBox2(key)))(v);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var lookup2 = function() {\n        return function(dictIsSymbol) {\n            var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n            return function(dictOrd) {\n                var mkOrdBox2 = mkOrdBox(dictOrd);\n                return function(sym) {\n                    return function(key) {\n                        return function(v) {\n                            return lookup1(new Tuple(reflectSymbol2(sym), mkOrdBox2(key)))(v);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var insert2 = function() {\n        return function(dictIsSymbol) {\n            var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n            return function(dictOrd) {\n                var mkOrdBox2 = mkOrdBox(dictOrd);\n                return function(sym) {\n                    return function(key) {\n                        return function(val) {\n                            return function(v) {\n                                return insert1(new Tuple(reflectSymbol2(sym), mkOrdBox2(key)))(val)(v);\n                            };\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var foreachSlot = function(dictApplicative) {\n        var traverse_10 = traverse_(dictApplicative)(foldableMap);\n        return function(v) {\n            return function(k) {\n                return traverse_10(function($54) {\n                    return k($54);\n                })(v);\n            };\n        };\n    };\n    var empty3 = empty2;\n    // output/Data.String.Common/foreign.js\n    var joinWith = function(s) {\n        return function(xs) {\n            return xs.join(s);\n        };\n    };\n    // output/Data.String.Common/index.js\n    var $$null2 = function(s) {\n        return s === \"\";\n    };\n    // output/DOM.HTML.Indexed.InputType/index.js\n    var InputButton = /* @__PURE__ */ function() {\n        function InputButton2() {}\n        InputButton2.value = new InputButton2();\n        return InputButton2;\n    }();\n    var InputCheckbox = /* @__PURE__ */ function() {\n        function InputCheckbox2() {}\n        InputCheckbox2.value = new InputCheckbox2();\n        return InputCheckbox2;\n    }();\n    var InputColor = /* @__PURE__ */ function() {\n        function InputColor2() {}\n        InputColor2.value = new InputColor2();\n        return InputColor2;\n    }();\n    var InputDate = /* @__PURE__ */ function() {\n        function InputDate2() {}\n        InputDate2.value = new InputDate2();\n        return InputDate2;\n    }();\n    var InputDatetimeLocal = /* @__PURE__ */ function() {\n        function InputDatetimeLocal2() {}\n        InputDatetimeLocal2.value = new InputDatetimeLocal2();\n        return InputDatetimeLocal2;\n    }();\n    var InputEmail = /* @__PURE__ */ function() {\n        function InputEmail2() {}\n        InputEmail2.value = new InputEmail2();\n        return InputEmail2;\n    }();\n    var InputFile = /* @__PURE__ */ function() {\n        function InputFile2() {}\n        InputFile2.value = new InputFile2();\n        return InputFile2;\n    }();\n    var InputHidden = /* @__PURE__ */ function() {\n        function InputHidden2() {}\n        InputHidden2.value = new InputHidden2();\n        return InputHidden2;\n    }();\n    var InputImage = /* @__PURE__ */ function() {\n        function InputImage2() {}\n        InputImage2.value = new InputImage2();\n        return InputImage2;\n    }();\n    var InputMonth = /* @__PURE__ */ function() {\n        function InputMonth2() {}\n        InputMonth2.value = new InputMonth2();\n        return InputMonth2;\n    }();\n    var InputNumber = /* @__PURE__ */ function() {\n        function InputNumber2() {}\n        InputNumber2.value = new InputNumber2();\n        return InputNumber2;\n    }();\n    var InputPassword = /* @__PURE__ */ function() {\n        function InputPassword2() {}\n        InputPassword2.value = new InputPassword2();\n        return InputPassword2;\n    }();\n    var InputRadio = /* @__PURE__ */ function() {\n        function InputRadio2() {}\n        InputRadio2.value = new InputRadio2();\n        return InputRadio2;\n    }();\n    var InputRange = /* @__PURE__ */ function() {\n        function InputRange2() {}\n        InputRange2.value = new InputRange2();\n        return InputRange2;\n    }();\n    var InputReset = /* @__PURE__ */ function() {\n        function InputReset2() {}\n        InputReset2.value = new InputReset2();\n        return InputReset2;\n    }();\n    var InputSearch = /* @__PURE__ */ function() {\n        function InputSearch2() {}\n        InputSearch2.value = new InputSearch2();\n        return InputSearch2;\n    }();\n    var InputSubmit = /* @__PURE__ */ function() {\n        function InputSubmit2() {}\n        InputSubmit2.value = new InputSubmit2();\n        return InputSubmit2;\n    }();\n    var InputTel = /* @__PURE__ */ function() {\n        function InputTel2() {}\n        InputTel2.value = new InputTel2();\n        return InputTel2;\n    }();\n    var InputText = /* @__PURE__ */ function() {\n        function InputText2() {}\n        InputText2.value = new InputText2();\n        return InputText2;\n    }();\n    var InputTime = /* @__PURE__ */ function() {\n        function InputTime2() {}\n        InputTime2.value = new InputTime2();\n        return InputTime2;\n    }();\n    var InputUrl = /* @__PURE__ */ function() {\n        function InputUrl2() {}\n        InputUrl2.value = new InputUrl2();\n        return InputUrl2;\n    }();\n    var InputWeek = /* @__PURE__ */ function() {\n        function InputWeek2() {}\n        InputWeek2.value = new InputWeek2();\n        return InputWeek2;\n    }();\n    var renderInputType = function(v) {\n        if (v instanceof InputButton) return \"button\";\n        if (v instanceof InputCheckbox) return \"checkbox\";\n        if (v instanceof InputColor) return \"color\";\n        if (v instanceof InputDate) return \"date\";\n        if (v instanceof InputDatetimeLocal) return \"datetime-local\";\n        if (v instanceof InputEmail) return \"email\";\n        if (v instanceof InputFile) return \"file\";\n        if (v instanceof InputHidden) return \"hidden\";\n        if (v instanceof InputImage) return \"image\";\n        if (v instanceof InputMonth) return \"month\";\n        if (v instanceof InputNumber) return \"number\";\n        if (v instanceof InputPassword) return \"password\";\n        if (v instanceof InputRadio) return \"radio\";\n        if (v instanceof InputRange) return \"range\";\n        if (v instanceof InputReset) return \"reset\";\n        if (v instanceof InputSearch) return \"search\";\n        if (v instanceof InputSubmit) return \"submit\";\n        if (v instanceof InputTel) return \"tel\";\n        if (v instanceof InputText) return \"text\";\n        if (v instanceof InputTime) return \"time\";\n        if (v instanceof InputUrl) return \"url\";\n        if (v instanceof InputWeek) return \"week\";\n        throw new Error(\"Failed pattern match at DOM.HTML.Indexed.InputType (line 33, column 19 - line 55, column 22): \" + [\n            v.constructor.name\n        ]);\n    };\n    // output/DOM.HTML.Indexed.StepValue/index.js\n    var show2 = /* @__PURE__ */ show(showNumber);\n    var Any = /* @__PURE__ */ function() {\n        function Any2() {}\n        Any2.value = new Any2();\n        return Any2;\n    }();\n    var Step = /* @__PURE__ */ function() {\n        function Step3(value0) {\n            this.value0 = value0;\n        }\n        Step3.create = function(value0) {\n            return new Step3(value0);\n        };\n        return Step3;\n    }();\n    var renderStepValue = function(v) {\n        if (v instanceof Any) return \"any\";\n        if (v instanceof Step) return show2(v.value0);\n        throw new Error(\"Failed pattern match at DOM.HTML.Indexed.StepValue (line 13, column 19 - line 15, column 19): \" + [\n            v.constructor.name\n        ]);\n    };\n    // output/Halogen.Query.Input/index.js\n    var RefUpdate = /* @__PURE__ */ function() {\n        function RefUpdate2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        RefUpdate2.create = function(value0) {\n            return function(value1) {\n                return new RefUpdate2(value0, value1);\n            };\n        };\n        return RefUpdate2;\n    }();\n    var Action = /* @__PURE__ */ function() {\n        function Action3(value0) {\n            this.value0 = value0;\n        }\n        Action3.create = function(value0) {\n            return new Action3(value0);\n        };\n        return Action3;\n    }();\n    // output/Data.Nullable/foreign.js\n    var nullImpl = null;\n    function nullable(a2, r, f2) {\n        return a2 == null ? r : f2(a2);\n    }\n    function notNull(x) {\n        return x;\n    }\n    // output/Data.Nullable/index.js\n    var toNullable = /* @__PURE__ */ maybe(nullImpl)(notNull);\n    var toMaybe = function(n) {\n        return nullable(n, Nothing.value, Just.create);\n    };\n    // output/Halogen.VDom.Machine/index.js\n    var Step2 = /* @__PURE__ */ function() {\n        function Step3(value0, value1, value22, value32) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n            this.value3 = value32;\n        }\n        Step3.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return function(value32) {\n                        return new Step3(value0, value1, value22, value32);\n                    };\n                };\n            };\n        };\n        return Step3;\n    }();\n    var unStep = unsafeCoerce2;\n    var step = function(v, a2) {\n        return v.value2(v.value1, a2);\n    };\n    var mkStep = unsafeCoerce2;\n    var halt = function(v) {\n        return v.value3(v.value1);\n    };\n    var extract2 = /* @__PURE__ */ unStep(function(v) {\n        return v.value0;\n    });\n    // output/Halogen.VDom.Types/index.js\n    var map8 = /* @__PURE__ */ map(functorArray);\n    var map1 = /* @__PURE__ */ map(functorTuple);\n    var Text = /* @__PURE__ */ function() {\n        function Text2(value0) {\n            this.value0 = value0;\n        }\n        Text2.create = function(value0) {\n            return new Text2(value0);\n        };\n        return Text2;\n    }();\n    var Elem = /* @__PURE__ */ function() {\n        function Elem2(value0, value1, value22, value32) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n            this.value3 = value32;\n        }\n        Elem2.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return function(value32) {\n                        return new Elem2(value0, value1, value22, value32);\n                    };\n                };\n            };\n        };\n        return Elem2;\n    }();\n    var Keyed = /* @__PURE__ */ function() {\n        function Keyed2(value0, value1, value22, value32) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n            this.value3 = value32;\n        }\n        Keyed2.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return function(value32) {\n                        return new Keyed2(value0, value1, value22, value32);\n                    };\n                };\n            };\n        };\n        return Keyed2;\n    }();\n    var Widget = /* @__PURE__ */ function() {\n        function Widget2(value0) {\n            this.value0 = value0;\n        }\n        Widget2.create = function(value0) {\n            return new Widget2(value0);\n        };\n        return Widget2;\n    }();\n    var Grafted = /* @__PURE__ */ function() {\n        function Grafted2(value0) {\n            this.value0 = value0;\n        }\n        Grafted2.create = function(value0) {\n            return new Grafted2(value0);\n        };\n        return Grafted2;\n    }();\n    var Graft = /* @__PURE__ */ function() {\n        function Graft2(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        Graft2.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new Graft2(value0, value1, value22);\n                };\n            };\n        };\n        return Graft2;\n    }();\n    var unGraft = function(f2) {\n        return function($61) {\n            return f2($61);\n        };\n    };\n    var graft = unsafeCoerce2;\n    var bifunctorGraft = {\n        bimap: function(f2) {\n            return function(g) {\n                return unGraft(function(v) {\n                    return graft(new Graft(function($63) {\n                        return f2(v.value0($63));\n                    }, function($64) {\n                        return g(v.value1($64));\n                    }, v.value2));\n                });\n            };\n        }\n    };\n    var bimap2 = /* @__PURE__ */ bimap(bifunctorGraft);\n    var runGraft = /* @__PURE__ */ unGraft(function(v) {\n        var go2 = function(v2) {\n            if (v2 instanceof Text) return new Text(v2.value0);\n            if (v2 instanceof Elem) return new Elem(v2.value0, v2.value1, v.value0(v2.value2), map8(go2)(v2.value3));\n            if (v2 instanceof Keyed) return new Keyed(v2.value0, v2.value1, v.value0(v2.value2), map8(map1(go2))(v2.value3));\n            if (v2 instanceof Widget) return new Widget(v.value1(v2.value0));\n            if (v2 instanceof Grafted) return new Grafted(bimap2(v.value0)(v.value1)(v2.value0));\n            throw new Error(\"Failed pattern match at Halogen.VDom.Types (line 86, column 7 - line 86, column 27): \" + [\n                v2.constructor.name\n            ]);\n        };\n        return go2(v.value2);\n    });\n    // output/Halogen.VDom.Util/foreign.js\n    function unsafeGetAny(key, obj) {\n        return obj[key];\n    }\n    function unsafeHasAny(key, obj) {\n        return obj.hasOwnProperty(key);\n    }\n    function unsafeSetAny(key, val, obj) {\n        obj[key] = val;\n    }\n    function forE2(a2, f2) {\n        var b2 = [];\n        for(var i2 = 0; i2 < a2.length; i2++)b2.push(f2(i2, a2[i2]));\n        return b2;\n    }\n    function forEachE(a2, f2) {\n        for(var i2 = 0; i2 < a2.length; i2++)f2(a2[i2]);\n    }\n    function forInE(o, f2) {\n        var ks = Object.keys(o);\n        for(var i2 = 0; i2 < ks.length; i2++){\n            var k = ks[i2];\n            f2(k, o[k]);\n        }\n    }\n    function diffWithIxE(a1, a2, f1, f2, f3) {\n        var a3 = [];\n        var l1 = a1.length;\n        var l2 = a2.length;\n        var i2 = 0;\n        while(true){\n            if (i2 < l1) {\n                if (i2 < l2) a3.push(f1(i2, a1[i2], a2[i2]));\n                else f2(i2, a1[i2]);\n            } else if (i2 < l2) a3.push(f3(i2, a2[i2]));\n            else break;\n            i2++;\n        }\n        return a3;\n    }\n    function strMapWithIxE(as, fk, f2) {\n        var o = {};\n        for(var i2 = 0; i2 < as.length; i2++){\n            var a2 = as[i2];\n            var k = fk(a2);\n            o[k] = f2(k, i2, a2);\n        }\n        return o;\n    }\n    function diffWithKeyAndIxE(o1, as, fk, f1, f2, f3) {\n        var o2 = {};\n        for(var i2 = 0; i2 < as.length; i2++){\n            var a2 = as[i2];\n            var k = fk(a2);\n            if (o1.hasOwnProperty(k)) o2[k] = f1(k, i2, o1[k], a2);\n            else o2[k] = f3(k, i2, a2);\n        }\n        for(var k in o1){\n            if (k in o2) continue;\n            f2(k, o1[k]);\n        }\n        return o2;\n    }\n    function refEq2(a2, b2) {\n        return a2 === b2;\n    }\n    function createTextNode(s, doc) {\n        return doc.createTextNode(s);\n    }\n    function setTextContent(s, n) {\n        n.textContent = s;\n    }\n    function createElement(ns, name15, doc) {\n        if (ns != null) return doc.createElementNS(ns, name15);\n        else return doc.createElement(name15);\n    }\n    function insertChildIx(i2, a2, b2) {\n        var n = b2.childNodes.item(i2) || null;\n        if (n !== a2) b2.insertBefore(a2, n);\n    }\n    function removeChild(a2, b2) {\n        if (b2 && a2.parentNode === b2) b2.removeChild(a2);\n    }\n    function parentNode(a2) {\n        return a2.parentNode;\n    }\n    function setAttribute(ns, attr3, val, el) {\n        if (ns != null) el.setAttributeNS(ns, attr3, val);\n        else el.setAttribute(attr3, val);\n    }\n    function removeAttribute(ns, attr3, el) {\n        if (ns != null) el.removeAttributeNS(ns, attr3);\n        else el.removeAttribute(attr3);\n    }\n    function hasAttribute(ns, attr3, el) {\n        if (ns != null) return el.hasAttributeNS(ns, attr3);\n        else return el.hasAttribute(attr3);\n    }\n    function addEventListener(ev, listener, el) {\n        el.addEventListener(ev, listener, false);\n    }\n    function removeEventListener(ev, listener, el) {\n        el.removeEventListener(ev, listener, false);\n    }\n    var jsUndefined = void 0;\n    // output/Foreign.Object.ST/foreign.js\n    var newImpl = function() {\n        return {};\n    };\n    function poke2(k) {\n        return function(v) {\n            return function(m) {\n                return function() {\n                    m[k] = v;\n                    return m;\n                };\n            };\n        };\n    }\n    // output/Halogen.VDom.Util/index.js\n    var unsafeLookup = unsafeGetAny;\n    var unsafeFreeze2 = unsafeCoerce2;\n    var pokeMutMap = unsafeSetAny;\n    var newMutMap = newImpl;\n    // output/Web.DOM.Element/foreign.js\n    var getProp = function(name15) {\n        return function(doctype) {\n            return doctype[name15];\n        };\n    };\n    var _namespaceURI = getProp(\"namespaceURI\");\n    var _prefix = getProp(\"prefix\");\n    var localName = getProp(\"localName\");\n    var tagName = getProp(\"tagName\");\n    // output/Web.DOM.ParentNode/foreign.js\n    var getEffProp = function(name15) {\n        return function(node) {\n            return function() {\n                return node[name15];\n            };\n        };\n    };\n    var children = getEffProp(\"children\");\n    var _firstElementChild = getEffProp(\"firstElementChild\");\n    var _lastElementChild = getEffProp(\"lastElementChild\");\n    var childElementCount = getEffProp(\"childElementCount\");\n    function _querySelector(selector) {\n        return function(node) {\n            return function() {\n                return node.querySelector(selector);\n            };\n        };\n    }\n    // output/Web.DOM.ParentNode/index.js\n    var map9 = /* @__PURE__ */ map(functorEffect);\n    var querySelector = function(qs) {\n        var $2 = map9(toMaybe);\n        var $3 = _querySelector(qs);\n        return function($4) {\n            return $2($3($4));\n        };\n    };\n    // output/Web.Internal.FFI/foreign.js\n    function _unsafeReadProtoTagged(nothing, just, name15, value15) {\n        if (typeof window !== \"undefined\") {\n            var ty = window[name15];\n            if (ty != null && value15 instanceof ty) return just(value15);\n        }\n        var obj = value15;\n        while(obj != null){\n            var proto = Object.getPrototypeOf(obj);\n            var constructorName = proto.constructor.name;\n            if (constructorName === name15) return just(value15);\n            else if (constructorName === \"Object\") return nothing;\n            obj = proto;\n        }\n        return nothing;\n    }\n    // output/Web.Internal.FFI/index.js\n    var unsafeReadProtoTagged = function(name15) {\n        return function(value15) {\n            return _unsafeReadProtoTagged(Nothing.value, Just.create, name15, value15);\n        };\n    };\n    // output/Web.DOM.Element/index.js\n    var toNode = unsafeCoerce2;\n    // output/Halogen.VDom.DOM/index.js\n    var $runtime_lazy4 = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var haltWidget = function(v) {\n        return halt(v.widget);\n    };\n    var $lazy_patchWidget = /* @__PURE__ */ $runtime_lazy4(\"patchWidget\", \"Halogen.VDom.DOM\", function() {\n        return function(state3, vdom) {\n            if (vdom instanceof Grafted) return $lazy_patchWidget(291)(state3, runGraft(vdom.value0));\n            if (vdom instanceof Widget) {\n                var res = step(state3.widget, vdom.value0);\n                var res$prime = unStep(function(v) {\n                    return mkStep(new Step2(v.value0, {\n                        build: state3.build,\n                        widget: res\n                    }, $lazy_patchWidget(296), haltWidget));\n                })(res);\n                return res$prime;\n            }\n            haltWidget(state3);\n            return state3.build(vdom);\n        };\n    });\n    var patchWidget = /* @__PURE__ */ $lazy_patchWidget(286);\n    var haltText = function(v) {\n        var parent2 = parentNode(v.node);\n        return removeChild(v.node, parent2);\n    };\n    var $lazy_patchText = /* @__PURE__ */ $runtime_lazy4(\"patchText\", \"Halogen.VDom.DOM\", function() {\n        return function(state3, vdom) {\n            if (vdom instanceof Grafted) return $lazy_patchText(82)(state3, runGraft(vdom.value0));\n            if (vdom instanceof Text) {\n                if (state3.value === vdom.value0) return mkStep(new Step2(state3.node, state3, $lazy_patchText(85), haltText));\n                if (otherwise) {\n                    var nextState = {\n                        build: state3.build,\n                        node: state3.node,\n                        value: vdom.value0\n                    };\n                    setTextContent(vdom.value0, state3.node);\n                    return mkStep(new Step2(state3.node, nextState, $lazy_patchText(89), haltText));\n                }\n            }\n            haltText(state3);\n            return state3.build(vdom);\n        };\n    });\n    var patchText = /* @__PURE__ */ $lazy_patchText(77);\n    var haltKeyed = function(v) {\n        var parent2 = parentNode(v.node);\n        removeChild(v.node, parent2);\n        forInE(v.children, function(v1, s) {\n            return halt(s);\n        });\n        return halt(v.attrs);\n    };\n    var haltElem = function(v) {\n        var parent2 = parentNode(v.node);\n        removeChild(v.node, parent2);\n        forEachE(v.children, halt);\n        return halt(v.attrs);\n    };\n    var eqElemSpec = function(ns1, v, ns2, v1) {\n        var $63 = v === v1;\n        if ($63) {\n            if (ns1 instanceof Just && ns2 instanceof Just && ns1.value0 === ns2.value0) return true;\n            if (ns1 instanceof Nothing && ns2 instanceof Nothing) return true;\n            return false;\n        }\n        return false;\n    };\n    var $lazy_patchElem = /* @__PURE__ */ $runtime_lazy4(\"patchElem\", \"Halogen.VDom.DOM\", function() {\n        return function(state3, vdom) {\n            if (vdom instanceof Grafted) return $lazy_patchElem(135)(state3, runGraft(vdom.value0));\n            if (vdom instanceof Elem && eqElemSpec(state3.ns, state3.name, vdom.value0, vdom.value1)) {\n                var v = length(vdom.value3);\n                var v1 = length(state3.children);\n                if (v1 === 0 && v === 0) {\n                    var attrs2 = step(state3.attrs, vdom.value2);\n                    var nextState = {\n                        build: state3.build,\n                        node: state3.node,\n                        attrs: attrs2,\n                        ns: vdom.value0,\n                        name: vdom.value1,\n                        children: state3.children\n                    };\n                    return mkStep(new Step2(state3.node, nextState, $lazy_patchElem(149), haltElem));\n                }\n                var onThis = function(v2, s) {\n                    return halt(s);\n                };\n                var onThese = function(ix, s, v2) {\n                    var res = step(s, v2);\n                    insertChildIx(ix, extract2(res), state3.node);\n                    return res;\n                };\n                var onThat = function(ix, v2) {\n                    var res = state3.build(v2);\n                    insertChildIx(ix, extract2(res), state3.node);\n                    return res;\n                };\n                var children2 = diffWithIxE(state3.children, vdom.value3, onThese, onThis, onThat);\n                var attrs2 = step(state3.attrs, vdom.value2);\n                var nextState = {\n                    build: state3.build,\n                    node: state3.node,\n                    attrs: attrs2,\n                    ns: vdom.value0,\n                    name: vdom.value1,\n                    children: children2\n                };\n                return mkStep(new Step2(state3.node, nextState, $lazy_patchElem(172), haltElem));\n            }\n            haltElem(state3);\n            return state3.build(vdom);\n        };\n    });\n    var patchElem = /* @__PURE__ */ $lazy_patchElem(130);\n    var $lazy_patchKeyed = /* @__PURE__ */ $runtime_lazy4(\"patchKeyed\", \"Halogen.VDom.DOM\", function() {\n        return function(state3, vdom) {\n            if (vdom instanceof Grafted) return $lazy_patchKeyed(222)(state3, runGraft(vdom.value0));\n            if (vdom instanceof Keyed && eqElemSpec(state3.ns, state3.name, vdom.value0, vdom.value1)) {\n                var v = length(vdom.value3);\n                if (state3.length === 0 && v === 0) {\n                    var attrs2 = step(state3.attrs, vdom.value2);\n                    var nextState = {\n                        build: state3.build,\n                        node: state3.node,\n                        attrs: attrs2,\n                        ns: vdom.value0,\n                        name: vdom.value1,\n                        children: state3.children,\n                        length: 0\n                    };\n                    return mkStep(new Step2(state3.node, nextState, $lazy_patchKeyed(237), haltKeyed));\n                }\n                var onThis = function(v2, s) {\n                    return halt(s);\n                };\n                var onThese = function(v2, ix$prime, s, v3) {\n                    var res = step(s, v3.value1);\n                    insertChildIx(ix$prime, extract2(res), state3.node);\n                    return res;\n                };\n                var onThat = function(v2, ix, v3) {\n                    var res = state3.build(v3.value1);\n                    insertChildIx(ix, extract2(res), state3.node);\n                    return res;\n                };\n                var children2 = diffWithKeyAndIxE(state3.children, vdom.value3, fst, onThese, onThis, onThat);\n                var attrs2 = step(state3.attrs, vdom.value2);\n                var nextState = {\n                    build: state3.build,\n                    node: state3.node,\n                    attrs: attrs2,\n                    ns: vdom.value0,\n                    name: vdom.value1,\n                    children: children2,\n                    length: v\n                };\n                return mkStep(new Step2(state3.node, nextState, $lazy_patchKeyed(261), haltKeyed));\n            }\n            haltKeyed(state3);\n            return state3.build(vdom);\n        };\n    });\n    var patchKeyed = /* @__PURE__ */ $lazy_patchKeyed(217);\n    var buildWidget = function(v, build, w) {\n        var res = v.buildWidget(v)(w);\n        var res$prime = unStep(function(v1) {\n            return mkStep(new Step2(v1.value0, {\n                build: build,\n                widget: res\n            }, patchWidget, haltWidget));\n        })(res);\n        return res$prime;\n    };\n    var buildText = function(v, build, s) {\n        var node = createTextNode(s, v.document);\n        var state3 = {\n            build: build,\n            node: node,\n            value: s\n        };\n        return mkStep(new Step2(node, state3, patchText, haltText));\n    };\n    var buildKeyed = function(v, build, ns1, name1, as1, ch1) {\n        var el = createElement(toNullable(ns1), name1, v.document);\n        var node = toNode(el);\n        var onChild = function(v1, ix, v2) {\n            var res = build(v2.value1);\n            insertChildIx(ix, extract2(res), node);\n            return res;\n        };\n        var children2 = strMapWithIxE(ch1, fst, onChild);\n        var attrs = v.buildAttributes(el)(as1);\n        var state3 = {\n            build: build,\n            node: node,\n            attrs: attrs,\n            ns: ns1,\n            name: name1,\n            children: children2,\n            length: length(ch1)\n        };\n        return mkStep(new Step2(node, state3, patchKeyed, haltKeyed));\n    };\n    var buildElem = function(v, build, ns1, name1, as1, ch1) {\n        var el = createElement(toNullable(ns1), name1, v.document);\n        var node = toNode(el);\n        var onChild = function(ix, child) {\n            var res = build(child);\n            insertChildIx(ix, extract2(res), node);\n            return res;\n        };\n        var children2 = forE2(ch1, onChild);\n        var attrs = v.buildAttributes(el)(as1);\n        var state3 = {\n            build: build,\n            node: node,\n            attrs: attrs,\n            ns: ns1,\n            name: name1,\n            children: children2\n        };\n        return mkStep(new Step2(node, state3, patchElem, haltElem));\n    };\n    var buildVDom = function(spec) {\n        var $lazy_build = $runtime_lazy4(\"build\", \"Halogen.VDom.DOM\", function() {\n            return function(v) {\n                if (v instanceof Text) return buildText(spec, $lazy_build(59), v.value0);\n                if (v instanceof Elem) return buildElem(spec, $lazy_build(60), v.value0, v.value1, v.value2, v.value3);\n                if (v instanceof Keyed) return buildKeyed(spec, $lazy_build(61), v.value0, v.value1, v.value2, v.value3);\n                if (v instanceof Widget) return buildWidget(spec, $lazy_build(62), v.value0);\n                if (v instanceof Grafted) return $lazy_build(63)(runGraft(v.value0));\n                throw new Error(\"Failed pattern match at Halogen.VDom.DOM (line 58, column 27 - line 63, column 52): \" + [\n                    v.constructor.name\n                ]);\n            };\n        });\n        var build = $lazy_build(58);\n        return build;\n    };\n    // output/Foreign/foreign.js\n    function typeOf(value15) {\n        return typeof value15;\n    }\n    function tagOf(value15) {\n        return Object.prototype.toString.call(value15).slice(8, -1);\n    }\n    var isArray = Array.isArray || function(value15) {\n        return Object.prototype.toString.call(value15) === \"[object Array]\";\n    };\n    // output/Control.Monad.Except.Trans/index.js\n    var map10 = /* @__PURE__ */ map(functorEither);\n    var ExceptT = function(x) {\n        return x;\n    };\n    var runExceptT = function(v) {\n        return v;\n    };\n    var mapExceptT = function(f2) {\n        return function(v) {\n            return f2(v);\n        };\n    };\n    var functorExceptT = function(dictFunctor) {\n        var map112 = map(dictFunctor);\n        return {\n            map: function(f2) {\n                return mapExceptT(map112(map10(f2)));\n            }\n        };\n    };\n    var monadExceptT = function(dictMonad) {\n        return {\n            Applicative0: function() {\n                return applicativeExceptT(dictMonad);\n            },\n            Bind1: function() {\n                return bindExceptT(dictMonad);\n            }\n        };\n    };\n    var bindExceptT = function(dictMonad) {\n        var bind20 = bind(dictMonad.Bind1());\n        var pure18 = pure(dictMonad.Applicative0());\n        return {\n            bind: function(v) {\n                return function(k) {\n                    return bind20(v)(either(function($187) {\n                        return pure18(Left.create($187));\n                    })(function(a2) {\n                        var v1 = k(a2);\n                        return v1;\n                    }));\n                };\n            },\n            Apply0: function() {\n                return applyExceptT(dictMonad);\n            }\n        };\n    };\n    var applyExceptT = function(dictMonad) {\n        var functorExceptT1 = functorExceptT(dictMonad.Bind1().Apply0().Functor0());\n        return {\n            apply: ap(monadExceptT(dictMonad)),\n            Functor0: function() {\n                return functorExceptT1;\n            }\n        };\n    };\n    var applicativeExceptT = function(dictMonad) {\n        return {\n            pure: function() {\n                var $188 = pure(dictMonad.Applicative0());\n                return function($189) {\n                    return ExceptT($188(Right.create($189)));\n                };\n            }(),\n            Apply0: function() {\n                return applyExceptT(dictMonad);\n            }\n        };\n    };\n    var monadThrowExceptT = function(dictMonad) {\n        var monadExceptT1 = monadExceptT(dictMonad);\n        return {\n            throwError: function() {\n                var $198 = pure(dictMonad.Applicative0());\n                return function($199) {\n                    return ExceptT($198(Left.create($199)));\n                };\n            }(),\n            Monad0: function() {\n                return monadExceptT1;\n            }\n        };\n    };\n    // output/Data.Int/foreign.js\n    var fromNumberImpl = function(just) {\n        return function(nothing) {\n            return function(n) {\n                return (n | 0) === n ? just(n) : nothing;\n            };\n        };\n    };\n    var toNumber = function(n) {\n        return n;\n    };\n    var fromStringAsImpl = function(just) {\n        return function(nothing) {\n            return function(radix) {\n                var digits;\n                if (radix < 11) digits = \"[0-\" + (radix - 1).toString() + \"]\";\n                else if (radix === 11) digits = \"[0-9a]\";\n                else digits = \"[0-9a-\" + String.fromCharCode(86 + radix) + \"]\";\n                var pattern2 = new RegExp(\"^[\\\\+\\\\-]?\" + digits + \"+$\", \"i\");\n                return function(s) {\n                    if (pattern2.test(s)) {\n                        var i2 = parseInt(s, radix);\n                        return (i2 | 0) === i2 ? just(i2) : nothing;\n                    } else return nothing;\n                };\n            };\n        };\n    };\n    // output/Data.Number/foreign.js\n    var isFiniteImpl = isFinite;\n    var floor = Math.floor;\n    // output/Data.Int/index.js\n    var top2 = /* @__PURE__ */ top(boundedInt);\n    var bottom2 = /* @__PURE__ */ bottom(boundedInt);\n    var fromStringAs = /* @__PURE__ */ function() {\n        return fromStringAsImpl(Just.create)(Nothing.value);\n    }();\n    var fromString = /* @__PURE__ */ fromStringAs(10);\n    var fromNumber = /* @__PURE__ */ function() {\n        return fromNumberImpl(Just.create)(Nothing.value);\n    }();\n    var unsafeClamp = function(x) {\n        if (!isFiniteImpl(x)) return 0;\n        if (x >= toNumber(top2)) return top2;\n        if (x <= toNumber(bottom2)) return bottom2;\n        if (otherwise) return fromMaybe(0)(fromNumber(x));\n        throw new Error(\"Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): \" + [\n            x.constructor.name\n        ]);\n    };\n    var floor2 = function($39) {\n        return unsafeClamp(floor($39));\n    };\n    // output/Data.List/index.js\n    var reverse2 = /* @__PURE__ */ function() {\n        var go2 = function($copy_v) {\n            return function($copy_v1) {\n                var $tco_var_v = $copy_v;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(v, v1) {\n                    if (v1 instanceof Nil) {\n                        $tco_done = true;\n                        return v;\n                    }\n                    if (v1 instanceof Cons) {\n                        $tco_var_v = new Cons(v1.value0, v);\n                        $copy_v1 = v1.value1;\n                        return;\n                    }\n                    throw new Error(\"Failed pattern match at Data.List (line 368, column 3 - line 368, column 19): \" + [\n                        v.constructor.name,\n                        v1.constructor.name\n                    ]);\n                }\n                while(!$tco_done)$tco_result = $tco_loop($tco_var_v, $copy_v1);\n                return $tco_result;\n            };\n        };\n        return go2(Nil.value);\n    }();\n    var $$null3 = function(v) {\n        if (v instanceof Nil) return true;\n        return false;\n    };\n    // output/Partial.Unsafe/foreign.js\n    var _unsafePartial = function(f2) {\n        return f2();\n    };\n    // output/Partial/foreign.js\n    var _crashWith = function(msg) {\n        throw new Error(msg);\n    };\n    // output/Partial/index.js\n    var crashWith = function() {\n        return _crashWith;\n    };\n    // output/Partial.Unsafe/index.js\n    var crashWith2 = /* @__PURE__ */ crashWith();\n    var unsafePartial = _unsafePartial;\n    var unsafeCrashWith = function(msg) {\n        return unsafePartial(function() {\n            return crashWith2(msg);\n        });\n    };\n    // output/Data.List.NonEmpty/index.js\n    var singleton5 = /* @__PURE__ */ function() {\n        var $200 = singleton3(plusList);\n        return function($201) {\n            return NonEmptyList($200($201));\n        };\n    }();\n    var cons = function(y) {\n        return function(v) {\n            return new NonEmpty(y, new Cons(v.value0, v.value1));\n        };\n    };\n    // output/Data.String.CodeUnits/foreign.js\n    var length3 = function(s) {\n        return s.length;\n    };\n    var splitAt = function(i2) {\n        return function(s) {\n            return {\n                before: s.substring(0, i2),\n                after: s.substring(i2)\n            };\n        };\n    };\n    // output/Data.String.CodeUnits/index.js\n    var stripPrefix = function(v) {\n        return function(str) {\n            var v1 = splitAt(length3(v))(str);\n            var $20 = v1.before === v;\n            if ($20) return new Just(v1.after);\n            return Nothing.value;\n        };\n    };\n    // output/Foreign/index.js\n    var show3 = /* @__PURE__ */ show(showString);\n    var show1 = /* @__PURE__ */ show(showInt);\n    var ForeignError = /* @__PURE__ */ function() {\n        function ForeignError2(value0) {\n            this.value0 = value0;\n        }\n        ForeignError2.create = function(value0) {\n            return new ForeignError2(value0);\n        };\n        return ForeignError2;\n    }();\n    var TypeMismatch = /* @__PURE__ */ function() {\n        function TypeMismatch3(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        TypeMismatch3.create = function(value0) {\n            return function(value1) {\n                return new TypeMismatch3(value0, value1);\n            };\n        };\n        return TypeMismatch3;\n    }();\n    var ErrorAtIndex = /* @__PURE__ */ function() {\n        function ErrorAtIndex2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        ErrorAtIndex2.create = function(value0) {\n            return function(value1) {\n                return new ErrorAtIndex2(value0, value1);\n            };\n        };\n        return ErrorAtIndex2;\n    }();\n    var ErrorAtProperty = /* @__PURE__ */ function() {\n        function ErrorAtProperty2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        ErrorAtProperty2.create = function(value0) {\n            return function(value1) {\n                return new ErrorAtProperty2(value0, value1);\n            };\n        };\n        return ErrorAtProperty2;\n    }();\n    var unsafeToForeign = unsafeCoerce2;\n    var unsafeFromForeign = unsafeCoerce2;\n    var renderForeignError = function(v) {\n        if (v instanceof ForeignError) return v.value0;\n        if (v instanceof ErrorAtIndex) return \"Error at array index \" + (show1(v.value0) + (\": \" + renderForeignError(v.value1)));\n        if (v instanceof ErrorAtProperty) return \"Error at property \" + (show3(v.value0) + (\": \" + renderForeignError(v.value1)));\n        if (v instanceof TypeMismatch) return \"Type mismatch: expected \" + (v.value0 + (\", found \" + v.value1));\n        throw new Error(\"Failed pattern match at Foreign (line 78, column 1 - line 78, column 45): \" + [\n            v.constructor.name\n        ]);\n    };\n    var fail = function(dictMonad) {\n        var $153 = throwError(monadThrowExceptT(dictMonad));\n        return function($154) {\n            return $153(singleton5($154));\n        };\n    };\n    var unsafeReadTagged = function(dictMonad) {\n        var pure18 = pure(applicativeExceptT(dictMonad));\n        var fail1 = fail(dictMonad);\n        return function(tag) {\n            return function(value15) {\n                if (tagOf(value15) === tag) return pure18(unsafeFromForeign(value15));\n                if (otherwise) return fail1(new TypeMismatch(tag, tagOf(value15)));\n                throw new Error(\"Failed pattern match at Foreign (line 123, column 1 - line 123, column 104): \" + [\n                    tag.constructor.name,\n                    value15.constructor.name\n                ]);\n            };\n        };\n    };\n    var readString = function(dictMonad) {\n        return unsafeReadTagged(dictMonad)(\"String\");\n    };\n    // output/Foreign.Object/foreign.js\n    function _copyST(m) {\n        return function() {\n            var r = {};\n            for(var k in m)if (hasOwnProperty.call(m, k)) r[k] = m[k];\n            return r;\n        };\n    }\n    var empty4 = {};\n    function runST(f2) {\n        return f2();\n    }\n    function _lookup(no, yes, k, m) {\n        return k in m ? yes(m[k]) : no;\n    }\n    function toArrayWithKey(f2) {\n        return function(m) {\n            var r = [];\n            for(var k in m)if (hasOwnProperty.call(m, k)) r.push(f2(k)(m[k]));\n            return r;\n        };\n    }\n    var keys = Object.keys || toArrayWithKey(function(k) {\n        return function() {\n            return k;\n        };\n    });\n    // output/Foreign.Object/index.js\n    var thawST = _copyST;\n    var mutate = function(f2) {\n        return function(m) {\n            return runST(function __do2() {\n                var s = thawST(m)();\n                f2(s)();\n                return s;\n            });\n        };\n    };\n    var lookup3 = /* @__PURE__ */ function() {\n        return runFn4(_lookup)(Nothing.value)(Just.create);\n    }();\n    var insert3 = function(k) {\n        return function(v) {\n            return mutate(poke2(k)(v));\n        };\n    };\n    // output/Web.Event.EventTarget/foreign.js\n    function eventListener(fn) {\n        return function() {\n            return function(event) {\n                return fn(event)();\n            };\n        };\n    }\n    function addEventListener2(type) {\n        return function(listener) {\n            return function(useCapture) {\n                return function(target7) {\n                    return function() {\n                        return target7.addEventListener(type, listener, useCapture);\n                    };\n                };\n            };\n        };\n    }\n    function removeEventListener2(type) {\n        return function(listener) {\n            return function(useCapture) {\n                return function(target7) {\n                    return function() {\n                        return target7.removeEventListener(type, listener, useCapture);\n                    };\n                };\n            };\n        };\n    }\n    // output/Halogen.VDom.DOM.Prop/index.js\n    var $runtime_lazy5 = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var Created = /* @__PURE__ */ function() {\n        function Created2(value0) {\n            this.value0 = value0;\n        }\n        Created2.create = function(value0) {\n            return new Created2(value0);\n        };\n        return Created2;\n    }();\n    var Removed = /* @__PURE__ */ function() {\n        function Removed2(value0) {\n            this.value0 = value0;\n        }\n        Removed2.create = function(value0) {\n            return new Removed2(value0);\n        };\n        return Removed2;\n    }();\n    var Attribute = /* @__PURE__ */ function() {\n        function Attribute2(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        Attribute2.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new Attribute2(value0, value1, value22);\n                };\n            };\n        };\n        return Attribute2;\n    }();\n    var Property = /* @__PURE__ */ function() {\n        function Property2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Property2.create = function(value0) {\n            return function(value1) {\n                return new Property2(value0, value1);\n            };\n        };\n        return Property2;\n    }();\n    var Handler = /* @__PURE__ */ function() {\n        function Handler2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Handler2.create = function(value0) {\n            return function(value1) {\n                return new Handler2(value0, value1);\n            };\n        };\n        return Handler2;\n    }();\n    var Ref = /* @__PURE__ */ function() {\n        function Ref2(value0) {\n            this.value0 = value0;\n        }\n        Ref2.create = function(value0) {\n            return new Ref2(value0);\n        };\n        return Ref2;\n    }();\n    var unsafeGetProperty = unsafeGetAny;\n    var setProperty = unsafeSetAny;\n    var removeProperty = function(key, el) {\n        var v = hasAttribute(nullImpl, key, el);\n        if (v) return removeAttribute(nullImpl, key, el);\n        var v1 = typeOf(unsafeGetAny(key, el));\n        if (v1 === \"string\") return unsafeSetAny(key, \"\", el);\n        if (key === \"rowSpan\") return unsafeSetAny(key, 1, el);\n        if (key === \"colSpan\") return unsafeSetAny(key, 1, el);\n        return unsafeSetAny(key, jsUndefined, el);\n    };\n    var propToStrKey = function(v) {\n        if (v instanceof Attribute && v.value0 instanceof Just) return \"attr/\" + (v.value0.value0 + (\":\" + v.value1));\n        if (v instanceof Attribute) return \"attr/:\" + v.value1;\n        if (v instanceof Property) return \"prop/\" + v.value0;\n        if (v instanceof Handler) return \"handler/\" + v.value0;\n        if (v instanceof Ref) return \"ref\";\n        throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 182, column 16 - line 187, column 16): \" + [\n            v.constructor.name\n        ]);\n    };\n    var propFromString = unsafeCoerce2;\n    var propFromNumber = unsafeCoerce2;\n    var propFromBoolean = unsafeCoerce2;\n    var buildProp = function(emit) {\n        return function(el) {\n            var removeProp = function(prevEvents) {\n                return function(v, v1) {\n                    if (v1 instanceof Attribute) return removeAttribute(toNullable(v1.value0), v1.value1, el);\n                    if (v1 instanceof Property) return removeProperty(v1.value0, el);\n                    if (v1 instanceof Handler) {\n                        var handler3 = unsafeLookup(v1.value0, prevEvents);\n                        return removeEventListener(v1.value0, fst(handler3), el);\n                    }\n                    if (v1 instanceof Ref) return unit;\n                    throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 169, column 5 - line 179, column 18): \" + [\n                        v1.constructor.name\n                    ]);\n                };\n            };\n            var mbEmit = function(v) {\n                if (v instanceof Just) return emit(v.value0)();\n                return unit;\n            };\n            var haltProp = function(state3) {\n                var v = lookup3(\"ref\")(state3.props);\n                if (v instanceof Just && v.value0 instanceof Ref) return mbEmit(v.value0.value0(new Removed(el)));\n                return unit;\n            };\n            var diffProp = function(prevEvents, events) {\n                return function(v, v1, v11, v2) {\n                    if (v11 instanceof Attribute && v2 instanceof Attribute) {\n                        var $66 = v11.value2 === v2.value2;\n                        if ($66) return v2;\n                        setAttribute(toNullable(v2.value0), v2.value1, v2.value2, el);\n                        return v2;\n                    }\n                    if (v11 instanceof Property && v2 instanceof Property) {\n                        var v42 = refEq2(v11.value1, v2.value1);\n                        if (v42) return v2;\n                        if (v2.value0 === \"value\") {\n                            var elVal = unsafeGetProperty(\"value\", el);\n                            var $75 = refEq2(elVal, v2.value1);\n                            if ($75) return v2;\n                            setProperty(v2.value0, v2.value1, el);\n                            return v2;\n                        }\n                        setProperty(v2.value0, v2.value1, el);\n                        return v2;\n                    }\n                    if (v11 instanceof Handler && v2 instanceof Handler) {\n                        var handler3 = unsafeLookup(v2.value0, prevEvents);\n                        write(v2.value1)(snd(handler3))();\n                        pokeMutMap(v2.value0, handler3, events);\n                        return v2;\n                    }\n                    return v2;\n                };\n            };\n            var applyProp = function(events) {\n                return function(v, v1, v2) {\n                    if (v2 instanceof Attribute) {\n                        setAttribute(toNullable(v2.value0), v2.value1, v2.value2, el);\n                        return v2;\n                    }\n                    if (v2 instanceof Property) {\n                        setProperty(v2.value0, v2.value1, el);\n                        return v2;\n                    }\n                    if (v2 instanceof Handler) {\n                        var v3 = unsafeGetAny(v2.value0, events);\n                        if (unsafeHasAny(v2.value0, events)) {\n                            write(v2.value1)(snd(v3))();\n                            return v2;\n                        }\n                        var ref3 = $$new(v2.value1)();\n                        var listener = eventListener(function(ev) {\n                            return function __do2() {\n                                var f$prime = read(ref3)();\n                                return mbEmit(f$prime(ev));\n                            };\n                        })();\n                        pokeMutMap(v2.value0, new Tuple(listener, ref3), events);\n                        addEventListener(v2.value0, listener, el);\n                        return v2;\n                    }\n                    if (v2 instanceof Ref) {\n                        mbEmit(v2.value0(new Created(el)));\n                        return v2;\n                    }\n                    throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 113, column 5 - line 135, column 15): \" + [\n                        v2.constructor.name\n                    ]);\n                };\n            };\n            var $lazy_patchProp = $runtime_lazy5(\"patchProp\", \"Halogen.VDom.DOM.Prop\", function() {\n                return function(state3, ps2) {\n                    var events = newMutMap();\n                    var onThis = removeProp(state3.events);\n                    var onThese = diffProp(state3.events, events);\n                    var onThat = applyProp(events);\n                    var props = diffWithKeyAndIxE(state3.props, ps2, propToStrKey, onThese, onThis, onThat);\n                    var nextState = {\n                        events: unsafeFreeze2(events),\n                        props: props\n                    };\n                    return mkStep(new Step2(unit, nextState, $lazy_patchProp(100), haltProp));\n                };\n            });\n            var patchProp = $lazy_patchProp(87);\n            var renderProp = function(ps1) {\n                var events = newMutMap();\n                var ps1$prime = strMapWithIxE(ps1, propToStrKey, applyProp(events));\n                var state3 = {\n                    events: unsafeFreeze2(events),\n                    props: ps1$prime\n                };\n                return mkStep(new Step2(unit, state3, patchProp, haltProp));\n            };\n            return renderProp;\n        };\n    };\n    // output/Web.HTML.Common/index.js\n    var ClassName = function(x) {\n        return x;\n    };\n    // output/Halogen.HTML.Core/index.js\n    var HTML = function(x) {\n        return x;\n    };\n    var widget = function($28) {\n        return HTML(Widget.create($28));\n    };\n    var toPropValue = function(dict) {\n        return dict.toPropValue;\n    };\n    var text = function($29) {\n        return HTML(Text.create($29));\n    };\n    var ref = function(f2) {\n        return new Ref(function($30) {\n            return f2(function(v) {\n                if (v instanceof Created) return new Just(v.value0);\n                if (v instanceof Removed) return Nothing.value;\n                throw new Error(\"Failed pattern match at Halogen.HTML.Core (line 109, column 21 - line 111, column 23): \" + [\n                    v.constructor.name\n                ]);\n            }($30));\n        });\n    };\n    var prop = function(dictIsProp) {\n        var toPropValue1 = toPropValue(dictIsProp);\n        return function(v) {\n            var $31 = Property.create(v);\n            return function($32) {\n                return $31(toPropValue1($32));\n            };\n        };\n    };\n    var isPropString = {\n        toPropValue: propFromString\n    };\n    var isPropStepValue = {\n        toPropValue: function($36) {\n            return propFromString(renderStepValue($36));\n        }\n    };\n    var isPropNumber = {\n        toPropValue: propFromNumber\n    };\n    var isPropInputType = {\n        toPropValue: function($45) {\n            return propFromString(renderInputType($45));\n        }\n    };\n    var isPropBoolean = {\n        toPropValue: propFromBoolean\n    };\n    var handler = /* @__PURE__ */ function() {\n        return Handler.create;\n    }();\n    var element = function(ns) {\n        return function(name15) {\n            return function(props) {\n                return function(children2) {\n                    return new Elem(ns, name15, props, children2);\n                };\n            };\n        };\n    };\n    // output/Control.Applicative.Free/index.js\n    var identity9 = /* @__PURE__ */ identity(categoryFn);\n    var Pure = /* @__PURE__ */ function() {\n        function Pure2(value0) {\n            this.value0 = value0;\n        }\n        Pure2.create = function(value0) {\n            return new Pure2(value0);\n        };\n        return Pure2;\n    }();\n    var Lift = /* @__PURE__ */ function() {\n        function Lift3(value0) {\n            this.value0 = value0;\n        }\n        Lift3.create = function(value0) {\n            return new Lift3(value0);\n        };\n        return Lift3;\n    }();\n    var Ap = /* @__PURE__ */ function() {\n        function Ap2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Ap2.create = function(value0) {\n            return function(value1) {\n                return new Ap2(value0, value1);\n            };\n        };\n        return Ap2;\n    }();\n    var mkAp = function(fba) {\n        return function(fb) {\n            return new Ap(fba, fb);\n        };\n    };\n    var liftFreeAp = /* @__PURE__ */ function() {\n        return Lift.create;\n    }();\n    var goLeft = function(dictApplicative) {\n        var pure18 = pure(dictApplicative);\n        return function(fStack) {\n            return function(valStack) {\n                return function(nat) {\n                    return function(func) {\n                        return function(count) {\n                            if (func instanceof Pure) return new Tuple(new Cons({\n                                func: pure18(func.value0),\n                                count: count\n                            }, fStack), valStack);\n                            if (func instanceof Lift) return new Tuple(new Cons({\n                                func: nat(func.value0),\n                                count: count\n                            }, fStack), valStack);\n                            if (func instanceof Ap) return goLeft(dictApplicative)(fStack)(cons(func.value1)(valStack))(nat)(func.value0)(count + 1 | 0);\n                            throw new Error(\"Failed pattern match at Control.Applicative.Free (line 102, column 41 - line 105, column 81): \" + [\n                                func.constructor.name\n                            ]);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var goApply = function(dictApplicative) {\n        var apply4 = apply(dictApplicative.Apply0());\n        return function(fStack) {\n            return function(vals) {\n                return function(gVal) {\n                    if (fStack instanceof Nil) return new Left(gVal);\n                    if (fStack instanceof Cons) {\n                        var gRes = apply4(fStack.value0.func)(gVal);\n                        var $31 = fStack.value0.count === 1;\n                        if ($31) {\n                            if (fStack.value1 instanceof Nil) return new Left(gRes);\n                            return goApply(dictApplicative)(fStack.value1)(vals)(gRes);\n                        }\n                        if (vals instanceof Nil) return new Left(gRes);\n                        if (vals instanceof Cons) return new Right(new Tuple(new Cons({\n                            func: gRes,\n                            count: fStack.value0.count - 1 | 0\n                        }, fStack.value1), new NonEmpty(vals.value0, vals.value1)));\n                        throw new Error(\"Failed pattern match at Control.Applicative.Free (line 83, column 11 - line 88, column 50): \" + [\n                            vals.constructor.name\n                        ]);\n                    }\n                    throw new Error(\"Failed pattern match at Control.Applicative.Free (line 72, column 3 - line 88, column 50): \" + [\n                        fStack.constructor.name\n                    ]);\n                };\n            };\n        };\n    };\n    var functorFreeAp = {\n        map: function(f2) {\n            return function(x) {\n                return mkAp(new Pure(f2))(x);\n            };\n        }\n    };\n    var foldFreeAp = function(dictApplicative) {\n        var goApply1 = goApply(dictApplicative);\n        var pure18 = pure(dictApplicative);\n        var goLeft1 = goLeft(dictApplicative);\n        return function(nat) {\n            return function(z) {\n                var go2 = function($copy_v) {\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(v) {\n                        if (v.value1.value0 instanceof Pure) {\n                            var v1 = goApply1(v.value0)(v.value1.value1)(pure18(v.value1.value0.value0));\n                            if (v1 instanceof Left) {\n                                $tco_done = true;\n                                return v1.value0;\n                            }\n                            if (v1 instanceof Right) {\n                                $copy_v = v1.value0;\n                                return;\n                            }\n                            throw new Error(\"Failed pattern match at Control.Applicative.Free (line 54, column 17 - line 56, column 24): \" + [\n                                v1.constructor.name\n                            ]);\n                        }\n                        if (v.value1.value0 instanceof Lift) {\n                            var v1 = goApply1(v.value0)(v.value1.value1)(nat(v.value1.value0.value0));\n                            if (v1 instanceof Left) {\n                                $tco_done = true;\n                                return v1.value0;\n                            }\n                            if (v1 instanceof Right) {\n                                $copy_v = v1.value0;\n                                return;\n                            }\n                            throw new Error(\"Failed pattern match at Control.Applicative.Free (line 57, column 17 - line 59, column 24): \" + [\n                                v1.constructor.name\n                            ]);\n                        }\n                        if (v.value1.value0 instanceof Ap) {\n                            var nextVals = new NonEmpty(v.value1.value0.value1, v.value1.value1);\n                            $copy_v = goLeft1(v.value0)(nextVals)(nat)(v.value1.value0.value0)(1);\n                            return;\n                        }\n                        throw new Error(\"Failed pattern match at Control.Applicative.Free (line 53, column 5 - line 62, column 47): \" + [\n                            v.value1.value0.constructor.name\n                        ]);\n                    }\n                    while(!$tco_done)$tco_result = $tco_loop($copy_v);\n                    return $tco_result;\n                };\n                return go2(new Tuple(Nil.value, singleton5(z)));\n            };\n        };\n    };\n    var retractFreeAp = function(dictApplicative) {\n        return foldFreeAp(dictApplicative)(identity9);\n    };\n    var applyFreeAp = {\n        apply: function(fba) {\n            return function(fb) {\n                return mkAp(fba)(fb);\n            };\n        },\n        Functor0: function() {\n            return functorFreeAp;\n        }\n    };\n    var applicativeFreeAp = /* @__PURE__ */ function() {\n        return {\n            pure: Pure.create,\n            Apply0: function() {\n                return applyFreeAp;\n            }\n        };\n    }();\n    var foldFreeAp1 = /* @__PURE__ */ foldFreeAp(applicativeFreeAp);\n    var hoistFreeAp = function(f2) {\n        return foldFreeAp1(function($54) {\n            return liftFreeAp(f2($54));\n        });\n    };\n    // output/Data.CatQueue/index.js\n    var CatQueue = /* @__PURE__ */ function() {\n        function CatQueue2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        CatQueue2.create = function(value0) {\n            return function(value1) {\n                return new CatQueue2(value0, value1);\n            };\n        };\n        return CatQueue2;\n    }();\n    var uncons2 = function($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v.value0 instanceof Nil && v.value1 instanceof Nil) {\n                $tco_done = true;\n                return Nothing.value;\n            }\n            if (v.value0 instanceof Nil) {\n                $copy_v = new CatQueue(reverse2(v.value1), Nil.value);\n                return;\n            }\n            if (v.value0 instanceof Cons) {\n                $tco_done = true;\n                return new Just(new Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));\n            }\n            throw new Error(\"Failed pattern match at Data.CatQueue (line 82, column 1 - line 82, column 63): \" + [\n                v.constructor.name\n            ]);\n        }\n        while(!$tco_done)$tco_result = $tco_loop($copy_v);\n        return $tco_result;\n    };\n    var snoc3 = function(v) {\n        return function(a2) {\n            return new CatQueue(v.value0, new Cons(a2, v.value1));\n        };\n    };\n    var $$null4 = function(v) {\n        if (v.value0 instanceof Nil && v.value1 instanceof Nil) return true;\n        return false;\n    };\n    var empty5 = /* @__PURE__ */ function() {\n        return new CatQueue(Nil.value, Nil.value);\n    }();\n    // output/Data.CatList/index.js\n    var CatNil = /* @__PURE__ */ function() {\n        function CatNil2() {}\n        CatNil2.value = new CatNil2();\n        return CatNil2;\n    }();\n    var CatCons = /* @__PURE__ */ function() {\n        function CatCons2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        CatCons2.create = function(value0) {\n            return function(value1) {\n                return new CatCons2(value0, value1);\n            };\n        };\n        return CatCons2;\n    }();\n    var link = function(v) {\n        return function(v1) {\n            if (v instanceof CatNil) return v1;\n            if (v1 instanceof CatNil) return v;\n            if (v instanceof CatCons) return new CatCons(v.value0, snoc3(v.value1)(v1));\n            throw new Error(\"Failed pattern match at Data.CatList (line 108, column 1 - line 108, column 54): \" + [\n                v.constructor.name,\n                v1.constructor.name\n            ]);\n        };\n    };\n    var foldr4 = function(k) {\n        return function(b2) {\n            return function(q2) {\n                var foldl2 = function($copy_v) {\n                    return function($copy_v1) {\n                        return function($copy_v2) {\n                            var $tco_var_v = $copy_v;\n                            var $tco_var_v1 = $copy_v1;\n                            var $tco_done = false;\n                            var $tco_result;\n                            function $tco_loop(v, v1, v2) {\n                                if (v2 instanceof Nil) {\n                                    $tco_done = true;\n                                    return v1;\n                                }\n                                if (v2 instanceof Cons) {\n                                    $tco_var_v = v;\n                                    $tco_var_v1 = v(v1)(v2.value0);\n                                    $copy_v2 = v2.value1;\n                                    return;\n                                }\n                                throw new Error(\"Failed pattern match at Data.CatList (line 124, column 3 - line 124, column 59): \" + [\n                                    v.constructor.name,\n                                    v1.constructor.name,\n                                    v2.constructor.name\n                                ]);\n                            }\n                            while(!$tco_done)$tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);\n                            return $tco_result;\n                        };\n                    };\n                };\n                var go2 = function($copy_xs) {\n                    return function($copy_ys) {\n                        var $tco_var_xs = $copy_xs;\n                        var $tco_done1 = false;\n                        var $tco_result;\n                        function $tco_loop(xs, ys) {\n                            var v = uncons2(xs);\n                            if (v instanceof Nothing) {\n                                $tco_done1 = true;\n                                return foldl2(function(x) {\n                                    return function(i2) {\n                                        return i2(x);\n                                    };\n                                })(b2)(ys);\n                            }\n                            if (v instanceof Just) {\n                                $tco_var_xs = v.value0.value1;\n                                $copy_ys = new Cons(k(v.value0.value0), ys);\n                                return;\n                            }\n                            throw new Error(\"Failed pattern match at Data.CatList (line 120, column 14 - line 122, column 67): \" + [\n                                v.constructor.name\n                            ]);\n                        }\n                        while(!$tco_done1)$tco_result = $tco_loop($tco_var_xs, $copy_ys);\n                        return $tco_result;\n                    };\n                };\n                return go2(q2)(Nil.value);\n            };\n        };\n    };\n    var uncons3 = function(v) {\n        if (v instanceof CatNil) return Nothing.value;\n        if (v instanceof CatCons) return new Just(new Tuple(v.value0, function() {\n            var $66 = $$null4(v.value1);\n            if ($66) return CatNil.value;\n            return foldr4(link)(CatNil.value)(v.value1);\n        }()));\n        throw new Error(\"Failed pattern match at Data.CatList (line 99, column 1 - line 99, column 61): \" + [\n            v.constructor.name\n        ]);\n    };\n    var empty6 = /* @__PURE__ */ function() {\n        return CatNil.value;\n    }();\n    var append2 = link;\n    var semigroupCatList = {\n        append: append2\n    };\n    var snoc4 = function(cat) {\n        return function(a2) {\n            return append2(cat)(new CatCons(a2, empty5));\n        };\n    };\n    // output/Control.Monad.Free/index.js\n    var $runtime_lazy6 = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var append3 = /* @__PURE__ */ append(semigroupCatList);\n    var Free = /* @__PURE__ */ function() {\n        function Free2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Free2.create = function(value0) {\n            return function(value1) {\n                return new Free2(value0, value1);\n            };\n        };\n        return Free2;\n    }();\n    var Return = /* @__PURE__ */ function() {\n        function Return2(value0) {\n            this.value0 = value0;\n        }\n        Return2.create = function(value0) {\n            return new Return2(value0);\n        };\n        return Return2;\n    }();\n    var Bind = /* @__PURE__ */ function() {\n        function Bind2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Bind2.create = function(value0) {\n            return function(value1) {\n                return new Bind2(value0, value1);\n            };\n        };\n        return Bind2;\n    }();\n    var toView = function($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            var runExpF = function(v22) {\n                return v22;\n            };\n            var concatF = function(v22) {\n                return function(r) {\n                    return new Free(v22.value0, append3(v22.value1)(r));\n                };\n            };\n            if (v.value0 instanceof Return) {\n                var v2 = uncons3(v.value1);\n                if (v2 instanceof Nothing) {\n                    $tco_done = true;\n                    return new Return(v.value0.value0);\n                }\n                if (v2 instanceof Just) {\n                    $copy_v = concatF(runExpF(v2.value0.value0)(v.value0.value0))(v2.value0.value1);\n                    return;\n                }\n                throw new Error(\"Failed pattern match at Control.Monad.Free (line 227, column 7 - line 231, column 64): \" + [\n                    v2.constructor.name\n                ]);\n            }\n            if (v.value0 instanceof Bind) {\n                $tco_done = true;\n                return new Bind(v.value0.value0, function(a2) {\n                    return concatF(v.value0.value1(a2))(v.value1);\n                });\n            }\n            throw new Error(\"Failed pattern match at Control.Monad.Free (line 225, column 3 - line 233, column 56): \" + [\n                v.value0.constructor.name\n            ]);\n        }\n        while(!$tco_done)$tco_result = $tco_loop($copy_v);\n        return $tco_result;\n    };\n    var fromView = function(f2) {\n        return new Free(f2, empty6);\n    };\n    var freeMonad = {\n        Applicative0: function() {\n            return freeApplicative;\n        },\n        Bind1: function() {\n            return freeBind;\n        }\n    };\n    var freeFunctor = {\n        map: function(k) {\n            return function(f2) {\n                return bindFlipped(freeBind)(function() {\n                    var $189 = pure(freeApplicative);\n                    return function($190) {\n                        return $189(k($190));\n                    };\n                }())(f2);\n            };\n        }\n    };\n    var freeBind = {\n        bind: function(v) {\n            return function(k) {\n                return new Free(v.value0, snoc4(v.value1)(k));\n            };\n        },\n        Apply0: function() {\n            return $lazy_freeApply(0);\n        }\n    };\n    var freeApplicative = {\n        pure: function($191) {\n            return fromView(Return.create($191));\n        },\n        Apply0: function() {\n            return $lazy_freeApply(0);\n        }\n    };\n    var $lazy_freeApply = /* @__PURE__ */ $runtime_lazy6(\"freeApply\", \"Control.Monad.Free\", function() {\n        return {\n            apply: ap(freeMonad),\n            Functor0: function() {\n                return freeFunctor;\n            }\n        };\n    });\n    var freeApply = /* @__PURE__ */ $lazy_freeApply(77);\n    var lift22 = /* @__PURE__ */ lift2(freeApply);\n    var pure2 = /* @__PURE__ */ pure(freeApplicative);\n    var semigroupFree = function(dictSemigroup) {\n        return {\n            append: lift22(append(dictSemigroup))\n        };\n    };\n    var liftF = function(f2) {\n        return fromView(new Bind(f2, function($192) {\n            return pure2($192);\n        }));\n    };\n    var monoidFree = function(dictMonoid) {\n        var semigroupFree1 = semigroupFree(dictMonoid.Semigroup0());\n        return {\n            mempty: pure2(mempty(dictMonoid)),\n            Semigroup0: function() {\n                return semigroupFree1;\n            }\n        };\n    };\n    var foldFree = function(dictMonadRec) {\n        var Monad0 = dictMonadRec.Monad0();\n        var map112 = map(Monad0.Bind1().Apply0().Functor0());\n        var pure18 = pure(Monad0.Applicative0());\n        var tailRecM4 = tailRecM(dictMonadRec);\n        return function(k) {\n            var go2 = function(f2) {\n                var v = toView(f2);\n                if (v instanceof Return) return map112(Done.create)(pure18(v.value0));\n                if (v instanceof Bind) return map112(function($199) {\n                    return Loop.create(v.value1($199));\n                })(k(v.value0));\n                throw new Error(\"Failed pattern match at Control.Monad.Free (line 158, column 10 - line 160, column 37): \" + [\n                    v.constructor.name\n                ]);\n            };\n            return tailRecM4(go2);\n        };\n    };\n    // output/Effect.Aff/foreign.js\n    var Aff = function() {\n        var EMPTY = {};\n        var PURE = \"Pure\";\n        var THROW = \"Throw\";\n        var CATCH = \"Catch\";\n        var SYNC = \"Sync\";\n        var ASYNC = \"Async\";\n        var BIND = \"Bind\";\n        var BRACKET = \"Bracket\";\n        var FORK = \"Fork\";\n        var SEQ = \"Sequential\";\n        var MAP = \"Map\";\n        var APPLY = \"Apply\";\n        var ALT = \"Alt\";\n        var CONS = \"Cons\";\n        var RESUME = \"Resume\";\n        var RELEASE = \"Release\";\n        var FINALIZER = \"Finalizer\";\n        var FINALIZED = \"Finalized\";\n        var FORKED = \"Forked\";\n        var FIBER = \"Fiber\";\n        var THUNK = \"Thunk\";\n        function Aff2(tag, _1, _2, _3) {\n            this.tag = tag;\n            this._1 = _1;\n            this._2 = _2;\n            this._3 = _3;\n        }\n        function AffCtr(tag) {\n            var fn = function(_1, _2, _3) {\n                return new Aff2(tag, _1, _2, _3);\n            };\n            fn.tag = tag;\n            return fn;\n        }\n        function nonCanceler2(error6) {\n            return new Aff2(PURE, void 0);\n        }\n        function runEff(eff) {\n            try {\n                eff();\n            } catch (error6) {\n                setTimeout(function() {\n                    throw error6;\n                }, 0);\n            }\n        }\n        function runSync(left, right, eff) {\n            try {\n                return right(eff());\n            } catch (error6) {\n                return left(error6);\n            }\n        }\n        function runAsync(left, eff, k) {\n            try {\n                return eff(k)();\n            } catch (error6) {\n                k(left(error6))();\n                return nonCanceler2;\n            }\n        }\n        var Scheduler = function() {\n            var limit = 1024;\n            var size5 = 0;\n            var ix = 0;\n            var queue = new Array(limit);\n            var draining = false;\n            function drain() {\n                var thunk;\n                draining = true;\n                while(size5 !== 0){\n                    size5--;\n                    thunk = queue[ix];\n                    queue[ix] = void 0;\n                    ix = (ix + 1) % limit;\n                    thunk();\n                }\n                draining = false;\n            }\n            return {\n                isDraining: function() {\n                    return draining;\n                },\n                enqueue: function(cb) {\n                    var i2, tmp;\n                    if (size5 === limit) {\n                        tmp = draining;\n                        drain();\n                        draining = tmp;\n                    }\n                    queue[(ix + size5) % limit] = cb;\n                    size5++;\n                    if (!draining) drain();\n                }\n            };\n        }();\n        function Supervisor(util) {\n            var fibers = {};\n            var fiberId = 0;\n            var count = 0;\n            return {\n                register: function(fiber) {\n                    var fid = fiberId++;\n                    fiber.onComplete({\n                        rethrow: true,\n                        handler: function(result) {\n                            return function() {\n                                count--;\n                                delete fibers[fid];\n                            };\n                        }\n                    })();\n                    fibers[fid] = fiber;\n                    count++;\n                },\n                isEmpty: function() {\n                    return count === 0;\n                },\n                killAll: function(killError, cb) {\n                    return function() {\n                        if (count === 0) return cb();\n                        var killCount = 0;\n                        var kills = {};\n                        function kill2(fid) {\n                            kills[fid] = fibers[fid].kill(killError, function(result) {\n                                return function() {\n                                    delete kills[fid];\n                                    killCount--;\n                                    if (util.isLeft(result) && util.fromLeft(result)) setTimeout(function() {\n                                        throw util.fromLeft(result);\n                                    }, 0);\n                                    if (killCount === 0) cb();\n                                };\n                            })();\n                        }\n                        for(var k in fibers)if (fibers.hasOwnProperty(k)) {\n                            killCount++;\n                            kill2(k);\n                        }\n                        fibers = {};\n                        fiberId = 0;\n                        count = 0;\n                        return function(error6) {\n                            return new Aff2(SYNC, function() {\n                                for(var k2 in kills)if (kills.hasOwnProperty(k2)) kills[k2]();\n                            });\n                        };\n                    };\n                }\n            };\n        }\n        var SUSPENDED = 0;\n        var CONTINUE = 1;\n        var STEP_BIND = 2;\n        var STEP_RESULT = 3;\n        var PENDING = 4;\n        var RETURN = 5;\n        var COMPLETED = 6;\n        function Fiber(util, supervisor, aff) {\n            var runTick = 0;\n            var status = SUSPENDED;\n            var step4 = aff;\n            var fail2 = null;\n            var interrupt = null;\n            var bhead = null;\n            var btail = null;\n            var attempts = null;\n            var bracketCount = 0;\n            var joinId = 0;\n            var joins = null;\n            var rethrow = true;\n            function run4(localRunTick) {\n                var tmp, result, attempt2;\n                while(true){\n                    tmp = null;\n                    result = null;\n                    attempt2 = null;\n                    switch(status){\n                        case STEP_BIND:\n                            status = CONTINUE;\n                            try {\n                                step4 = bhead(step4);\n                                if (btail === null) bhead = null;\n                                else {\n                                    bhead = btail._1;\n                                    btail = btail._2;\n                                }\n                            } catch (e) {\n                                status = RETURN;\n                                fail2 = util.left(e);\n                                step4 = null;\n                            }\n                            break;\n                        case STEP_RESULT:\n                            if (util.isLeft(step4)) {\n                                status = RETURN;\n                                fail2 = step4;\n                                step4 = null;\n                            } else if (bhead === null) status = RETURN;\n                            else {\n                                status = STEP_BIND;\n                                step4 = util.fromRight(step4);\n                            }\n                            break;\n                        case CONTINUE:\n                            switch(step4.tag){\n                                case BIND:\n                                    if (bhead) btail = new Aff2(CONS, bhead, btail);\n                                    bhead = step4._2;\n                                    status = CONTINUE;\n                                    step4 = step4._1;\n                                    break;\n                                case PURE:\n                                    if (bhead === null) {\n                                        status = RETURN;\n                                        step4 = util.right(step4._1);\n                                    } else {\n                                        status = STEP_BIND;\n                                        step4 = step4._1;\n                                    }\n                                    break;\n                                case SYNC:\n                                    status = STEP_RESULT;\n                                    step4 = runSync(util.left, util.right, step4._1);\n                                    break;\n                                case ASYNC:\n                                    status = PENDING;\n                                    step4 = runAsync(util.left, step4._1, function(result2) {\n                                        return function() {\n                                            if (runTick !== localRunTick) return;\n                                            runTick++;\n                                            Scheduler.enqueue(function() {\n                                                if (runTick !== localRunTick + 1) return;\n                                                status = STEP_RESULT;\n                                                step4 = result2;\n                                                run4(runTick);\n                                            });\n                                        };\n                                    });\n                                    return;\n                                case THROW:\n                                    status = RETURN;\n                                    fail2 = util.left(step4._1);\n                                    step4 = null;\n                                    break;\n                                case CATCH:\n                                    if (bhead === null) attempts = new Aff2(CONS, step4, attempts, interrupt);\n                                    else attempts = new Aff2(CONS, step4, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);\n                                    bhead = null;\n                                    btail = null;\n                                    status = CONTINUE;\n                                    step4 = step4._1;\n                                    break;\n                                case BRACKET:\n                                    bracketCount++;\n                                    if (bhead === null) attempts = new Aff2(CONS, step4, attempts, interrupt);\n                                    else attempts = new Aff2(CONS, step4, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);\n                                    bhead = null;\n                                    btail = null;\n                                    status = CONTINUE;\n                                    step4 = step4._1;\n                                    break;\n                                case FORK:\n                                    status = STEP_RESULT;\n                                    tmp = Fiber(util, supervisor, step4._2);\n                                    if (supervisor) supervisor.register(tmp);\n                                    if (step4._1) tmp.run();\n                                    step4 = util.right(tmp);\n                                    break;\n                                case SEQ:\n                                    status = CONTINUE;\n                                    step4 = sequential3(util, supervisor, step4._1);\n                                    break;\n                            }\n                            break;\n                        case RETURN:\n                            bhead = null;\n                            btail = null;\n                            if (attempts === null) {\n                                status = COMPLETED;\n                                step4 = interrupt || fail2 || step4;\n                            } else {\n                                tmp = attempts._3;\n                                attempt2 = attempts._1;\n                                attempts = attempts._2;\n                                switch(attempt2.tag){\n                                    case CATCH:\n                                        if (interrupt && interrupt !== tmp && bracketCount === 0) status = RETURN;\n                                        else if (fail2) {\n                                            status = CONTINUE;\n                                            step4 = attempt2._2(util.fromLeft(fail2));\n                                            fail2 = null;\n                                        }\n                                        break;\n                                    case RESUME:\n                                        if (interrupt && interrupt !== tmp && bracketCount === 0 || fail2) status = RETURN;\n                                        else {\n                                            bhead = attempt2._1;\n                                            btail = attempt2._2;\n                                            status = STEP_BIND;\n                                            step4 = util.fromRight(step4);\n                                        }\n                                        break;\n                                    case BRACKET:\n                                        bracketCount--;\n                                        if (fail2 === null) {\n                                            result = util.fromRight(step4);\n                                            attempts = new Aff2(CONS, new Aff2(RELEASE, attempt2._2, result), attempts, tmp);\n                                            if (interrupt === tmp || bracketCount > 0) {\n                                                status = CONTINUE;\n                                                step4 = attempt2._3(result);\n                                            }\n                                        }\n                                        break;\n                                    case RELEASE:\n                                        attempts = new Aff2(CONS, new Aff2(FINALIZED, step4, fail2), attempts, interrupt);\n                                        status = CONTINUE;\n                                        if (interrupt && interrupt !== tmp && bracketCount === 0) step4 = attempt2._1.killed(util.fromLeft(interrupt))(attempt2._2);\n                                        else if (fail2) step4 = attempt2._1.failed(util.fromLeft(fail2))(attempt2._2);\n                                        else step4 = attempt2._1.completed(util.fromRight(step4))(attempt2._2);\n                                        fail2 = null;\n                                        bracketCount++;\n                                        break;\n                                    case FINALIZER:\n                                        bracketCount++;\n                                        attempts = new Aff2(CONS, new Aff2(FINALIZED, step4, fail2), attempts, interrupt);\n                                        status = CONTINUE;\n                                        step4 = attempt2._1;\n                                        break;\n                                    case FINALIZED:\n                                        bracketCount--;\n                                        status = RETURN;\n                                        step4 = attempt2._1;\n                                        fail2 = attempt2._2;\n                                        break;\n                                }\n                            }\n                            break;\n                        case COMPLETED:\n                            for(var k in joins)if (joins.hasOwnProperty(k)) {\n                                rethrow = rethrow && joins[k].rethrow;\n                                runEff(joins[k].handler(step4));\n                            }\n                            joins = null;\n                            if (interrupt && fail2) setTimeout(function() {\n                                throw util.fromLeft(fail2);\n                            }, 0);\n                            else if (util.isLeft(step4) && rethrow) setTimeout(function() {\n                                if (rethrow) throw util.fromLeft(step4);\n                            }, 0);\n                            return;\n                        case SUSPENDED:\n                            status = CONTINUE;\n                            break;\n                        case PENDING:\n                            return;\n                    }\n                }\n            }\n            function onComplete(join5) {\n                return function() {\n                    if (status === COMPLETED) {\n                        rethrow = rethrow && join5.rethrow;\n                        join5.handler(step4)();\n                        return function() {};\n                    }\n                    var jid = joinId++;\n                    joins = joins || {};\n                    joins[jid] = join5;\n                    return function() {\n                        if (joins !== null) delete joins[jid];\n                    };\n                };\n            }\n            function kill2(error6, cb) {\n                return function() {\n                    if (status === COMPLETED) {\n                        cb(util.right(void 0))();\n                        return function() {};\n                    }\n                    var canceler = onComplete({\n                        rethrow: false,\n                        handler: function() {\n                            return cb(util.right(void 0));\n                        }\n                    })();\n                    switch(status){\n                        case SUSPENDED:\n                            interrupt = util.left(error6);\n                            status = COMPLETED;\n                            step4 = interrupt;\n                            run4(runTick);\n                            break;\n                        case PENDING:\n                            if (interrupt === null) interrupt = util.left(error6);\n                            if (bracketCount === 0) {\n                                if (status === PENDING) attempts = new Aff2(CONS, new Aff2(FINALIZER, step4(error6)), attempts, interrupt);\n                                status = RETURN;\n                                step4 = null;\n                                fail2 = null;\n                                run4(++runTick);\n                            }\n                            break;\n                        default:\n                            if (interrupt === null) interrupt = util.left(error6);\n                            if (bracketCount === 0) {\n                                status = RETURN;\n                                step4 = null;\n                                fail2 = null;\n                            }\n                    }\n                    return canceler;\n                };\n            }\n            function join4(cb) {\n                return function() {\n                    var canceler = onComplete({\n                        rethrow: false,\n                        handler: cb\n                    })();\n                    if (status === SUSPENDED) run4(runTick);\n                    return canceler;\n                };\n            }\n            return {\n                kill: kill2,\n                join: join4,\n                onComplete: onComplete,\n                isSuspended: function() {\n                    return status === SUSPENDED;\n                },\n                run: function() {\n                    if (status === SUSPENDED) {\n                        if (!Scheduler.isDraining()) Scheduler.enqueue(function() {\n                            run4(runTick);\n                        });\n                        else run4(runTick);\n                    }\n                }\n            };\n        }\n        function runPar(util, supervisor, par, cb) {\n            var fiberId = 0;\n            var fibers = {};\n            var killId = 0;\n            var kills = {};\n            var early = new Error(\"[ParAff] Early exit\");\n            var interrupt = null;\n            var root = EMPTY;\n            function kill2(error6, par2, cb2) {\n                var step4 = par2;\n                var head4 = null;\n                var tail2 = null;\n                var count = 0;\n                var kills2 = {};\n                var tmp, kid;\n                loop: while(true){\n                    tmp = null;\n                    switch(step4.tag){\n                        case FORKED:\n                            if (step4._3 === EMPTY) {\n                                tmp = fibers[step4._1];\n                                kills2[count++] = tmp.kill(error6, function(result) {\n                                    return function() {\n                                        count--;\n                                        if (count === 0) cb2(result)();\n                                    };\n                                });\n                            }\n                            if (head4 === null) break loop;\n                            step4 = head4._2;\n                            if (tail2 === null) head4 = null;\n                            else {\n                                head4 = tail2._1;\n                                tail2 = tail2._2;\n                            }\n                            break;\n                        case MAP:\n                            step4 = step4._2;\n                            break;\n                        case APPLY:\n                        case ALT:\n                            if (head4) tail2 = new Aff2(CONS, head4, tail2);\n                            head4 = step4;\n                            step4 = step4._1;\n                            break;\n                    }\n                }\n                if (count === 0) cb2(util.right(void 0))();\n                else {\n                    kid = 0;\n                    tmp = count;\n                    for(; kid < tmp; kid++)kills2[kid] = kills2[kid]();\n                }\n                return kills2;\n            }\n            function join4(result, head4, tail2) {\n                var fail2, step4, lhs, rhs, tmp, kid;\n                if (util.isLeft(result)) {\n                    fail2 = result;\n                    step4 = null;\n                } else {\n                    step4 = result;\n                    fail2 = null;\n                }\n                loop: while(true){\n                    lhs = null;\n                    rhs = null;\n                    tmp = null;\n                    kid = null;\n                    if (interrupt !== null) return;\n                    if (head4 === null) {\n                        cb(fail2 || step4)();\n                        return;\n                    }\n                    if (head4._3 !== EMPTY) return;\n                    switch(head4.tag){\n                        case MAP:\n                            if (fail2 === null) {\n                                head4._3 = util.right(head4._1(util.fromRight(step4)));\n                                step4 = head4._3;\n                            } else head4._3 = fail2;\n                            break;\n                        case APPLY:\n                            lhs = head4._1._3;\n                            rhs = head4._2._3;\n                            if (fail2) {\n                                head4._3 = fail2;\n                                tmp = true;\n                                kid = killId++;\n                                kills[kid] = kill2(early, fail2 === lhs ? head4._2 : head4._1, function() {\n                                    return function() {\n                                        delete kills[kid];\n                                        if (tmp) tmp = false;\n                                        else if (tail2 === null) join4(fail2, null, null);\n                                        else join4(fail2, tail2._1, tail2._2);\n                                    };\n                                });\n                                if (tmp) {\n                                    tmp = false;\n                                    return;\n                                }\n                            } else if (lhs === EMPTY || rhs === EMPTY) return;\n                            else {\n                                step4 = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n                                head4._3 = step4;\n                            }\n                            break;\n                        case ALT:\n                            lhs = head4._1._3;\n                            rhs = head4._2._3;\n                            if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) return;\n                            if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n                                fail2 = step4 === lhs ? rhs : lhs;\n                                step4 = null;\n                                head4._3 = fail2;\n                            } else {\n                                head4._3 = step4;\n                                tmp = true;\n                                kid = killId++;\n                                kills[kid] = kill2(early, step4 === lhs ? head4._2 : head4._1, function() {\n                                    return function() {\n                                        delete kills[kid];\n                                        if (tmp) tmp = false;\n                                        else if (tail2 === null) join4(step4, null, null);\n                                        else join4(step4, tail2._1, tail2._2);\n                                    };\n                                });\n                                if (tmp) {\n                                    tmp = false;\n                                    return;\n                                }\n                            }\n                            break;\n                    }\n                    if (tail2 === null) head4 = null;\n                    else {\n                        head4 = tail2._1;\n                        tail2 = tail2._2;\n                    }\n                }\n            }\n            function resolve(fiber) {\n                return function(result) {\n                    return function() {\n                        delete fibers[fiber._1];\n                        fiber._3 = result;\n                        join4(result, fiber._2._1, fiber._2._2);\n                    };\n                };\n            }\n            function run4() {\n                var status = CONTINUE;\n                var step4 = par;\n                var head4 = null;\n                var tail2 = null;\n                var tmp, fid;\n                loop: while(true){\n                    tmp = null;\n                    fid = null;\n                    switch(status){\n                        case CONTINUE:\n                            switch(step4.tag){\n                                case MAP:\n                                    if (head4) tail2 = new Aff2(CONS, head4, tail2);\n                                    head4 = new Aff2(MAP, step4._1, EMPTY, EMPTY);\n                                    step4 = step4._2;\n                                    break;\n                                case APPLY:\n                                    if (head4) tail2 = new Aff2(CONS, head4, tail2);\n                                    head4 = new Aff2(APPLY, EMPTY, step4._2, EMPTY);\n                                    step4 = step4._1;\n                                    break;\n                                case ALT:\n                                    if (head4) tail2 = new Aff2(CONS, head4, tail2);\n                                    head4 = new Aff2(ALT, EMPTY, step4._2, EMPTY);\n                                    step4 = step4._1;\n                                    break;\n                                default:\n                                    fid = fiberId++;\n                                    status = RETURN;\n                                    tmp = step4;\n                                    step4 = new Aff2(FORKED, fid, new Aff2(CONS, head4, tail2), EMPTY);\n                                    tmp = Fiber(util, supervisor, tmp);\n                                    tmp.onComplete({\n                                        rethrow: false,\n                                        handler: resolve(step4)\n                                    })();\n                                    fibers[fid] = tmp;\n                                    if (supervisor) supervisor.register(tmp);\n                            }\n                            break;\n                        case RETURN:\n                            if (head4 === null) break loop;\n                            if (head4._1 === EMPTY) {\n                                head4._1 = step4;\n                                status = CONTINUE;\n                                step4 = head4._2;\n                                head4._2 = EMPTY;\n                            } else {\n                                head4._2 = step4;\n                                step4 = head4;\n                                if (tail2 === null) head4 = null;\n                                else {\n                                    head4 = tail2._1;\n                                    tail2 = tail2._2;\n                                }\n                            }\n                    }\n                }\n                root = step4;\n                for(fid = 0; fid < fiberId; fid++)fibers[fid].run();\n            }\n            function cancel(error6, cb2) {\n                interrupt = util.left(error6);\n                var innerKills;\n                for(var kid in kills)if (kills.hasOwnProperty(kid)) {\n                    innerKills = kills[kid];\n                    for(kid in innerKills)if (innerKills.hasOwnProperty(kid)) innerKills[kid]();\n                }\n                kills = null;\n                var newKills = kill2(error6, root, cb2);\n                return function(killError) {\n                    return new Aff2(ASYNC, function(killCb) {\n                        return function() {\n                            for(var kid2 in newKills)if (newKills.hasOwnProperty(kid2)) newKills[kid2]();\n                            return nonCanceler2;\n                        };\n                    });\n                };\n            }\n            run4();\n            return function(killError) {\n                return new Aff2(ASYNC, function(killCb) {\n                    return function() {\n                        return cancel(killError, killCb);\n                    };\n                });\n            };\n        }\n        function sequential3(util, supervisor, par) {\n            return new Aff2(ASYNC, function(cb) {\n                return function() {\n                    return runPar(util, supervisor, par, cb);\n                };\n            });\n        }\n        Aff2.EMPTY = EMPTY;\n        Aff2.Pure = AffCtr(PURE);\n        Aff2.Throw = AffCtr(THROW);\n        Aff2.Catch = AffCtr(CATCH);\n        Aff2.Sync = AffCtr(SYNC);\n        Aff2.Async = AffCtr(ASYNC);\n        Aff2.Bind = AffCtr(BIND);\n        Aff2.Bracket = AffCtr(BRACKET);\n        Aff2.Fork = AffCtr(FORK);\n        Aff2.Seq = AffCtr(SEQ);\n        Aff2.ParMap = AffCtr(MAP);\n        Aff2.ParApply = AffCtr(APPLY);\n        Aff2.ParAlt = AffCtr(ALT);\n        Aff2.Fiber = Fiber;\n        Aff2.Supervisor = Supervisor;\n        Aff2.Scheduler = Scheduler;\n        Aff2.nonCanceler = nonCanceler2;\n        return Aff2;\n    }();\n    var _pure = Aff.Pure;\n    var _throwError = Aff.Throw;\n    function _catchError(aff) {\n        return function(k) {\n            return Aff.Catch(aff, k);\n        };\n    }\n    function _map(f2) {\n        return function(aff) {\n            if (aff.tag === Aff.Pure.tag) return Aff.Pure(f2(aff._1));\n            else return Aff.Bind(aff, function(value15) {\n                return Aff.Pure(f2(value15));\n            });\n        };\n    }\n    function _bind(aff) {\n        return function(k) {\n            return Aff.Bind(aff, k);\n        };\n    }\n    function _fork(immediate) {\n        return function(aff) {\n            return Aff.Fork(immediate, aff);\n        };\n    }\n    var _liftEffect = Aff.Sync;\n    function _parAffMap(f2) {\n        return function(aff) {\n            return Aff.ParMap(f2, aff);\n        };\n    }\n    function _parAffApply(aff1) {\n        return function(aff2) {\n            return Aff.ParApply(aff1, aff2);\n        };\n    }\n    var makeAff = Aff.Async;\n    function generalBracket(acquire) {\n        return function(options2) {\n            return function(k) {\n                return Aff.Bracket(acquire, options2, k);\n            };\n        };\n    }\n    function _makeFiber(util, aff) {\n        return function() {\n            return Aff.Fiber(util, null, aff);\n        };\n    }\n    var _sequential = Aff.Seq;\n    // output/Control.Parallel.Class/index.js\n    var sequential = function(dict) {\n        return dict.sequential;\n    };\n    var parallel = function(dict) {\n        return dict.parallel;\n    };\n    // output/Control.Parallel/index.js\n    var identity10 = /* @__PURE__ */ identity(categoryFn);\n    var parTraverse_ = function(dictParallel) {\n        var sequential3 = sequential(dictParallel);\n        var parallel4 = parallel(dictParallel);\n        return function(dictApplicative) {\n            var traverse_10 = traverse_(dictApplicative);\n            return function(dictFoldable) {\n                var traverse_15 = traverse_10(dictFoldable);\n                return function(f2) {\n                    var $51 = traverse_15(function($53) {\n                        return parallel4(f2($53));\n                    });\n                    return function($52) {\n                        return sequential3($51($52));\n                    };\n                };\n            };\n        };\n    };\n    var parSequence_ = function(dictParallel) {\n        var parTraverse_1 = parTraverse_(dictParallel);\n        return function(dictApplicative) {\n            var parTraverse_2 = parTraverse_1(dictApplicative);\n            return function(dictFoldable) {\n                return parTraverse_2(dictFoldable)(identity10);\n            };\n        };\n    };\n    // output/Effect.Unsafe/foreign.js\n    var unsafePerformEffect = function(f2) {\n        return f2();\n    };\n    // output/Effect.Aff/index.js\n    var $runtime_lazy7 = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var pure3 = /* @__PURE__ */ pure(applicativeEffect);\n    var $$void4 = /* @__PURE__ */ $$void(functorEffect);\n    var map11 = /* @__PURE__ */ map(functorEffect);\n    var Canceler = function(x) {\n        return x;\n    };\n    var suspendAff = /* @__PURE__ */ _fork(false);\n    var functorParAff = {\n        map: _parAffMap\n    };\n    var functorAff = {\n        map: _map\n    };\n    var map12 = /* @__PURE__ */ map(functorAff);\n    var forkAff = /* @__PURE__ */ _fork(true);\n    var ffiUtil = /* @__PURE__ */ function() {\n        var unsafeFromRight = function(v) {\n            if (v instanceof Right) return v.value0;\n            if (v instanceof Left) return unsafeCrashWith(\"unsafeFromRight: Left\");\n            throw new Error(\"Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): \" + [\n                v.constructor.name\n            ]);\n        };\n        var unsafeFromLeft = function(v) {\n            if (v instanceof Left) return v.value0;\n            if (v instanceof Right) return unsafeCrashWith(\"unsafeFromLeft: Right\");\n            throw new Error(\"Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): \" + [\n                v.constructor.name\n            ]);\n        };\n        var isLeft = function(v) {\n            if (v instanceof Left) return true;\n            if (v instanceof Right) return false;\n            throw new Error(\"Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): \" + [\n                v.constructor.name\n            ]);\n        };\n        return {\n            isLeft: isLeft,\n            fromLeft: unsafeFromLeft,\n            fromRight: unsafeFromRight,\n            left: Left.create,\n            right: Right.create\n        };\n    }();\n    var makeFiber = function(aff) {\n        return _makeFiber(ffiUtil, aff);\n    };\n    var launchAff = function(aff) {\n        return function __do2() {\n            var fiber = makeFiber(aff)();\n            fiber.run();\n            return fiber;\n        };\n    };\n    var bracket = function(acquire) {\n        return function(completed) {\n            return generalBracket(acquire)({\n                killed: $$const(completed),\n                failed: $$const(completed),\n                completed: $$const(completed)\n            });\n        };\n    };\n    var applyParAff = {\n        apply: _parAffApply,\n        Functor0: function() {\n            return functorParAff;\n        }\n    };\n    var monadAff = {\n        Applicative0: function() {\n            return applicativeAff;\n        },\n        Bind1: function() {\n            return bindAff;\n        }\n    };\n    var bindAff = {\n        bind: _bind,\n        Apply0: function() {\n            return $lazy_applyAff(0);\n        }\n    };\n    var applicativeAff = {\n        pure: _pure,\n        Apply0: function() {\n            return $lazy_applyAff(0);\n        }\n    };\n    var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy7(\"applyAff\", \"Effect.Aff\", function() {\n        return {\n            apply: ap(monadAff),\n            Functor0: function() {\n                return functorAff;\n            }\n        };\n    });\n    var applyAff = /* @__PURE__ */ $lazy_applyAff(73);\n    var pure22 = /* @__PURE__ */ pure(applicativeAff);\n    var bind1 = /* @__PURE__ */ bind(bindAff);\n    var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindAff);\n    var $$finally = function(fin) {\n        return function(a2) {\n            return bracket(pure22(unit))($$const(fin))($$const(a2));\n        };\n    };\n    var parallelAff = {\n        parallel: unsafeCoerce2,\n        sequential: _sequential,\n        Apply0: function() {\n            return applyAff;\n        },\n        Apply1: function() {\n            return applyParAff;\n        }\n    };\n    var parallel2 = /* @__PURE__ */ parallel(parallelAff);\n    var applicativeParAff = {\n        pure: function($76) {\n            return parallel2(pure22($76));\n        },\n        Apply0: function() {\n            return applyParAff;\n        }\n    };\n    var monadEffectAff = {\n        liftEffect: _liftEffect,\n        Monad0: function() {\n            return monadAff;\n        }\n    };\n    var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);\n    var effectCanceler = function($77) {\n        return Canceler($$const(liftEffect2($77)));\n    };\n    var joinFiber = function(v) {\n        return makeAff(function(k) {\n            return map11(effectCanceler)(v.join(k));\n        });\n    };\n    var functorFiber = {\n        map: function(f2) {\n            return function(t) {\n                return unsafePerformEffect(makeFiber(map12(f2)(joinFiber(t))));\n            };\n        }\n    };\n    var killFiber = function(e) {\n        return function(v) {\n            return bind1(liftEffect2(v.isSuspended))(function(suspended) {\n                if (suspended) return liftEffect2($$void4(v.kill(e, $$const(pure3(unit)))));\n                return makeAff(function(k) {\n                    return map11(effectCanceler)(v.kill(e, k));\n                });\n            });\n        };\n    };\n    var monadThrowAff = {\n        throwError: _throwError,\n        Monad0: function() {\n            return monadAff;\n        }\n    };\n    var monadErrorAff = {\n        catchError: _catchError,\n        MonadThrow0: function() {\n            return monadThrowAff;\n        }\n    };\n    var $$try2 = /* @__PURE__ */ $$try(monadErrorAff);\n    var attempt = $$try2;\n    var runAff = function(k) {\n        return function(aff) {\n            return launchAff(bindFlipped3(function($83) {\n                return liftEffect2(k($83));\n            })($$try2(aff)));\n        };\n    };\n    var runAff_ = function(k) {\n        return function(aff) {\n            return $$void4(runAff(k)(aff));\n        };\n    };\n    var monadRecAff = {\n        tailRecM: function(k) {\n            var go2 = function(a2) {\n                return bind1(k(a2))(function(res) {\n                    if (res instanceof Done) return pure22(res.value0);\n                    if (res instanceof Loop) return go2(res.value0);\n                    throw new Error(\"Failed pattern match at Effect.Aff (line 104, column 7 - line 106, column 23): \" + [\n                        res.constructor.name\n                    ]);\n                });\n            };\n            return go2;\n        },\n        Monad0: function() {\n            return monadAff;\n        }\n    };\n    var nonCanceler = /* @__PURE__ */ $$const(/* @__PURE__ */ pure22(unit));\n    // output/Effect.Aff.Class/index.js\n    var monadAffAff = {\n        liftAff: /* @__PURE__ */ identity(categoryFn),\n        MonadEffect0: function() {\n            return monadEffectAff;\n        }\n    };\n    var liftAff = function(dict) {\n        return dict.liftAff;\n    };\n    // output/Halogen.Query.ChildQuery/index.js\n    var ChildQuery = /* @__PURE__ */ function() {\n        function ChildQuery3(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        ChildQuery3.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new ChildQuery3(value0, value1, value22);\n                };\n            };\n        };\n        return ChildQuery3;\n    }();\n    var unChildQueryBox = unsafeCoerce2;\n    var mkChildQueryBox = unsafeCoerce2;\n    // output/Unsafe.Reference/foreign.js\n    function reallyUnsafeRefEq(a2) {\n        return function(b2) {\n            return a2 === b2;\n        };\n    }\n    // output/Unsafe.Reference/index.js\n    var unsafeRefEq = reallyUnsafeRefEq;\n    // output/Halogen.Subscription/index.js\n    var $$void5 = /* @__PURE__ */ $$void(functorEffect);\n    var bind3 = /* @__PURE__ */ bind(bindEffect);\n    var append4 = /* @__PURE__ */ append(semigroupArray);\n    var traverse_2 = /* @__PURE__ */ traverse_(applicativeEffect);\n    var traverse_1 = /* @__PURE__ */ traverse_2(foldableArray);\n    var unsubscribe = function(v) {\n        return v;\n    };\n    var subscribe = function(v) {\n        return function(k) {\n            return v(function($76) {\n                return $$void5(k($76));\n            });\n        };\n    };\n    var notify = function(v) {\n        return function(a2) {\n            return v(a2);\n        };\n    };\n    var create = function __do() {\n        var subscribers = $$new([])();\n        return {\n            emitter: function(k) {\n                return function __do2() {\n                    modify_(function(v) {\n                        return append4(v)([\n                            k\n                        ]);\n                    })(subscribers)();\n                    return modify_(deleteBy(unsafeRefEq)(k))(subscribers);\n                };\n            },\n            listener: function(a2) {\n                return bind3(read(subscribers))(traverse_1(function(k) {\n                    return k(a2);\n                }));\n            }\n        };\n    };\n    // output/Halogen.Query.HalogenM/index.js\n    var identity11 = /* @__PURE__ */ identity(categoryFn);\n    var foldrWithIndex2 = /* @__PURE__ */ foldrWithIndex(foldableWithIndexMap);\n    var traverse2 = /* @__PURE__ */ traverse(traversableMap);\n    var slots2 = /* @__PURE__ */ slots();\n    var lookup4 = /* @__PURE__ */ lookup2();\n    var SubscriptionId = function(x) {\n        return x;\n    };\n    var ForkId = function(x) {\n        return x;\n    };\n    var State = /* @__PURE__ */ function() {\n        function State2(value0) {\n            this.value0 = value0;\n        }\n        State2.create = function(value0) {\n            return new State2(value0);\n        };\n        return State2;\n    }();\n    var Subscribe = /* @__PURE__ */ function() {\n        function Subscribe2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Subscribe2.create = function(value0) {\n            return function(value1) {\n                return new Subscribe2(value0, value1);\n            };\n        };\n        return Subscribe2;\n    }();\n    var Unsubscribe = /* @__PURE__ */ function() {\n        function Unsubscribe2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Unsubscribe2.create = function(value0) {\n            return function(value1) {\n                return new Unsubscribe2(value0, value1);\n            };\n        };\n        return Unsubscribe2;\n    }();\n    var Lift2 = /* @__PURE__ */ function() {\n        function Lift3(value0) {\n            this.value0 = value0;\n        }\n        Lift3.create = function(value0) {\n            return new Lift3(value0);\n        };\n        return Lift3;\n    }();\n    var ChildQuery2 = /* @__PURE__ */ function() {\n        function ChildQuery3(value0) {\n            this.value0 = value0;\n        }\n        ChildQuery3.create = function(value0) {\n            return new ChildQuery3(value0);\n        };\n        return ChildQuery3;\n    }();\n    var Raise = /* @__PURE__ */ function() {\n        function Raise2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Raise2.create = function(value0) {\n            return function(value1) {\n                return new Raise2(value0, value1);\n            };\n        };\n        return Raise2;\n    }();\n    var Par = /* @__PURE__ */ function() {\n        function Par2(value0) {\n            this.value0 = value0;\n        }\n        Par2.create = function(value0) {\n            return new Par2(value0);\n        };\n        return Par2;\n    }();\n    var Fork = /* @__PURE__ */ function() {\n        function Fork2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Fork2.create = function(value0) {\n            return function(value1) {\n                return new Fork2(value0, value1);\n            };\n        };\n        return Fork2;\n    }();\n    var Join = /* @__PURE__ */ function() {\n        function Join2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Join2.create = function(value0) {\n            return function(value1) {\n                return new Join2(value0, value1);\n            };\n        };\n        return Join2;\n    }();\n    var Kill = /* @__PURE__ */ function() {\n        function Kill2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Kill2.create = function(value0) {\n            return function(value1) {\n                return new Kill2(value0, value1);\n            };\n        };\n        return Kill2;\n    }();\n    var GetRef = /* @__PURE__ */ function() {\n        function GetRef2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        GetRef2.create = function(value0) {\n            return function(value1) {\n                return new GetRef2(value0, value1);\n            };\n        };\n        return GetRef2;\n    }();\n    var HalogenM = function(x) {\n        return x;\n    };\n    var subscribe2 = function(es) {\n        return liftF(new Subscribe(function(v) {\n            return es;\n        }, identity11));\n    };\n    var raise = function(o) {\n        return liftF(new Raise(o, unit));\n    };\n    var queryAll = function() {\n        return function(dictIsSymbol) {\n            var slots1 = slots2(dictIsSymbol);\n            return function(dictOrd) {\n                var slots22 = slots1(dictOrd);\n                return function(label5) {\n                    return function(q2) {\n                        var catMapMaybes = function(dictOrd1) {\n                            var insert10 = insert(dictOrd1);\n                            return foldrWithIndex2(function(k) {\n                                return function(v) {\n                                    return function(acc) {\n                                        return maybe(acc)(flip(insert10(k))(acc))(v);\n                                    };\n                                };\n                            })(empty2);\n                        };\n                        var catMapMaybes1 = catMapMaybes(dictOrd);\n                        return liftF(new ChildQuery2(mkChildQueryBox(new ChildQuery(function(dictApplicative) {\n                            var map42 = map(dictApplicative.Apply0().Functor0());\n                            var traverse12 = traverse2(dictApplicative);\n                            return function(k) {\n                                var $173 = map42(catMapMaybes1);\n                                var $174 = traverse12(k);\n                                var $175 = slots22(label5);\n                                return function($176) {\n                                    return $173($174($175($176)));\n                                };\n                            };\n                        }, q2, identity11))));\n                    };\n                };\n            };\n        };\n    };\n    var query = function() {\n        return function(dictIsSymbol) {\n            var lookup13 = lookup4(dictIsSymbol);\n            return function(dictOrd) {\n                var lookup23 = lookup13(dictOrd);\n                return function(label5) {\n                    return function(p2) {\n                        return function(q2) {\n                            return liftF(new ChildQuery2(mkChildQueryBox(new ChildQuery(function(dictApplicative) {\n                                var pure18 = pure(dictApplicative);\n                                return function(k) {\n                                    var $177 = maybe(pure18(Nothing.value))(k);\n                                    var $178 = lookup23(label5)(p2);\n                                    return function($179) {\n                                        return $177($178($179));\n                                    };\n                                };\n                            }, q2, identity11))));\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var ordSubscriptionId = ordInt;\n    var ordForkId = ordInt;\n    var monoidHalogenM = function(dictMonoid) {\n        return monoidFree(dictMonoid);\n    };\n    var monadHalogenM = freeMonad;\n    var monadStateHalogenM = {\n        state: function($181) {\n            return HalogenM(liftF(State.create($181)));\n        },\n        Monad0: function() {\n            return monadHalogenM;\n        }\n    };\n    var monadThrowHalogenM = function(dictMonadThrow) {\n        return {\n            throwError: function() {\n                var $184 = throwError(dictMonadThrow);\n                return function($185) {\n                    return HalogenM(liftF(Lift2.create($184($185))));\n                };\n            }(),\n            Monad0: function() {\n                return monadHalogenM;\n            }\n        };\n    };\n    var monadEffectHalogenM = function(dictMonadEffect) {\n        return {\n            liftEffect: function() {\n                var $186 = liftEffect(dictMonadEffect);\n                return function($187) {\n                    return HalogenM(liftF(Lift2.create($186($187))));\n                };\n            }(),\n            Monad0: function() {\n                return monadHalogenM;\n            }\n        };\n    };\n    var monadAffHalogenM = function(dictMonadAff) {\n        var monadEffectHalogenM1 = monadEffectHalogenM(dictMonadAff.MonadEffect0());\n        return {\n            liftAff: function() {\n                var $188 = liftAff(dictMonadAff);\n                return function($189) {\n                    return HalogenM(liftF(Lift2.create($188($189))));\n                };\n            }(),\n            MonadEffect0: function() {\n                return monadEffectHalogenM1;\n            }\n        };\n    };\n    var kill = function(fid) {\n        return liftF(new Kill(fid, unit));\n    };\n    var getRef = function(p2) {\n        return liftF(new GetRef(p2, identity11));\n    };\n    var functorHalogenM = freeFunctor;\n    var fork = function(hmu) {\n        return liftF(new Fork(hmu, identity11));\n    };\n    var bindHalogenM = freeBind;\n    var applyHalogenM = freeApply;\n    var applicativeHalogenM = freeApplicative;\n    // output/Halogen.Query.HalogenQ/index.js\n    var Initialize = /* @__PURE__ */ function() {\n        function Initialize5(value0) {\n            this.value0 = value0;\n        }\n        Initialize5.create = function(value0) {\n            return new Initialize5(value0);\n        };\n        return Initialize5;\n    }();\n    var Finalize = /* @__PURE__ */ function() {\n        function Finalize2(value0) {\n            this.value0 = value0;\n        }\n        Finalize2.create = function(value0) {\n            return new Finalize2(value0);\n        };\n        return Finalize2;\n    }();\n    var Receive = /* @__PURE__ */ function() {\n        function Receive5(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Receive5.create = function(value0) {\n            return function(value1) {\n                return new Receive5(value0, value1);\n            };\n        };\n        return Receive5;\n    }();\n    var Action2 = /* @__PURE__ */ function() {\n        function Action3(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Action3.create = function(value0) {\n            return function(value1) {\n                return new Action3(value0, value1);\n            };\n        };\n        return Action3;\n    }();\n    var Query = /* @__PURE__ */ function() {\n        function Query3(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Query3.create = function(value0) {\n            return function(value1) {\n                return new Query3(value0, value1);\n            };\n        };\n        return Query3;\n    }();\n    // output/Halogen.VDom.Thunk/index.js\n    var $runtime_lazy8 = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var unsafeEqThunk = function(v, v1) {\n        return refEq2(v.value0, v1.value0) && refEq2(v.value1, v1.value1) && v.value1(v.value3, v1.value3);\n    };\n    var runThunk = function(v) {\n        return v.value2(v.value3);\n    };\n    var buildThunk = function(toVDom) {\n        var haltThunk = function(state3) {\n            return halt(state3.vdom);\n        };\n        var $lazy_patchThunk = $runtime_lazy8(\"patchThunk\", \"Halogen.VDom.Thunk\", function() {\n            return function(state3, t2) {\n                var $48 = unsafeEqThunk(state3.thunk, t2);\n                if ($48) return mkStep(new Step2(extract2(state3.vdom), state3, $lazy_patchThunk(112), haltThunk));\n                var vdom = step(state3.vdom, toVDom(runThunk(t2)));\n                return mkStep(new Step2(extract2(vdom), {\n                    vdom: vdom,\n                    thunk: t2\n                }, $lazy_patchThunk(115), haltThunk));\n            };\n        });\n        var patchThunk = $lazy_patchThunk(108);\n        var renderThunk = function(spec) {\n            return function(t) {\n                var vdom = buildVDom(spec)(toVDom(runThunk(t)));\n                return mkStep(new Step2(extract2(vdom), {\n                    thunk: t,\n                    vdom: vdom\n                }, patchThunk, haltThunk));\n            };\n        };\n        return renderThunk;\n    };\n    // output/Halogen.Component/index.js\n    var voidLeft2 = /* @__PURE__ */ voidLeft(functorHalogenM);\n    var traverse_3 = /* @__PURE__ */ traverse_(applicativeHalogenM)(foldableMaybe);\n    var map13 = /* @__PURE__ */ map(functorHalogenM);\n    var pure4 = /* @__PURE__ */ pure(applicativeHalogenM);\n    var lookup5 = /* @__PURE__ */ lookup2();\n    var pop3 = /* @__PURE__ */ pop2();\n    var insert4 = /* @__PURE__ */ insert2();\n    var ComponentSlot = /* @__PURE__ */ function() {\n        function ComponentSlot2(value0) {\n            this.value0 = value0;\n        }\n        ComponentSlot2.create = function(value0) {\n            return new ComponentSlot2(value0);\n        };\n        return ComponentSlot2;\n    }();\n    var ThunkSlot = /* @__PURE__ */ function() {\n        function ThunkSlot2(value0) {\n            this.value0 = value0;\n        }\n        ThunkSlot2.create = function(value0) {\n            return new ThunkSlot2(value0);\n        };\n        return ThunkSlot2;\n    }();\n    var unComponentSlot = unsafeCoerce2;\n    var unComponent = unsafeCoerce2;\n    var mkEval = function(args) {\n        return function(v) {\n            if (v instanceof Initialize) return voidLeft2(traverse_3(args.handleAction)(args.initialize))(v.value0);\n            if (v instanceof Finalize) return voidLeft2(traverse_3(args.handleAction)(args.finalize))(v.value0);\n            if (v instanceof Receive) return voidLeft2(traverse_3(args.handleAction)(args.receive(v.value0)))(v.value1);\n            if (v instanceof Action2) return voidLeft2(args.handleAction(v.value0))(v.value1);\n            if (v instanceof Query) return unCoyoneda(function(g) {\n                var $45 = map13(maybe(v.value1(unit))(g));\n                return function($46) {\n                    return $45(args.handleQuery($46));\n                };\n            })(v.value0);\n            throw new Error(\"Failed pattern match at Halogen.Component (line 182, column 15 - line 192, column 71): \" + [\n                v.constructor.name\n            ]);\n        };\n    };\n    var mkComponentSlot = unsafeCoerce2;\n    var mkComponent = unsafeCoerce2;\n    var defaultEval = /* @__PURE__ */ function() {\n        return {\n            handleAction: $$const(pure4(unit)),\n            handleQuery: $$const(pure4(Nothing.value)),\n            receive: $$const(Nothing.value),\n            initialize: Nothing.value,\n            finalize: Nothing.value\n        };\n    }();\n    var componentSlot = function() {\n        return function(dictIsSymbol) {\n            var lookup13 = lookup5(dictIsSymbol);\n            var pop12 = pop3(dictIsSymbol);\n            var insert13 = insert4(dictIsSymbol);\n            return function(dictOrd) {\n                var lookup23 = lookup13(dictOrd);\n                var pop22 = pop12(dictOrd);\n                var insert22 = insert13(dictOrd);\n                return function(label5) {\n                    return function(p2) {\n                        return function(comp) {\n                            return function(input3) {\n                                return function(output2) {\n                                    return mkComponentSlot({\n                                        get: lookup23(label5)(p2),\n                                        pop: pop22(label5)(p2),\n                                        set: insert22(label5)(p2),\n                                        component: comp,\n                                        input: input3,\n                                        output: output2\n                                    });\n                                };\n                            };\n                        };\n                    };\n                };\n            };\n        };\n    };\n    // output/Halogen.HTML.Elements/index.js\n    var element2 = /* @__PURE__ */ function() {\n        return element(Nothing.value);\n    }();\n    var footer = /* @__PURE__ */ element2(\"footer\");\n    var h1 = /* @__PURE__ */ element2(\"h1\");\n    var h2 = /* @__PURE__ */ element2(\"h2\");\n    var header = /* @__PURE__ */ element2(\"header\");\n    var i = /* @__PURE__ */ element2(\"i\");\n    var input = function(props) {\n        return element2(\"input\")(props)([]);\n    };\n    var li = /* @__PURE__ */ element2(\"li\");\n    var main = /* @__PURE__ */ element2(\"main\");\n    var option = /* @__PURE__ */ element2(\"option\");\n    var select = /* @__PURE__ */ element2(\"select\");\n    var ul = /* @__PURE__ */ element2(\"ul\");\n    var div2 = /* @__PURE__ */ element2(\"div\");\n    var div_ = /* @__PURE__ */ div2([]);\n    var button = /* @__PURE__ */ element2(\"button\");\n    var a = /* @__PURE__ */ element2(\"a\");\n    // output/Control.Monad.Except/index.js\n    var unwrap2 = /* @__PURE__ */ unwrap();\n    var runExcept = function($3) {\n        return unwrap2(runExceptT($3));\n    };\n    // output/Foreign.Index/foreign.js\n    function unsafeReadPropImpl(f2, s, key, value15) {\n        return value15 == null ? f2 : s(value15[key]);\n    }\n    // output/Foreign.Index/index.js\n    var unsafeReadProp = function(dictMonad) {\n        var fail2 = fail(dictMonad);\n        var pure18 = pure(applicativeExceptT(dictMonad));\n        return function(k) {\n            return function(value15) {\n                return unsafeReadPropImpl(fail2(new TypeMismatch(\"object\", typeOf(value15))), pure18, k, value15);\n            };\n        };\n    };\n    var readProp = function(dictMonad) {\n        return unsafeReadProp(dictMonad);\n    };\n    // output/Web.Event.Event/foreign.js\n    function _currentTarget(e) {\n        return e.currentTarget;\n    }\n    function _target(e) {\n        return e.target;\n    }\n    function preventDefault(e) {\n        return function() {\n            return e.preventDefault();\n        };\n    }\n    // output/Control.Alternative/index.js\n    var guard = function(dictAlternative) {\n        var pure18 = pure(dictAlternative.Applicative0());\n        var empty8 = empty(dictAlternative.Plus1());\n        return function(v) {\n            if (v) return pure18(unit);\n            if (!v) return empty8;\n            throw new Error(\"Failed pattern match at Control.Alternative (line 48, column 1 - line 48, column 54): \" + [\n                v.constructor.name\n            ]);\n        };\n    };\n    // output/Web.Event.Event/index.js\n    var target = function($3) {\n        return toMaybe(_target($3));\n    };\n    var currentTarget = function($5) {\n        return toMaybe(_currentTarget($5));\n    };\n    // output/Web.HTML.Event.DragEvent.EventTypes/index.js\n    var drop3 = \"drop\";\n    var dragstart = \"dragstart\";\n    var dragover = \"dragover\";\n    var dragenter = \"dragenter\";\n    // output/Web.HTML.Event.EventTypes/index.js\n    var domcontentloaded = \"DOMContentLoaded\";\n    var change = \"change\";\n    // output/Web.HTML.HTMLInputElement/foreign.js\n    function select2(input3) {\n        return function() {\n            input3.select();\n        };\n    }\n    // output/Web.HTML.HTMLInputElement/index.js\n    var fromEventTarget = /* @__PURE__ */ unsafeReadProtoTagged(\"HTMLInputElement\");\n    // output/Web.UIEvent.FocusEvent.EventTypes/index.js\n    var focus = \"focus\";\n    // output/Web.UIEvent.MouseEvent.EventTypes/index.js\n    var click = \"click\";\n    // output/Halogen.HTML.Events/index.js\n    var map14 = /* @__PURE__ */ map(functorMaybe);\n    var composeKleisli2 = /* @__PURE__ */ composeKleisli(bindMaybe);\n    var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(/* @__PURE__ */ bindExceptT(monadIdentity));\n    var readProp2 = /* @__PURE__ */ readProp(monadIdentity);\n    var readString2 = /* @__PURE__ */ readString(monadIdentity);\n    var mouseHandler = unsafeCoerce2;\n    var handler$prime = function(et) {\n        return function(f2) {\n            return handler(et)(function(ev) {\n                return map14(Action.create)(f2(ev));\n            });\n        };\n    };\n    var handler2 = function(et) {\n        return function(f2) {\n            return handler(et)(function(ev) {\n                return new Just(new Action(f2(ev)));\n            });\n        };\n    };\n    var onClick = /* @__PURE__ */ function() {\n        var $15 = handler2(click);\n        return function($16) {\n            return $15(mouseHandler($16));\n        };\n    }();\n    var focusHandler = unsafeCoerce2;\n    var onFocus = /* @__PURE__ */ function() {\n        var $57 = handler2(focus);\n        return function($58) {\n            return $57(focusHandler($58));\n        };\n    }();\n    var dragHandler = unsafeCoerce2;\n    var onDragEnter = /* @__PURE__ */ function() {\n        var $67 = handler2(dragenter);\n        return function($68) {\n            return $67(dragHandler($68));\n        };\n    }();\n    var onDragOver = /* @__PURE__ */ function() {\n        var $73 = handler2(dragover);\n        return function($74) {\n            return $73(dragHandler($74));\n        };\n    }();\n    var onDragStart = /* @__PURE__ */ function() {\n        var $75 = handler2(dragstart);\n        return function($76) {\n            return $75(dragHandler($76));\n        };\n    }();\n    var onDrop = /* @__PURE__ */ function() {\n        var $77 = handler2(drop3);\n        return function($78) {\n            return $77(dragHandler($78));\n        };\n    }();\n    var addForeignPropHandler = function(key) {\n        return function(prop3) {\n            return function(reader) {\n                return function(f2) {\n                    var go2 = function(a2) {\n                        return composeKleisliFlipped2(reader)(readProp2(prop3))(unsafeToForeign(a2));\n                    };\n                    return handler$prime(key)(composeKleisli2(currentTarget)(function(e) {\n                        return either($$const(Nothing.value))(function($85) {\n                            return Just.create(f2($85));\n                        })(runExcept(go2(e)));\n                    }));\n                };\n            };\n        };\n    };\n    var onValueChange = /* @__PURE__ */ addForeignPropHandler(change)(\"value\")(readString2);\n    // output/Halogen.HTML.Properties/index.js\n    var unwrap3 = /* @__PURE__ */ unwrap();\n    var ref2 = /* @__PURE__ */ function() {\n        var go2 = function(p2) {\n            return function(mel) {\n                return new Just(new RefUpdate(p2, mel));\n            };\n        };\n        return function($29) {\n            return ref(go2($29));\n        };\n    }();\n    var prop2 = function(dictIsProp) {\n        return prop(dictIsProp);\n    };\n    var prop1 = /* @__PURE__ */ prop2(isPropBoolean);\n    var prop22 = /* @__PURE__ */ prop2(isPropString);\n    var prop4 = /* @__PURE__ */ prop2(isPropNumber);\n    var rel = /* @__PURE__ */ prop22(\"rel\");\n    var step3 = /* @__PURE__ */ prop2(isPropStepValue)(\"step\");\n    var target2 = /* @__PURE__ */ prop22(\"target\");\n    var type_3 = function(dictIsProp) {\n        return prop2(dictIsProp)(\"type\");\n    };\n    var value2 = function(dictIsProp) {\n        return prop2(dictIsProp)(\"value\");\n    };\n    var min4 = /* @__PURE__ */ prop4(\"min\");\n    var max4 = /* @__PURE__ */ prop4(\"max\");\n    var href = /* @__PURE__ */ prop22(\"href\");\n    var draggable = /* @__PURE__ */ prop1(\"draggable\");\n    var classes = /* @__PURE__ */ function() {\n        var $32 = prop22(\"className\");\n        var $33 = joinWith(\" \");\n        var $34 = map(functorArray)(unwrap3);\n        return function($35) {\n            return $32($33($34($35)));\n        };\n    }();\n    var class_ = /* @__PURE__ */ function() {\n        var $36 = prop22(\"className\");\n        return function($37) {\n            return $36(unwrap3($37));\n        };\n    }();\n    // output/Record/index.js\n    var insert5 = function(dictIsSymbol) {\n        var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n        return function() {\n            return function() {\n                return function(l) {\n                    return function(a2) {\n                        return function(r) {\n                            return unsafeSet(reflectSymbol2(l))(a2)(r);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var get2 = function(dictIsSymbol) {\n        var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n        return function() {\n            return function(l) {\n                return function(r) {\n                    return unsafeGet(reflectSymbol2(l))(r);\n                };\n            };\n        };\n    };\n    // output/Util.Halogen/index.js\n    var append12 = /* @__PURE__ */ append(semigroupArray);\n    var fa_ = function(s) {\n        return i([\n            class_(\"fa-solid \" + s)\n        ])([]);\n    };\n    var fa = function(s) {\n        return function(c) {\n            return i([\n                classes(append12([\n                    \"fa-solid \" + s\n                ])(c))\n            ])([]);\n        };\n    };\n    var empty7 = /* @__PURE__ */ text(/* @__PURE__ */ mempty(monoidString));\n    var button2 = function(content3) {\n        return function(style2) {\n            return function(h) {\n                return button([\n                    classes([\n                        \"rounded w-full h-full py-1 px-2 transition-colors duration-75\",\n                        style2\n                    ]),\n                    onClick($$const(h))\n                ])([\n                    content3\n                ]);\n            };\n        };\n    };\n    var downButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-angle-down\"))(\"text-gray-500 hover:bg-gray-200\");\n    var plusButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-plus\"))(\"border border-sky-500 text-sky-700 hover:bg-sky-200\");\n    var removeButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-xmark\"))(\"text-gray-500 hover:bg-gray-200\");\n    var toggleButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-arrows-rotate\"))(\"text-gray-500 hover:bg-gray-200\");\n    var upButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-angle-up\"))(\"text-gray-500 hover:bg-gray-200\");\n    // output/App.Selector/index.js\n    var not2 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));\n    var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorArray);\n    var discard2 = /* @__PURE__ */ discard(discardUnit)(/* @__PURE__ */ bindMaybeT(monadHalogenM));\n    var put2 = /* @__PURE__ */ put(/* @__PURE__ */ monadStateMaybeT(monadStateHalogenM));\n    var pure5 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeMaybeT(monadHalogenM));\n    var map15 = /* @__PURE__ */ map(functorArray);\n    var insert6 = /* @__PURE__ */ insert5({\n        reflectSymbol: function() {\n            return \"selected\";\n        }\n    })()();\n    var modify_3 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n    var bind4 = /* @__PURE__ */ bind(bindHalogenM);\n    var modify5 = /* @__PURE__ */ modify2(monadStateHalogenM);\n    var whenM2 = /* @__PURE__ */ whenM(monadHalogenM);\n    var gets2 = /* @__PURE__ */ gets(monadStateHalogenM);\n    var bind12 = /* @__PURE__ */ bind(bindFn);\n    var SetItems = /* @__PURE__ */ function() {\n        function SetItems2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        SetItems2.create = function(value0) {\n            return function(value1) {\n                return new SetItems2(value0, value1);\n            };\n        };\n        return SetItems2;\n    }();\n    var EnterEdit = /* @__PURE__ */ function() {\n        function EnterEdit2() {}\n        EnterEdit2.value = new EnterEdit2();\n        return EnterEdit2;\n    }();\n    var LeaveEdit = /* @__PURE__ */ function() {\n        function LeaveEdit2() {}\n        LeaveEdit2.value = new LeaveEdit2();\n        return LeaveEdit2;\n    }();\n    var Toggle = /* @__PURE__ */ function() {\n        function Toggle2(value0) {\n            this.value0 = value0;\n        }\n        Toggle2.create = function(value0) {\n            return new Toggle2(value0);\n        };\n        return Toggle2;\n    }();\n    var Receive2 = /* @__PURE__ */ function() {\n        function Receive5(value0) {\n            this.value0 = value0;\n        }\n        Receive5.create = function(value0) {\n            return new Receive5(value0);\n        };\n        return Receive5;\n    }();\n    var component = function(dictEq) {\n        var eq8 = eq(dictEq);\n        var renderItem = function(isEditMode) {\n            return function(item) {\n                return li([\n                    class_(function() {\n                        var $48 = item.selected || isEditMode;\n                        if ($48) return \"min-w-0\";\n                        return \"hidden\";\n                    }())\n                ])([\n                    button([\n                        classes([\n                            \"h-full w-full rounded border px-3 py-1 transition-colors duration-75\",\n                            function() {\n                                if (item.selected) return \"border-sky-700 bg-sky-500 text-white hover:bg-sky-600\";\n                                return \"border-gray-800 bg-gray-300 text-black hover:bg-gray-400\";\n                            }()\n                        ]),\n                        onClick($$const(new Toggle(item.id)))\n                    ])([\n                        text(item.value)\n                    ])\n                ]);\n            };\n        };\n        var renderBackground = function(isEditMode) {\n            return div2([\n                class_(function() {\n                    if (isEditMode) return \"fixed inset-0 bg-black opacity-20\";\n                    return \"hidden\";\n                }()),\n                onClick($$const(LeaveEdit.value))\n            ])([]);\n        };\n        var renderAddButton = div_([\n            plusButton(EnterEdit.value)\n        ]);\n        var render = function(v) {\n            return div2([\n                class_(\"mx-1 flex\")\n            ])([\n                function() {\n                    var $52 = all2(not2(function(v1) {\n                        return v1.selected;\n                    }))(v.items) || v.isEditMode;\n                    if ($52) return renderAddButton;\n                    return empty7;\n                }(),\n                renderBackground(v.isEditMode),\n                ul([\n                    class_(function() {\n                        if (v.isEditMode) return \"break-anywhere absolute flex min-w-48 flex-col gap-0.5 bg-white p-4 shadow-md\";\n                        return \"break-anywhere flex w-full flex-wrap gap-1\";\n                    }()),\n                    onClick($$const(EnterEdit.value))\n                ])(mapFlipped2(v.items)(renderItem(v.isEditMode)))\n            ]);\n        };\n        var query3 = function(v) {\n            return discard2(put2({\n                items: v.value0,\n                isEditMode: false\n            }))(function() {\n                return pure5(v.value1);\n            });\n        };\n        var initialState = function() {\n            var $83 = map15(insert6($$Proxy.value)(false));\n            return function($84) {\n                return /* @__PURE__ */ function(v) {\n                    return {\n                        items: v,\n                        isEditMode: false\n                    };\n                }($83($84));\n            };\n        }();\n        var action2 = function(v) {\n            if (v instanceof EnterEdit) return modify_3(function(v1) {\n                var $60 = {};\n                for(var $61 in v1)if (({}).hasOwnProperty.call(v1, $61)) $60[$61] = v1[$61];\n                $60.isEditMode = true;\n                return $60;\n            });\n            if (v instanceof LeaveEdit) return bind4(modify5(function(v1) {\n                var $63 = {};\n                for(var $64 in v1)if (({}).hasOwnProperty.call(v1, $64)) $63[$64] = v1[$64];\n                $63.isEditMode = false;\n                return $63;\n            }))(function(v1) {\n                return raise(mapFlipped2(filter(function(v2) {\n                    return v2.selected;\n                })(v1.items))(function(v2) {\n                    return v2.id;\n                }));\n            });\n            if (v instanceof Toggle) return whenM2(gets2(function(v1) {\n                return v1.isEditMode;\n            }))(modify_3(bind12(function(v1) {\n                return v1.items;\n            })(function(items3) {\n                var items$prime = mapFlipped2(items3)(function(item) {\n                    var $68 = eq8(item.id)(v.value0);\n                    if ($68) {\n                        var $69 = {};\n                        for(var $70 in item)if (({}).hasOwnProperty.call(item, $70)) $69[$70] = item[$70];\n                        $69.selected = !item.selected;\n                        return $69;\n                    }\n                    return item;\n                });\n                return function(v1) {\n                    var $72 = {};\n                    for(var $73 in v1)if (({}).hasOwnProperty.call(v1, $73)) $72[$73] = v1[$73];\n                    $72.items = items$prime;\n                    return $72;\n                };\n            })));\n            if (v instanceof Receive2) return modify_3(bind12(function(v1) {\n                return v1.items;\n            })(function(items3) {\n                var items$prime = mapFlipped2(v.value0)(function(v1) {\n                    return {\n                        id: v1.id,\n                        value: v1.value,\n                        selected: maybe(false)(function(v2) {\n                            return v2.selected;\n                        })(find2(function($85) {\n                            return function(v2) {\n                                return eq8(v2)(v1.id);\n                            }(function(v2) {\n                                return v2.id;\n                            }($85));\n                        })(items3))\n                    };\n                });\n                return function(v1) {\n                    var $79 = {};\n                    for(var $80 in v1)if (({}).hasOwnProperty.call(v1, $80)) $79[$80] = v1[$80];\n                    $79.items = items$prime;\n                    return $79;\n                };\n            }));\n            throw new Error(\"Failed pattern match at App.Selector (line 92, column 12 - line 108, column 29): \" + [\n                v.constructor.name\n            ]);\n        };\n        return mkComponent({\n            initialState: initialState,\n            render: render,\n            \"eval\": mkEval({\n                initialize: defaultEval.initialize,\n                finalize: defaultEval.finalize,\n                handleAction: action2,\n                handleQuery: function($86) {\n                    return runMaybeT(query3($86));\n                },\n                receive: function($87) {\n                    return Just.create(Receive2.create($87));\n                }\n            })\n        });\n    };\n    // output/Halogen.HTML/index.js\n    var componentSlot2 = /* @__PURE__ */ componentSlot();\n    var slot_ = function() {\n        return function(dictIsSymbol) {\n            var componentSlot1 = componentSlot2(dictIsSymbol);\n            return function(dictOrd) {\n                var componentSlot22 = componentSlot1(dictOrd);\n                return function(label5) {\n                    return function(p2) {\n                        return function(component7) {\n                            return function(input3) {\n                                return widget(new ComponentSlot(componentSlot22(label5)(p2)(component7)(input3)($$const(Nothing.value))));\n                            };\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var slot = function() {\n        return function(dictIsSymbol) {\n            var componentSlot1 = componentSlot2(dictIsSymbol);\n            return function(dictOrd) {\n                var componentSlot22 = componentSlot1(dictOrd);\n                return function(label5) {\n                    return function(p2) {\n                        return function(component7) {\n                            return function(input3) {\n                                return function(outputQuery) {\n                                    return widget(new ComponentSlot(componentSlot22(label5)(p2)(component7)(input3)(function($11) {\n                                        return Just.create(outputQuery($11));\n                                    })));\n                                };\n                            };\n                        };\n                    };\n                };\n            };\n        };\n    };\n    // output/Web.HTML.HTMLElement/foreign.js\n    function _read(nothing, just, value15) {\n        var tag = Object.prototype.toString.call(value15);\n        if (tag.indexOf(\"[object HTML\") === 0 && tag.indexOf(\"Element]\") === tag.length - 8) return just(value15);\n        else return nothing;\n    }\n    // output/Web.HTML.HTMLElement/index.js\n    var toNode2 = unsafeCoerce2;\n    var fromElement = function(x) {\n        return _read(Nothing.value, Just.create, x);\n    };\n    // output/Halogen.Query/index.js\n    var $$void6 = /* @__PURE__ */ $$void(functorHalogenM);\n    var queryAll2 = /* @__PURE__ */ queryAll();\n    var query2 = /* @__PURE__ */ query();\n    var identity12 = /* @__PURE__ */ identity(categoryFn);\n    var tell2 = function() {\n        return function(dictIsSymbol) {\n            var query1 = query2(dictIsSymbol);\n            return function(dictOrd) {\n                var query22 = query1(dictOrd);\n                return function(slot5) {\n                    return function(label5) {\n                        return function(req) {\n                            return $$void6(query22(slot5)(label5)(req(unit)));\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var requestAll = function() {\n        return function(dictIsSymbol) {\n            var queryAll1 = queryAll2(dictIsSymbol);\n            return function(dictOrd) {\n                var queryAll22 = queryAll1(dictOrd);\n                return function(label5) {\n                    return function(req) {\n                        return queryAll22(label5)(req(identity12));\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Argonaut.Core/foreign.js\n    function id2(x) {\n        return x;\n    }\n    function stringify(j) {\n        return JSON.stringify(j);\n    }\n    function _caseJson(isNull3, isBool, isNum, isStr, isArr, isObj, j) {\n        if (j == null) return isNull3();\n        else if (typeof j === \"boolean\") return isBool(j);\n        else if (typeof j === \"number\") return isNum(j);\n        else if (typeof j === \"string\") return isStr(j);\n        else if (Object.prototype.toString.call(j) === \"[object Array]\") return isArr(j);\n        else return isObj(j);\n    }\n    // output/Data.Argonaut.Core/index.js\n    var verbJsonType = function(def) {\n        return function(f2) {\n            return function(g) {\n                return g(def)(f2);\n            };\n        };\n    };\n    var toJsonType = /* @__PURE__ */ function() {\n        return verbJsonType(Nothing.value)(Just.create);\n    }();\n    var caseJsonString = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), $$const(d), $$const(d), f2, $$const(d), $$const(d), j);\n            };\n        };\n    };\n    var caseJsonObject = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), $$const(d), f2, j);\n            };\n        };\n    };\n    var toObject = /* @__PURE__ */ toJsonType(caseJsonObject);\n    var caseJsonNumber = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), $$const(d), f2, $$const(d), $$const(d), $$const(d), j);\n            };\n        };\n    };\n    var caseJsonBoolean = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), f2, $$const(d), $$const(d), $$const(d), $$const(d), j);\n            };\n        };\n    };\n    var caseJsonArray = function(d) {\n        return function(f2) {\n            return function(j) {\n                return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), f2, $$const(d), j);\n            };\n        };\n    };\n    var toArray = /* @__PURE__ */ toJsonType(caseJsonArray);\n    // output/Data.Argonaut.Decode.Error/index.js\n    var show12 = /* @__PURE__ */ show(showInt);\n    var TypeMismatch2 = /* @__PURE__ */ function() {\n        function TypeMismatch3(value0) {\n            this.value0 = value0;\n        }\n        TypeMismatch3.create = function(value0) {\n            return new TypeMismatch3(value0);\n        };\n        return TypeMismatch3;\n    }();\n    var UnexpectedValue = /* @__PURE__ */ function() {\n        function UnexpectedValue2(value0) {\n            this.value0 = value0;\n        }\n        UnexpectedValue2.create = function(value0) {\n            return new UnexpectedValue2(value0);\n        };\n        return UnexpectedValue2;\n    }();\n    var AtIndex = /* @__PURE__ */ function() {\n        function AtIndex2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        AtIndex2.create = function(value0) {\n            return function(value1) {\n                return new AtIndex2(value0, value1);\n            };\n        };\n        return AtIndex2;\n    }();\n    var AtKey = /* @__PURE__ */ function() {\n        function AtKey2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        AtKey2.create = function(value0) {\n            return function(value1) {\n                return new AtKey2(value0, value1);\n            };\n        };\n        return AtKey2;\n    }();\n    var Named = /* @__PURE__ */ function() {\n        function Named2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Named2.create = function(value0) {\n            return function(value1) {\n                return new Named2(value0, value1);\n            };\n        };\n        return Named2;\n    }();\n    var MissingValue = /* @__PURE__ */ function() {\n        function MissingValue2() {}\n        MissingValue2.value = new MissingValue2();\n        return MissingValue2;\n    }();\n    var printJsonDecodeError = function(err) {\n        var go2 = function(v) {\n            if (v instanceof TypeMismatch2) return \"  Expected value of type '\" + (v.value0 + \"'.\");\n            if (v instanceof UnexpectedValue) return \"  Unexpected value \" + (stringify(v.value0) + \".\");\n            if (v instanceof AtIndex) return \"  At array index \" + (show12(v.value0) + (\":\\n\" + go2(v.value1)));\n            if (v instanceof AtKey) return \"  At object key '\" + (v.value0 + (\"':\\n\" + go2(v.value1)));\n            if (v instanceof Named) return \"  Under '\" + (v.value0 + (\"':\\n\" + go2(v.value1)));\n            if (v instanceof MissingValue) return \"  No value was found.\";\n            throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Error (line 37, column 8 - line 43, column 44): \" + [\n                v.constructor.name\n            ]);\n        };\n        return \"An error occurred while decoding a JSON value:\\n\" + go2(err);\n    };\n    // output/Data.Array.NonEmpty.Internal/index.js\n    var NonEmptyArray = function(x) {\n        return x;\n    };\n    // output/Data.Array.NonEmpty/index.js\n    var unsafeFromArray = NonEmptyArray;\n    var toArray2 = function(v) {\n        return v;\n    };\n    var fromArray = function(xs) {\n        if (length(xs) > 0) return new Just(unsafeFromArray(xs));\n        if (otherwise) return Nothing.value;\n        throw new Error(\"Failed pattern match at Data.Array.NonEmpty (line 161, column 1 - line 161, column 58): \" + [\n            xs.constructor.name\n        ]);\n    };\n    var fromFoldable3 = function(dictFoldable) {\n        var $119 = fromFoldable(dictFoldable);\n        return function($120) {\n            return fromArray($119($120));\n        };\n    };\n    // output/Data.String.CodePoints/foreign.js\n    var hasArrayFrom = typeof Array.from === \"function\";\n    var hasStringIterator = typeof Symbol !== \"undefined\" && Symbol != null && typeof Symbol.iterator !== \"undefined\" && typeof String.prototype[Symbol.iterator] === \"function\";\n    var hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\n    var hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n    // output/Data.Argonaut.Decode.Decoders/index.js\n    var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);\n    var composeKleisliFlipped3 = /* @__PURE__ */ composeKleisliFlipped(bindEither);\n    var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeEither);\n    var decodeString = /* @__PURE__ */ function() {\n        return caseJsonString(new Left(new TypeMismatch2(\"String\")))(Right.create);\n    }();\n    var decodeNumber = /* @__PURE__ */ function() {\n        return caseJsonNumber(new Left(new TypeMismatch2(\"Number\")))(Right.create);\n    }();\n    var decodeJArray = /* @__PURE__ */ function() {\n        var $52 = note(new TypeMismatch2(\"Array\"));\n        return function($53) {\n            return $52(toArray($53));\n        };\n    }();\n    var decodeInt = /* @__PURE__ */ composeKleisliFlipped3(/* @__PURE__ */ function() {\n        var $84 = note(new TypeMismatch2(\"Integer\"));\n        return function($85) {\n            return $84(fromNumber($85));\n        };\n    }())(decodeNumber);\n    var decodeBoolean = /* @__PURE__ */ function() {\n        return caseJsonBoolean(new Left(new TypeMismatch2(\"Boolean\")))(Right.create);\n    }();\n    var decodeArray = function(decoder) {\n        return composeKleisliFlipped3(function() {\n            var $89 = lmap2(Named.create(\"Array\"));\n            var $90 = traverseWithIndex2(function(i2) {\n                var $92 = lmap2(AtIndex.create(i2));\n                return function($93) {\n                    return $92(decoder($93));\n                };\n            });\n            return function($91) {\n                return $89($90($91));\n            };\n        }())(decodeJArray);\n    };\n    // output/Data.Argonaut.Decode.Class/index.js\n    var bind5 = /* @__PURE__ */ bind(bindEither);\n    var lmap3 = /* @__PURE__ */ lmap(bifunctorEither);\n    var map17 = /* @__PURE__ */ map(functorMaybe);\n    var gDecodeJsonNil = {\n        gDecodeJson: function(v) {\n            return function(v1) {\n                return new Right({});\n            };\n        }\n    };\n    var gDecodeJson = function(dict) {\n        return dict.gDecodeJson;\n    };\n    var decodeRecord = function(dictGDecodeJson) {\n        var gDecodeJson1 = gDecodeJson(dictGDecodeJson);\n        return function() {\n            return {\n                decodeJson: function(json) {\n                    var v = toObject(json);\n                    if (v instanceof Just) return gDecodeJson1(v.value0)($$Proxy.value);\n                    if (v instanceof Nothing) return new Left(new TypeMismatch2(\"Object\"));\n                    throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Class (line 103, column 5 - line 105, column 46): \" + [\n                        v.constructor.name\n                    ]);\n                }\n            };\n        };\n    };\n    var decodeJsonString = {\n        decodeJson: decodeString\n    };\n    var decodeJsonInt = {\n        decodeJson: decodeInt\n    };\n    var decodeJsonField = function(dict) {\n        return dict.decodeJsonField;\n    };\n    var gDecodeJsonCons = function(dictDecodeJsonField) {\n        var decodeJsonField1 = decodeJsonField(dictDecodeJsonField);\n        return function(dictGDecodeJson) {\n            var gDecodeJson1 = gDecodeJson(dictGDecodeJson);\n            return function(dictIsSymbol) {\n                var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n                var insert10 = insert5(dictIsSymbol)()();\n                return function() {\n                    return function() {\n                        return {\n                            gDecodeJson: function(object2) {\n                                return function(v) {\n                                    var fieldName = reflectSymbol2($$Proxy.value);\n                                    var fieldValue = lookup3(fieldName)(object2);\n                                    var v1 = decodeJsonField1(fieldValue);\n                                    if (v1 instanceof Just) return bind5(lmap3(AtKey.create(fieldName))(v1.value0))(function(val) {\n                                        return bind5(gDecodeJson1(object2)($$Proxy.value))(function(rest) {\n                                            return new Right(insert10($$Proxy.value)(val)(rest));\n                                        });\n                                    });\n                                    if (v1 instanceof Nothing) return new Left(new AtKey(fieldName, MissingValue.value));\n                                    throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Class (line 127, column 5 - line 134, column 44): \" + [\n                                        v1.constructor.name\n                                    ]);\n                                };\n                            }\n                        };\n                    };\n                };\n            };\n        };\n    };\n    var decodeJsonBoolean = {\n        decodeJson: decodeBoolean\n    };\n    var decodeJson = function(dict) {\n        return dict.decodeJson;\n    };\n    var decodeFieldId = function(dictDecodeJson) {\n        var decodeJson1 = decodeJson(dictDecodeJson);\n        return {\n            decodeJsonField: function(j) {\n                return map17(decodeJson1)(j);\n            }\n        };\n    };\n    var decodeArray2 = function(dictDecodeJson) {\n        return {\n            decodeJson: decodeArray(decodeJson(dictDecodeJson))\n        };\n    };\n    // output/Data.Argonaut.Encode.Encoders/index.js\n    var map18 = /* @__PURE__ */ map(functorArray);\n    var encodeString = id2;\n    var encodeInt = function($53) {\n        return id2(toNumber($53));\n    };\n    var encodeBoolean = id2;\n    var encodeArray = function(encoder) {\n        var $58 = map18(encoder);\n        return function($59) {\n            return id2($58($59));\n        };\n    };\n    var encodeNonEmptyArray = function(encoder) {\n        var $60 = encodeArray(encoder);\n        return function($61) {\n            return $60(toArray2($61));\n        };\n    };\n    // output/Data.Argonaut.Encode.Class/index.js\n    var gEncodeJsonNil = {\n        gEncodeJson: function(v) {\n            return function(v1) {\n                return empty4;\n            };\n        }\n    };\n    var gEncodeJson = function(dict) {\n        return dict.gEncodeJson;\n    };\n    var encodeRecord = function(dictGEncodeJson) {\n        var gEncodeJson1 = gEncodeJson(dictGEncodeJson);\n        return function() {\n            return {\n                encodeJson: function(rec) {\n                    return id2(gEncodeJson1(rec)($$Proxy.value));\n                }\n            };\n        };\n    };\n    var encodeJsonJString = {\n        encodeJson: encodeString\n    };\n    var encodeJsonJBoolean = {\n        encodeJson: encodeBoolean\n    };\n    var encodeJsonInt = {\n        encodeJson: encodeInt\n    };\n    var encodeJson = function(dict) {\n        return dict.encodeJson;\n    };\n    var encodeJsonArray = function(dictEncodeJson) {\n        return {\n            encodeJson: encodeArray(encodeJson(dictEncodeJson))\n        };\n    };\n    var encodeJsonNonEmptyArray = function(dictEncodeJson) {\n        return {\n            encodeJson: encodeNonEmptyArray(encodeJson(dictEncodeJson))\n        };\n    };\n    var gEncodeJsonCons = function(dictEncodeJson) {\n        var encodeJson1 = encodeJson(dictEncodeJson);\n        return function(dictGEncodeJson) {\n            var gEncodeJson1 = gEncodeJson(dictGEncodeJson);\n            return function(dictIsSymbol) {\n                var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n                var get7 = get2(dictIsSymbol)();\n                return function() {\n                    return {\n                        gEncodeJson: function(row) {\n                            return function(v) {\n                                return insert3(reflectSymbol2($$Proxy.value))(encodeJson1(get7($$Proxy.value)(row)))(gEncodeJson1(row)($$Proxy.value));\n                            };\n                        }\n                    };\n                };\n            };\n        };\n    };\n    // output/Data.Show.Generic/foreign.js\n    var intercalate3 = function(separator) {\n        return function(xs) {\n            return xs.join(separator);\n        };\n    };\n    // output/Data.Show.Generic/index.js\n    var append5 = /* @__PURE__ */ append(semigroupArray);\n    var genericShowArgsNoArguments = {\n        genericShowArgs: function(v) {\n            return [];\n        }\n    };\n    var genericShowArgs = function(dict) {\n        return dict.genericShowArgs;\n    };\n    var genericShowConstructor = function(dictGenericShowArgs) {\n        var genericShowArgs1 = genericShowArgs(dictGenericShowArgs);\n        return function(dictIsSymbol) {\n            var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n            return {\n                \"genericShow'\": function(v) {\n                    var ctor = reflectSymbol2($$Proxy.value);\n                    var v1 = genericShowArgs1(v);\n                    if (v1.length === 0) return ctor;\n                    return \"(\" + (intercalate3(\" \")(append5([\n                        ctor\n                    ])(v1)) + \")\");\n                }\n            };\n        };\n    };\n    var genericShow$prime = function(dict) {\n        return dict[\"genericShow'\"];\n    };\n    var genericShowSum = function(dictGenericShow) {\n        var genericShow$prime1 = genericShow$prime(dictGenericShow);\n        return function(dictGenericShow1) {\n            var genericShow$prime2 = genericShow$prime(dictGenericShow1);\n            return {\n                \"genericShow'\": function(v) {\n                    if (v instanceof Inl) return genericShow$prime1(v.value0);\n                    if (v instanceof Inr) return genericShow$prime2(v.value0);\n                    throw new Error(\"Failed pattern match at Data.Show.Generic (line 26, column 1 - line 28, column 40): \" + [\n                        v.constructor.name\n                    ]);\n                }\n            };\n        };\n    };\n    var genericShow = function(dictGeneric) {\n        var from3 = from(dictGeneric);\n        return function(dictGenericShow) {\n            var genericShow$prime1 = genericShow$prime(dictGenericShow);\n            return function(x) {\n                return genericShow$prime1(from3(x));\n            };\n        };\n    };\n    // node_modules/uuid/dist/esm-browser/rng.js\n    var getRandomValues;\n    var rnds8 = new Uint8Array(16);\n    function rng() {\n        if (!getRandomValues) {\n            getRandomValues = typeof crypto !== \"undefined\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n            if (!getRandomValues) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n        }\n        return getRandomValues(rnds8);\n    }\n    // node_modules/uuid/dist/esm-browser/regex.js\n    var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n    // node_modules/uuid/dist/esm-browser/validate.js\n    function validate(uuid) {\n        return typeof uuid === \"string\" && regex_default.test(uuid);\n    }\n    var validate_default = validate;\n    // node_modules/uuid/dist/esm-browser/stringify.js\n    var byteToHex = [];\n    for(let i2 = 0; i2 < 256; ++i2)byteToHex.push((i2 + 256).toString(16).slice(1));\n    function unsafeStringify(arr, offset = 0) {\n        return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n    }\n    // node_modules/uuid/dist/esm-browser/parse.js\n    function parse(uuid) {\n        if (!validate_default(uuid)) throw TypeError(\"Invalid UUID\");\n        let v;\n        const arr = new Uint8Array(16);\n        arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n        arr[1] = v >>> 16 & 255;\n        arr[2] = v >>> 8 & 255;\n        arr[3] = v & 255;\n        arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n        arr[5] = v & 255;\n        arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n        arr[7] = v & 255;\n        arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n        arr[9] = v & 255;\n        arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;\n        arr[11] = v / 4294967296 & 255;\n        arr[12] = v >>> 24 & 255;\n        arr[13] = v >>> 16 & 255;\n        arr[14] = v >>> 8 & 255;\n        arr[15] = v & 255;\n        return arr;\n    }\n    var parse_default = parse;\n    // node_modules/uuid/dist/esm-browser/v35.js\n    function stringToBytes(str) {\n        str = unescape(encodeURIComponent(str));\n        const bytes = [];\n        for(let i2 = 0; i2 < str.length; ++i2)bytes.push(str.charCodeAt(i2));\n        return bytes;\n    }\n    var DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n    var URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\n    function v35(name15, version, hashfunc) {\n        function generateUUID(value15, namespace, buf, offset) {\n            var _namespace;\n            if (typeof value15 === \"string\") value15 = stringToBytes(value15);\n            if (typeof namespace === \"string\") namespace = parse_default(namespace);\n            if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n            let bytes = new Uint8Array(16 + value15.length);\n            bytes.set(namespace);\n            bytes.set(value15, namespace.length);\n            bytes = hashfunc(bytes);\n            bytes[6] = bytes[6] & 15 | version;\n            bytes[8] = bytes[8] & 63 | 128;\n            if (buf) {\n                offset = offset || 0;\n                for(let i2 = 0; i2 < 16; ++i2)buf[offset + i2] = bytes[i2];\n                return buf;\n            }\n            return unsafeStringify(bytes);\n        }\n        try {\n            generateUUID.name = name15;\n        } catch (err) {}\n        generateUUID.DNS = DNS;\n        generateUUID.URL = URL;\n        return generateUUID;\n    }\n    // node_modules/uuid/dist/esm-browser/native.js\n    var randomUUID = typeof crypto !== \"undefined\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n    var native_default = {\n        randomUUID: randomUUID\n    };\n    // node_modules/uuid/dist/esm-browser/v4.js\n    function v4(options2, buf, offset) {\n        if (native_default.randomUUID && !buf && !options2) return native_default.randomUUID();\n        options2 = options2 || {};\n        const rnds = options2.random || (options2.rng || rng)();\n        rnds[6] = rnds[6] & 15 | 64;\n        rnds[8] = rnds[8] & 63 | 128;\n        if (buf) {\n            offset = offset || 0;\n            for(let i2 = 0; i2 < 16; ++i2)buf[offset + i2] = rnds[i2];\n            return buf;\n        }\n        return unsafeStringify(rnds);\n    }\n    var v4_default = v4;\n    // node_modules/uuid/dist/esm-browser/sha1.js\n    function f(s, x, y, z) {\n        switch(s){\n            case 0:\n                return x & y ^ ~x & z;\n            case 1:\n                return x ^ y ^ z;\n            case 2:\n                return x & y ^ x & z ^ y & z;\n            case 3:\n                return x ^ y ^ z;\n        }\n    }\n    function ROTL(x, n) {\n        return x << n | x >>> 32 - n;\n    }\n    function sha1(bytes) {\n        const K = [\n            1518500249,\n            1859775393,\n            2400959708,\n            3395469782\n        ];\n        const H = [\n            1732584193,\n            4023233417,\n            2562383102,\n            271733878,\n            3285377520\n        ];\n        if (typeof bytes === \"string\") {\n            const msg = unescape(encodeURIComponent(bytes));\n            bytes = [];\n            for(let i2 = 0; i2 < msg.length; ++i2)bytes.push(msg.charCodeAt(i2));\n        } else if (!Array.isArray(bytes)) bytes = Array.prototype.slice.call(bytes);\n        bytes.push(128);\n        const l = bytes.length / 4 + 2;\n        const N = Math.ceil(l / 16);\n        const M = new Array(N);\n        for(let i2 = 0; i2 < N; ++i2){\n            const arr = new Uint32Array(16);\n            for(let j = 0; j < 16; ++j)arr[j] = bytes[i2 * 64 + j * 4] << 24 | bytes[i2 * 64 + j * 4 + 1] << 16 | bytes[i2 * 64 + j * 4 + 2] << 8 | bytes[i2 * 64 + j * 4 + 3];\n            M[i2] = arr;\n        }\n        M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n        M[N - 1][14] = Math.floor(M[N - 1][14]);\n        M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n        for(let i2 = 0; i2 < N; ++i2){\n            const W = new Uint32Array(80);\n            for(let t = 0; t < 16; ++t)W[t] = M[i2][t];\n            for(let t = 16; t < 80; ++t)W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n            let a2 = H[0];\n            let b2 = H[1];\n            let c = H[2];\n            let d = H[3];\n            let e = H[4];\n            for(let t = 0; t < 80; ++t){\n                const s = Math.floor(t / 20);\n                const T = ROTL(a2, 5) + f(s, b2, c, d) + e + K[s] + W[t] >>> 0;\n                e = d;\n                d = c;\n                c = ROTL(b2, 30) >>> 0;\n                b2 = a2;\n                a2 = T;\n            }\n            H[0] = H[0] + a2 >>> 0;\n            H[1] = H[1] + b2 >>> 0;\n            H[2] = H[2] + c >>> 0;\n            H[3] = H[3] + d >>> 0;\n            H[4] = H[4] + e >>> 0;\n        }\n        return [\n            H[0] >> 24 & 255,\n            H[0] >> 16 & 255,\n            H[0] >> 8 & 255,\n            H[0] & 255,\n            H[1] >> 24 & 255,\n            H[1] >> 16 & 255,\n            H[1] >> 8 & 255,\n            H[1] & 255,\n            H[2] >> 24 & 255,\n            H[2] >> 16 & 255,\n            H[2] >> 8 & 255,\n            H[2] & 255,\n            H[3] >> 24 & 255,\n            H[3] >> 16 & 255,\n            H[3] >> 8 & 255,\n            H[3] & 255,\n            H[4] >> 24 & 255,\n            H[4] >> 16 & 255,\n            H[4] >> 8 & 255,\n            H[4] & 255\n        ];\n    }\n    var sha1_default = sha1;\n    // node_modules/uuid/dist/esm-browser/v5.js\n    var v5 = v35(\"v5\", 80, sha1_default);\n    var v5_default = v5;\n    // output/Data.UUID/foreign.js\n    var getUUIDImpl = v4_default;\n    var getUUID5Impl = function(str) {\n        return function(namespace) {\n            return v5_default(str, namespace);\n        };\n    };\n    var validateV4UUID = validate_default;\n    // output/Data.UUID/index.js\n    var compare2 = /* @__PURE__ */ compare(ordString);\n    var UUID = function(x) {\n        return x;\n    };\n    var toString3 = function(v) {\n        return v;\n    };\n    var parseUUID = function(str) {\n        var v = validateV4UUID(str);\n        if (v) return new Just(str);\n        return Nothing.value;\n    };\n    var genv5UUID = function(s) {\n        return function(v) {\n            return getUUID5Impl(s)(v);\n        };\n    };\n    var genUUID = /* @__PURE__ */ bind(bindEffect)(getUUIDImpl)(/* @__PURE__ */ function() {\n        var $30 = pure(applicativeEffect);\n        return function($31) {\n            return $30(UUID($31));\n        };\n    }());\n    var eqUUID = {\n        eq: function(x) {\n            return function(y) {\n                return x === y;\n            };\n        }\n    };\n    var ordUUID = {\n        compare: function(x) {\n            return function(y) {\n                return compare2(x)(y);\n            };\n        },\n        Eq0: function() {\n            return eqUUID;\n        }\n    };\n    var emptyUUID = \"00000000-0000-0000-0000-000000000000\";\n    // output/TcgCalculator.Types.Id/index.js\n    var eq3 = /* @__PURE__ */ eq(eqUUID);\n    var compare3 = /* @__PURE__ */ compare(ordUUID);\n    var encodeJson2 = /* @__PURE__ */ encodeJson(encodeJsonJString);\n    var mapFlipped3 = /* @__PURE__ */ mapFlipped(functorEither);\n    var decodeJson2 = /* @__PURE__ */ decodeJson(decodeJsonString);\n    var map19 = /* @__PURE__ */ map(functorEffect);\n    var Id = function(x) {\n        return x;\n    };\n    var eqId = {\n        eq: function(x) {\n            return function(y) {\n                return eq3(x)(y);\n            };\n        }\n    };\n    var ordId = {\n        compare: function(x) {\n            return function(y) {\n                return compare3(x)(y);\n            };\n        },\n        Eq0: function() {\n            return eqId;\n        }\n    };\n    var encodeJsonId = {\n        encodeJson: function(v) {\n            return encodeJson2(toString3(v));\n        }\n    };\n    var toString4 = function(v) {\n        return toString3(v);\n    };\n    var namespaceTcgCalculator = /* @__PURE__ */ genv5UUID(\"tcg-calculator\")(emptyUUID);\n    var mkId = function(s) {\n        return genv5UUID(s)(namespaceTcgCalculator);\n    };\n    var decodeJsonId = {\n        decodeJson: function(json) {\n            return mapFlipped3(decodeJson2(json))(function(id3) {\n                return maybe$prime(function(v) {\n                    return mkId(id3);\n                })(Id)(parseUUID(id3));\n            });\n        }\n    };\n    var generateId = function(dictMonadEffect) {\n        return liftEffect(dictMonadEffect)(map19(Id)(genUUID));\n    };\n    var fromString3 = /* @__PURE__ */ function() {\n        var $36 = map(functorMaybe)(Id);\n        return function($37) {\n            return $36(parseUUID($37));\n        };\n    }();\n    // output/TcgCalculator.Types/index.js\n    var genericShowConstructor2 = /* @__PURE__ */ genericShowConstructor(genericShowArgsNoArguments);\n    var cardsIsSymbol = {\n        reflectSymbol: function() {\n            return \"cards\";\n        }\n    };\n    var countIsSymbol = {\n        reflectSymbol: function() {\n            return \"count\";\n        }\n    };\n    var modeIsSymbol = {\n        reflectSymbol: function() {\n            return \"mode\";\n        }\n    };\n    var idIsSymbol = {\n        reflectSymbol: function() {\n            return \"id\";\n        }\n    };\n    var nameIsSymbol = {\n        reflectSymbol: function() {\n            return \"name\";\n        }\n    };\n    var gEncodeJsonCons2 = /* @__PURE__ */ gEncodeJsonCons(encodeJsonInt);\n    var bindFlipped4 = /* @__PURE__ */ bindFlipped(bindEither);\n    var decodeJson3 = /* @__PURE__ */ decodeJson(decodeJsonString);\n    var AtLeast = /* @__PURE__ */ function() {\n        function AtLeast2() {}\n        AtLeast2.value = new AtLeast2();\n        return AtLeast2;\n    }();\n    var JustDraw = /* @__PURE__ */ function() {\n        function JustDraw2() {}\n        JustDraw2.value = new JustDraw2();\n        return JustDraw2;\n    }();\n    var Remains = /* @__PURE__ */ function() {\n        function Remains2() {}\n        Remains2.value = new Remains2();\n        return Remains2;\n    }();\n    var JustRemains = /* @__PURE__ */ function() {\n        function JustRemains2() {}\n        JustRemains2.value = new JustRemains2();\n        return JustRemains2;\n    }();\n    var Choice = /* @__PURE__ */ function() {\n        function Choice2() {}\n        Choice2.value = new Choice2();\n        return Choice2;\n    }();\n    var LeftOne = /* @__PURE__ */ function() {\n        function LeftOne2() {}\n        LeftOne2.value = new LeftOne2();\n        return LeftOne2;\n    }();\n    var LeftAll = /* @__PURE__ */ function() {\n        function LeftAll2() {}\n        LeftAll2.value = new LeftAll2();\n        return LeftAll2;\n    }();\n    var Condition = function(x) {\n        return x;\n    };\n    var genericConditionMode_ = {\n        to: function(x) {\n            if (x instanceof Inl) return AtLeast.value;\n            if (x instanceof Inr && x.value0 instanceof Inl) return JustDraw.value;\n            if (x instanceof Inr && x.value0 instanceof Inr && x.value0.value0 instanceof Inl) return Remains.value;\n            if (x instanceof Inr && x.value0 instanceof Inr && x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inl) return JustRemains.value;\n            if (x instanceof Inr && x.value0 instanceof Inr && x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0 instanceof Inl) return Choice.value;\n            if (x instanceof Inr && x.value0 instanceof Inr && x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0.value0 instanceof Inl) return LeftOne.value;\n            if (x instanceof Inr && x.value0 instanceof Inr && x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0.value0 instanceof Inr) return LeftAll.value;\n            throw new Error(\"Failed pattern match at TcgCalculator.Types (line 46, column 1 - line 46, column 40): \" + [\n                x.constructor.name\n            ]);\n        },\n        from: function(x) {\n            if (x instanceof AtLeast) return new Inl(NoArguments.value);\n            if (x instanceof JustDraw) return new Inr(new Inl(NoArguments.value));\n            if (x instanceof Remains) return new Inr(new Inr(new Inl(NoArguments.value)));\n            if (x instanceof JustRemains) return new Inr(new Inr(new Inr(new Inl(NoArguments.value))));\n            if (x instanceof Choice) return new Inr(new Inr(new Inr(new Inr(new Inl(NoArguments.value)))));\n            if (x instanceof LeftOne) return new Inr(new Inr(new Inr(new Inr(new Inr(new Inl(NoArguments.value))))));\n            if (x instanceof LeftAll) return new Inr(new Inr(new Inr(new Inr(new Inr(new Inr(NoArguments.value))))));\n            throw new Error(\"Failed pattern match at TcgCalculator.Types (line 46, column 1 - line 46, column 40): \" + [\n                x.constructor.name\n            ]);\n        }\n    };\n    var showConditionMode = {\n        show: /* @__PURE__ */ genericShow(genericConditionMode_)(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n            reflectSymbol: function() {\n                return \"AtLeast\";\n            }\n        }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n            reflectSymbol: function() {\n                return \"JustDraw\";\n            }\n        }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n            reflectSymbol: function() {\n                return \"Remains\";\n            }\n        }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n            reflectSymbol: function() {\n                return \"JustRemains\";\n            }\n        }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n            reflectSymbol: function() {\n                return \"Choice\";\n            }\n        }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n            reflectSymbol: function() {\n                return \"LeftOne\";\n            }\n        }))(/* @__PURE__ */ genericShowConstructor2({\n            reflectSymbol: function() {\n                return \"LeftAll\";\n            }\n        }))))))))\n    };\n    var encodeJsonConditionMode = {\n        encodeJson: /* @__PURE__ */ function() {\n            var $231 = encodeJson(encodeJsonJString);\n            var $232 = show(showConditionMode);\n            return function($233) {\n                return $231($232($233));\n            };\n        }()\n    };\n    var encodeJsonCondition = /* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons2(/* @__PURE__ */ gEncodeJsonCons(encodeJsonId)(/* @__PURE__ */ gEncodeJsonCons(encodeJsonJString)(gEncodeJsonNil)(nameIsSymbol)())(idIsSymbol)())(countIsSymbol)())()))(/* @__PURE__ */ gEncodeJsonCons2(/* @__PURE__ */ gEncodeJsonCons(encodeJsonConditionMode)(gEncodeJsonNil)(modeIsSymbol)())(countIsSymbol)())(cardsIsSymbol)())();\n    var readConditionMode = function(v) {\n        if (v === \"AtLeast\") return new Just(AtLeast.value);\n        if (v === \"JustDraw\") return new Just(JustDraw.value);\n        if (v === \"Remains\") return new Just(Remains.value);\n        if (v === \"JustRemains\") return new Just(JustRemains.value);\n        if (v === \"Choice\") return new Just(Choice.value);\n        if (v === \"LeftOne\") return new Just(LeftOne.value);\n        if (v === \"LeftAll\") return new Just(LeftAll.value);\n        return Nothing.value;\n    };\n    var decodeJsonConditionMode = {\n        decodeJson: function(json) {\n            return bindFlipped4(function() {\n                var $234 = note(new UnexpectedValue(json));\n                return function($235) {\n                    return $234(readConditionMode($235));\n                };\n            }())(decodeJson3(json));\n        }\n    };\n    // output/Web.UIEvent.FocusEvent/index.js\n    var toEvent = unsafeCoerce2;\n    // output/App.ConditionLine/index.js\n    var value3 = /* @__PURE__ */ value2(isPropString);\n    var show4 = /* @__PURE__ */ show(showConditionMode);\n    var mapFlipped4 = /* @__PURE__ */ mapFlipped(functorArray);\n    var selectorIsSymbol = {\n        reflectSymbol: function() {\n            return \"selector\";\n        }\n    };\n    var slot2 = /* @__PURE__ */ slot()(selectorIsSymbol)(ordUnit);\n    var component1 = /* @__PURE__ */ component(eqId);\n    var type_4 = /* @__PURE__ */ type_3(isPropInputType);\n    var show13 = /* @__PURE__ */ show(showInt);\n    var alaF2 = /* @__PURE__ */ alaF()()()();\n    var foldMap3 = /* @__PURE__ */ foldMap2(/* @__PURE__ */ monoidAdditive(semiringInt));\n    var min5 = /* @__PURE__ */ min(ordInt);\n    var map20 = /* @__PURE__ */ map(/* @__PURE__ */ functorMaybeT(functorHalogenM));\n    var gets3 = /* @__PURE__ */ gets(/* @__PURE__ */ monadStateMaybeT(monadStateHalogenM));\n    var lift4 = /* @__PURE__ */ lift(monadTransMaybeT)(monadHalogenM);\n    var discard3 = /* @__PURE__ */ discard(discardUnit)(bindHalogenM);\n    var put3 = /* @__PURE__ */ put(monadStateHalogenM);\n    var elem3 = /* @__PURE__ */ elem2(/* @__PURE__ */ eqRec()(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(eqRowNil)()({\n        reflectSymbol: function() {\n            return \"name\";\n        }\n    })(eqString))()({\n        reflectSymbol: function() {\n            return \"id\";\n        }\n    })(eqId))()({\n        reflectSymbol: function() {\n            return \"count\";\n        }\n    })(eqInt)));\n    var tell3 = /* @__PURE__ */ tell2()(selectorIsSymbol)(ordUnit);\n    var pure6 = /* @__PURE__ */ pure(applicativeHalogenM);\n    var clamp2 = /* @__PURE__ */ clamp(ordInt);\n    var bind6 = /* @__PURE__ */ bind(bindHalogenM);\n    var get3 = /* @__PURE__ */ get(monadStateHalogenM);\n    var elem1 = /* @__PURE__ */ elem2(eqId);\n    var traverse_4 = /* @__PURE__ */ traverse_(applicativeHalogenM)(foldableMaybe);\n    var modify6 = /* @__PURE__ */ modify2(monadStateHalogenM);\n    var composeKleisliFlipped4 = /* @__PURE__ */ composeKleisliFlipped(bindMaybe);\n    var liftEffect3 = /* @__PURE__ */ liftEffect(/* @__PURE__ */ monadEffectHalogenM(monadEffectAff));\n    var traverse_12 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableMaybe);\n    var GetCondition = /* @__PURE__ */ function() {\n        function GetCondition2(value0) {\n            this.value0 = value0;\n        }\n        GetCondition2.create = function(value0) {\n            return new GetCondition2(value0);\n        };\n        return GetCondition2;\n    }();\n    var RestoreState = /* @__PURE__ */ function() {\n        function RestoreState4(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        RestoreState4.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new RestoreState4(value0, value1, value22);\n                };\n            };\n        };\n        return RestoreState4;\n    }();\n    var Updated = /* @__PURE__ */ function() {\n        function Updated3() {}\n        Updated3.value = new Updated3();\n        return Updated3;\n    }();\n    var Initialize2 = /* @__PURE__ */ function() {\n        function Initialize5() {}\n        Initialize5.value = new Initialize5();\n        return Initialize5;\n    }();\n    var UpdateConditionMode = /* @__PURE__ */ function() {\n        function UpdateConditionMode2(value0) {\n            this.value0 = value0;\n        }\n        UpdateConditionMode2.create = function(value0) {\n            return new UpdateConditionMode2(value0);\n        };\n        return UpdateConditionMode2;\n    }();\n    var UpdateCardSelected = /* @__PURE__ */ function() {\n        function UpdateCardSelected2(value0) {\n            this.value0 = value0;\n        }\n        UpdateCardSelected2.create = function(value0) {\n            return new UpdateCardSelected2(value0);\n        };\n        return UpdateCardSelected2;\n    }();\n    var UpdateCardCount = /* @__PURE__ */ function() {\n        function UpdateCardCount2(value0) {\n            this.value0 = value0;\n        }\n        UpdateCardCount2.create = function(value0) {\n            return new UpdateCardCount2(value0);\n        };\n        return UpdateCardCount2;\n    }();\n    var Receive3 = /* @__PURE__ */ function() {\n        function Receive5(value0) {\n            this.value0 = value0;\n        }\n        Receive5.create = function(value0) {\n            return new Receive5(value0);\n        };\n        return Receive5;\n    }();\n    var SelectOnFocus = /* @__PURE__ */ function() {\n        function SelectOnFocus3(value0) {\n            this.value0 = value0;\n        }\n        SelectOnFocus3.create = function(value0) {\n            return new SelectOnFocus3(value0);\n        };\n        return SelectOnFocus3;\n    }();\n    var component2 = /* @__PURE__ */ function() {\n        var renderModeSelector = function(mode) {\n            return select([\n                classes([\n                    \"w-full appearance-none rounded border border-gray-400 bg-transparent px-3 py-1\",\n                    \"transition ease-in-out hover:border-gray-500 focus:border-blue-600 focus:outline-none\"\n                ]),\n                value3(show4(mode)),\n                onValueChange(UpdateConditionMode.create)\n            ])([\n                option([\n                    value3(show4(AtLeast.value))\n                ])([\n                    text(\"\\u679A\\u4EE5\\u4E0A\\u30C9\\u30ED\\u30FC\\u3059\\u308B\")\n                ]),\n                option([\n                    value3(show4(JustDraw.value))\n                ])([\n                    text(\"\\u679A\\u3061\\u3087\\u3046\\u3069\\u30C9\\u30ED\\u30FC\\u3059\\u308B\")\n                ]),\n                option([\n                    value3(show4(Remains.value))\n                ])([\n                    text(\"\\u679A\\u4EE5\\u4E0A\\u30C7\\u30C3\\u30AD\\u306B\\u6B8B\\u3059\")\n                ]),\n                option([\n                    value3(show4(JustRemains.value))\n                ])([\n                    text(\"\\u679A\\u3061\\u3087\\u3046\\u3069\\u30C7\\u30C3\\u30AD\\u306B\\u6B8B\\u3059\")\n                ]),\n                option([\n                    value3(show4(Choice.value))\n                ])([\n                    text(\"\\u7A2E\\u985E\\u4EE5\\u4E0A\\u30C9\\u30ED\\u30FC\\u3059\\u308B\")\n                ]),\n                option([\n                    value3(show4(LeftOne.value))\n                ])([\n                    text(\"\\u7A2E\\u985E\\u4EE5\\u4E0A\\u30C7\\u30C3\\u30AD\\u306B\\u6B8B\\u3059\")\n                ]),\n                option([\n                    value3(show4(LeftAll.value))\n                ])([\n                    text(\"\\u7A2E\\u985E\\u4EE5\\u4E0A\\u30C9\\u30ED\\u30FC\\u3057\\u306A\\u3044\")\n                ])\n            ]);\n        };\n        var renderCardSelector = function(cards) {\n            var cards$prime = mapFlipped4(cards)(function(card) {\n                return {\n                    id: card.id,\n                    value: card.name\n                };\n            });\n            return slot2($$Proxy.value)(unit)(component1)(cards$prime)(UpdateCardSelected.create);\n        };\n        var renderCardCounter = function(count) {\n            return function(min1) {\n                return function(max7) {\n                    return input([\n                        classes([\n                            \"w-12 appearance-none rounded border border-gray-400 bg-transparent p-1 text-right\",\n                            \"transition ease-in-out hover:border-gray-500 focus:border-blue-600 focus:outline-none\"\n                        ]),\n                        type_4(InputNumber.value),\n                        step3(new Step(1)),\n                        value3(show13(count)),\n                        min4(toNumber(min1)),\n                        max4(toNumber(max7)),\n                        onFocus(SelectOnFocus.create),\n                        onValueChange(UpdateCardCount.create)\n                    ]);\n                };\n            };\n        };\n        var render = function(v) {\n            return div2([\n                class_(\"flex flex-wrap items-center justify-end\")\n            ])([\n                div2([\n                    class_(\"w-48 grow rounded border p-0.5\")\n                ])([\n                    renderCardSelector(v.cards)\n                ]),\n                div2([\n                    class_(\"flex items-center\")\n                ])([\n                    div2([\n                        class_(\"mx-1\")\n                    ])([\n                        text(\"\\u3092\")\n                    ]),\n                    renderCardCounter(v.condition.count)(v.minValue)(v.maxValue),\n                    renderModeSelector(v.condition.mode)\n                ])\n            ]);\n        };\n        var initialState = function(v) {\n            return {\n                cards: v,\n                condition: {\n                    mode: AtLeast.value,\n                    count: 0,\n                    cards: []\n                },\n                minValue: 0,\n                maxValue: 0\n            };\n        };\n        var getMinMax = function(cards) {\n            var countCards = alaF2(Additive)(foldMap3)(function(v) {\n                return v.count;\n            });\n            return function(v) {\n                if (v instanceof AtLeast) {\n                    var max7 = countCards(cards);\n                    return {\n                        min: min5(1)(max7),\n                        max: max7\n                    };\n                }\n                if (v instanceof JustDraw) {\n                    var max7 = countCards(cards);\n                    return {\n                        min: 0,\n                        max: max7\n                    };\n                }\n                if (v instanceof Remains) {\n                    var max7 = countCards(cards);\n                    return {\n                        min: min5(1)(max7),\n                        max: max7\n                    };\n                }\n                if (v instanceof JustRemains) {\n                    var max7 = countCards(cards);\n                    return {\n                        min: 0,\n                        max: max7\n                    };\n                }\n                if (v instanceof Choice) {\n                    var max7 = length(cards);\n                    return {\n                        min: min5(1)(max7),\n                        max: max7\n                    };\n                }\n                if (v instanceof LeftOne) {\n                    var max7 = length(cards);\n                    return {\n                        min: min5(1)(max7),\n                        max: max7\n                    };\n                }\n                if (v instanceof LeftAll) {\n                    var max7 = length(cards);\n                    return {\n                        min: min5(1)(max7),\n                        max: max7\n                    };\n                }\n                throw new Error(\"Failed pattern match at App.ConditionLine (line 143, column 21 - line 164, column 30): \" + [\n                    v.constructor.name\n                ]);\n            };\n        };\n        var query3 = function(v) {\n            if (v instanceof GetCondition) return map20(function($133) {\n                return v.value0(Condition($133));\n            })(gets3(function(v1) {\n                return v1.condition;\n            }));\n            if (v instanceof RestoreState) return lift4(function() {\n                var v1 = getMinMax(v.value1.cards)(v.value1.mode);\n                return discard3(put3({\n                    cards: v.value0,\n                    condition: v.value1,\n                    minValue: v1.min,\n                    maxValue: v1.max\n                }))(function() {\n                    var items3 = mapFlipped4(v.value0)(function(card) {\n                        return {\n                            id: card.id,\n                            value: card.name,\n                            selected: elem3(card)(v.value1.cards)\n                        };\n                    });\n                    return discard3(tell3($$Proxy.value)(unit)(SetItems.create(items3)))(function() {\n                        return pure6(v.value2);\n                    });\n                });\n            }());\n            throw new Error(\"Failed pattern match at App.ConditionLine (line 169, column 11 - line 177, column 13): \" + [\n                v.constructor.name\n            ]);\n        };\n        var action2 = /* @__PURE__ */ function() {\n            var updateStatus = function(cards) {\n                return function(selected2) {\n                    return function(mode) {\n                        return function(count) {\n                            var v = getMinMax(selected2)(mode);\n                            return put3({\n                                cards: cards,\n                                condition: {\n                                    mode: mode,\n                                    cards: selected2,\n                                    count: clamp2(v.min)(v.max)(count)\n                                },\n                                minValue: v.min,\n                                maxValue: v.max\n                            });\n                        };\n                    };\n                };\n            };\n            var updateCardSelected = function(selected2) {\n                return bind6(get3)(function(v) {\n                    var selected$prime = filter(function(v1) {\n                        return elem1(v1.id)(selected2);\n                    })(v.cards);\n                    return updateStatus(v.cards)(selected$prime)(v.condition.mode)(v.condition.count);\n                });\n            };\n            return function(v) {\n                if (v instanceof Initialize2) return bind6(get3)(function(v1) {\n                    return updateStatus(v1.cards)(v1.condition.cards)(v1.condition.mode)(v1.condition.count);\n                });\n                if (v instanceof UpdateCardSelected) return discard3(updateCardSelected(v.value0))(function() {\n                    return raise(Updated.value);\n                });\n                if (v instanceof UpdateConditionMode) return traverse_4(function(mode$prime) {\n                    return bind6(get3)(function(v1) {\n                        return discard3(updateStatus(v1.cards)(v1.condition.cards)(mode$prime)(v1.condition.count))(function() {\n                            return raise(Updated.value);\n                        });\n                    });\n                })(readConditionMode(v.value0));\n                if (v instanceof UpdateCardCount) return traverse_4(function(count$prime) {\n                    return bind6(get3)(function(v1) {\n                        return discard3(updateStatus(v1.cards)(v1.condition.cards)(v1.condition.mode)(count$prime))(function() {\n                            return raise(Updated.value);\n                        });\n                    });\n                })(fromString(v.value0));\n                if (v instanceof Receive3) return bind6(modify6(function(v1) {\n                    var $125 = {};\n                    for(var $126 in v1)if (({}).hasOwnProperty.call(v1, $126)) $125[$126] = v1[$126];\n                    $125.cards = v.value0;\n                    return $125;\n                }))(function(v1) {\n                    return updateCardSelected(mapFlipped4(v1.condition.cards)(function(v2) {\n                        return v2.id;\n                    }));\n                });\n                if (v instanceof SelectOnFocus) {\n                    var element3 = composeKleisliFlipped4(fromEventTarget)(function($134) {\n                        return target(toEvent($134));\n                    })(v.value0);\n                    return liftEffect3(traverse_12(select2)(element3));\n                }\n                throw new Error(\"Failed pattern match at App.ConditionLine (line 110, column 12 - line 132, column 52): \" + [\n                    v.constructor.name\n                ]);\n            };\n        }();\n        return mkComponent({\n            initialState: initialState,\n            render: render,\n            \"eval\": mkEval({\n                finalize: defaultEval.finalize,\n                handleAction: action2,\n                handleQuery: function($135) {\n                    return runMaybeT(query3($135));\n                },\n                initialize: new Just(Initialize2.value),\n                receive: function($136) {\n                    return Just.create(Receive3.create($136));\n                }\n            })\n        });\n    }();\n    // output/Data.BigInt/foreign.js\n    var import_big_integer = __toESM(require_BigInteger(), 1);\n    function fromBaseImpl(just) {\n        return function(nothing) {\n            return function(b2) {\n                return function(s) {\n                    try {\n                        var x = (0, import_big_integer.default)(s, b2);\n                        return just(x);\n                    } catch (err) {\n                        return nothing;\n                    }\n                };\n            };\n        };\n    }\n    function fromInt(n) {\n        return (0, import_big_integer.default)(n);\n    }\n    function toBase(base2) {\n        return function(x) {\n            return x.toString(base2);\n        };\n    }\n    function toNumber2(x) {\n        return x.toJSNumber();\n    }\n    function biAdd(x) {\n        return function(y) {\n            return x.add(y);\n        };\n    }\n    function biMul(x) {\n        return function(y) {\n            return x.multiply(y);\n        };\n    }\n    function biSub(x) {\n        return function(y) {\n            return x.minus(y);\n        };\n    }\n    function biMod(x) {\n        return function(y) {\n            return x.mod(y);\n        };\n    }\n    function biDiv(x) {\n        return function(y) {\n            return x.divide(y);\n        };\n    }\n    function biEquals(x) {\n        return function(y) {\n            return x.equals(y);\n        };\n    }\n    function abs3(x) {\n        return x.abs();\n    }\n    // output/Data.BigInt/index.js\n    var toString5 = /* @__PURE__ */ toBase(10);\n    var semiringBigInt = {\n        add: biAdd,\n        zero: /* @__PURE__ */ fromInt(0),\n        mul: biMul,\n        one: /* @__PURE__ */ fromInt(1)\n    };\n    var add2 = /* @__PURE__ */ add(semiringBigInt);\n    var ringBigInt = {\n        sub: biSub,\n        Semiring0: function() {\n            return semiringBigInt;\n        }\n    };\n    var sub3 = /* @__PURE__ */ sub(ringBigInt);\n    var fromBase = /* @__PURE__ */ function() {\n        return fromBaseImpl(Just.create)(Nothing.value);\n    }();\n    var fromString4 = /* @__PURE__ */ fromBase(10);\n    var eqBigInt = {\n        eq: biEquals\n    };\n    var commutativeRingBigInt = {\n        Ring0: function() {\n            return ringBigInt;\n        }\n    };\n    var euclideanRingBigInt = {\n        div: function(x) {\n            return function(y) {\n                return biDiv(sub3(x)(mod(euclideanRingBigInt)(x)(y)))(y);\n            };\n        },\n        mod: function(x) {\n            return function(y) {\n                var yy = abs3(y);\n                return biMod(add2(biMod(x)(yy))(yy))(yy);\n            };\n        },\n        degree: function($13) {\n            return floor2(toNumber2(abs3($13)));\n        },\n        CommutativeRing0: function() {\n            return commutativeRingBigInt;\n        }\n    };\n    // output/Web.HTML.Event.ErrorEvent/foreign.js\n    function message2(e) {\n        return e.message;\n    }\n    // output/Web.HTML.Event.ErrorEvent/index.js\n    var fromEvent = /* @__PURE__ */ unsafeReadProtoTagged(\"ErrorEvent\");\n    // output/Web.Worker.MessageEvent/foreign.js\n    function data_(ev) {\n        return ev.data;\n    }\n    // output/Web.Worker.Worker/foreign.js\n    function _new2(src9) {\n        return function(opts) {\n            return function() {\n                return new Worker(src9, opts);\n            };\n        };\n    }\n    function postMessageImpl(data) {\n        return function(transfer) {\n            return function(worker) {\n                return function() {\n                    worker.postMessage(data, transfer.length > 0 ? transfer : void 0);\n                };\n            };\n        };\n    }\n    function terminate(worker) {\n        return function() {\n            worker.terminate();\n        };\n    }\n    function onMessage(f2) {\n        return function(worker) {\n            return function() {\n                worker.onmessage = function(ev) {\n                    f2(ev)();\n                };\n            };\n        };\n    }\n    function onError(f2) {\n        return function(worker) {\n            return function() {\n                worker.onerror = function(ev) {\n                    f2(ev)();\n                };\n            };\n        };\n    }\n    // output/Web.Worker.Worker/index.js\n    var Classic = /* @__PURE__ */ function() {\n        function Classic2() {}\n        Classic2.value = new Classic2();\n        return Classic2;\n    }();\n    var Module = /* @__PURE__ */ function() {\n        function Module2() {}\n        Module2.value = new Module2();\n        return Module2;\n    }();\n    var Omit = /* @__PURE__ */ function() {\n        function Omit2() {}\n        Omit2.value = new Omit2();\n        return Omit2;\n    }();\n    var SameOrigin = /* @__PURE__ */ function() {\n        function SameOrigin2() {}\n        SameOrigin2.value = new SameOrigin2();\n        return SameOrigin2;\n    }();\n    var Include = /* @__PURE__ */ function() {\n        function Include2() {}\n        Include2.value = new Include2();\n        return Include2;\n    }();\n    var showWorkerType = {\n        show: function(v) {\n            if (v instanceof Classic) return \"classic\";\n            if (v instanceof Module) return \"module\";\n            throw new Error(\"Failed pattern match at Web.Worker.Worker (line 85, column 10 - line 87, column 24): \" + [\n                v.constructor.name\n            ]);\n        }\n    };\n    var show5 = /* @__PURE__ */ show(showWorkerType);\n    var showCredentials = {\n        show: function(v) {\n            if (v instanceof Omit) return \"omit\";\n            if (v instanceof SameOrigin) return \"same-origin\";\n            if (v instanceof Include) return \"include\";\n            throw new Error(\"Failed pattern match at Web.Worker.Worker (line 90, column 10 - line 93, column 28): \" + [\n                v.constructor.name\n            ]);\n        }\n    };\n    var show14 = /* @__PURE__ */ show(showCredentials);\n    var postMessage = function(msg) {\n        return postMessageImpl(msg)([]);\n    };\n    var $$new2 = function(url) {\n        return function(v) {\n            return _new2(url)({\n                name: v.name,\n                credentials: show14(v.credentials),\n                type: show5(v.type)\n            });\n        };\n    };\n    var defaultWorkerOptions = /* @__PURE__ */ function() {\n        return {\n            name: \"\",\n            credentials: Omit.value,\n            type: Classic.value\n        };\n    }();\n    // output/App.Worker/index.js\n    var bind13 = /* @__PURE__ */ bind(bindEither);\n    var lmap4 = /* @__PURE__ */ lmap(bifunctorEither);\n    var intercalateMap2 = /* @__PURE__ */ intercalateMap(foldable1NonEmptyList)(semigroupString);\n    var readString3 = /* @__PURE__ */ readString(monadIdentity);\n    var gEncodeJsonCons3 = /* @__PURE__ */ gEncodeJsonCons(encodeJsonInt);\n    var encodeJson3 = /* @__PURE__ */ encodeJson(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeJsonNonEmptyArray(encodeJsonCondition)))(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons3(/* @__PURE__ */ gEncodeJsonCons(encodeJsonId)(/* @__PURE__ */ gEncodeJsonCons(encodeJsonJString)(gEncodeJsonNil)({\n        reflectSymbol: function() {\n            return \"name\";\n        }\n    })())({\n        reflectSymbol: function() {\n            return \"id\";\n        }\n    })())({\n        reflectSymbol: function() {\n            return \"count\";\n        }\n    })())()))(/* @__PURE__ */ gEncodeJsonCons3(/* @__PURE__ */ gEncodeJsonCons3(gEncodeJsonNil)({\n        reflectSymbol: function() {\n            return \"others\";\n        }\n    })())({\n        reflectSymbol: function() {\n            return \"hand\";\n        }\n    })())({\n        reflectSymbol: function() {\n            return \"cards\";\n        }\n    })())())(gEncodeJsonNil)({\n        reflectSymbol: function() {\n            return \"deck\";\n        }\n    })())({\n        reflectSymbol: function() {\n            return \"conditions\";\n        }\n    })())());\n    var run3 = function(param2) {\n        return makeAff(function(reply) {\n            return function __do2() {\n                var worker = $$new2(\"bundle/worker.js\")({\n                    credentials: defaultWorkerOptions.credentials,\n                    name: defaultWorkerOptions.name,\n                    type: Module.value\n                })();\n                onMessage(function(event) {\n                    return reply(bind13(lmap4(function() {\n                        var $59 = intercalateMap2(\"\\n\")(renderForeignError);\n                        return function($60) {\n                            return error($59($60));\n                        };\n                    }())(runExcept(readString3(data_(event)))))(function(result) {\n                        return note(error(\"BigInt.fromString\"))(fromString4(result));\n                    }));\n                })(worker)();\n                onError(function(event) {\n                    return function __do3() {\n                        terminate(worker)();\n                        var message3 = maybe(\"Unknown worker error\")(message2)(fromEvent(event));\n                        return reply(new Left(error(message3)))();\n                    };\n                })(worker)();\n                postMessage(encodeJson3(param2))(worker)();\n                return effectCanceler(terminate(worker));\n            };\n        });\n    };\n    // output/Data.Number.Format/foreign.js\n    function wrap2(method2) {\n        return function(d) {\n            return function(num) {\n                return method2.apply(num, [\n                    d\n                ]);\n            };\n        };\n    }\n    var toPrecisionNative = wrap2(Number.prototype.toPrecision);\n    var toFixedNative = wrap2(Number.prototype.toFixed);\n    var toExponentialNative = wrap2(Number.prototype.toExponential);\n    // output/Data.Number.Format/index.js\n    var clamp3 = /* @__PURE__ */ clamp(ordInt);\n    var Precision = /* @__PURE__ */ function() {\n        function Precision2(value0) {\n            this.value0 = value0;\n        }\n        Precision2.create = function(value0) {\n            return new Precision2(value0);\n        };\n        return Precision2;\n    }();\n    var Fixed = /* @__PURE__ */ function() {\n        function Fixed2(value0) {\n            this.value0 = value0;\n        }\n        Fixed2.create = function(value0) {\n            return new Fixed2(value0);\n        };\n        return Fixed2;\n    }();\n    var Exponential = /* @__PURE__ */ function() {\n        function Exponential2(value0) {\n            this.value0 = value0;\n        }\n        Exponential2.create = function(value0) {\n            return new Exponential2(value0);\n        };\n        return Exponential2;\n    }();\n    var toStringWith = function(v) {\n        if (v instanceof Precision) return toPrecisionNative(v.value0);\n        if (v instanceof Fixed) return toFixedNative(v.value0);\n        if (v instanceof Exponential) return toExponentialNative(v.value0);\n        throw new Error(\"Failed pattern match at Data.Number.Format (line 59, column 1 - line 59, column 43): \" + [\n            v.constructor.name\n        ]);\n    };\n    var fixed = /* @__PURE__ */ function() {\n        var $9 = clamp3(0)(20);\n        return function($10) {\n            return Fixed.create($9($10));\n        };\n    }();\n    // output/Util.Array/index.js\n    var $$void7 = /* @__PURE__ */ $$void(functorST);\n    var applySecond2 = /* @__PURE__ */ applySecond(applyST);\n    var swapST = function(x) {\n        return function(y) {\n            return function(st) {\n                return function __do2() {\n                    var a2 = peek(x)(st)();\n                    var b2 = peek(y)(st)();\n                    if (a2 instanceof Just && b2 instanceof Just) return $$void7(applySecond2(poke(x)(b2.value0)(st))(poke(y)(a2.value0)(st)))();\n                    return unit;\n                };\n            };\n        };\n    };\n    var swap = function(x) {\n        return function(y) {\n            return function(array) {\n                return run2(function __do2() {\n                    var st = thaw(array)();\n                    swapST(x)(y)(st)();\n                    return st;\n                });\n            };\n        };\n    };\n    var shiftInsert = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v === v1) return v2;\n                return run2(function __do2() {\n                    var st = thaw(v2)();\n                    var item = splice(v)(1)([])(st)();\n                    splice(v1)(0)(item)(st)();\n                    return st;\n                });\n            };\n        };\n    };\n    // output/TcgCalculator.Math/index.js\n    var iterateN2 = /* @__PURE__ */ iterateN(unfoldable1Array);\n    var add1 = /* @__PURE__ */ add(semiringBigInt);\n    var append6 = /* @__PURE__ */ append(semigroupArray);\n    var zero2 = /* @__PURE__ */ zero(semiringBigInt);\n    var one2 = /* @__PURE__ */ one(semiringBigInt);\n    var map21 = /* @__PURE__ */ map(functorArray);\n    var unsafeIndex2 = /* @__PURE__ */ unsafeIndex();\n    var product3 = /* @__PURE__ */ product(foldableArray)(semiringBigInt);\n    var div3 = /* @__PURE__ */ div(euclideanRingBigInt);\n    var ptCacheSize = 64;\n    var createPascalTriangle = function(v) {\n        if (v <= 0) return [];\n        return iterateN2(v)(function(r) {\n            return zipWith(add1)(append6([\n                zero2\n            ])(r))(append6(r)([\n                zero2\n            ]));\n        })([\n            one2\n        ]);\n    };\n    var pascalTriangle = /* @__PURE__ */ createPascalTriangle(ptCacheSize);\n    var combinationNumber = function($copy_n) {\n        return function($copy_r) {\n            var $tco_var_n = $copy_n;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(n, r) {\n                if (n < 0 || r < 0) {\n                    $tco_done = true;\n                    return zero2;\n                }\n                if (r === 0) {\n                    $tco_done = true;\n                    return one2;\n                }\n                if (r === 1) {\n                    $tco_done = true;\n                    return fromInt(n);\n                }\n                if ((n - r | 0) < r) {\n                    $tco_var_n = n;\n                    $copy_r = n - r | 0;\n                    return;\n                }\n                if (n < ptCacheSize) {\n                    $tco_done = true;\n                    return unsafeIndex2(unsafeIndex2(pascalTriangle)(n))(r);\n                }\n                if (otherwise) {\n                    var product$prime = function() {\n                        var $58 = map21(fromInt);\n                        return function($59) {\n                            return product3($58($59));\n                        };\n                    }();\n                    $tco_done = true;\n                    return div3(product$prime(range2((n - r | 0) + 1 | 0)(n)))(product$prime(range2(1)(r)));\n                }\n                throw new Error(\"Failed pattern match at TcgCalculator.Math (line 45, column 1 - line 45, column 42): \" + [\n                    n.constructor.name,\n                    r.constructor.name\n                ]);\n            }\n            while(!$tco_done)$tco_result = $tco_loop($tco_var_n, $copy_r);\n            return $tco_result;\n        };\n    };\n    // output/TcgCalculator/index.js\n    var alaF3 = /* @__PURE__ */ alaF()()()();\n    var eq4 = /* @__PURE__ */ eq(eqId);\n    var unwrap4 = /* @__PURE__ */ unwrap();\n    var sumBy = function(dictSemiring) {\n        return alaF3(Additive)(foldMap2(monoidAdditive(dictSemiring)));\n    };\n    var sumBy1 = /* @__PURE__ */ sumBy(semiringInt);\n    var normalizeDeck = function(deck) {\n        return function(conditions) {\n            var usedCards = function() {\n                var $132 = nubByEq(on(eq4)(function(v) {\n                    return v.id;\n                }));\n                var $133 = concatMap(function($136) {\n                    return function(v) {\n                        return v.cards;\n                    }(unwrap4($136));\n                });\n                var $134 = concatMap(toArray2);\n                return function($135) {\n                    return $132($133($134($135)));\n                };\n            }();\n            var diffCards = foldr2(deleteBy(on(eq4)(function(v) {\n                return v.id;\n            })));\n            var used = usedCards(conditions);\n            var unused = diffCards(deck.cards)(used);\n            return {\n                hand: deck.hand,\n                cards: used,\n                others: deck.others + sumBy1(function(v1) {\n                    return v1.count;\n                })(unused) | 0\n            };\n        };\n    };\n    var calculateTotal = function(v) {\n        return combinationNumber(sumBy1(function(v1) {\n            return v1.count;\n        })(v.cards) + v.others | 0)(v.hand);\n    };\n    // output/App.Result/index.js\n    var eq5 = /* @__PURE__ */ eq(eqBigInt);\n    var zero3 = /* @__PURE__ */ zero(semiringBigInt);\n    var div4 = /* @__PURE__ */ div(euclideanRingNumber);\n    var lift5 = /* @__PURE__ */ lift(monadTransMaybeT)(monadHalogenM);\n    var bind7 = /* @__PURE__ */ bind(bindHalogenM);\n    var liftAff2 = /* @__PURE__ */ liftAff(/* @__PURE__ */ monadAffHalogenM(monadAffAff));\n    var discard4 = /* @__PURE__ */ discard(discardUnit)(bindHalogenM);\n    var put4 = /* @__PURE__ */ put(monadStateHalogenM);\n    var throwError2 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowHalogenM(monadThrowAff));\n    var gets4 = /* @__PURE__ */ gets(monadStateHalogenM);\n    var modify_4 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n    var traverse_5 = /* @__PURE__ */ traverse_(applicativeHalogenM)(foldableMaybe);\n    var pure7 = /* @__PURE__ */ pure(applicativeHalogenM);\n    var Calculate = /* @__PURE__ */ function() {\n        function Calculate4(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        Calculate4.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new Calculate4(value0, value1, value22);\n                };\n            };\n        };\n        return Calculate4;\n    }();\n    var component3 = /* @__PURE__ */ function() {\n        var render = function(v) {\n            return div2([\n                class_(\"flex min-w-60 items-center\")\n            ])([\n                div2([\n                    class_(\"mx-1 flex w-36 items-center justify-end gap-1\")\n                ])(function() {\n                    if (v.calculation instanceof Just) return [\n                        div2([\n                            class_(\"text-2xl\")\n                        ])([\n                            text(\"Calculating\")\n                        ]),\n                        fa_(\"fa-spinner fa-pulse\")\n                    ];\n                    return [\n                        div2([\n                            class_(\"text-2xl\")\n                        ])([\n                            text(function() {\n                                var $30 = eq5(v.total)(zero3);\n                                if ($30) return \"N/A\";\n                                return toStringWith(fixed(4))(100 * on(div4)(toNumber2)(v.combination)(v.total)) + \"%\";\n                            }())\n                        ])\n                    ];\n                }()),\n                div2([\n                    class_(\"mx-1 flex min-w-20 flex-col items-end divide-y divide-gray-400\")\n                ])([\n                    div2([\n                        class_(\"px-1\")\n                    ])([\n                        text(toString5(v.combination))\n                    ]),\n                    div2([\n                        class_(\"px-1\")\n                    ])([\n                        text(toString5(v.total))\n                    ])\n                ])\n            ]);\n        };\n        var query3 = function(v) {\n            return lift5(bind7(fork(function() {\n                var deck$prime = normalizeDeck(v.value0)(v.value1);\n                return bind7(liftAff2(attempt(run3({\n                    deck: deck$prime,\n                    conditions: v.value1\n                }))))(function(result) {\n                    if (result instanceof Left) return discard4(put4({\n                        combination: zero3,\n                        total: zero3,\n                        calculation: Nothing.value\n                    }))(function() {\n                        return throwError2(result.value0);\n                    });\n                    if (result instanceof Right) {\n                        var total = calculateTotal(deck$prime);\n                        return put4({\n                            combination: result.value0,\n                            total: total,\n                            calculation: Nothing.value\n                        });\n                    }\n                    throw new Error(\"Failed pattern match at App.Result (line 73, column 9 - line 79, column 63): \" + [\n                        result.constructor.name\n                    ]);\n                });\n            }()))(function(newCalculation) {\n                return bind7(gets4(function(v1) {\n                    return v1.calculation;\n                }))(function(currentCalculation) {\n                    return discard4(modify_4(function(v1) {\n                        var $38 = {};\n                        for(var $39 in v1)if (({}).hasOwnProperty.call(v1, $39)) $38[$39] = v1[$39];\n                        $38.calculation = new Just(newCalculation);\n                        return $38;\n                    }))(function() {\n                        return discard4(traverse_5(kill)(currentCalculation))(function() {\n                            return pure7(v.value2);\n                        });\n                    });\n                });\n            }));\n        };\n        var initialState = function(v) {\n            return {\n                combination: zero3,\n                total: zero3,\n                calculation: Nothing.value\n            };\n        };\n        return mkComponent({\n            initialState: initialState,\n            render: render,\n            \"eval\": mkEval({\n                handleAction: defaultEval.handleAction,\n                receive: defaultEval.receive,\n                initialize: defaultEval.initialize,\n                finalize: defaultEval.finalize,\n                handleQuery: function($44) {\n                    return runMaybeT(query3($44));\n                }\n            })\n        });\n    }();\n    // output/App.Condition/index.js\n    var lineIsSymbol = {\n        reflectSymbol: function() {\n            return \"line\";\n        }\n    };\n    var slot3 = /* @__PURE__ */ slot()(lineIsSymbol)(ordId);\n    var resultIsSymbol = {\n        reflectSymbol: function() {\n            return \"result\";\n        }\n    };\n    var slot_2 = /* @__PURE__ */ slot_()(resultIsSymbol)(ordUnit);\n    var map23 = /* @__PURE__ */ map(functorArray);\n    var apply2 = /* @__PURE__ */ apply(applyHalogenM);\n    var map110 = /* @__PURE__ */ map(functorHalogenM);\n    var fromFoldable7 = /* @__PURE__ */ fromFoldable3(foldableList);\n    var filterKeys2 = /* @__PURE__ */ filterKeys(ordId);\n    var flap2 = /* @__PURE__ */ flap(functorFn);\n    var notElem3 = /* @__PURE__ */ notElem2(eqId);\n    var gets5 = /* @__PURE__ */ gets(monadStateHalogenM);\n    var requestAll2 = /* @__PURE__ */ requestAll()(lineIsSymbol)(ordId);\n    var bind8 = /* @__PURE__ */ bind(bindHalogenM);\n    var fromFoldable1 = /* @__PURE__ */ fromFoldable(foldableMaybe);\n    var tell4 = /* @__PURE__ */ tell2();\n    var tell1 = /* @__PURE__ */ tell4(resultIsSymbol)(ordUnit);\n    var apply1 = /* @__PURE__ */ apply(/* @__PURE__ */ applyMaybeT(monadHalogenM));\n    var map24 = /* @__PURE__ */ map(/* @__PURE__ */ functorMaybeT(functorHalogenM));\n    var bindMaybeT2 = /* @__PURE__ */ bindMaybeT(monadHalogenM);\n    var bindFlipped5 = /* @__PURE__ */ bindFlipped(bindMaybeT2);\n    var guard2 = /* @__PURE__ */ guard(/* @__PURE__ */ alternativeMaybeT(monadHalogenM));\n    var monadStateMaybeT2 = /* @__PURE__ */ monadStateMaybeT(monadStateHalogenM);\n    var gets1 = /* @__PURE__ */ gets(monadStateMaybeT2);\n    var map32 = /* @__PURE__ */ map(functorMaybe);\n    var $$for2 = /* @__PURE__ */ $$for(applicativeMaybe)(traversableArray);\n    var mapFlipped5 = /* @__PURE__ */ mapFlipped(functorMaybe);\n    var lookup6 = /* @__PURE__ */ lookup(ordId);\n    var mapFlipped1 = /* @__PURE__ */ mapFlipped(functorArray);\n    var get4 = /* @__PURE__ */ get(monadStateHalogenM);\n    var lift6 = /* @__PURE__ */ lift(monadTransMaybeT)(monadHalogenM);\n    var traverse3 = /* @__PURE__ */ traverse(traversableArray)(applicativeHalogenM);\n    var flap1 = /* @__PURE__ */ flap(functorHalogenM);\n    var idIsSymbol2 = {\n        reflectSymbol: function() {\n            return \"id\";\n        }\n    };\n    var insert8 = /* @__PURE__ */ insert5(idIsSymbol2)()();\n    var generateId2 = /* @__PURE__ */ generateId(/* @__PURE__ */ monadEffectHalogenM(monadEffectAff));\n    var discard5 = /* @__PURE__ */ discard(discardUnit);\n    var discard1 = /* @__PURE__ */ discard5(bindHalogenM);\n    var put5 = /* @__PURE__ */ put(monadStateHalogenM);\n    var for_2 = /* @__PURE__ */ for_(applicativeHalogenM)(foldableArray);\n    var eq6 = /* @__PURE__ */ eq(eqId);\n    var tell22 = /* @__PURE__ */ tell4(lineIsSymbol)(ordId);\n    var pure8 = /* @__PURE__ */ pure(applicativeHalogenM);\n    var discard22 = /* @__PURE__ */ discard5(bindMaybeT2);\n    var modify_5 = /* @__PURE__ */ modify_2(monadStateMaybeT2);\n    var bind14 = /* @__PURE__ */ bind(bindFn);\n    var pure1 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeMaybeT(monadHalogenM));\n    var modify_1 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n    var modify7 = /* @__PURE__ */ modify2(monadStateHalogenM);\n    var notEq2 = /* @__PURE__ */ notEq(eqId);\n    var identity13 = /* @__PURE__ */ identity(categoryFn);\n    var bind22 = /* @__PURE__ */ bind(bindMaybe);\n    var pure23 = /* @__PURE__ */ pure(applicativeMaybe);\n    var when3 = /* @__PURE__ */ when(applicativeHalogenM);\n    var eqRec2 = /* @__PURE__ */ eqRec();\n    var eqRowCons2 = /* @__PURE__ */ eqRowCons(eqRowNil)();\n    var notEq1 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({\n        reflectSymbol: function() {\n            return \"others\";\n        }\n    })(eqInt))()({\n        reflectSymbol: function() {\n            return \"hand\";\n        }\n    })(eqInt))()({\n        reflectSymbol: function() {\n            return \"cards\";\n        }\n    })(/* @__PURE__ */ eqArray(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({\n        reflectSymbol: function() {\n            return \"name\";\n        }\n    })(eqString))()(idIsSymbol2)(eqId))()({\n        reflectSymbol: function() {\n            return \"count\";\n        }\n    })(eqInt))))));\n    var Updated2 = /* @__PURE__ */ function() {\n        function Updated3() {}\n        Updated3.value = new Updated3();\n        return Updated3;\n    }();\n    var AllConditionDeleted = /* @__PURE__ */ function() {\n        function AllConditionDeleted2() {}\n        AllConditionDeleted2.value = new AllConditionDeleted2();\n        return AllConditionDeleted2;\n    }();\n    var GetConditions = /* @__PURE__ */ function() {\n        function GetConditions2(value0) {\n            this.value0 = value0;\n        }\n        GetConditions2.create = function(value0) {\n            return new GetConditions2(value0);\n        };\n        return GetConditions2;\n    }();\n    var GetState = /* @__PURE__ */ function() {\n        function GetState2(value0) {\n            this.value0 = value0;\n        }\n        GetState2.create = function(value0) {\n            return new GetState2(value0);\n        };\n        return GetState2;\n    }();\n    var RestoreState2 = /* @__PURE__ */ function() {\n        function RestoreState4(value0, value1, value22) {\n            this.value0 = value0;\n            this.value1 = value1;\n            this.value2 = value22;\n        }\n        RestoreState4.create = function(value0) {\n            return function(value1) {\n                return function(value22) {\n                    return new RestoreState4(value0, value1, value22);\n                };\n            };\n        };\n        return RestoreState4;\n    }();\n    var ToggleDisabled = /* @__PURE__ */ function() {\n        function ToggleDisabled3(value0) {\n            this.value0 = value0;\n        }\n        ToggleDisabled3.create = function(value0) {\n            return new ToggleDisabled3(value0);\n        };\n        return ToggleDisabled3;\n    }();\n    var Initialize3 = /* @__PURE__ */ function() {\n        function Initialize5() {}\n        Initialize5.value = new Initialize5();\n        return Initialize5;\n    }();\n    var AddCondition = /* @__PURE__ */ function() {\n        function AddCondition3() {}\n        AddCondition3.value = new AddCondition3();\n        return AddCondition3;\n    }();\n    var RemoveCondition = /* @__PURE__ */ function() {\n        function RemoveCondition3(value0) {\n            this.value0 = value0;\n        }\n        RemoveCondition3.create = function(value0) {\n            return new RemoveCondition3(value0);\n        };\n        return RemoveCondition3;\n    }();\n    var ToggleItemDisabled = /* @__PURE__ */ function() {\n        function ToggleItemDisabled2(value0) {\n            this.value0 = value0;\n        }\n        ToggleItemDisabled2.create = function(value0) {\n            return new ToggleItemDisabled2(value0);\n        };\n        return ToggleItemDisabled2;\n    }();\n    var Receive4 = /* @__PURE__ */ function() {\n        function Receive5(value0) {\n            this.value0 = value0;\n        }\n        Receive5.create = function(value0) {\n            return new Receive5(value0);\n        };\n        return Receive5;\n    }();\n    var Calculate2 = /* @__PURE__ */ function() {\n        function Calculate4() {}\n        Calculate4.value = new Calculate4();\n        return Calculate4;\n    }();\n    var component4 = /* @__PURE__ */ function() {\n        var renderConditionLine = function(cards) {\n            return function(v) {\n                return li([\n                    classes([\n                        \"flex gap-1 rounded px-1\",\n                        function() {\n                            if (v.disabled) return \"bg-slate-100 text-gray-400 line-through\";\n                            return \"bg-transparent\";\n                        }()\n                    ])\n                ])([\n                    div2([\n                        class_(\"mx-1 flex\")\n                    ])([\n                        removeButton(new RemoveCondition(v.id)),\n                        toggleButton(new ToggleItemDisabled(v.id))\n                    ]),\n                    div2([\n                        class_(\"min-w-0 grow\")\n                    ])([\n                        slot3($$Proxy.value)(v.id)(component2)(cards)($$const(Calculate2.value))\n                    ])\n                ]);\n            };\n        };\n        var renderConditionHeader = function(disabled10) {\n            return div2([\n                class_(\"flex items-center justify-end gap-1\")\n            ])([\n                div2([\n                    class_(function() {\n                        if (disabled10) return \"mr-auto w-0 py-1 pl-3 text-xl\";\n                        return \"hidden\";\n                    }())\n                ])([\n                    text(\"Disabled\")\n                ]),\n                div2([\n                    class_(function() {\n                        if (disabled10) return \"text-gray-400\";\n                        return \"text-black\";\n                    }())\n                ])([\n                    slot_2($$Proxy.value)(unit)(component3)(unit)\n                ])\n            ]);\n        };\n        var renderConditionAddButton = div2([\n            class_(\"px-1\")\n        ])([\n            plusButton(AddCondition.value)\n        ]);\n        var render = function(v) {\n            return div2([\n                classes([\n                    \"grow rounded border-2 border-violet-300 p-1\",\n                    function() {\n                        if (v.disabled) return \"bg-slate-100 text-gray-400\";\n                        return \"bg-white text-gray-700\";\n                    }()\n                ])\n            ])([\n                renderConditionHeader(v.disabled),\n                ul([\n                    class_(\"my-1\")\n                ])(map23(renderConditionLine(v.deck.cards))(v.conditions)),\n                renderConditionAddButton\n            ]);\n        };\n        var initialState = function(v) {\n            return {\n                conditions: [],\n                deck: v,\n                disabled: false\n            };\n        };\n        var getConditions = apply2(map110(function(v) {\n            return function(v1) {\n                return fromFoldable7(values(filterKeys2(flap2(notElem3)(v))(v1)));\n            };\n        })(map110(function() {\n            var $218 = map23(function(v) {\n                return v.id;\n            });\n            var $219 = filter(function(v) {\n                return v.disabled;\n            });\n            return function($220) {\n                return $218($219($220));\n            };\n        }())(gets5(function(v) {\n            return v.conditions;\n        }))))(requestAll2($$Proxy.value)(GetCondition.create));\n        var calculate = bind8(gets5(function(v) {\n            return v.deck;\n        }))(function(deck) {\n            return bind8(map110(fromFoldable1)(getConditions))(function(conditions) {\n                return tell1($$Proxy.value)(unit)(Calculate.create(deck)(conditions));\n            });\n        });\n        var query3 = function(v) {\n            if (v instanceof GetConditions) return apply1(map24(function(v1) {\n                return function(v2) {\n                    return v.value0(v2);\n                };\n            })(bindFlipped5(function($221) {\n                return guard2(!$221);\n            })(gets1(function(v1) {\n                return v1.disabled;\n            }))))(getConditions);\n            if (v instanceof GetState) return apply2(map110(function(v1) {\n                return function(v2) {\n                    return map32(function(v3) {\n                        return v.value0({\n                            conditions: v3,\n                            disabled: v1.disabled\n                        });\n                    })($$for2(v1.conditions)(function(v3) {\n                        return mapFlipped5(lookup6(v3.id)(v2))(function(v42) {\n                            return {\n                                mode: v42.mode,\n                                count: v42.count,\n                                cards: mapFlipped1(v42.cards)(function(v52) {\n                                    return v52.id;\n                                }),\n                                disabled: v3.disabled\n                            };\n                        });\n                    }));\n                };\n            })(get4))(requestAll2($$Proxy.value)(GetCondition.create));\n            if (v instanceof RestoreState2) return lift6(bind8(traverse3(flap1(map110(insert8($$Proxy.value))(generateId2)))(v.value1.conditions))(function(conditions$prime) {\n                return discard1(put5({\n                    conditions: mapFlipped1(conditions$prime)(function(v1) {\n                        return {\n                            id: v1.id,\n                            disabled: v1.disabled\n                        };\n                    }),\n                    deck: v.value0,\n                    disabled: v.value1.disabled\n                }))(function() {\n                    return discard1(for_2(conditions$prime)(function(v1) {\n                        var cards$prime = flap2(mapMaybe)(v1.cards)(function(cardId) {\n                            return find2(function($222) {\n                                return function(v2) {\n                                    return eq6(v2)(cardId);\n                                }(function(v2) {\n                                    return v2.id;\n                                }($222));\n                            })(v.value0.cards);\n                        });\n                        return tell22($$Proxy.value)(v1.id)(RestoreState.create(v.value0.cards)({\n                            mode: v1.mode,\n                            count: v1.count,\n                            cards: cards$prime\n                        }));\n                    }))(function() {\n                        return discard1(calculate)(function() {\n                            return pure8(v.value2);\n                        });\n                    });\n                });\n            }));\n            if (v instanceof ToggleDisabled) return discard22(modify_5(bind14(function(v1) {\n                return v1.disabled;\n            })(function(disabled10) {\n                return function(v1) {\n                    var $192 = {};\n                    for(var $193 in v1)if (({}).hasOwnProperty.call(v1, $193)) $192[$193] = v1[$193];\n                    $192.disabled = !disabled10;\n                    return $192;\n                };\n            })))(function() {\n                return pure1(v.value0);\n            });\n            throw new Error(\"Failed pattern match at App.Condition (line 158, column 11 - line 182, column 13): \" + [\n                v.constructor.name\n            ]);\n        };\n        var action2 = function(v) {\n            if (v instanceof Initialize3) return discard1(action2(AddCondition.value))(function() {\n                return calculate;\n            });\n            if (v instanceof AddCondition) return bind8(gets5(function(v1) {\n                return v1.conditions;\n            }))(function(conditions) {\n                return bind8(generateId2)(function(id3) {\n                    return modify_1(function(v1) {\n                        var $197 = {};\n                        for(var $198 in v1)if (({}).hasOwnProperty.call(v1, $198)) $197[$198] = v1[$198];\n                        $197.conditions = snoc(conditions)({\n                            id: id3,\n                            disabled: false\n                        });\n                        return $197;\n                    });\n                });\n            });\n            if (v instanceof RemoveCondition) return bind8(modify7(bind14(function(v1) {\n                return v1.conditions;\n            })(function(conditions) {\n                return function(v1) {\n                    var $200 = {};\n                    for(var $201 in v1)if (({}).hasOwnProperty.call(v1, $201)) $200[$201] = v1[$201];\n                    $200.conditions = filter(function($223) {\n                        return function(v2) {\n                            return notEq2(v2)(v.value0);\n                        }(function(v2) {\n                            return v2.id;\n                        }($223));\n                    })(conditions);\n                    return $200;\n                };\n            })))(function(v1) {\n                var $204 = $$null(v1.conditions);\n                if ($204) return raise(AllConditionDeleted.value);\n                return action2(Calculate2.value);\n            });\n            if (v instanceof ToggleItemDisabled) return discard1(modify_1(bind14(function(v1) {\n                return v1.conditions;\n            })(function(conditions) {\n                return fromMaybe(identity13)(bind22(findIndex(function($224) {\n                    return function(v1) {\n                        return eq6(v1)(v.value0);\n                    }(function(v1) {\n                        return v1.id;\n                    }($224));\n                })(conditions))(function(i2) {\n                    return bind22(modifyAt(i2)(function(s) {\n                        var $207 = {};\n                        for(var $208 in s)if (({}).hasOwnProperty.call(s, $208)) $207[$208] = s[$208];\n                        $207.disabled = !s.disabled;\n                        return $207;\n                    })(conditions))(function(conditions$prime) {\n                        return pure23(function(v1) {\n                            var $210 = {};\n                            for(var $211 in v1)if (({}).hasOwnProperty.call(v1, $211)) $210[$211] = v1[$211];\n                            $210.conditions = conditions$prime;\n                            return $210;\n                        });\n                    });\n                }));\n            })))(function() {\n                return action2(Calculate2.value);\n            });\n            if (v instanceof Receive4) return bind8(gets5(function(v1) {\n                return v1.deck;\n            }))(function(current) {\n                return when3(notEq1(v.value0)(current))(discard1(modify_1(function(v1) {\n                    var $214 = {};\n                    for(var $215 in v1)if (({}).hasOwnProperty.call(v1, $215)) $214[$215] = v1[$215];\n                    $214.deck = v.value0;\n                    return $214;\n                }))(function() {\n                    return calculate;\n                }));\n            });\n            if (v instanceof Calculate2) return discard1(calculate)(function() {\n                return raise(Updated2.value);\n            });\n            throw new Error(\"Failed pattern match at App.Condition (line 115, column 12 - line 145, column 22): \" + [\n                v.constructor.name\n            ]);\n        };\n        return mkComponent({\n            initialState: initialState,\n            render: render,\n            \"eval\": mkEval({\n                finalize: defaultEval.finalize,\n                handleAction: action2,\n                handleQuery: function($225) {\n                    return runMaybeT(query3($225));\n                },\n                initialize: new Just(Initialize3.value),\n                receive: function($226) {\n                    return Just.create(Receive4.create($226));\n                }\n            })\n        });\n    }();\n    // output/Web.HTML/foreign.js\n    var windowImpl = function() {\n        return window;\n    };\n    // output/Web.HTML.HTMLDocument/foreign.js\n    function _readyState(doc) {\n        return doc.readyState;\n    }\n    // output/Web.HTML.HTMLDocument.ReadyState/index.js\n    var Loading = /* @__PURE__ */ function() {\n        function Loading2() {}\n        Loading2.value = new Loading2();\n        return Loading2;\n    }();\n    var Interactive = /* @__PURE__ */ function() {\n        function Interactive2() {}\n        Interactive2.value = new Interactive2();\n        return Interactive2;\n    }();\n    var Complete = /* @__PURE__ */ function() {\n        function Complete2() {}\n        Complete2.value = new Complete2();\n        return Complete2;\n    }();\n    var parse2 = function(v) {\n        if (v === \"loading\") return new Just(Loading.value);\n        if (v === \"interactive\") return new Just(Interactive.value);\n        if (v === \"complete\") return new Just(Complete.value);\n        return Nothing.value;\n    };\n    // output/Web.HTML.HTMLDocument/index.js\n    var map25 = /* @__PURE__ */ map(functorEffect);\n    var toParentNode = unsafeCoerce2;\n    var toDocument = unsafeCoerce2;\n    var readyState = function(doc) {\n        return map25(function() {\n            var $4 = fromMaybe(Loading.value);\n            return function($5) {\n                return $4(parse2($5));\n            };\n        }())(function() {\n            return _readyState(doc);\n        });\n    };\n    // output/Web.HTML.Location/foreign.js\n    function hash(location2) {\n        return function() {\n            return location2.hash;\n        };\n    }\n    function setHash(hash2) {\n        return function(location2) {\n            return function() {\n                location2.hash = hash2;\n            };\n        };\n    }\n    // output/Web.HTML.Window/foreign.js\n    function document(window2) {\n        return function() {\n            return window2.document;\n        };\n    }\n    function location(window2) {\n        return function() {\n            return window2.location;\n        };\n    }\n    function confirm(str) {\n        return function(window2) {\n            return function() {\n                return window2.confirm(str);\n            };\n        };\n    }\n    // output/Web.HTML.Window/index.js\n    var toEventTarget = unsafeCoerce2;\n    // output/Web.HTML.Event.DataTransfer/foreign.js\n    function types(dataTransfer2) {\n        return dataTransfer2.types;\n    }\n    function _getData(format) {\n        return function(dataTransfer2) {\n            return function() {\n                return dataTransfer2.getData(format);\n            };\n        };\n    }\n    function _setData(format) {\n        return function(data) {\n            return function(dataTransfer2) {\n                return function() {\n                    return dataTransfer2.setData(format, data);\n                };\n            };\n        };\n    }\n    function _setDragImage(dataTransfer2) {\n        return function(image) {\n            return function(x) {\n                return function(y) {\n                    return function() {\n                        return dataTransfer2.setDragImage(image, x, y);\n                    };\n                };\n            };\n        };\n    }\n    // output/Web.HTML.Event.DataTransfer/index.js\n    var setDragImage = _setDragImage;\n    var setData2 = function(v) {\n        return function(dat) {\n            return function(dt2) {\n                return _setData(v)(dat)(dt2);\n            };\n        };\n    };\n    var getData = function(v) {\n        return function(dt2) {\n            return _getData(v)(dt2);\n        };\n    };\n    // output/Web.HTML.Event.DragEvent/foreign.js\n    function dataTransfer(e) {\n        return e.dataTransfer;\n    }\n    // output/Web.HTML.Event.DragEvent/index.js\n    var toEvent2 = unsafeCoerce2;\n    // output/App.Deck/index.js\n    var collect3 = /* @__PURE__ */ collect()();\n    var type_20 = /* @__PURE__ */ type_3(isPropInputType);\n    var value14 = /* @__PURE__ */ value2(isPropString);\n    var show6 = /* @__PURE__ */ show(showInt);\n    var map26 = /* @__PURE__ */ map(functorArray);\n    var not4 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));\n    var discard6 = /* @__PURE__ */ discard(discardUnit);\n    var discard12 = /* @__PURE__ */ discard6(/* @__PURE__ */ bindMaybeT(monadHalogenM));\n    var put6 = /* @__PURE__ */ put(/* @__PURE__ */ monadStateMaybeT(monadStateHalogenM));\n    var pure9 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeMaybeT(monadHalogenM));\n    var bind9 = /* @__PURE__ */ bind(bindHalogenM);\n    var monadEffectHalogenM2 = /* @__PURE__ */ monadEffectHalogenM(monadEffectAff);\n    var generateId3 = /* @__PURE__ */ generateId(monadEffectHalogenM2);\n    var modify_6 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n    var bind15 = /* @__PURE__ */ bind(bindFn);\n    var $$void8 = /* @__PURE__ */ $$void(functorHalogenM);\n    var whenM3 = /* @__PURE__ */ whenM(monadHalogenM);\n    var pure12 = /* @__PURE__ */ pure(applicativeHalogenM);\n    var liftEffect4 = /* @__PURE__ */ liftEffect(monadEffectHalogenM2);\n    var bindFlipped6 = /* @__PURE__ */ bindFlipped(bindEffect);\n    var get5 = /* @__PURE__ */ get(monadStateHalogenM);\n    var eq7 = /* @__PURE__ */ eq(eqId);\n    var bindFlipped1 = /* @__PURE__ */ bindFlipped(bindHalogenM);\n    var modify8 = /* @__PURE__ */ modify2(monadStateHalogenM);\n    var fold2 = /* @__PURE__ */ fold(foldableMaybe);\n    var fold12 = /* @__PURE__ */ fold2(/* @__PURE__ */ monoidHalogenM(monoidUnit));\n    var bind23 = /* @__PURE__ */ bind(bindMaybe);\n    var clamp4 = /* @__PURE__ */ clamp(ordInt);\n    var pure24 = /* @__PURE__ */ pure(applicativeMaybe);\n    var gets6 = /* @__PURE__ */ gets(monadStateHalogenM);\n    var identity14 = /* @__PURE__ */ identity(categoryFn);\n    var min7 = /* @__PURE__ */ min(ordInt);\n    var composeKleisliFlipped5 = /* @__PURE__ */ composeKleisliFlipped(bindMaybe);\n    var traverse_6 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableMaybe);\n    var discard23 = /* @__PURE__ */ discard6(bindHalogenM);\n    var when4 = /* @__PURE__ */ when(applicativeHalogenM);\n    var eq12 = /* @__PURE__ */ eq(/* @__PURE__ */ eqArray(eqString));\n    var unless2 = /* @__PURE__ */ unless(applicativeHalogenM);\n    var fold22 = /* @__PURE__ */ fold2(monoidArray);\n    var SetDeck = /* @__PURE__ */ function() {\n        function SetDeck2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        SetDeck2.create = function(value0) {\n            return function(value1) {\n                return new SetDeck2(value0, value1);\n            };\n        };\n        return SetDeck2;\n    }();\n    var AddCard = /* @__PURE__ */ function() {\n        function AddCard2() {}\n        AddCard2.value = new AddCard2();\n        return AddCard2;\n    }();\n    var RemoveCard = /* @__PURE__ */ function() {\n        function RemoveCard2(value0) {\n            this.value0 = value0;\n        }\n        RemoveCard2.create = function(value0) {\n            return new RemoveCard2(value0);\n        };\n        return RemoveCard2;\n    }();\n    var UpdateCard = /* @__PURE__ */ function() {\n        function UpdateCard2(value0) {\n            this.value0 = value0;\n        }\n        UpdateCard2.create = function(value0) {\n            return new UpdateCard2(value0);\n        };\n        return UpdateCard2;\n    }();\n    var UpdateDeck = /* @__PURE__ */ function() {\n        function UpdateDeck3(value0) {\n            this.value0 = value0;\n        }\n        UpdateDeck3.create = function(value0) {\n            return new UpdateDeck3(value0);\n        };\n        return UpdateDeck3;\n    }();\n    var UpdateHand = /* @__PURE__ */ function() {\n        function UpdateHand2(value0) {\n            this.value0 = value0;\n        }\n        UpdateHand2.create = function(value0) {\n            return new UpdateHand2(value0);\n        };\n        return UpdateHand2;\n    }();\n    var UpdateOthers = /* @__PURE__ */ function() {\n        function UpdateOthers2(value0) {\n            this.value0 = value0;\n        }\n        UpdateOthers2.create = function(value0) {\n            return new UpdateOthers2(value0);\n        };\n        return UpdateOthers2;\n    }();\n    var SelectOnFocus2 = /* @__PURE__ */ function() {\n        function SelectOnFocus3(value0) {\n            this.value0 = value0;\n        }\n        SelectOnFocus3.create = function(value0) {\n            return new SelectOnFocus3(value0);\n        };\n        return SelectOnFocus3;\n    }();\n    var StartReorder = /* @__PURE__ */ function() {\n        function StartReorder2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        StartReorder2.create = function(value0) {\n            return function(value1) {\n                return new StartReorder2(value0, value1);\n            };\n        };\n        return StartReorder2;\n    }();\n    var HandleDragBehavior = /* @__PURE__ */ function() {\n        function HandleDragBehavior2(value0) {\n            this.value0 = value0;\n        }\n        HandleDragBehavior2.create = function(value0) {\n            return new HandleDragBehavior2(value0);\n        };\n        return HandleDragBehavior2;\n    }();\n    var ExecuteReorder = /* @__PURE__ */ function() {\n        function ExecuteReorder2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        ExecuteReorder2.create = function(value0) {\n            return function(value1) {\n                return new ExecuteReorder2(value0, value1);\n            };\n        };\n        return ExecuteReorder2;\n    }();\n    var component5 = /* @__PURE__ */ function() {\n        var styleFormInput = collect3(ClassName)(joinWith(\" \"))([\n            \"appearance-none border-b border-transparent bg-white p-1 text-gray-700\",\n            \"transition-colors duration-75 hover:border-gray-500 focus:border-slate-800 focus:outline-none\"\n        ]);\n        var styleFormNumber = collect3(ClassName)(joinWith(\" \"))([\n            \"w-16 text-right\",\n            styleFormInput\n        ]);\n        var renderIntegerInput = function(text6) {\n            return function(count) {\n                return function(min1) {\n                    return function(max7) {\n                        return function(h) {\n                            return div2([\n                                class_(\"mx-1 flex flex-wrap items-baseline justify-end border-b border-gray-500\")\n                            ])([\n                                div2([\n                                    class_(\"m-1\")\n                                ])([\n                                    text(text6)\n                                ]),\n                                input([\n                                    class_(styleFormNumber),\n                                    type_20(InputNumber.value),\n                                    value14(show6(count)),\n                                    step3(new Step(1)),\n                                    min4(toNumber(min1)),\n                                    max4(toNumber(max7)),\n                                    onFocus(SelectOnFocus2.create),\n                                    onValueChange(function() {\n                                        var $129 = fromMaybe(0);\n                                        return function($130) {\n                                            return h($129(fromString($130)));\n                                        };\n                                    }())\n                                ])\n                            ]);\n                        };\n                    };\n                };\n            };\n        };\n        var renderCard = function(others) {\n            return function(card) {\n                return li([\n                    class_(\"flex\"),\n                    ref2(toString4(card.id)),\n                    onDrop(ExecuteReorder.create(card.id))\n                ])([\n                    div2([\n                        class_(\"mx-1 flex items-center\")\n                    ])([\n                        div2([\n                            class_(\"hidden cursor-grab px-1 text-gray-500 active:cursor-grabbing md:block\"),\n                            draggable(true),\n                            onDragStart(StartReorder.create(card.id))\n                        ])([\n                            fa_(\"fa-grip-vertical\")\n                        ]),\n                        removeButton(new RemoveCard(card))\n                    ]),\n                    div2([\n                        class_(\"flex grow border-b border-gray-500\")\n                    ])([\n                        input([\n                            classes([\n                                \"grow\",\n                                styleFormInput\n                            ]),\n                            type_20(InputText.value),\n                            value14(card.name),\n                            onValueChange(function($131) {\n                                return UpdateCard.create(function(v) {\n                                    return {\n                                        id: card.id,\n                                        count: card.count,\n                                        name: v\n                                    };\n                                }($131));\n                            })\n                        ]),\n                        input([\n                            class_(styleFormNumber),\n                            type_20(InputNumber.value),\n                            step3(new Step(1)),\n                            value14(show6(card.count)),\n                            min4(0),\n                            max4(function() {\n                                var $92 = $$null2(card.name);\n                                if ($92) return 0;\n                                return toNumber(card.count + others | 0);\n                            }()),\n                            onFocus(SelectOnFocus2.create),\n                            onValueChange(function() {\n                                var $132 = fromMaybe(0);\n                                return function($133) {\n                                    return UpdateCard.create(function(v) {\n                                        return {\n                                            id: card.id,\n                                            name: card.name,\n                                            count: v\n                                        };\n                                    }($132(fromString($133))));\n                                };\n                            }())\n                        ])\n                    ])\n                ]);\n            };\n        };\n        var renderCardList = function(others) {\n            return function(cards) {\n                return ul([\n                    class_(\"m-1\"),\n                    onDragEnter(HandleDragBehavior.create),\n                    onDragOver(HandleDragBehavior.create)\n                ])(map26(renderCard(others))(cards));\n            };\n        };\n        var raiseUpdated = function(deck) {\n            return raise({\n                others: deck.others,\n                hand: deck.hand,\n                cards: filter(function() {\n                    var $134 = not4($$null2);\n                    return function($135) {\n                        return $134(function(v1) {\n                            return v1.name;\n                        }($135));\n                    };\n                }())(deck.cards)\n            });\n        };\n        var query3 = function(v) {\n            return discard12(put6(v.value0))(function() {\n                return pure9(v.value1);\n            });\n        };\n        var initialState = function(v) {\n            return {\n                cards: [],\n                others: 40,\n                hand: 5\n            };\n        };\n        var renderFooter = function(otherCount) {\n            return function(cardCount) {\n                return div2([\n                    class_(\"flex items-baseline gap-1\")\n                ])([\n                    div2([\n                        class_(\"mx-1 grow\")\n                    ])([\n                        plusButton(AddCard.value)\n                    ]),\n                    renderIntegerInput(\"\\u305D\\u306E\\u4ED6\\u306E\\u30AB\\u30FC\\u30C9:\")(otherCount)(0)(255 - cardCount | 0)(UpdateOthers.create)\n                ]);\n            };\n        };\n        var renderHeader = function(deckCount) {\n            return function(handCount) {\n                return function(cardCount) {\n                    return div2([\n                        class_(\"flex items-baseline gap-1\")\n                    ])([\n                        div2([\n                            class_(\"mx-1 flex grow flex-wrap items-baseline text-sky-900\")\n                        ])([\n                            fa(\"fa-layer-group\")([\n                                \"m-1 text-2xl\"\n                            ]),\n                            div2([\n                                class_(\"m-1\")\n                            ])([\n                                text(\"\\u30C7\\u30C3\\u30AD\\u60C5\\u5831\")\n                            ])\n                        ]),\n                        renderIntegerInput(\"\\u624B\\u672D\\u679A\\u6570:\")(handCount)(1)(deckCount)(UpdateHand.create),\n                        renderIntegerInput(\"\\u30C7\\u30C3\\u30AD\\u679A\\u6570:\")(deckCount)(cardCount)(255)(UpdateDeck.create)\n                    ]);\n                };\n            };\n        };\n        var countCards = alaF()()()()(Additive)(foldMap2(monoidAdditive(semiringInt)))(function(v) {\n            return v.count;\n        });\n        var render = function(v) {\n            var cardCount = countCards(v.cards);\n            var deckCount = cardCount + v.others | 0;\n            return div2([\n                class_(\"rounded border-2 border-amber-500 p-1\")\n            ])([\n                renderHeader(deckCount)(v.hand)(cardCount),\n                renderCardList(v.others)(v.cards),\n                renderFooter(v.others)(cardCount)\n            ]);\n        };\n        var action2 = function(v) {\n            if (v instanceof AddCard) return bind9(generateId3)(function(id3) {\n                return modify_6(bind15(function(v1) {\n                    return v1.cards;\n                })(function(cards) {\n                    return function(v1) {\n                        var $101 = {};\n                        for(var $102 in v1)if (({}).hasOwnProperty.call(v1, $102)) $101[$102] = v1[$102];\n                        $101.cards = snoc(cards)({\n                            id: id3,\n                            name: \"\",\n                            count: 0\n                        });\n                        return $101;\n                    };\n                }));\n            });\n            if (v instanceof RemoveCard) return $$void8(fork(whenM3(function() {\n                var $104 = $$null2(v.value0.name);\n                if ($104) return pure12(true);\n                return liftEffect4(bindFlipped6(confirm(\"\\u30AB\\u30FC\\u30C9\\u300C\" + (v.value0.name + \"\\u300D\\u3092\\u524A\\u9664\\u3057\\u307E\\u3059\\u3002\")))(windowImpl));\n            }())(bind9(get5)(function(v1) {\n                var cards$prime = deleteBy(on(eq7)(function(v2) {\n                    return v2.id;\n                }))(v.value0)(v1.cards);\n                return bindFlipped1(raiseUpdated)(modify8(function(v2) {\n                    return {\n                        hand: v2.hand,\n                        cards: cards$prime,\n                        others: v1.others + v.value0.count | 0\n                    };\n                }));\n            }))));\n            if (v instanceof UpdateCard) return bind9(get5)(function(v1) {\n                return fold12(bind23(findIndex(function($136) {\n                    return function(v2) {\n                        return eq7(v2)(v.value0.id);\n                    }(function(v2) {\n                        return v2.id;\n                    }($136));\n                })(v1.cards))(function(i2) {\n                    return bind23(index(v1.cards)(i2))(function(old) {\n                        var $$new3 = function() {\n                            var $110 = $$null2(v.value0.name);\n                            if ($110) return {\n                                id: v.value0.id,\n                                name: v.value0.name,\n                                count: 0\n                            };\n                            return {\n                                id: v.value0.id,\n                                name: v.value0.name,\n                                count: clamp4(0)(old.count + v1.others | 0)(v.value0.count)\n                            };\n                        }();\n                        return bind23(updateAt(i2)($$new3)(v1.cards))(function(cards$prime) {\n                            return pure24(bindFlipped1(raiseUpdated)(modify8(function(v2) {\n                                return {\n                                    hand: v2.hand,\n                                    cards: cards$prime,\n                                    others: v1.others - ($$new3.count - old.count | 0) | 0\n                                };\n                            })));\n                        });\n                    });\n                }));\n            });\n            if (v instanceof UpdateDeck) return bind9(gets6(function(v1) {\n                return v1.cards;\n            }))(function(cards) {\n                var cardCount = countCards(cards);\n                return action2(new UpdateOthers(v.value0 - cardCount | 0));\n            });\n            if (v instanceof UpdateHand) return bindFlipped1(raiseUpdated)(modify8(bind15(identity14)(function(v1) {\n                var deckCount = countCards(v1.cards) + v1.others | 0;\n                return function(v2) {\n                    return {\n                        cards: v2.cards,\n                        others: v2.others,\n                        hand: clamp4(1)(deckCount)(v.value0)\n                    };\n                };\n            })));\n            if (v instanceof UpdateOthers) return bindFlipped1(raiseUpdated)(modify8(bind15(identity14)(function(v1) {\n                var cardCount = countCards(v1.cards);\n                var deckCount = clamp4(cardCount)(255)(cardCount + v.value0 | 0);\n                return function(v2) {\n                    return {\n                        cards: v2.cards,\n                        others: deckCount - cardCount | 0,\n                        hand: min7(v1.hand)(deckCount)\n                    };\n                };\n            })));\n            if (v instanceof SelectOnFocus2) {\n                var element3 = composeKleisliFlipped5(fromEventTarget)(function($137) {\n                    return target(toEvent($137));\n                })(v.value0);\n                return liftEffect4(traverse_6(select2)(element3));\n            }\n            if (v instanceof StartReorder) {\n                var transfer = dataTransfer(v.value1);\n                return discard23(liftEffect4(setData2(\"tcg-calculator/card\")(toString4(v.value0))(transfer)))(function() {\n                    return bind9(getRef(toString4(v.value0)))(function(elem4) {\n                        return liftEffect4(traverse_6(function(e) {\n                            return setDragImage(transfer)(e)(5)(15);\n                        })(elem4));\n                    });\n                });\n            }\n            if (v instanceof HandleDragBehavior) {\n                var transfer = dataTransfer(v.value0);\n                return when4(eq12(types(transfer))([\n                    \"tcg-calculator/card\"\n                ]))(liftEffect4(preventDefault(toEvent2(v.value0))));\n            }\n            if (v instanceof ExecuteReorder) {\n                var transfer = dataTransfer(v.value1);\n                return bind9(liftEffect4(getData(\"tcg-calculator/card\")(transfer)))(function(id3) {\n                    return unless2($$null2(id3))(discard23(bindFlipped1(raiseUpdated)(modify8(bind15(function(v1) {\n                        return v1.cards;\n                    })(function(cards) {\n                        var cards$prime = fold22(bind23(fromString3(id3))(function(target7) {\n                            return bind23(findIndex(function($138) {\n                                return function(v1) {\n                                    return eq7(v1)(target7);\n                                }(function(v1) {\n                                    return v1.id;\n                                }($138));\n                            })(cards))(function(from3) {\n                                return bind23(findIndex(function($139) {\n                                    return function(v1) {\n                                        return eq7(v1)(v.value0);\n                                    }(function(v1) {\n                                        return v1.id;\n                                    }($139));\n                                })(cards))(function(to) {\n                                    return pure24(shiftInsert(from3)(to)(cards));\n                                });\n                            });\n                        }));\n                        return function(v1) {\n                            return {\n                                hand: v1.hand,\n                                others: v1.others,\n                                cards: cards$prime\n                            };\n                        };\n                    }))))(function() {\n                        return liftEffect4(preventDefault(toEvent2(v.value1)));\n                    }));\n                });\n            }\n            throw new Error(\"Failed pattern match at App.Deck (line 170, column 12 - line 229, column 67): \" + [\n                v.constructor.name\n            ]);\n        };\n        return mkComponent({\n            initialState: initialState,\n            render: render,\n            \"eval\": mkEval({\n                receive: defaultEval.receive,\n                initialize: defaultEval.initialize,\n                finalize: defaultEval.finalize,\n                handleAction: action2,\n                handleQuery: function($140) {\n                    return runMaybeT(query3($140));\n                }\n            })\n        });\n    }();\n    // output/Data.Argonaut.Parser/foreign.js\n    function _jsonParser(fail2, succ, s) {\n        try {\n            return succ(JSON.parse(s));\n        } catch (e) {\n            return fail2(e.message);\n        }\n    }\n    // output/Data.Argonaut.Parser/index.js\n    var jsonParser = function(j) {\n        return _jsonParser(Left.create, Right.create, j);\n    };\n    // output/Data.Argonaut.Decode.Parser/index.js\n    var parseJson = /* @__PURE__ */ function() {\n        var $3 = lmap(bifunctorEither)(function(v) {\n            return new TypeMismatch2(\"JSON\");\n        });\n        return function($4) {\n            return $3(jsonParser($4));\n        };\n    }();\n    // output/Effect.Console/foreign.js\n    var warn = function(s) {\n        return function() {\n            console.warn(s);\n        };\n    };\n    var error3 = function(s) {\n        return function() {\n            console.error(s);\n        };\n    };\n    // output/Effect.Class.Console/index.js\n    var error4 = function(dictMonadEffect) {\n        var $79 = liftEffect(dictMonadEffect);\n        return function($80) {\n            return $79(error3($80));\n        };\n    };\n    // output/JSURI/foreign.js\n    function _decodeURIComponent(fail2, succeed, input3) {\n        try {\n            return succeed(decodeURIComponent(input3));\n        } catch (err) {\n            return fail2(err);\n        }\n    }\n    // output/JSURI/index.js\n    var $$decodeURIComponent = /* @__PURE__ */ function() {\n        return runFn3(_decodeURIComponent)($$const(Nothing.value))(Just.create);\n    }();\n    // output/Web.HTML.Event.HashChangeEvent.EventTypes/index.js\n    var hashchange = \"hashchange\";\n    // output/Routing.Hash/index.js\n    var bind10 = /* @__PURE__ */ bind(bindEffect);\n    var map27 = /* @__PURE__ */ map(functorEffect);\n    var bindFlipped7 = /* @__PURE__ */ bindFlipped(bindEffect);\n    var join3 = /* @__PURE__ */ join(bindEffect);\n    var apply3 = /* @__PURE__ */ apply(applyEffect);\n    var pure10 = /* @__PURE__ */ pure(applicativeEffect);\n    var voidRight2 = /* @__PURE__ */ voidRight(functorEffect);\n    var setHash2 = function(h) {\n        return bind10(bind10(windowImpl)(location))(setHash(h));\n    };\n    var getHash = /* @__PURE__ */ bind10(/* @__PURE__ */ bind10(windowImpl)(location))(/* @__PURE__ */ function() {\n        var $16 = map27(function() {\n            var $18 = fromMaybe(\"\");\n            var $19 = stripPrefix(\"#\");\n            return function($20) {\n                return $18($19($20));\n            };\n        }());\n        return function($17) {\n            return $16(hash($17));\n        };\n    }());\n    var foldHashes = function(cb) {\n        return function(init3) {\n            return function __do2() {\n                var ref3 = bindFlipped7($$new)(bindFlipped7(init3)(getHash))();\n                var win = map27(toEventTarget)(windowImpl)();\n                var listener = eventListener(function(v) {\n                    return bindFlipped7(flip(write)(ref3))(join3(apply3(map27(cb)(read(ref3)))(getHash)));\n                })();\n                addEventListener2(hashchange)(listener)(false)(win)();\n                return removeEventListener2(hashchange)(listener)(false)(win);\n            };\n        };\n    };\n    var matchesWith = function(dictFoldable) {\n        var indexl2 = indexl(dictFoldable);\n        return function(parser) {\n            return function(cb) {\n                var go2 = function(a2) {\n                    var $21 = maybe(pure10(a2))(function(b2) {\n                        return voidRight2(new Just(b2))(cb(a2)(b2));\n                    });\n                    var $22 = indexl2(0);\n                    return function($23) {\n                        return $21($22(parser($23)));\n                    };\n                };\n                return foldHashes(go2)(go2(Nothing.value));\n            };\n        };\n    };\n    // output/App.App/index.js\n    var resultIsSymbol2 = {\n        reflectSymbol: function() {\n            return \"result\";\n        }\n    };\n    var slot4 = /* @__PURE__ */ slot();\n    var deckIsSymbol = {\n        reflectSymbol: function() {\n            return \"deck\";\n        }\n    };\n    var conditionIsSymbol = {\n        reflectSymbol: function() {\n            return \"condition\";\n        }\n    };\n    var slot1 = /* @__PURE__ */ slot4(conditionIsSymbol)(ordId);\n    var bind11 = /* @__PURE__ */ bind(bindHalogenM);\n    var monadEffectHalogenM3 = /* @__PURE__ */ monadEffectHalogenM(monadEffectAff);\n    var liftEffect5 = /* @__PURE__ */ liftEffect(monadEffectHalogenM3);\n    var $$void9 = /* @__PURE__ */ $$void(functorHalogenM);\n    var matchesWith2 = /* @__PURE__ */ matchesWith(foldableMaybe);\n    var get6 = /* @__PURE__ */ get(monadStateHalogenM);\n    var when5 = /* @__PURE__ */ when(applicativeHalogenM);\n    var generateId4 = /* @__PURE__ */ generateId(monadEffectHalogenM3);\n    var discard7 = /* @__PURE__ */ discard(discardUnit)(bindHalogenM);\n    var modify_7 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n    var tell5 = /* @__PURE__ */ tell2();\n    var tell12 = /* @__PURE__ */ tell5(deckIsSymbol)(ordUnit);\n    var gets7 = /* @__PURE__ */ gets(monadStateHalogenM);\n    var eqRec3 = /* @__PURE__ */ eqRec();\n    var eqRowCons3 = /* @__PURE__ */ eqRowCons(eqRowNil)();\n    var othersIsSymbol = {\n        reflectSymbol: function() {\n            return \"others\";\n        }\n    };\n    var handIsSymbol = {\n        reflectSymbol: function() {\n            return \"hand\";\n        }\n    };\n    var cardsIsSymbol2 = {\n        reflectSymbol: function() {\n            return \"cards\";\n        }\n    };\n    var nameIsSymbol2 = {\n        reflectSymbol: function() {\n            return \"name\";\n        }\n    };\n    var idIsSymbol3 = {\n        reflectSymbol: function() {\n            return \"id\";\n        }\n    };\n    var countIsSymbol2 = {\n        reflectSymbol: function() {\n            return \"count\";\n        }\n    };\n    var notEq3 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons3(othersIsSymbol)(eqInt))()(handIsSymbol)(eqInt))()(cardsIsSymbol2)(/* @__PURE__ */ eqArray(/* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons3(nameIsSymbol2)(eqString))()(idIsSymbol3)(eqId))()(countIsSymbol2)(eqInt))))));\n    var bind16 = /* @__PURE__ */ bind(bindFn);\n    var notEq12 = /* @__PURE__ */ notEq(eqId);\n    var tell23 = /* @__PURE__ */ tell5(conditionIsSymbol)(ordId);\n    var requestAll3 = /* @__PURE__ */ requestAll()(conditionIsSymbol)(ordId);\n    var fromFoldable8 = /* @__PURE__ */ fromFoldable(foldableList);\n    var tell32 = /* @__PURE__ */ tell5(resultIsSymbol2)(ordUnit);\n    var bind24 = /* @__PURE__ */ bind(bindEither);\n    var gDecodeJsonCons2 = /* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonInt));\n    var gDecodeJsonCons1 = /* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonBoolean));\n    var modeIsSymbol2 = {\n        reflectSymbol: function() {\n            return \"mode\";\n        }\n    };\n    var disabledIsSymbol = {\n        reflectSymbol: function() {\n            return \"disabled\";\n        }\n    };\n    var conditionsIsSymbol = {\n        reflectSymbol: function() {\n            return \"conditions\";\n        }\n    };\n    var decodeJson4 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(decodeJsonId)))(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons1(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonConditionMode))(gDecodeJsonNil)(modeIsSymbol2)()())(disabledIsSymbol)()())(countIsSymbol2)()())(cardsIsSymbol2)()())())))(/* @__PURE__ */ gDecodeJsonCons1(gDecodeJsonNil)(disabledIsSymbol)()())(conditionsIsSymbol)()())())))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonId))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonString))(gDecodeJsonNil)(nameIsSymbol2)()())(idIsSymbol3)()())(countIsSymbol2)()())())))(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons2(gDecodeJsonNil)(othersIsSymbol)()())(handIsSymbol)()())(cardsIsSymbol2)()())()))(gDecodeJsonNil)(deckIsSymbol)()())(conditionsIsSymbol)()())());\n    var error5 = /* @__PURE__ */ error4(monadEffectHalogenM3);\n    var traverse4 = /* @__PURE__ */ traverse(traversableArray)(applicativeHalogenM);\n    var flap3 = /* @__PURE__ */ flap(functorHalogenM);\n    var map28 = /* @__PURE__ */ map(functorHalogenM);\n    var put7 = /* @__PURE__ */ put(monadStateHalogenM);\n    var mapFlipped6 = /* @__PURE__ */ mapFlipped(functorArray);\n    var for_3 = /* @__PURE__ */ for_(applicativeHalogenM)(foldableArray);\n    var flap12 = /* @__PURE__ */ flap(functorFn);\n    var lookup7 = /* @__PURE__ */ lookup(ordId);\n    var gEncodeJsonCons4 = /* @__PURE__ */ gEncodeJsonCons(encodeJsonInt);\n    var gEncodeJsonCons1 = /* @__PURE__ */ gEncodeJsonCons(encodeJsonJBoolean);\n    var encodeJson4 = /* @__PURE__ */ encodeJson(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(encodeJsonId))(/* @__PURE__ */ gEncodeJsonCons4(/* @__PURE__ */ gEncodeJsonCons1(/* @__PURE__ */ gEncodeJsonCons(encodeJsonConditionMode)(gEncodeJsonNil)(modeIsSymbol2)())(disabledIsSymbol)())(countIsSymbol2)())(cardsIsSymbol2)())()))(/* @__PURE__ */ gEncodeJsonCons1(gEncodeJsonNil)(disabledIsSymbol)())(conditionsIsSymbol)())()))(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons4(/* @__PURE__ */ gEncodeJsonCons(encodeJsonId)(/* @__PURE__ */ gEncodeJsonCons(encodeJsonJString)(gEncodeJsonNil)(nameIsSymbol2)())(idIsSymbol3)())(countIsSymbol2)())()))(/* @__PURE__ */ gEncodeJsonCons4(/* @__PURE__ */ gEncodeJsonCons4(gEncodeJsonNil)(othersIsSymbol)())(handIsSymbol)())(cardsIsSymbol2)())())(gEncodeJsonNil)(deckIsSymbol)())(conditionsIsSymbol)())());\n    var Initialize4 = /* @__PURE__ */ function() {\n        function Initialize5() {}\n        Initialize5.value = new Initialize5();\n        return Initialize5;\n    }();\n    var PrepareDefaultState = /* @__PURE__ */ function() {\n        function PrepareDefaultState2() {}\n        PrepareDefaultState2.value = new PrepareDefaultState2();\n        return PrepareDefaultState2;\n    }();\n    var UpdateDeck2 = /* @__PURE__ */ function() {\n        function UpdateDeck3(value0) {\n            this.value0 = value0;\n        }\n        UpdateDeck3.create = function(value0) {\n            return new UpdateDeck3(value0);\n        };\n        return UpdateDeck3;\n    }();\n    var AddCondition2 = /* @__PURE__ */ function() {\n        function AddCondition3() {}\n        AddCondition3.value = new AddCondition3();\n        return AddCondition3;\n    }();\n    var RemoveCondition2 = /* @__PURE__ */ function() {\n        function RemoveCondition3(value0) {\n            this.value0 = value0;\n        }\n        RemoveCondition3.create = function(value0) {\n            return new RemoveCondition3(value0);\n        };\n        return RemoveCondition3;\n    }();\n    var ToggleDisabled2 = /* @__PURE__ */ function() {\n        function ToggleDisabled3(value0) {\n            this.value0 = value0;\n        }\n        ToggleDisabled3.create = function(value0) {\n            return new ToggleDisabled3(value0);\n        };\n        return ToggleDisabled3;\n    }();\n    var Swap = /* @__PURE__ */ function() {\n        function Swap2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        Swap2.create = function(value0) {\n            return function(value1) {\n                return new Swap2(value0, value1);\n            };\n        };\n        return Swap2;\n    }();\n    var ReceiveConditionUpdated = /* @__PURE__ */ function() {\n        function ReceiveConditionUpdated2(value0, value1) {\n            this.value0 = value0;\n            this.value1 = value1;\n        }\n        ReceiveConditionUpdated2.create = function(value0) {\n            return function(value1) {\n                return new ReceiveConditionUpdated2(value0, value1);\n            };\n        };\n        return ReceiveConditionUpdated2;\n    }();\n    var Calculate3 = /* @__PURE__ */ function() {\n        function Calculate4() {}\n        Calculate4.value = new Calculate4();\n        return Calculate4;\n    }();\n    var RestoreState3 = /* @__PURE__ */ function() {\n        function RestoreState4(value0) {\n            this.value0 = value0;\n        }\n        RestoreState4.create = function(value0) {\n            return new RestoreState4(value0);\n        };\n        return RestoreState4;\n    }();\n    var SaveState = /* @__PURE__ */ function() {\n        function SaveState2() {}\n        SaveState2.value = new SaveState2();\n        return SaveState2;\n    }();\n    var component6 = /* @__PURE__ */ function() {\n        var renderResult = div2([\n            class_(\"flex grow basis-0 items-center rounded border-2 border-cyan-400 p-1\")\n        ])([\n            div2([\n                class_(\"flex w-full justify-end gap-3\")\n            ])([\n                div_([\n                    button2(text(\"Save\"))(\"border border-rose-500 hover:bg-rose-100\")(SaveState.value)\n                ]),\n                slot_()(resultIsSymbol2)(ordUnit)($$Proxy.value)(unit)(component3)(unit)\n            ])\n        ]);\n        var renderDeck = div2([\n            class_(\"grow\")\n        ])([\n            slot4(deckIsSymbol)(ordUnit)($$Proxy.value)(unit)(component5)(unit)(UpdateDeck2.create)\n        ]);\n        var renderConditionAddButton = div_([\n            plusButton(AddCondition2.value)\n        ]);\n        var renderCondition = function(deck) {\n            return function(i2) {\n                return function(id3) {\n                    return li([\n                        class_(\"flex items-start gap-1\")\n                    ])([\n                        div2([\n                            class_(\"flex flex-col\")\n                        ])([\n                            upButton(new Swap(i2 - 1 | 0, i2)),\n                            removeButton(new RemoveCondition2(id3)),\n                            toggleButton(new ToggleDisabled2(id3)),\n                            downButton(new Swap(i2, i2 + 1 | 0))\n                        ]),\n                        slot1($$Proxy.value)(id3)(component4)(deck)(ReceiveConditionUpdated.create(id3))\n                    ]);\n                };\n            };\n        };\n        var render = function(v) {\n            return div2([\n                class_(\"relative overflow-x-clip\")\n            ])([\n                header([\n                    class_(\"flex items-baseline px-2\")\n                ])([\n                    h1([\n                        class_(\"p-1 text-lg\")\n                    ])([\n                        a([\n                            href(\".\")\n                        ])([\n                            text(\"Draw Calculator\")\n                        ])\n                    ]),\n                    text(\"-\"),\n                    h2([\n                        class_(\"p-1\")\n                    ])([\n                        text(\"TCG \\u7528\\u30C9\\u30ED\\u30FC\\u78BA\\u7387\\u8A08\\u7B97\\u6A5F\")\n                    ])\n                ]),\n                main([\n                    class_(\"relative mb-[80vh] flex max-w-4xl flex-col gap-3 p-1\")\n                ])([\n                    div2([\n                        class_(\"flex flex-wrap gap-1\")\n                    ])([\n                        renderDeck,\n                        renderResult\n                    ]),\n                    ul([\n                        class_(\"flex flex-col gap-1\")\n                    ])(mapWithIndex2(renderCondition(v.deck))(v.conditions)),\n                    renderConditionAddButton\n                ]),\n                footer([\n                    class_(\"flex items-baseline px-2\")\n                ])([\n                    a([\n                        class_(\"m-1 rounded border border-sky-500 px-2 py-1 text-sm\"),\n                        href(\"https://github.com/acple/tcg-calculator\"),\n                        target2(\"_blank\"),\n                        rel(\"noopener noreferrer\")\n                    ])([\n                        text(\"\\u2192 \\u4F7F\\u3044\\u65B9\\u3068\\u304B\\u30BD\\u30FC\\u30B9\")\n                    ])\n                ])\n            ]);\n        };\n        var initialState = function(v) {\n            return {\n                deck: {\n                    cards: [],\n                    others: 0,\n                    hand: 0\n                },\n                conditions: []\n            };\n        };\n        var action2 = function(v) {\n            if (v instanceof Initialize4) return bind11(liftEffect5(create))(function(v12) {\n                return bind11(subscribe2(v12.emitter))(function() {\n                    return $$void9(liftEffect5(matchesWith2($$decodeURIComponent)(function(v2) {\n                        return function(hash2) {\n                            return notify(v12.listener)(function() {\n                                var $275 = $$null2(hash2);\n                                if ($275) return PrepareDefaultState.value;\n                                return new RestoreState3(hash2);\n                            }());\n                        };\n                    })));\n                });\n            });\n            if (v instanceof PrepareDefaultState) return bind11(get6)(function(v12) {\n                return when5($$null(v12.deck.cards) && $$null(v12.conditions))(bind11(generateId4)(function(id3) {\n                    var defaultDeck = {\n                        cards: [\n                            {\n                                id: id3,\n                                name: \"Card1\",\n                                count: 3\n                            }\n                        ],\n                        others: 37,\n                        hand: 5\n                    };\n                    return discard7(modify_7(function(v2) {\n                        var $279 = {};\n                        for(var $280 in v2)if (({}).hasOwnProperty.call(v2, $280)) $279[$280] = v2[$280];\n                        $279.deck = defaultDeck;\n                        return $279;\n                    }))(function() {\n                        return discard7(tell12($$Proxy.value)(unit)(SetDeck.create(defaultDeck)))(function() {\n                            return action2(AddCondition2.value);\n                        });\n                    });\n                }));\n            });\n            if (v instanceof UpdateDeck2) return bind11(gets7(function(v12) {\n                return v12.deck;\n            }))(function(current) {\n                return when5(notEq3(v.value0)(current))(discard7(modify_7(function(v12) {\n                    var $284 = {};\n                    for(var $285 in v12)if (({}).hasOwnProperty.call(v12, $285)) $284[$285] = v12[$285];\n                    $284.deck = v.value0;\n                    return $284;\n                }))(function() {\n                    return action2(Calculate3.value);\n                }));\n            });\n            if (v instanceof AddCondition2) return bind11(generateId4)(function(id3) {\n                return discard7(modify_7(bind16(function(v12) {\n                    return v12.conditions;\n                })(function(conditions) {\n                    return function(v12) {\n                        var $288 = {};\n                        for(var $289 in v12)if (({}).hasOwnProperty.call(v12, $289)) $288[$289] = v12[$289];\n                        $288.conditions = snoc(conditions)(id3);\n                        return $288;\n                    };\n                })))(function() {\n                    return action2(Calculate3.value);\n                });\n            });\n            if (v instanceof RemoveCondition2) return discard7(modify_7(bind16(function(v12) {\n                return v12.conditions;\n            })(function(conditions) {\n                return function(v12) {\n                    var $291 = {};\n                    for(var $292 in v12)if (({}).hasOwnProperty.call(v12, $292)) $291[$292] = v12[$292];\n                    $291.conditions = filter(function(v2) {\n                        return notEq12(v2)(v.value0);\n                    })(conditions);\n                    return $291;\n                };\n            })))(function() {\n                return action2(Calculate3.value);\n            });\n            if (v instanceof ToggleDisabled2) return discard7(tell23($$Proxy.value)(v.value0)(ToggleDisabled.create))(function() {\n                return action2(Calculate3.value);\n            });\n            if (v instanceof Swap) return modify_7(bind16(function(v12) {\n                return v12.conditions;\n            })(function(conditions) {\n                return function(v12) {\n                    var $296 = {};\n                    for(var $297 in v12)if (({}).hasOwnProperty.call(v12, $297)) $296[$297] = v12[$297];\n                    $296.conditions = swap(v.value0)(v.value1)(conditions);\n                    return $296;\n                };\n            }));\n            if (v instanceof ReceiveConditionUpdated && v.value1 instanceof Updated2) return action2(Calculate3.value);\n            if (v instanceof ReceiveConditionUpdated && v.value1 instanceof AllConditionDeleted) return action2(new RemoveCondition2(v.value0));\n            if (v instanceof Calculate3) return bind11(gets7(function(v12) {\n                return v12.deck;\n            }))(function(deck) {\n                return bind11(requestAll3($$Proxy.value)(GetConditions.create))(function(conditions) {\n                    var conditions$prime = fromFoldable8(values(conditions));\n                    return tell32($$Proxy.value)(unit)(Calculate.create(deck)(conditions$prime));\n                });\n            });\n            if (v instanceof RestoreState3) {\n                var v1 = bind24(parseJson(v.value0))(decodeJson4);\n                if (v1 instanceof Left) return discard7(error5(printJsonDecodeError(v1.value0)))(function() {\n                    return action2(PrepareDefaultState.value);\n                });\n                if (v1 instanceof Right) return bind11(traverse4(flap3(map28(function(v2) {\n                    return function(v3) {\n                        return {\n                            id: v2,\n                            condition: v3\n                        };\n                    };\n                })(generateId4)))(v1.value0.conditions))(function(conditions$prime) {\n                    return discard7(put7({\n                        deck: v1.value0.deck,\n                        conditions: mapFlipped6(conditions$prime)(function(v2) {\n                            return v2.id;\n                        })\n                    }))(function() {\n                        return discard7(tell12($$Proxy.value)(unit)(SetDeck.create(v1.value0.deck)))(function() {\n                            return discard7(for_3(conditions$prime)(function(v2) {\n                                return tell23($$Proxy.value)(v2.id)(RestoreState2.create(v1.value0.deck)(v2.condition));\n                            }))(function() {\n                                return action2(Calculate3.value);\n                            });\n                        });\n                    });\n                });\n                throw new Error(\"Failed pattern match at App.App (line 180, column 7 - line 190, column 27): \" + [\n                    v1.constructor.name\n                ]);\n            }\n            if (v instanceof SaveState) return bind11(get6)(function(v12) {\n                return bind11(requestAll3($$Proxy.value)(GetState.create))(function(conditions) {\n                    var conditions$prime = mapMaybe(flap12(lookup7)(conditions))(v12.conditions);\n                    var json = encodeJson4({\n                        deck: v12.deck,\n                        conditions: conditions$prime\n                    });\n                    return liftEffect5(setHash2(stringify(json)));\n                });\n            });\n            throw new Error(\"Failed pattern match at App.App (line 131, column 12 - line 196, column 51): \" + [\n                v.constructor.name\n            ]);\n        };\n        return mkComponent({\n            initialState: initialState,\n            render: render,\n            \"eval\": mkEval({\n                handleQuery: defaultEval.handleQuery,\n                receive: defaultEval.receive,\n                finalize: defaultEval.finalize,\n                handleAction: action2,\n                initialize: new Just(Initialize4.value)\n            })\n        });\n    }();\n    // output/Halogen.Aff.Util/index.js\n    var bind17 = /* @__PURE__ */ bind(bindAff);\n    var liftEffect6 = /* @__PURE__ */ liftEffect(monadEffectAff);\n    var bindFlipped8 = /* @__PURE__ */ bindFlipped(bindEffect);\n    var composeKleisliFlipped6 = /* @__PURE__ */ composeKleisliFlipped(bindEffect);\n    var pure11 = /* @__PURE__ */ pure(applicativeAff);\n    var bindFlipped12 = /* @__PURE__ */ bindFlipped(bindMaybe);\n    var pure13 = /* @__PURE__ */ pure(applicativeEffect);\n    var map29 = /* @__PURE__ */ map(functorEffect);\n    var discard8 = /* @__PURE__ */ discard(discardUnit);\n    var throwError3 = /* @__PURE__ */ throwError(monadThrowAff);\n    var selectElement = function(query3) {\n        return bind17(liftEffect6(bindFlipped8(composeKleisliFlipped6(function() {\n            var $16 = querySelector(query3);\n            return function($17) {\n                return $16(toParentNode($17));\n            };\n        }())(document))(windowImpl)))(function(mel) {\n            return pure11(bindFlipped12(fromElement)(mel));\n        });\n    };\n    var runHalogenAff = /* @__PURE__ */ runAff_(/* @__PURE__ */ either(throwException)(/* @__PURE__ */ $$const(/* @__PURE__ */ pure13(unit))));\n    var awaitLoad = /* @__PURE__ */ makeAff(function(callback) {\n        return function __do2() {\n            var rs = bindFlipped8(readyState)(bindFlipped8(document)(windowImpl))();\n            if (rs instanceof Loading) {\n                var et = map29(toEventTarget)(windowImpl)();\n                var listener = eventListener(function(v) {\n                    return callback(new Right(unit));\n                })();\n                addEventListener2(domcontentloaded)(listener)(false)(et)();\n                return effectCanceler(removeEventListener2(domcontentloaded)(listener)(false)(et));\n            }\n            callback(new Right(unit))();\n            return nonCanceler;\n        };\n    });\n    var awaitBody = /* @__PURE__ */ discard8(bindAff)(awaitLoad)(function() {\n        return bind17(selectElement(\"body\"))(function(body2) {\n            return maybe(throwError3(error(\"Could not find body\")))(pure11)(body2);\n        });\n    });\n    // output/Control.Monad.Fork.Class/index.js\n    var monadForkAff = {\n        suspend: suspendAff,\n        fork: forkAff,\n        join: joinFiber,\n        Monad0: function() {\n            return monadAff;\n        },\n        Functor1: function() {\n            return functorFiber;\n        }\n    };\n    var fork2 = function(dict) {\n        return dict.fork;\n    };\n    // output/Halogen.Aff.Driver.State/index.js\n    var unRenderStateX = unsafeCoerce2;\n    var unDriverStateX = unsafeCoerce2;\n    var renderStateX_ = function(dictApplicative) {\n        var traverse_10 = traverse_(dictApplicative)(foldableMaybe);\n        return function(f2) {\n            return unDriverStateX(function(st) {\n                return traverse_10(f2)(st.rendering);\n            });\n        };\n    };\n    var mkRenderStateX = unsafeCoerce2;\n    var renderStateX = function(dictFunctor) {\n        return function(f2) {\n            return unDriverStateX(function(st) {\n                return mkRenderStateX(f2(st.rendering));\n            });\n        };\n    };\n    var mkDriverStateXRef = unsafeCoerce2;\n    var mapDriverState = function(f2) {\n        return function(v) {\n            return f2(v);\n        };\n    };\n    var initDriverState = function(component7) {\n        return function(input3) {\n            return function(handler3) {\n                return function(lchs) {\n                    return function __do2() {\n                        var selfRef = $$new({})();\n                        var childrenIn = $$new(empty3)();\n                        var childrenOut = $$new(empty3)();\n                        var handlerRef = $$new(handler3)();\n                        var pendingQueries = $$new(new Just(Nil.value))();\n                        var pendingOuts = $$new(new Just(Nil.value))();\n                        var pendingHandlers = $$new(Nothing.value)();\n                        var fresh2 = $$new(1)();\n                        var subscriptions = $$new(new Just(empty2))();\n                        var forks = $$new(empty2)();\n                        var ds = {\n                            component: component7,\n                            state: component7.initialState(input3),\n                            refs: empty2,\n                            children: empty3,\n                            childrenIn: childrenIn,\n                            childrenOut: childrenOut,\n                            selfRef: selfRef,\n                            handlerRef: handlerRef,\n                            pendingQueries: pendingQueries,\n                            pendingOuts: pendingOuts,\n                            pendingHandlers: pendingHandlers,\n                            rendering: Nothing.value,\n                            fresh: fresh2,\n                            subscriptions: subscriptions,\n                            forks: forks,\n                            lifecycleHandlers: lchs\n                        };\n                        write(ds)(selfRef)();\n                        return mkDriverStateXRef(selfRef);\n                    };\n                };\n            };\n        };\n    };\n    // output/Halogen.Aff.Driver.Eval/index.js\n    var traverse_7 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableMaybe);\n    var bindFlipped9 = /* @__PURE__ */ bindFlipped(bindMaybe);\n    var lookup8 = /* @__PURE__ */ lookup(ordSubscriptionId);\n    var bind18 = /* @__PURE__ */ bind(bindAff);\n    var liftEffect7 = /* @__PURE__ */ liftEffect(monadEffectAff);\n    var discard9 = /* @__PURE__ */ discard(discardUnit);\n    var discard13 = /* @__PURE__ */ discard9(bindAff);\n    var traverse_13 = /* @__PURE__ */ traverse_(applicativeAff);\n    var traverse_22 = /* @__PURE__ */ traverse_13(foldableList);\n    var fork3 = /* @__PURE__ */ fork2(monadForkAff);\n    var parSequence_2 = /* @__PURE__ */ parSequence_(parallelAff)(applicativeParAff)(foldableList);\n    var pure14 = /* @__PURE__ */ pure(applicativeAff);\n    var map30 = /* @__PURE__ */ map(functorCoyoneda);\n    var parallel3 = /* @__PURE__ */ parallel(parallelAff);\n    var map111 = /* @__PURE__ */ map(functorAff);\n    var sequential2 = /* @__PURE__ */ sequential(parallelAff);\n    var map210 = /* @__PURE__ */ map(functorMaybe);\n    var insert9 = /* @__PURE__ */ insert(ordSubscriptionId);\n    var retractFreeAp2 = /* @__PURE__ */ retractFreeAp(applicativeParAff);\n    var $$delete3 = /* @__PURE__ */ $$delete(ordForkId);\n    var unlessM2 = /* @__PURE__ */ unlessM(monadEffect);\n    var insert12 = /* @__PURE__ */ insert(ordForkId);\n    var traverse_32 = /* @__PURE__ */ traverse_13(foldableMaybe);\n    var lookup12 = /* @__PURE__ */ lookup(ordForkId);\n    var lookup22 = /* @__PURE__ */ lookup(ordString);\n    var foldFree2 = /* @__PURE__ */ foldFree(monadRecAff);\n    var alter2 = /* @__PURE__ */ alter(ordString);\n    var unsubscribe3 = function(sid) {\n        return function(ref3) {\n            return function __do2() {\n                var v = read(ref3)();\n                var subs = read(v.subscriptions)();\n                return traverse_7(unsubscribe)(bindFlipped9(lookup8(sid))(subs))();\n            };\n        };\n    };\n    var queueOrRun = function(ref3) {\n        return function(au) {\n            return bind18(liftEffect7(read(ref3)))(function(v) {\n                if (v instanceof Nothing) return au;\n                if (v instanceof Just) return liftEffect7(write(new Just(new Cons(au, v.value0)))(ref3));\n                throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 188, column 33 - line 190, column 57): \" + [\n                    v.constructor.name\n                ]);\n            });\n        };\n    };\n    var handleLifecycle = function(lchs) {\n        return function(f2) {\n            return discard13(liftEffect7(write({\n                initializers: Nil.value,\n                finalizers: Nil.value\n            })(lchs)))(function() {\n                return bind18(liftEffect7(f2))(function(result) {\n                    return bind18(liftEffect7(read(lchs)))(function(v) {\n                        return discard13(traverse_22(fork3)(v.finalizers))(function() {\n                            return discard13(parSequence_2(v.initializers))(function() {\n                                return pure14(result);\n                            });\n                        });\n                    });\n                });\n            });\n        };\n    };\n    var handleAff = /* @__PURE__ */ runAff_(/* @__PURE__ */ either(throwException)(/* @__PURE__ */ $$const(/* @__PURE__ */ pure(applicativeEffect)(unit))));\n    var fresh = function(f2) {\n        return function(ref3) {\n            return bind18(liftEffect7(read(ref3)))(function(v) {\n                return liftEffect7(modify$prime(function(i2) {\n                    return {\n                        state: i2 + 1 | 0,\n                        value: f2(i2)\n                    };\n                })(v.fresh));\n            });\n        };\n    };\n    var evalQ = function(render) {\n        return function(ref3) {\n            return function(q2) {\n                return bind18(liftEffect7(read(ref3)))(function(v) {\n                    return evalM(render)(ref3)(v[\"component\"][\"eval\"](new Query(map30(Just.create)(liftCoyoneda(q2)), $$const(Nothing.value))));\n                });\n            };\n        };\n    };\n    var evalM = function(render) {\n        return function(initRef) {\n            return function(v) {\n                var evalChildQuery = function(ref3) {\n                    return function(cqb) {\n                        return bind18(liftEffect7(read(ref3)))(function(v1) {\n                            return unChildQueryBox(function(v2) {\n                                var evalChild = function(v3) {\n                                    return parallel3(bind18(liftEffect7(read(v3)))(function(dsx) {\n                                        return unDriverStateX(function(ds) {\n                                            return evalQ(render)(ds.selfRef)(v2.value1);\n                                        })(dsx);\n                                    }));\n                                };\n                                return map111(v2.value2)(sequential2(v2.value0(applicativeParAff)(evalChild)(v1.children)));\n                            })(cqb);\n                        });\n                    };\n                };\n                var go2 = function(ref3) {\n                    return function(v1) {\n                        if (v1 instanceof State) return bind18(liftEffect7(read(ref3)))(function(v2) {\n                            var v3 = v1.value0(v2.state);\n                            if (unsafeRefEq(v2.state)(v3.value1)) return pure14(v3.value0);\n                            if (otherwise) return discard13(liftEffect7(write({\n                                component: v2.component,\n                                refs: v2.refs,\n                                children: v2.children,\n                                childrenIn: v2.childrenIn,\n                                childrenOut: v2.childrenOut,\n                                selfRef: v2.selfRef,\n                                handlerRef: v2.handlerRef,\n                                pendingQueries: v2.pendingQueries,\n                                pendingOuts: v2.pendingOuts,\n                                pendingHandlers: v2.pendingHandlers,\n                                rendering: v2.rendering,\n                                fresh: v2.fresh,\n                                subscriptions: v2.subscriptions,\n                                forks: v2.forks,\n                                lifecycleHandlers: v2.lifecycleHandlers,\n                                state: v3.value1\n                            })(ref3)))(function() {\n                                return discard13(handleLifecycle(v2.lifecycleHandlers)(render(v2.lifecycleHandlers)(ref3)))(function() {\n                                    return pure14(v3.value0);\n                                });\n                            });\n                            throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 86, column 7 - line 92, column 21): \" + [\n                                v3.constructor.name\n                            ]);\n                        });\n                        if (v1 instanceof Subscribe) return bind18(fresh(SubscriptionId)(ref3))(function(sid) {\n                            return bind18(liftEffect7(subscribe(v1.value0(sid))(function(act) {\n                                return handleAff(evalF(render)(ref3)(new Action(act)));\n                            })))(function(finalize) {\n                                return bind18(liftEffect7(read(ref3)))(function(v2) {\n                                    return discard13(liftEffect7(modify_(map210(insert9(sid)(finalize)))(v2.subscriptions)))(function() {\n                                        return pure14(v1.value1(sid));\n                                    });\n                                });\n                            });\n                        });\n                        if (v1 instanceof Unsubscribe) return discard13(liftEffect7(unsubscribe3(v1.value0)(ref3)))(function() {\n                            return pure14(v1.value1);\n                        });\n                        if (v1 instanceof Lift2) return v1.value0;\n                        if (v1 instanceof ChildQuery2) return evalChildQuery(ref3)(v1.value0);\n                        if (v1 instanceof Raise) return bind18(liftEffect7(read(ref3)))(function(v2) {\n                            return bind18(liftEffect7(read(v2.handlerRef)))(function(handler3) {\n                                return discard13(queueOrRun(v2.pendingOuts)(handler3(v1.value0)))(function() {\n                                    return pure14(v1.value1);\n                                });\n                            });\n                        });\n                        if (v1 instanceof Par) return sequential2(retractFreeAp2(hoistFreeAp(function() {\n                            var $119 = evalM(render)(ref3);\n                            return function($120) {\n                                return parallel3($119($120));\n                            };\n                        }())(v1.value0)));\n                        if (v1 instanceof Fork) return bind18(fresh(ForkId)(ref3))(function(fid) {\n                            return bind18(liftEffect7(read(ref3)))(function(v2) {\n                                return bind18(liftEffect7($$new(false)))(function(doneRef) {\n                                    return bind18(fork3($$finally(liftEffect7(function __do2() {\n                                        modify_($$delete3(fid))(v2.forks)();\n                                        return write(true)(doneRef)();\n                                    }))(evalM(render)(ref3)(v1.value0))))(function(fiber) {\n                                        return discard13(liftEffect7(unlessM2(read(doneRef))(modify_(insert12(fid)(fiber))(v2.forks))))(function() {\n                                            return pure14(v1.value1(fid));\n                                        });\n                                    });\n                                });\n                            });\n                        });\n                        if (v1 instanceof Join) return bind18(liftEffect7(read(ref3)))(function(v2) {\n                            return bind18(liftEffect7(read(v2.forks)))(function(forkMap) {\n                                return discard13(traverse_32(joinFiber)(lookup12(v1.value0)(forkMap)))(function() {\n                                    return pure14(v1.value1);\n                                });\n                            });\n                        });\n                        if (v1 instanceof Kill) return bind18(liftEffect7(read(ref3)))(function(v2) {\n                            return bind18(liftEffect7(read(v2.forks)))(function(forkMap) {\n                                return discard13(traverse_32(killFiber(error(\"Cancelled\")))(lookup12(v1.value0)(forkMap)))(function() {\n                                    return pure14(v1.value1);\n                                });\n                            });\n                        });\n                        if (v1 instanceof GetRef) return bind18(liftEffect7(read(ref3)))(function(v2) {\n                            return pure14(v1.value1(lookup22(v1.value0)(v2.refs)));\n                        });\n                        throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 83, column 12 - line 139, column 33): \" + [\n                            v1.constructor.name\n                        ]);\n                    };\n                };\n                return foldFree2(go2(initRef))(v);\n            };\n        };\n    };\n    var evalF = function(render) {\n        return function(ref3) {\n            return function(v) {\n                if (v instanceof RefUpdate) return liftEffect7(flip(modify_)(ref3)(mapDriverState(function(st) {\n                    return {\n                        component: st.component,\n                        state: st.state,\n                        children: st.children,\n                        childrenIn: st.childrenIn,\n                        childrenOut: st.childrenOut,\n                        selfRef: st.selfRef,\n                        handlerRef: st.handlerRef,\n                        pendingQueries: st.pendingQueries,\n                        pendingOuts: st.pendingOuts,\n                        pendingHandlers: st.pendingHandlers,\n                        rendering: st.rendering,\n                        fresh: st.fresh,\n                        subscriptions: st.subscriptions,\n                        forks: st.forks,\n                        lifecycleHandlers: st.lifecycleHandlers,\n                        refs: alter2($$const(v.value1))(v.value0)(st.refs)\n                    };\n                })));\n                if (v instanceof Action) return bind18(liftEffect7(read(ref3)))(function(v1) {\n                    return evalM(render)(ref3)(v1[\"component\"][\"eval\"](new Action2(v.value0, unit)));\n                });\n                throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 52, column 20 - line 58, column 62): \" + [\n                    v.constructor.name\n                ]);\n            };\n        };\n    };\n    // output/Halogen.Aff.Driver/index.js\n    var bind19 = /* @__PURE__ */ bind(bindEffect);\n    var discard10 = /* @__PURE__ */ discard(discardUnit);\n    var for_4 = /* @__PURE__ */ for_(applicativeEffect)(foldableMaybe);\n    var traverse_8 = /* @__PURE__ */ traverse_(applicativeAff)(foldableList);\n    var fork4 = /* @__PURE__ */ fork2(monadForkAff);\n    var bindFlipped10 = /* @__PURE__ */ bindFlipped(bindEffect);\n    var traverse_14 = /* @__PURE__ */ traverse_(applicativeEffect);\n    var traverse_23 = /* @__PURE__ */ traverse_14(foldableMaybe);\n    var traverse_33 = /* @__PURE__ */ traverse_14(foldableMap);\n    var discard24 = /* @__PURE__ */ discard10(bindAff);\n    var parSequence_3 = /* @__PURE__ */ parSequence_(parallelAff)(applicativeParAff)(foldableList);\n    var liftEffect8 = /* @__PURE__ */ liftEffect(monadEffectAff);\n    var pure15 = /* @__PURE__ */ pure(applicativeEffect);\n    var map31 = /* @__PURE__ */ map(functorEffect);\n    var pure16 = /* @__PURE__ */ pure(applicativeAff);\n    var when6 = /* @__PURE__ */ when(applicativeEffect);\n    var renderStateX2 = /* @__PURE__ */ renderStateX(functorEffect);\n    var $$void10 = /* @__PURE__ */ $$void(functorAff);\n    var foreachSlot2 = /* @__PURE__ */ foreachSlot(applicativeEffect);\n    var renderStateX_2 = /* @__PURE__ */ renderStateX_(applicativeEffect);\n    var tailRecM3 = /* @__PURE__ */ tailRecM(monadRecEffect);\n    var voidLeft3 = /* @__PURE__ */ voidLeft(functorEffect);\n    var bind110 = /* @__PURE__ */ bind(bindAff);\n    var liftEffect1 = /* @__PURE__ */ liftEffect(monadEffectEffect);\n    var newLifecycleHandlers = /* @__PURE__ */ function() {\n        return $$new({\n            initializers: Nil.value,\n            finalizers: Nil.value\n        });\n    }();\n    var handlePending = function(ref3) {\n        return function __do2() {\n            var queue = read(ref3)();\n            write(Nothing.value)(ref3)();\n            return for_4(queue)(function() {\n                var $59 = traverse_8(fork4);\n                return function($60) {\n                    return handleAff($59(reverse2($60)));\n                };\n            }())();\n        };\n    };\n    var cleanupSubscriptionsAndForks = function(v) {\n        return function __do2() {\n            bindFlipped10(traverse_23(traverse_33(unsubscribe)))(read(v.subscriptions))();\n            write(Nothing.value)(v.subscriptions)();\n            bindFlipped10(traverse_33(function() {\n                var $61 = killFiber(error(\"finalized\"));\n                return function($62) {\n                    return handleAff($61($62));\n                };\n            }()))(read(v.forks))();\n            return write(empty2)(v.forks)();\n        };\n    };\n    var runUI = function(renderSpec2) {\n        return function(component7) {\n            return function(i2) {\n                var squashChildInitializers = function(lchs) {\n                    return function(preInits) {\n                        return unDriverStateX(function(st) {\n                            var parentInitializer = evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Initialize(unit)));\n                            return modify_(function(handlers) {\n                                return {\n                                    initializers: new Cons(discard24(parSequence_3(reverse2(handlers.initializers)))(function() {\n                                        return discard24(parentInitializer)(function() {\n                                            return liftEffect8(function __do2() {\n                                                handlePending(st.pendingQueries)();\n                                                return handlePending(st.pendingOuts)();\n                                            });\n                                        });\n                                    }), preInits),\n                                    finalizers: handlers.finalizers\n                                };\n                            })(lchs);\n                        });\n                    };\n                };\n                var runComponent = function(lchs) {\n                    return function(handler3) {\n                        return function(j) {\n                            return unComponent(function(c) {\n                                return function __do2() {\n                                    var lchs$prime = newLifecycleHandlers();\n                                    var $$var2 = initDriverState(c)(j)(handler3)(lchs$prime)();\n                                    var pre2 = read(lchs)();\n                                    write({\n                                        initializers: Nil.value,\n                                        finalizers: pre2.finalizers\n                                    })(lchs)();\n                                    bindFlipped10(unDriverStateX(function() {\n                                        var $63 = render(lchs);\n                                        return function($64) {\n                                            return $63(function(v) {\n                                                return v.selfRef;\n                                            }($64));\n                                        };\n                                    }()))(read($$var2))();\n                                    bindFlipped10(squashChildInitializers(lchs)(pre2.initializers))(read($$var2))();\n                                    return $$var2;\n                                };\n                            });\n                        };\n                    };\n                };\n                var renderChild = function(lchs) {\n                    return function(handler3) {\n                        return function(childrenInRef) {\n                            return function(childrenOutRef) {\n                                return unComponentSlot(function(slot5) {\n                                    return function __do2() {\n                                        var childrenIn = map31(slot5.pop)(read(childrenInRef))();\n                                        var $$var2 = function() {\n                                            if (childrenIn instanceof Just) {\n                                                write(childrenIn.value0.value1)(childrenInRef)();\n                                                var dsx = read(childrenIn.value0.value0)();\n                                                unDriverStateX(function(st) {\n                                                    return function __do3() {\n                                                        flip(write)(st.handlerRef)(function() {\n                                                            var $65 = maybe(pure16(unit))(handler3);\n                                                            return function($66) {\n                                                                return $65(slot5.output($66));\n                                                            };\n                                                        }())();\n                                                        return handleAff(evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Receive(slot5.input, unit))))();\n                                                    };\n                                                })(dsx)();\n                                                return childrenIn.value0.value0;\n                                            }\n                                            if (childrenIn instanceof Nothing) return runComponent(lchs)(function() {\n                                                var $67 = maybe(pure16(unit))(handler3);\n                                                return function($68) {\n                                                    return $67(slot5.output($68));\n                                                };\n                                            }())(slot5.input)(slot5.component)();\n                                            throw new Error(\"Failed pattern match at Halogen.Aff.Driver (line 213, column 14 - line 222, column 98): \" + [\n                                                childrenIn.constructor.name\n                                            ]);\n                                        }();\n                                        var isDuplicate = map31(function($69) {\n                                            return isJust(slot5.get($69));\n                                        })(read(childrenOutRef))();\n                                        when6(isDuplicate)(warn(\"Halogen: Duplicate slot address was detected during rendering, unexpected results may occur\"))();\n                                        modify_(slot5.set($$var2))(childrenOutRef)();\n                                        return bind19(read($$var2))(renderStateX2(function(v) {\n                                            if (v instanceof Nothing) return $$throw(\"Halogen internal error: child was not initialized in renderChild\");\n                                            if (v instanceof Just) return pure15(renderSpec2.renderChild(v.value0));\n                                            throw new Error(\"Failed pattern match at Halogen.Aff.Driver (line 227, column 37 - line 229, column 50): \" + [\n                                                v.constructor.name\n                                            ]);\n                                        }))();\n                                    };\n                                });\n                            };\n                        };\n                    };\n                };\n                var render = function(lchs) {\n                    return function($$var2) {\n                        return function __do2() {\n                            var v = read($$var2)();\n                            var shouldProcessHandlers = map31(isNothing)(read(v.pendingHandlers))();\n                            when6(shouldProcessHandlers)(write(new Just(Nil.value))(v.pendingHandlers))();\n                            write(empty3)(v.childrenOut)();\n                            write(v.children)(v.childrenIn)();\n                            var handler3 = function() {\n                                var $70 = queueOrRun(v.pendingHandlers);\n                                var $71 = evalF(render)(v.selfRef);\n                                return function($72) {\n                                    return $70($$void10($71($72)));\n                                };\n                            }();\n                            var childHandler = function() {\n                                var $73 = queueOrRun(v.pendingQueries);\n                                return function($74) {\n                                    return $73(handler3(Action.create($74)));\n                                };\n                            }();\n                            var rendering = renderSpec2.render(function($75) {\n                                return handleAff(handler3($75));\n                            })(renderChild(lchs)(childHandler)(v.childrenIn)(v.childrenOut))(v.component.render(v.state))(v.rendering)();\n                            var children2 = read(v.childrenOut)();\n                            var childrenIn = read(v.childrenIn)();\n                            foreachSlot2(childrenIn)(function(v1) {\n                                return function __do3() {\n                                    var childDS = read(v1)();\n                                    renderStateX_2(renderSpec2.removeChild)(childDS)();\n                                    return finalize(lchs)(childDS)();\n                                };\n                            })();\n                            flip(modify_)(v.selfRef)(mapDriverState(function(ds$prime) {\n                                return {\n                                    component: ds$prime.component,\n                                    state: ds$prime.state,\n                                    refs: ds$prime.refs,\n                                    childrenIn: ds$prime.childrenIn,\n                                    childrenOut: ds$prime.childrenOut,\n                                    selfRef: ds$prime.selfRef,\n                                    handlerRef: ds$prime.handlerRef,\n                                    pendingQueries: ds$prime.pendingQueries,\n                                    pendingOuts: ds$prime.pendingOuts,\n                                    pendingHandlers: ds$prime.pendingHandlers,\n                                    fresh: ds$prime.fresh,\n                                    subscriptions: ds$prime.subscriptions,\n                                    forks: ds$prime.forks,\n                                    lifecycleHandlers: ds$prime.lifecycleHandlers,\n                                    rendering: new Just(rendering),\n                                    children: children2\n                                };\n                            }))();\n                            return when6(shouldProcessHandlers)(flip(tailRecM3)(unit)(function(v1) {\n                                return function __do3() {\n                                    var handlers = read(v.pendingHandlers)();\n                                    write(new Just(Nil.value))(v.pendingHandlers)();\n                                    traverse_23(function() {\n                                        var $76 = traverse_8(fork4);\n                                        return function($77) {\n                                            return handleAff($76(reverse2($77)));\n                                        };\n                                    }())(handlers)();\n                                    var mmore = read(v.pendingHandlers)();\n                                    var $52 = maybe(false)($$null3)(mmore);\n                                    if ($52) return voidLeft3(write(Nothing.value)(v.pendingHandlers))(new Done(unit))();\n                                    return new Loop(unit);\n                                };\n                            }))();\n                        };\n                    };\n                };\n                var finalize = function(lchs) {\n                    return unDriverStateX(function(st) {\n                        return function __do2() {\n                            cleanupSubscriptionsAndForks(st)();\n                            var f2 = evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Finalize(unit)));\n                            modify_(function(handlers) {\n                                return {\n                                    initializers: handlers.initializers,\n                                    finalizers: new Cons(f2, handlers.finalizers)\n                                };\n                            })(lchs)();\n                            return foreachSlot2(st.children)(function(v) {\n                                return function __do3() {\n                                    var dsx = read(v)();\n                                    return finalize(lchs)(dsx)();\n                                };\n                            })();\n                        };\n                    });\n                };\n                var evalDriver = function(disposed) {\n                    return function(ref3) {\n                        return function(q2) {\n                            return bind110(liftEffect8(read(disposed)))(function(v) {\n                                if (v) return pure16(Nothing.value);\n                                return evalQ(render)(ref3)(q2);\n                            });\n                        };\n                    };\n                };\n                var dispose = function(disposed) {\n                    return function(lchs) {\n                        return function(dsx) {\n                            return handleLifecycle(lchs)(function __do2() {\n                                var v = read(disposed)();\n                                if (v) return unit;\n                                write(true)(disposed)();\n                                finalize(lchs)(dsx)();\n                                return unDriverStateX(function(v1) {\n                                    return function __do3() {\n                                        var v2 = liftEffect1(read(v1.selfRef))();\n                                        return for_4(v2.rendering)(renderSpec2.dispose)();\n                                    };\n                                })(dsx)();\n                            });\n                        };\n                    };\n                };\n                return bind110(liftEffect8(newLifecycleHandlers))(function(lchs) {\n                    return bind110(liftEffect8($$new(false)))(function(disposed) {\n                        return handleLifecycle(lchs)(function __do2() {\n                            var sio = create();\n                            var dsx = bindFlipped10(read)(runComponent(lchs)(function() {\n                                var $78 = notify(sio.listener);\n                                return function($79) {\n                                    return liftEffect8($78($79));\n                                };\n                            }())(i2)(component7))();\n                            return unDriverStateX(function(st) {\n                                return pure15({\n                                    query: evalDriver(disposed)(st.selfRef),\n                                    messages: sio.emitter,\n                                    dispose: dispose(disposed)(lchs)(dsx)\n                                });\n                            })(dsx)();\n                        });\n                    });\n                });\n            };\n        };\n    };\n    // output/Web.DOM.Node/foreign.js\n    var getEffProp2 = function(name15) {\n        return function(node) {\n            return function() {\n                return node[name15];\n            };\n        };\n    };\n    var baseURI = getEffProp2(\"baseURI\");\n    var _ownerDocument = getEffProp2(\"ownerDocument\");\n    var _parentNode = getEffProp2(\"parentNode\");\n    var _parentElement = getEffProp2(\"parentElement\");\n    var childNodes = getEffProp2(\"childNodes\");\n    var _firstChild = getEffProp2(\"firstChild\");\n    var _lastChild = getEffProp2(\"lastChild\");\n    var _previousSibling = getEffProp2(\"previousSibling\");\n    var _nextSibling = getEffProp2(\"nextSibling\");\n    var _nodeValue = getEffProp2(\"nodeValue\");\n    var textContent = getEffProp2(\"textContent\");\n    function insertBefore(node1) {\n        return function(node2) {\n            return function(parent2) {\n                return function() {\n                    parent2.insertBefore(node1, node2);\n                };\n            };\n        };\n    }\n    function appendChild(node) {\n        return function(parent2) {\n            return function() {\n                parent2.appendChild(node);\n            };\n        };\n    }\n    function removeChild2(node) {\n        return function(parent2) {\n            return function() {\n                parent2.removeChild(node);\n            };\n        };\n    }\n    // output/Web.DOM.Node/index.js\n    var map33 = /* @__PURE__ */ map(functorEffect);\n    var parentNode2 = /* @__PURE__ */ function() {\n        var $6 = map33(toMaybe);\n        return function($7) {\n            return $6(_parentNode($7));\n        };\n    }();\n    var nextSibling = /* @__PURE__ */ function() {\n        var $15 = map33(toMaybe);\n        return function($16) {\n            return $15(_nextSibling($16));\n        };\n    }();\n    // output/Halogen.VDom.Driver/index.js\n    var $runtime_lazy9 = function(name15, moduleName, init3) {\n        var state3 = 0;\n        var val;\n        return function(lineNumber) {\n            if (state3 === 2) return val;\n            if (state3 === 1) throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n            state3 = 1;\n            val = init3();\n            state3 = 2;\n            return val;\n        };\n    };\n    var $$void11 = /* @__PURE__ */ $$void(functorEffect);\n    var pure17 = /* @__PURE__ */ pure(applicativeEffect);\n    var traverse_9 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableMaybe);\n    var unwrap5 = /* @__PURE__ */ unwrap();\n    var when7 = /* @__PURE__ */ when(applicativeEffect);\n    var not5 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean)));\n    var identity15 = /* @__PURE__ */ identity(categoryFn);\n    var bind111 = /* @__PURE__ */ bind(bindAff);\n    var liftEffect9 = /* @__PURE__ */ liftEffect(monadEffectAff);\n    var map34 = /* @__PURE__ */ map(functorEffect);\n    var bindFlipped11 = /* @__PURE__ */ bindFlipped(bindEffect);\n    var substInParent = function(v) {\n        return function(v1) {\n            return function(v2) {\n                if (v1 instanceof Just && v2 instanceof Just) return $$void11(insertBefore(v)(v1.value0)(v2.value0));\n                if (v1 instanceof Nothing && v2 instanceof Just) return $$void11(appendChild(v)(v2.value0));\n                return pure17(unit);\n            };\n        };\n    };\n    var removeChild3 = function(v) {\n        return function __do2() {\n            var npn = parentNode2(v.node)();\n            return traverse_9(function(pn) {\n                return removeChild2(v.node)(pn);\n            })(npn)();\n        };\n    };\n    var mkSpec = function(handler3) {\n        return function(renderChildRef) {\n            return function(document2) {\n                var getNode = unRenderStateX(function(v) {\n                    return v.node;\n                });\n                var done = function(st) {\n                    if (st instanceof Just) return halt(st.value0);\n                    return unit;\n                };\n                var buildWidget2 = function(spec) {\n                    var buildThunk2 = buildThunk(unwrap5)(spec);\n                    var $lazy_patch = $runtime_lazy9(\"patch\", \"Halogen.VDom.Driver\", function() {\n                        return function(st, slot5) {\n                            if (st instanceof Just) {\n                                if (slot5 instanceof ComponentSlot) {\n                                    halt(st.value0);\n                                    return $lazy_renderComponentSlot(100)(slot5.value0);\n                                }\n                                if (slot5 instanceof ThunkSlot) {\n                                    var step$prime = step(st.value0, slot5.value0);\n                                    return mkStep(new Step2(extract2(step$prime), new Just(step$prime), $lazy_patch(103), done));\n                                }\n                                throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 97, column 22 - line 103, column 79): \" + [\n                                    slot5.constructor.name\n                                ]);\n                            }\n                            return $lazy_render(104)(slot5);\n                        };\n                    });\n                    var $lazy_render = $runtime_lazy9(\"render\", \"Halogen.VDom.Driver\", function() {\n                        return function(slot5) {\n                            if (slot5 instanceof ComponentSlot) return $lazy_renderComponentSlot(86)(slot5.value0);\n                            if (slot5 instanceof ThunkSlot) {\n                                var step4 = buildThunk2(slot5.value0);\n                                return mkStep(new Step2(extract2(step4), new Just(step4), $lazy_patch(89), done));\n                            }\n                            throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 84, column 7 - line 89, column 75): \" + [\n                                slot5.constructor.name\n                            ]);\n                        };\n                    });\n                    var $lazy_renderComponentSlot = $runtime_lazy9(\"renderComponentSlot\", \"Halogen.VDom.Driver\", function() {\n                        return function(cs) {\n                            var renderChild = read(renderChildRef)();\n                            var rsx = renderChild(cs)();\n                            var node = getNode(rsx);\n                            return mkStep(new Step2(node, Nothing.value, $lazy_patch(117), done));\n                        };\n                    });\n                    var patch = $lazy_patch(91);\n                    var render = $lazy_render(82);\n                    var renderComponentSlot = $lazy_renderComponentSlot(109);\n                    return render;\n                };\n                var buildAttributes = buildProp(handler3);\n                return {\n                    buildWidget: buildWidget2,\n                    buildAttributes: buildAttributes,\n                    document: document2\n                };\n            };\n        };\n    };\n    var renderSpec = function(document2) {\n        return function(container) {\n            var render = function(handler3) {\n                return function(child) {\n                    return function(v) {\n                        return function(v1) {\n                            if (v1 instanceof Nothing) return function __do2() {\n                                var renderChildRef = $$new(child)();\n                                var spec = mkSpec(handler3)(renderChildRef)(document2);\n                                var machine = buildVDom(spec)(v);\n                                var node = extract2(machine);\n                                $$void11(appendChild(node)(toNode2(container)))();\n                                return {\n                                    machine: machine,\n                                    node: node,\n                                    renderChildRef: renderChildRef\n                                };\n                            };\n                            if (v1 instanceof Just) return function __do2() {\n                                write(child)(v1.value0.renderChildRef)();\n                                var parent2 = parentNode2(v1.value0.node)();\n                                var nextSib = nextSibling(v1.value0.node)();\n                                var machine$prime = step(v1.value0.machine, v);\n                                var newNode = extract2(machine$prime);\n                                when7(not5(unsafeRefEq)(v1.value0.node)(newNode))(substInParent(newNode)(nextSib)(parent2))();\n                                return {\n                                    machine: machine$prime,\n                                    node: newNode,\n                                    renderChildRef: v1.value0.renderChildRef\n                                };\n                            };\n                            throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 157, column 5 - line 173, column 80): \" + [\n                                v1.constructor.name\n                            ]);\n                        };\n                    };\n                };\n            };\n            return {\n                render: render,\n                renderChild: identity15,\n                removeChild: removeChild3,\n                dispose: removeChild3\n            };\n        };\n    };\n    var runUI2 = function(component7) {\n        return function(i2) {\n            return function(element3) {\n                return bind111(liftEffect9(map34(toDocument)(bindFlipped11(document)(windowImpl))))(function(document2) {\n                    return runUI(renderSpec(document2)(element3))(component7)(i2);\n                });\n            };\n        };\n    };\n    // output/Main/index.js\n    var main2 = /* @__PURE__ */ runHalogenAff(/* @__PURE__ */ bind(bindAff)(awaitBody)(function(body2) {\n        return runUI2(component6)(unit)(body2);\n    }));\n    // <stdin>\n    main2();\n})();\n\n\n//# sourceMappingURL=index.d7634b56.js.map\n","(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod2) => function __require() {\n    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n  };\n  var __copyProps = (to, from3, except2, desc) => {\n    if (from3 && typeof from3 === \"object\" || typeof from3 === \"function\") {\n      for (let key of __getOwnPropNames(from3))\n        if (!__hasOwnProp.call(to, key) && key !== except2)\n          __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod2, isNodeMode, target7) => (target7 = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target7, \"default\", { value: mod2, enumerable: true }) : target7,\n    mod2\n  ));\n\n  // node_modules/big-integer/BigInteger.js\n  var require_BigInteger = __commonJS({\n    \"node_modules/big-integer/BigInteger.js\"(exports, module) {\n      var bigInt2 = function(undefined2) {\n        \"use strict\";\n        var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n        var supportsNativeBigInt = typeof BigInt === \"function\";\n        function Integer(v, radix, alphabet, caseSensitive) {\n          if (typeof v === \"undefined\")\n            return Integer[0];\n          if (typeof radix !== \"undefined\")\n            return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\n          return parseValue(v);\n        }\n        function BigInteger(value15, sign2) {\n          this.value = value15;\n          this.sign = sign2;\n          this.isSmall = false;\n        }\n        BigInteger.prototype = Object.create(Integer.prototype);\n        function SmallInteger(value15) {\n          this.value = value15;\n          this.sign = value15 < 0;\n          this.isSmall = true;\n        }\n        SmallInteger.prototype = Object.create(Integer.prototype);\n        function NativeBigInt(value15) {\n          this.value = value15;\n        }\n        NativeBigInt.prototype = Object.create(Integer.prototype);\n        function isPrecise(n) {\n          return -MAX_INT < n && n < MAX_INT;\n        }\n        function smallToArray(n) {\n          if (n < 1e7)\n            return [n];\n          if (n < 1e14)\n            return [n % 1e7, Math.floor(n / 1e7)];\n          return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\n        }\n        function arrayToSmall(arr) {\n          trim2(arr);\n          var length8 = arr.length;\n          if (length8 < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\n            switch (length8) {\n              case 0:\n                return 0;\n              case 1:\n                return arr[0];\n              case 2:\n                return arr[0] + arr[1] * BASE;\n              default:\n                return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\n            }\n          }\n          return arr;\n        }\n        function trim2(v) {\n          var i3 = v.length;\n          while (v[--i3] === 0)\n            ;\n          v.length = i3 + 1;\n        }\n        function createArray(length8) {\n          var x = new Array(length8);\n          var i3 = -1;\n          while (++i3 < length8) {\n            x[i3] = 0;\n          }\n          return x;\n        }\n        function truncate(n) {\n          if (n > 0)\n            return Math.floor(n);\n          return Math.ceil(n);\n        }\n        function add3(a2, b2) {\n          var l_a = a2.length, l_b = b2.length, r = new Array(l_a), carry = 0, base2 = BASE, sum2, i3;\n          for (i3 = 0; i3 < l_b; i3++) {\n            sum2 = a2[i3] + b2[i3] + carry;\n            carry = sum2 >= base2 ? 1 : 0;\n            r[i3] = sum2 - carry * base2;\n          }\n          while (i3 < l_a) {\n            sum2 = a2[i3] + carry;\n            carry = sum2 === base2 ? 1 : 0;\n            r[i3++] = sum2 - carry * base2;\n          }\n          if (carry > 0)\n            r.push(carry);\n          return r;\n        }\n        function addAny(a2, b2) {\n          if (a2.length >= b2.length)\n            return add3(a2, b2);\n          return add3(b2, a2);\n        }\n        function addSmall(a2, carry) {\n          var l = a2.length, r = new Array(l), base2 = BASE, sum2, i3;\n          for (i3 = 0; i3 < l; i3++) {\n            sum2 = a2[i3] - base2 + carry;\n            carry = Math.floor(sum2 / base2);\n            r[i3] = sum2 - carry * base2;\n            carry += 1;\n          }\n          while (carry > 0) {\n            r[i3++] = carry % base2;\n            carry = Math.floor(carry / base2);\n          }\n          return r;\n        }\n        BigInteger.prototype.add = function(v) {\n          var n = parseValue(v);\n          if (this.sign !== n.sign) {\n            return this.subtract(n.negate());\n          }\n          var a2 = this.value, b2 = n.value;\n          if (n.isSmall) {\n            return new BigInteger(addSmall(a2, Math.abs(b2)), this.sign);\n          }\n          return new BigInteger(addAny(a2, b2), this.sign);\n        };\n        BigInteger.prototype.plus = BigInteger.prototype.add;\n        SmallInteger.prototype.add = function(v) {\n          var n = parseValue(v);\n          var a2 = this.value;\n          if (a2 < 0 !== n.sign) {\n            return this.subtract(n.negate());\n          }\n          var b2 = n.value;\n          if (n.isSmall) {\n            if (isPrecise(a2 + b2))\n              return new SmallInteger(a2 + b2);\n            b2 = smallToArray(Math.abs(b2));\n          }\n          return new BigInteger(addSmall(b2, Math.abs(a2)), a2 < 0);\n        };\n        SmallInteger.prototype.plus = SmallInteger.prototype.add;\n        NativeBigInt.prototype.add = function(v) {\n          return new NativeBigInt(this.value + parseValue(v).value);\n        };\n        NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\n        function subtract(a2, b2) {\n          var a_l = a2.length, b_l = b2.length, r = new Array(a_l), borrow = 0, base2 = BASE, i3, difference3;\n          for (i3 = 0; i3 < b_l; i3++) {\n            difference3 = a2[i3] - borrow - b2[i3];\n            if (difference3 < 0) {\n              difference3 += base2;\n              borrow = 1;\n            } else\n              borrow = 0;\n            r[i3] = difference3;\n          }\n          for (i3 = b_l; i3 < a_l; i3++) {\n            difference3 = a2[i3] - borrow;\n            if (difference3 < 0)\n              difference3 += base2;\n            else {\n              r[i3++] = difference3;\n              break;\n            }\n            r[i3] = difference3;\n          }\n          for (; i3 < a_l; i3++) {\n            r[i3] = a2[i3];\n          }\n          trim2(r);\n          return r;\n        }\n        function subtractAny(a2, b2, sign2) {\n          var value15;\n          if (compareAbs(a2, b2) >= 0) {\n            value15 = subtract(a2, b2);\n          } else {\n            value15 = subtract(b2, a2);\n            sign2 = !sign2;\n          }\n          value15 = arrayToSmall(value15);\n          if (typeof value15 === \"number\") {\n            if (sign2)\n              value15 = -value15;\n            return new SmallInteger(value15);\n          }\n          return new BigInteger(value15, sign2);\n        }\n        function subtractSmall(a2, b2, sign2) {\n          var l = a2.length, r = new Array(l), carry = -b2, base2 = BASE, i3, difference3;\n          for (i3 = 0; i3 < l; i3++) {\n            difference3 = a2[i3] + carry;\n            carry = Math.floor(difference3 / base2);\n            difference3 %= base2;\n            r[i3] = difference3 < 0 ? difference3 + base2 : difference3;\n          }\n          r = arrayToSmall(r);\n          if (typeof r === \"number\") {\n            if (sign2)\n              r = -r;\n            return new SmallInteger(r);\n          }\n          return new BigInteger(r, sign2);\n        }\n        BigInteger.prototype.subtract = function(v) {\n          var n = parseValue(v);\n          if (this.sign !== n.sign) {\n            return this.add(n.negate());\n          }\n          var a2 = this.value, b2 = n.value;\n          if (n.isSmall)\n            return subtractSmall(a2, Math.abs(b2), this.sign);\n          return subtractAny(a2, b2, this.sign);\n        };\n        BigInteger.prototype.minus = BigInteger.prototype.subtract;\n        SmallInteger.prototype.subtract = function(v) {\n          var n = parseValue(v);\n          var a2 = this.value;\n          if (a2 < 0 !== n.sign) {\n            return this.add(n.negate());\n          }\n          var b2 = n.value;\n          if (n.isSmall) {\n            return new SmallInteger(a2 - b2);\n          }\n          return subtractSmall(b2, Math.abs(a2), a2 >= 0);\n        };\n        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\n        NativeBigInt.prototype.subtract = function(v) {\n          return new NativeBigInt(this.value - parseValue(v).value);\n        };\n        NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\n        BigInteger.prototype.negate = function() {\n          return new BigInteger(this.value, !this.sign);\n        };\n        SmallInteger.prototype.negate = function() {\n          var sign2 = this.sign;\n          var small2 = new SmallInteger(-this.value);\n          small2.sign = !sign2;\n          return small2;\n        };\n        NativeBigInt.prototype.negate = function() {\n          return new NativeBigInt(-this.value);\n        };\n        BigInteger.prototype.abs = function() {\n          return new BigInteger(this.value, false);\n        };\n        SmallInteger.prototype.abs = function() {\n          return new SmallInteger(Math.abs(this.value));\n        };\n        NativeBigInt.prototype.abs = function() {\n          return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\n        };\n        function multiplyLong(a2, b2) {\n          var a_l = a2.length, b_l = b2.length, l = a_l + b_l, r = createArray(l), base2 = BASE, product4, carry, i3, a_i, b_j;\n          for (i3 = 0; i3 < a_l; ++i3) {\n            a_i = a2[i3];\n            for (var j = 0; j < b_l; ++j) {\n              b_j = b2[j];\n              product4 = a_i * b_j + r[i3 + j];\n              carry = Math.floor(product4 / base2);\n              r[i3 + j] = product4 - carry * base2;\n              r[i3 + j + 1] += carry;\n            }\n          }\n          trim2(r);\n          return r;\n        }\n        function multiplySmall(a2, b2) {\n          var l = a2.length, r = new Array(l), base2 = BASE, carry = 0, product4, i3;\n          for (i3 = 0; i3 < l; i3++) {\n            product4 = a2[i3] * b2 + carry;\n            carry = Math.floor(product4 / base2);\n            r[i3] = product4 - carry * base2;\n          }\n          while (carry > 0) {\n            r[i3++] = carry % base2;\n            carry = Math.floor(carry / base2);\n          }\n          return r;\n        }\n        function shiftLeft(x, n) {\n          var r = [];\n          while (n-- > 0)\n            r.push(0);\n          return r.concat(x);\n        }\n        function multiplyKaratsuba(x, y) {\n          var n = Math.max(x.length, y.length);\n          if (n <= 30)\n            return multiplyLong(x, y);\n          n = Math.ceil(n / 2);\n          var b2 = x.slice(n), a2 = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);\n          var ac = multiplyKaratsuba(a2, c), bd = multiplyKaratsuba(b2, d), abcd = multiplyKaratsuba(addAny(a2, b2), addAny(c, d));\n          var product4 = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\n          trim2(product4);\n          return product4;\n        }\n        function useKaratsuba(l1, l2) {\n          return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;\n        }\n        BigInteger.prototype.multiply = function(v) {\n          var n = parseValue(v), a2 = this.value, b2 = n.value, sign2 = this.sign !== n.sign, abs4;\n          if (n.isSmall) {\n            if (b2 === 0)\n              return Integer[0];\n            if (b2 === 1)\n              return this;\n            if (b2 === -1)\n              return this.negate();\n            abs4 = Math.abs(b2);\n            if (abs4 < BASE) {\n              return new BigInteger(multiplySmall(a2, abs4), sign2);\n            }\n            b2 = smallToArray(abs4);\n          }\n          if (useKaratsuba(a2.length, b2.length))\n            return new BigInteger(multiplyKaratsuba(a2, b2), sign2);\n          return new BigInteger(multiplyLong(a2, b2), sign2);\n        };\n        BigInteger.prototype.times = BigInteger.prototype.multiply;\n        function multiplySmallAndArray(a2, b2, sign2) {\n          if (a2 < BASE) {\n            return new BigInteger(multiplySmall(b2, a2), sign2);\n          }\n          return new BigInteger(multiplyLong(b2, smallToArray(a2)), sign2);\n        }\n        SmallInteger.prototype._multiplyBySmall = function(a2) {\n          if (isPrecise(a2.value * this.value)) {\n            return new SmallInteger(a2.value * this.value);\n          }\n          return multiplySmallAndArray(Math.abs(a2.value), smallToArray(Math.abs(this.value)), this.sign !== a2.sign);\n        };\n        BigInteger.prototype._multiplyBySmall = function(a2) {\n          if (a2.value === 0)\n            return Integer[0];\n          if (a2.value === 1)\n            return this;\n          if (a2.value === -1)\n            return this.negate();\n          return multiplySmallAndArray(Math.abs(a2.value), this.value, this.sign !== a2.sign);\n        };\n        SmallInteger.prototype.multiply = function(v) {\n          return parseValue(v)._multiplyBySmall(this);\n        };\n        SmallInteger.prototype.times = SmallInteger.prototype.multiply;\n        NativeBigInt.prototype.multiply = function(v) {\n          return new NativeBigInt(this.value * parseValue(v).value);\n        };\n        NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\n        function square(a2) {\n          var l = a2.length, r = createArray(l + l), base2 = BASE, product4, carry, i3, a_i, a_j;\n          for (i3 = 0; i3 < l; i3++) {\n            a_i = a2[i3];\n            carry = 0 - a_i * a_i;\n            for (var j = i3; j < l; j++) {\n              a_j = a2[j];\n              product4 = 2 * (a_i * a_j) + r[i3 + j] + carry;\n              carry = Math.floor(product4 / base2);\n              r[i3 + j] = product4 - carry * base2;\n            }\n            r[i3 + l] = carry;\n          }\n          trim2(r);\n          return r;\n        }\n        BigInteger.prototype.square = function() {\n          return new BigInteger(square(this.value), false);\n        };\n        SmallInteger.prototype.square = function() {\n          var value15 = this.value * this.value;\n          if (isPrecise(value15))\n            return new SmallInteger(value15);\n          return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\n        };\n        NativeBigInt.prototype.square = function(v) {\n          return new NativeBigInt(this.value * this.value);\n        };\n        function divMod1(a2, b2) {\n          var a_l = a2.length, b_l = b2.length, base2 = BASE, result = createArray(b2.length), divisorMostSignificantDigit = b2[b_l - 1], lambda = Math.ceil(base2 / (2 * divisorMostSignificantDigit)), remainder2 = multiplySmall(a2, lambda), divisor = multiplySmall(b2, lambda), quotientDigit, shift, carry, borrow, i3, l, q2;\n          if (remainder2.length <= a_l)\n            remainder2.push(0);\n          divisor.push(0);\n          divisorMostSignificantDigit = divisor[b_l - 1];\n          for (shift = a_l - b_l; shift >= 0; shift--) {\n            quotientDigit = base2 - 1;\n            if (remainder2[shift + b_l] !== divisorMostSignificantDigit) {\n              quotientDigit = Math.floor((remainder2[shift + b_l] * base2 + remainder2[shift + b_l - 1]) / divisorMostSignificantDigit);\n            }\n            carry = 0;\n            borrow = 0;\n            l = divisor.length;\n            for (i3 = 0; i3 < l; i3++) {\n              carry += quotientDigit * divisor[i3];\n              q2 = Math.floor(carry / base2);\n              borrow += remainder2[shift + i3] - (carry - q2 * base2);\n              carry = q2;\n              if (borrow < 0) {\n                remainder2[shift + i3] = borrow + base2;\n                borrow = -1;\n              } else {\n                remainder2[shift + i3] = borrow;\n                borrow = 0;\n              }\n            }\n            while (borrow !== 0) {\n              quotientDigit -= 1;\n              carry = 0;\n              for (i3 = 0; i3 < l; i3++) {\n                carry += remainder2[shift + i3] - base2 + divisor[i3];\n                if (carry < 0) {\n                  remainder2[shift + i3] = carry + base2;\n                  carry = 0;\n                } else {\n                  remainder2[shift + i3] = carry;\n                  carry = 1;\n                }\n              }\n              borrow += carry;\n            }\n            result[shift] = quotientDigit;\n          }\n          remainder2 = divModSmall(remainder2, lambda)[0];\n          return [arrayToSmall(result), arrayToSmall(remainder2)];\n        }\n        function divMod2(a2, b2) {\n          var a_l = a2.length, b_l = b2.length, result = [], part = [], base2 = BASE, guess, xlen, highx, highy, check;\n          while (a_l) {\n            part.unshift(a2[--a_l]);\n            trim2(part);\n            if (compareAbs(part, b2) < 0) {\n              result.push(0);\n              continue;\n            }\n            xlen = part.length;\n            highx = part[xlen - 1] * base2 + part[xlen - 2];\n            highy = b2[b_l - 1] * base2 + b2[b_l - 2];\n            if (xlen > b_l) {\n              highx = (highx + 1) * base2;\n            }\n            guess = Math.ceil(highx / highy);\n            do {\n              check = multiplySmall(b2, guess);\n              if (compareAbs(check, part) <= 0)\n                break;\n              guess--;\n            } while (guess);\n            result.push(guess);\n            part = subtract(part, check);\n          }\n          result.reverse();\n          return [arrayToSmall(result), arrayToSmall(part)];\n        }\n        function divModSmall(value15, lambda) {\n          var length8 = value15.length, quotient = createArray(length8), base2 = BASE, i3, q2, remainder2, divisor;\n          remainder2 = 0;\n          for (i3 = length8 - 1; i3 >= 0; --i3) {\n            divisor = remainder2 * base2 + value15[i3];\n            q2 = truncate(divisor / lambda);\n            remainder2 = divisor - q2 * lambda;\n            quotient[i3] = q2 | 0;\n          }\n          return [quotient, remainder2 | 0];\n        }\n        function divModAny(self, v) {\n          var value15, n = parseValue(v);\n          if (supportsNativeBigInt) {\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\n          }\n          var a2 = self.value, b2 = n.value;\n          var quotient;\n          if (b2 === 0)\n            throw new Error(\"Cannot divide by zero\");\n          if (self.isSmall) {\n            if (n.isSmall) {\n              return [new SmallInteger(truncate(a2 / b2)), new SmallInteger(a2 % b2)];\n            }\n            return [Integer[0], self];\n          }\n          if (n.isSmall) {\n            if (b2 === 1)\n              return [self, Integer[0]];\n            if (b2 == -1)\n              return [self.negate(), Integer[0]];\n            var abs4 = Math.abs(b2);\n            if (abs4 < BASE) {\n              value15 = divModSmall(a2, abs4);\n              quotient = arrayToSmall(value15[0]);\n              var remainder2 = value15[1];\n              if (self.sign)\n                remainder2 = -remainder2;\n              if (typeof quotient === \"number\") {\n                if (self.sign !== n.sign)\n                  quotient = -quotient;\n                return [new SmallInteger(quotient), new SmallInteger(remainder2)];\n              }\n              return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder2)];\n            }\n            b2 = smallToArray(abs4);\n          }\n          var comparison = compareAbs(a2, b2);\n          if (comparison === -1)\n            return [Integer[0], self];\n          if (comparison === 0)\n            return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\n          if (a2.length + b2.length <= 200)\n            value15 = divMod1(a2, b2);\n          else\n            value15 = divMod2(a2, b2);\n          quotient = value15[0];\n          var qSign = self.sign !== n.sign, mod2 = value15[1], mSign = self.sign;\n          if (typeof quotient === \"number\") {\n            if (qSign)\n              quotient = -quotient;\n            quotient = new SmallInteger(quotient);\n          } else\n            quotient = new BigInteger(quotient, qSign);\n          if (typeof mod2 === \"number\") {\n            if (mSign)\n              mod2 = -mod2;\n            mod2 = new SmallInteger(mod2);\n          } else\n            mod2 = new BigInteger(mod2, mSign);\n          return [quotient, mod2];\n        }\n        BigInteger.prototype.divmod = function(v) {\n          var result = divModAny(this, v);\n          return {\n            quotient: result[0],\n            remainder: result[1]\n          };\n        };\n        NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\n        BigInteger.prototype.divide = function(v) {\n          return divModAny(this, v)[0];\n        };\n        NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {\n          return new NativeBigInt(this.value / parseValue(v).value);\n        };\n        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\n        BigInteger.prototype.mod = function(v) {\n          return divModAny(this, v)[1];\n        };\n        NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {\n          return new NativeBigInt(this.value % parseValue(v).value);\n        };\n        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\n        BigInteger.prototype.pow = function(v) {\n          var n = parseValue(v), a2 = this.value, b2 = n.value, value15, x, y;\n          if (b2 === 0)\n            return Integer[1];\n          if (a2 === 0)\n            return Integer[0];\n          if (a2 === 1)\n            return Integer[1];\n          if (a2 === -1)\n            return n.isEven() ? Integer[1] : Integer[-1];\n          if (n.sign) {\n            return Integer[0];\n          }\n          if (!n.isSmall)\n            throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\n          if (this.isSmall) {\n            if (isPrecise(value15 = Math.pow(a2, b2)))\n              return new SmallInteger(truncate(value15));\n          }\n          x = this;\n          y = Integer[1];\n          while (true) {\n            if (b2 & true) {\n              y = y.times(x);\n              --b2;\n            }\n            if (b2 === 0)\n              break;\n            b2 /= 2;\n            x = x.square();\n          }\n          return y;\n        };\n        SmallInteger.prototype.pow = BigInteger.prototype.pow;\n        NativeBigInt.prototype.pow = function(v) {\n          var n = parseValue(v);\n          var a2 = this.value, b2 = n.value;\n          var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\n          if (b2 === _0)\n            return Integer[1];\n          if (a2 === _0)\n            return Integer[0];\n          if (a2 === _1)\n            return Integer[1];\n          if (a2 === BigInt(-1))\n            return n.isEven() ? Integer[1] : Integer[-1];\n          if (n.isNegative())\n            return new NativeBigInt(_0);\n          var x = this;\n          var y = Integer[1];\n          while (true) {\n            if ((b2 & _1) === _1) {\n              y = y.times(x);\n              --b2;\n            }\n            if (b2 === _0)\n              break;\n            b2 /= _2;\n            x = x.square();\n          }\n          return y;\n        };\n        BigInteger.prototype.modPow = function(exp2, mod2) {\n          exp2 = parseValue(exp2);\n          mod2 = parseValue(mod2);\n          if (mod2.isZero())\n            throw new Error(\"Cannot take modPow with modulus 0\");\n          var r = Integer[1], base2 = this.mod(mod2);\n          if (exp2.isNegative()) {\n            exp2 = exp2.multiply(Integer[-1]);\n            base2 = base2.modInv(mod2);\n          }\n          while (exp2.isPositive()) {\n            if (base2.isZero())\n              return Integer[0];\n            if (exp2.isOdd())\n              r = r.multiply(base2).mod(mod2);\n            exp2 = exp2.divide(2);\n            base2 = base2.square().mod(mod2);\n          }\n          return r;\n        };\n        NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\n        function compareAbs(a2, b2) {\n          if (a2.length !== b2.length) {\n            return a2.length > b2.length ? 1 : -1;\n          }\n          for (var i3 = a2.length - 1; i3 >= 0; i3--) {\n            if (a2[i3] !== b2[i3])\n              return a2[i3] > b2[i3] ? 1 : -1;\n          }\n          return 0;\n        }\n        BigInteger.prototype.compareAbs = function(v) {\n          var n = parseValue(v), a2 = this.value, b2 = n.value;\n          if (n.isSmall)\n            return 1;\n          return compareAbs(a2, b2);\n        };\n        SmallInteger.prototype.compareAbs = function(v) {\n          var n = parseValue(v), a2 = Math.abs(this.value), b2 = n.value;\n          if (n.isSmall) {\n            b2 = Math.abs(b2);\n            return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;\n          }\n          return -1;\n        };\n        NativeBigInt.prototype.compareAbs = function(v) {\n          var a2 = this.value;\n          var b2 = parseValue(v).value;\n          a2 = a2 >= 0 ? a2 : -a2;\n          b2 = b2 >= 0 ? b2 : -b2;\n          return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;\n        };\n        BigInteger.prototype.compare = function(v) {\n          if (v === Infinity) {\n            return -1;\n          }\n          if (v === -Infinity) {\n            return 1;\n          }\n          var n = parseValue(v), a2 = this.value, b2 = n.value;\n          if (this.sign !== n.sign) {\n            return n.sign ? 1 : -1;\n          }\n          if (n.isSmall) {\n            return this.sign ? -1 : 1;\n          }\n          return compareAbs(a2, b2) * (this.sign ? -1 : 1);\n        };\n        BigInteger.prototype.compareTo = BigInteger.prototype.compare;\n        SmallInteger.prototype.compare = function(v) {\n          if (v === Infinity) {\n            return -1;\n          }\n          if (v === -Infinity) {\n            return 1;\n          }\n          var n = parseValue(v), a2 = this.value, b2 = n.value;\n          if (n.isSmall) {\n            return a2 == b2 ? 0 : a2 > b2 ? 1 : -1;\n          }\n          if (a2 < 0 !== n.sign) {\n            return a2 < 0 ? -1 : 1;\n          }\n          return a2 < 0 ? 1 : -1;\n        };\n        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\n        NativeBigInt.prototype.compare = function(v) {\n          if (v === Infinity) {\n            return -1;\n          }\n          if (v === -Infinity) {\n            return 1;\n          }\n          var a2 = this.value;\n          var b2 = parseValue(v).value;\n          return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;\n        };\n        NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\n        BigInteger.prototype.equals = function(v) {\n          return this.compare(v) === 0;\n        };\n        NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\n        BigInteger.prototype.notEquals = function(v) {\n          return this.compare(v) !== 0;\n        };\n        NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\n        BigInteger.prototype.greater = function(v) {\n          return this.compare(v) > 0;\n        };\n        NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\n        BigInteger.prototype.lesser = function(v) {\n          return this.compare(v) < 0;\n        };\n        NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\n        BigInteger.prototype.greaterOrEquals = function(v) {\n          return this.compare(v) >= 0;\n        };\n        NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\n        BigInteger.prototype.lesserOrEquals = function(v) {\n          return this.compare(v) <= 0;\n        };\n        NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\n        BigInteger.prototype.isEven = function() {\n          return (this.value[0] & 1) === 0;\n        };\n        SmallInteger.prototype.isEven = function() {\n          return (this.value & 1) === 0;\n        };\n        NativeBigInt.prototype.isEven = function() {\n          return (this.value & BigInt(1)) === BigInt(0);\n        };\n        BigInteger.prototype.isOdd = function() {\n          return (this.value[0] & 1) === 1;\n        };\n        SmallInteger.prototype.isOdd = function() {\n          return (this.value & 1) === 1;\n        };\n        NativeBigInt.prototype.isOdd = function() {\n          return (this.value & BigInt(1)) === BigInt(1);\n        };\n        BigInteger.prototype.isPositive = function() {\n          return !this.sign;\n        };\n        SmallInteger.prototype.isPositive = function() {\n          return this.value > 0;\n        };\n        NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\n        BigInteger.prototype.isNegative = function() {\n          return this.sign;\n        };\n        SmallInteger.prototype.isNegative = function() {\n          return this.value < 0;\n        };\n        NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\n        BigInteger.prototype.isUnit = function() {\n          return false;\n        };\n        SmallInteger.prototype.isUnit = function() {\n          return Math.abs(this.value) === 1;\n        };\n        NativeBigInt.prototype.isUnit = function() {\n          return this.abs().value === BigInt(1);\n        };\n        BigInteger.prototype.isZero = function() {\n          return false;\n        };\n        SmallInteger.prototype.isZero = function() {\n          return this.value === 0;\n        };\n        NativeBigInt.prototype.isZero = function() {\n          return this.value === BigInt(0);\n        };\n        BigInteger.prototype.isDivisibleBy = function(v) {\n          var n = parseValue(v);\n          if (n.isZero())\n            return false;\n          if (n.isUnit())\n            return true;\n          if (n.compareAbs(2) === 0)\n            return this.isEven();\n          return this.mod(n).isZero();\n        };\n        NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\n        function isBasicPrime(v) {\n          var n = v.abs();\n          if (n.isUnit())\n            return false;\n          if (n.equals(2) || n.equals(3) || n.equals(5))\n            return true;\n          if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))\n            return false;\n          if (n.lesser(49))\n            return true;\n        }\n        function millerRabinTest(n, a2) {\n          var nPrev = n.prev(), b2 = nPrev, r = 0, d, t, i3, x;\n          while (b2.isEven())\n            b2 = b2.divide(2), r++;\n          next:\n            for (i3 = 0; i3 < a2.length; i3++) {\n              if (n.lesser(a2[i3]))\n                continue;\n              x = bigInt2(a2[i3]).modPow(b2, n);\n              if (x.isUnit() || x.equals(nPrev))\n                continue;\n              for (d = r - 1; d != 0; d--) {\n                x = x.square().mod(n);\n                if (x.isUnit())\n                  return false;\n                if (x.equals(nPrev))\n                  continue next;\n              }\n              return false;\n            }\n          return true;\n        }\n        BigInteger.prototype.isPrime = function(strict) {\n          var isPrime = isBasicPrime(this);\n          if (isPrime !== undefined2)\n            return isPrime;\n          var n = this.abs();\n          var bits = n.bitLength();\n          if (bits <= 64)\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\n          var logN = Math.log(2) * bits.toJSNumber();\n          var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);\n          for (var a2 = [], i3 = 0; i3 < t; i3++) {\n            a2.push(bigInt2(i3 + 2));\n          }\n          return millerRabinTest(n, a2);\n        };\n        NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\n        BigInteger.prototype.isProbablePrime = function(iterations, rng2) {\n          var isPrime = isBasicPrime(this);\n          if (isPrime !== undefined2)\n            return isPrime;\n          var n = this.abs();\n          var t = iterations === undefined2 ? 5 : iterations;\n          for (var a2 = [], i3 = 0; i3 < t; i3++) {\n            a2.push(bigInt2.randBetween(2, n.minus(2), rng2));\n          }\n          return millerRabinTest(n, a2);\n        };\n        NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\n        BigInteger.prototype.modInv = function(n) {\n          var t = bigInt2.zero, newT = bigInt2.one, r = parseValue(n), newR = this.abs(), q2, lastT, lastR;\n          while (!newR.isZero()) {\n            q2 = r.divide(newR);\n            lastT = t;\n            lastR = r;\n            t = newT;\n            r = newR;\n            newT = lastT.subtract(q2.multiply(newT));\n            newR = lastR.subtract(q2.multiply(newR));\n          }\n          if (!r.isUnit())\n            throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\n          if (t.compare(0) === -1) {\n            t = t.add(n);\n          }\n          if (this.isNegative()) {\n            return t.negate();\n          }\n          return t;\n        };\n        NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\n        BigInteger.prototype.next = function() {\n          var value15 = this.value;\n          if (this.sign) {\n            return subtractSmall(value15, 1, this.sign);\n          }\n          return new BigInteger(addSmall(value15, 1), this.sign);\n        };\n        SmallInteger.prototype.next = function() {\n          var value15 = this.value;\n          if (value15 + 1 < MAX_INT)\n            return new SmallInteger(value15 + 1);\n          return new BigInteger(MAX_INT_ARR, false);\n        };\n        NativeBigInt.prototype.next = function() {\n          return new NativeBigInt(this.value + BigInt(1));\n        };\n        BigInteger.prototype.prev = function() {\n          var value15 = this.value;\n          if (this.sign) {\n            return new BigInteger(addSmall(value15, 1), true);\n          }\n          return subtractSmall(value15, 1, this.sign);\n        };\n        SmallInteger.prototype.prev = function() {\n          var value15 = this.value;\n          if (value15 - 1 > -MAX_INT)\n            return new SmallInteger(value15 - 1);\n          return new BigInteger(MAX_INT_ARR, true);\n        };\n        NativeBigInt.prototype.prev = function() {\n          return new NativeBigInt(this.value - BigInt(1));\n        };\n        var powersOfTwo = [1];\n        while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)\n          powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\n        var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\n        function shift_isSmall(n) {\n          return Math.abs(n) <= BASE;\n        }\n        BigInteger.prototype.shiftLeft = function(v) {\n          var n = parseValue(v).toJSNumber();\n          if (!shift_isSmall(n)) {\n            throw new Error(String(n) + \" is too large for shifting.\");\n          }\n          if (n < 0)\n            return this.shiftRight(-n);\n          var result = this;\n          if (result.isZero())\n            return result;\n          while (n >= powers2Length) {\n            result = result.multiply(highestPower2);\n            n -= powers2Length - 1;\n          }\n          return result.multiply(powersOfTwo[n]);\n        };\n        NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\n        BigInteger.prototype.shiftRight = function(v) {\n          var remQuo;\n          var n = parseValue(v).toJSNumber();\n          if (!shift_isSmall(n)) {\n            throw new Error(String(n) + \" is too large for shifting.\");\n          }\n          if (n < 0)\n            return this.shiftLeft(-n);\n          var result = this;\n          while (n >= powers2Length) {\n            if (result.isZero() || result.isNegative() && result.isUnit())\n              return result;\n            remQuo = divModAny(result, highestPower2);\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n            n -= powers2Length - 1;\n          }\n          remQuo = divModAny(result, powersOfTwo[n]);\n          return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n        };\n        NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\n        function bitwise(x, y, fn) {\n          y = parseValue(y);\n          var xSign = x.isNegative(), ySign = y.isNegative();\n          var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;\n          var xDigit = 0, yDigit = 0;\n          var xDivMod = null, yDivMod = null;\n          var result = [];\n          while (!xRem.isZero() || !yRem.isZero()) {\n            xDivMod = divModAny(xRem, highestPower2);\n            xDigit = xDivMod[1].toJSNumber();\n            if (xSign) {\n              xDigit = highestPower2 - 1 - xDigit;\n            }\n            yDivMod = divModAny(yRem, highestPower2);\n            yDigit = yDivMod[1].toJSNumber();\n            if (ySign) {\n              yDigit = highestPower2 - 1 - yDigit;\n            }\n            xRem = xDivMod[0];\n            yRem = yDivMod[0];\n            result.push(fn(xDigit, yDigit));\n          }\n          var sum2 = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);\n          for (var i3 = result.length - 1; i3 >= 0; i3 -= 1) {\n            sum2 = sum2.multiply(highestPower2).add(bigInt2(result[i3]));\n          }\n          return sum2;\n        }\n        BigInteger.prototype.not = function() {\n          return this.negate().prev();\n        };\n        NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\n        BigInteger.prototype.and = function(n) {\n          return bitwise(this, n, function(a2, b2) {\n            return a2 & b2;\n          });\n        };\n        NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\n        BigInteger.prototype.or = function(n) {\n          return bitwise(this, n, function(a2, b2) {\n            return a2 | b2;\n          });\n        };\n        NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\n        BigInteger.prototype.xor = function(n) {\n          return bitwise(this, n, function(a2, b2) {\n            return a2 ^ b2;\n          });\n        };\n        NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\n        var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\n        function roughLOB(n) {\n          var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;\n          return x & -x;\n        }\n        function integerLogarithm(value15, base2) {\n          if (base2.compareTo(value15) <= 0) {\n            var tmp = integerLogarithm(value15, base2.square(base2));\n            var p2 = tmp.p;\n            var e = tmp.e;\n            var t = p2.multiply(base2);\n            return t.compareTo(value15) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p2, e: e * 2 };\n          }\n          return { p: bigInt2(1), e: 0 };\n        }\n        BigInteger.prototype.bitLength = function() {\n          var n = this;\n          if (n.compareTo(bigInt2(0)) < 0) {\n            n = n.negate().subtract(bigInt2(1));\n          }\n          if (n.compareTo(bigInt2(0)) === 0) {\n            return bigInt2(0);\n          }\n          return bigInt2(integerLogarithm(n, bigInt2(2)).e).add(bigInt2(1));\n        };\n        NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\n        function max7(a2, b2) {\n          a2 = parseValue(a2);\n          b2 = parseValue(b2);\n          return a2.greater(b2) ? a2 : b2;\n        }\n        function min8(a2, b2) {\n          a2 = parseValue(a2);\n          b2 = parseValue(b2);\n          return a2.lesser(b2) ? a2 : b2;\n        }\n        function gcd(a2, b2) {\n          a2 = parseValue(a2).abs();\n          b2 = parseValue(b2).abs();\n          if (a2.equals(b2))\n            return a2;\n          if (a2.isZero())\n            return b2;\n          if (b2.isZero())\n            return a2;\n          var c = Integer[1], d, t;\n          while (a2.isEven() && b2.isEven()) {\n            d = min8(roughLOB(a2), roughLOB(b2));\n            a2 = a2.divide(d);\n            b2 = b2.divide(d);\n            c = c.multiply(d);\n          }\n          while (a2.isEven()) {\n            a2 = a2.divide(roughLOB(a2));\n          }\n          do {\n            while (b2.isEven()) {\n              b2 = b2.divide(roughLOB(b2));\n            }\n            if (a2.greater(b2)) {\n              t = b2;\n              b2 = a2;\n              a2 = t;\n            }\n            b2 = b2.subtract(a2);\n          } while (!b2.isZero());\n          return c.isUnit() ? a2 : a2.multiply(c);\n        }\n        function lcm(a2, b2) {\n          a2 = parseValue(a2).abs();\n          b2 = parseValue(b2).abs();\n          return a2.divide(gcd(a2, b2)).multiply(b2);\n        }\n        function randBetween(a2, b2, rng2) {\n          a2 = parseValue(a2);\n          b2 = parseValue(b2);\n          var usedRNG = rng2 || Math.random;\n          var low2 = min8(a2, b2), high2 = max7(a2, b2);\n          var range3 = high2.subtract(low2).add(1);\n          if (range3.isSmall)\n            return low2.add(Math.floor(usedRNG() * range3));\n          var digits = toBase2(range3, BASE).value;\n          var result = [], restricted = true;\n          for (var i3 = 0; i3 < digits.length; i3++) {\n            var top3 = restricted ? digits[i3] + (i3 + 1 < digits.length ? digits[i3 + 1] / BASE : 0) : BASE;\n            var digit = truncate(usedRNG() * top3);\n            result.push(digit);\n            if (digit < digits[i3])\n              restricted = false;\n          }\n          return low2.add(Integer.fromArray(result, BASE, false));\n        }\n        var parseBase = function(text6, base2, alphabet, caseSensitive) {\n          alphabet = alphabet || DEFAULT_ALPHABET;\n          text6 = String(text6);\n          if (!caseSensitive) {\n            text6 = text6.toLowerCase();\n            alphabet = alphabet.toLowerCase();\n          }\n          var length8 = text6.length;\n          var i3;\n          var absBase = Math.abs(base2);\n          var alphabetValues = {};\n          for (i3 = 0; i3 < alphabet.length; i3++) {\n            alphabetValues[alphabet[i3]] = i3;\n          }\n          for (i3 = 0; i3 < length8; i3++) {\n            var c = text6[i3];\n            if (c === \"-\")\n              continue;\n            if (c in alphabetValues) {\n              if (alphabetValues[c] >= absBase) {\n                if (c === \"1\" && absBase === 1)\n                  continue;\n                throw new Error(c + \" is not a valid digit in base \" + base2 + \".\");\n              }\n            }\n          }\n          base2 = parseValue(base2);\n          var digits = [];\n          var isNegative = text6[0] === \"-\";\n          for (i3 = isNegative ? 1 : 0; i3 < text6.length; i3++) {\n            var c = text6[i3];\n            if (c in alphabetValues)\n              digits.push(parseValue(alphabetValues[c]));\n            else if (c === \"<\") {\n              var start2 = i3;\n              do {\n                i3++;\n              } while (text6[i3] !== \">\" && i3 < text6.length);\n              digits.push(parseValue(text6.slice(start2 + 1, i3)));\n            } else\n              throw new Error(c + \" is not a valid character\");\n          }\n          return parseBaseFromArray(digits, base2, isNegative);\n        };\n        function parseBaseFromArray(digits, base2, isNegative) {\n          var val = Integer[0], pow4 = Integer[1], i3;\n          for (i3 = digits.length - 1; i3 >= 0; i3--) {\n            val = val.add(digits[i3].times(pow4));\n            pow4 = pow4.times(base2);\n          }\n          return isNegative ? val.negate() : val;\n        }\n        function stringify2(digit, alphabet) {\n          alphabet = alphabet || DEFAULT_ALPHABET;\n          if (digit < alphabet.length) {\n            return alphabet[digit];\n          }\n          return \"<\" + digit + \">\";\n        }\n        function toBase2(n, base2) {\n          base2 = bigInt2(base2);\n          if (base2.isZero()) {\n            if (n.isZero())\n              return { value: [0], isNegative: false };\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\n          }\n          if (base2.equals(-1)) {\n            if (n.isZero())\n              return { value: [0], isNegative: false };\n            if (n.isNegative())\n              return {\n                value: [].concat.apply(\n                  [],\n                  Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])\n                ),\n                isNegative: false\n              };\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);\n            arr.unshift([1]);\n            return {\n              value: [].concat.apply([], arr),\n              isNegative: false\n            };\n          }\n          var neg = false;\n          if (n.isNegative() && base2.isPositive()) {\n            neg = true;\n            n = n.abs();\n          }\n          if (base2.isUnit()) {\n            if (n.isZero())\n              return { value: [0], isNegative: false };\n            return {\n              value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),\n              isNegative: neg\n            };\n          }\n          var out = [];\n          var left = n, divmod;\n          while (left.isNegative() || left.compareAbs(base2) >= 0) {\n            divmod = left.divmod(base2);\n            left = divmod.quotient;\n            var digit = divmod.remainder;\n            if (digit.isNegative()) {\n              digit = base2.minus(digit).abs();\n              left = left.next();\n            }\n            out.push(digit.toJSNumber());\n          }\n          out.push(left.toJSNumber());\n          return { value: out.reverse(), isNegative: neg };\n        }\n        function toBaseString(n, base2, alphabet) {\n          var arr = toBase2(n, base2);\n          return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function(x) {\n            return stringify2(x, alphabet);\n          }).join(\"\");\n        }\n        BigInteger.prototype.toArray = function(radix) {\n          return toBase2(this, radix);\n        };\n        SmallInteger.prototype.toArray = function(radix) {\n          return toBase2(this, radix);\n        };\n        NativeBigInt.prototype.toArray = function(radix) {\n          return toBase2(this, radix);\n        };\n        BigInteger.prototype.toString = function(radix, alphabet) {\n          if (radix === undefined2)\n            radix = 10;\n          if (radix !== 10 || alphabet)\n            return toBaseString(this, radix, alphabet);\n          var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\n          while (--l >= 0) {\n            digit = String(v[l]);\n            str += zeros.slice(digit.length) + digit;\n          }\n          var sign2 = this.sign ? \"-\" : \"\";\n          return sign2 + str;\n        };\n        SmallInteger.prototype.toString = function(radix, alphabet) {\n          if (radix === undefined2)\n            radix = 10;\n          if (radix != 10 || alphabet)\n            return toBaseString(this, radix, alphabet);\n          return String(this.value);\n        };\n        NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\n        NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {\n          return this.toString();\n        };\n        BigInteger.prototype.valueOf = function() {\n          return parseInt(this.toString(), 10);\n        };\n        BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\n        SmallInteger.prototype.valueOf = function() {\n          return this.value;\n        };\n        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\n        NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {\n          return parseInt(this.toString(), 10);\n        };\n        function parseStringValue(v) {\n          if (isPrecise(+v)) {\n            var x = +v;\n            if (x === truncate(x))\n              return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\n            throw new Error(\"Invalid integer: \" + v);\n          }\n          var sign2 = v[0] === \"-\";\n          if (sign2)\n            v = v.slice(1);\n          var split2 = v.split(/e/i);\n          if (split2.length > 2)\n            throw new Error(\"Invalid integer: \" + split2.join(\"e\"));\n          if (split2.length === 2) {\n            var exp2 = split2[1];\n            if (exp2[0] === \"+\")\n              exp2 = exp2.slice(1);\n            exp2 = +exp2;\n            if (exp2 !== truncate(exp2) || !isPrecise(exp2))\n              throw new Error(\"Invalid integer: \" + exp2 + \" is not a valid exponent.\");\n            var text6 = split2[0];\n            var decimalPlace = text6.indexOf(\".\");\n            if (decimalPlace >= 0) {\n              exp2 -= text6.length - decimalPlace - 1;\n              text6 = text6.slice(0, decimalPlace) + text6.slice(decimalPlace + 1);\n            }\n            if (exp2 < 0)\n              throw new Error(\"Cannot include negative exponent part for integers\");\n            text6 += new Array(exp2 + 1).join(\"0\");\n            v = text6;\n          }\n          var isValid = /^([0-9][0-9]*)$/.test(v);\n          if (!isValid)\n            throw new Error(\"Invalid integer: \" + v);\n          if (supportsNativeBigInt) {\n            return new NativeBigInt(BigInt(sign2 ? \"-\" + v : v));\n          }\n          var r = [], max8 = v.length, l = LOG_BASE, min9 = max8 - l;\n          while (max8 > 0) {\n            r.push(+v.slice(min9, max8));\n            min9 -= l;\n            if (min9 < 0)\n              min9 = 0;\n            max8 -= l;\n          }\n          trim2(r);\n          return new BigInteger(r, sign2);\n        }\n        function parseNumberValue(v) {\n          if (supportsNativeBigInt) {\n            return new NativeBigInt(BigInt(v));\n          }\n          if (isPrecise(v)) {\n            if (v !== truncate(v))\n              throw new Error(v + \" is not an integer.\");\n            return new SmallInteger(v);\n          }\n          return parseStringValue(v.toString());\n        }\n        function parseValue(v) {\n          if (typeof v === \"number\") {\n            return parseNumberValue(v);\n          }\n          if (typeof v === \"string\") {\n            return parseStringValue(v);\n          }\n          if (typeof v === \"bigint\") {\n            return new NativeBigInt(v);\n          }\n          return v;\n        }\n        for (var i2 = 0; i2 < 1e3; i2++) {\n          Integer[i2] = parseValue(i2);\n          if (i2 > 0)\n            Integer[-i2] = parseValue(-i2);\n        }\n        Integer.one = Integer[1];\n        Integer.zero = Integer[0];\n        Integer.minusOne = Integer[-1];\n        Integer.max = max7;\n        Integer.min = min8;\n        Integer.gcd = gcd;\n        Integer.lcm = lcm;\n        Integer.isInstance = function(x) {\n          return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;\n        };\n        Integer.randBetween = randBetween;\n        Integer.fromArray = function(digits, base2, isNegative) {\n          return parseBaseFromArray(digits.map(parseValue), parseValue(base2 || 10), isNegative);\n        };\n        return Integer;\n      }();\n      if (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\n        module.exports = bigInt2;\n      }\n      if (typeof define === \"function\" && define.amd) {\n        define(function() {\n          return bigInt2;\n        });\n      }\n    }\n  });\n\n  // output/Control.Apply/foreign.js\n  var arrayApply = function(fs) {\n    return function(xs) {\n      var l = fs.length;\n      var k = xs.length;\n      var result = new Array(l * k);\n      var n = 0;\n      for (var i2 = 0; i2 < l; i2++) {\n        var f2 = fs[i2];\n        for (var j = 0; j < k; j++) {\n          result[n++] = f2(xs[j]);\n        }\n      }\n      return result;\n    };\n  };\n\n  // output/Control.Semigroupoid/index.js\n  var semigroupoidFn = {\n    compose: function(f2) {\n      return function(g) {\n        return function(x) {\n          return f2(g(x));\n        };\n      };\n    }\n  };\n  var compose = function(dict) {\n    return dict.compose;\n  };\n\n  // output/Control.Category/index.js\n  var identity = function(dict) {\n    return dict.identity;\n  };\n  var categoryFn = {\n    identity: function(x) {\n      return x;\n    },\n    Semigroupoid0: function() {\n      return semigroupoidFn;\n    }\n  };\n\n  // output/Data.Boolean/index.js\n  var otherwise = true;\n\n  // output/Data.Function/index.js\n  var on = function(f2) {\n    return function(g) {\n      return function(x) {\n        return function(y) {\n          return f2(g(x))(g(y));\n        };\n      };\n    };\n  };\n  var flip = function(f2) {\n    return function(b2) {\n      return function(a2) {\n        return f2(a2)(b2);\n      };\n    };\n  };\n  var $$const = function(a2) {\n    return function(v) {\n      return a2;\n    };\n  };\n\n  // output/Data.Functor/foreign.js\n  var arrayMap = function(f2) {\n    return function(arr) {\n      var l = arr.length;\n      var result = new Array(l);\n      for (var i2 = 0; i2 < l; i2++) {\n        result[i2] = f2(arr[i2]);\n      }\n      return result;\n    };\n  };\n\n  // output/Data.Unit/foreign.js\n  var unit = void 0;\n\n  // output/Type.Proxy/index.js\n  var $$Proxy = /* @__PURE__ */ function() {\n    function $$Proxy2() {\n    }\n    ;\n    $$Proxy2.value = new $$Proxy2();\n    return $$Proxy2;\n  }();\n\n  // output/Data.Functor/index.js\n  var map = function(dict) {\n    return dict.map;\n  };\n  var mapFlipped = function(dictFunctor) {\n    var map112 = map(dictFunctor);\n    return function(fa2) {\n      return function(f2) {\n        return map112(f2)(fa2);\n      };\n    };\n  };\n  var $$void = function(dictFunctor) {\n    return map(dictFunctor)($$const(unit));\n  };\n  var voidLeft = function(dictFunctor) {\n    var map112 = map(dictFunctor);\n    return function(f2) {\n      return function(x) {\n        return map112($$const(x))(f2);\n      };\n    };\n  };\n  var voidRight = function(dictFunctor) {\n    var map112 = map(dictFunctor);\n    return function(x) {\n      return map112($$const(x));\n    };\n  };\n  var functorFn = {\n    map: /* @__PURE__ */ compose(semigroupoidFn)\n  };\n  var functorArray = {\n    map: arrayMap\n  };\n  var flap = function(dictFunctor) {\n    var map112 = map(dictFunctor);\n    return function(ff2) {\n      return function(x) {\n        return map112(function(f2) {\n          return f2(x);\n        })(ff2);\n      };\n    };\n  };\n\n  // output/Control.Apply/index.js\n  var identity2 = /* @__PURE__ */ identity(categoryFn);\n  var applyFn = {\n    apply: function(f2) {\n      return function(g) {\n        return function(x) {\n          return f2(x)(g(x));\n        };\n      };\n    },\n    Functor0: function() {\n      return functorFn;\n    }\n  };\n  var applyArray = {\n    apply: arrayApply,\n    Functor0: function() {\n      return functorArray;\n    }\n  };\n  var apply = function(dict) {\n    return dict.apply;\n  };\n  var applySecond = function(dictApply) {\n    var apply12 = apply(dictApply);\n    var map35 = map(dictApply.Functor0());\n    return function(a2) {\n      return function(b2) {\n        return apply12(map35($$const(identity2))(a2))(b2);\n      };\n    };\n  };\n  var lift2 = function(dictApply) {\n    var apply12 = apply(dictApply);\n    var map35 = map(dictApply.Functor0());\n    return function(f2) {\n      return function(a2) {\n        return function(b2) {\n          return apply12(map35(f2)(a2))(b2);\n        };\n      };\n    };\n  };\n\n  // output/Control.Applicative/index.js\n  var pure = function(dict) {\n    return dict.pure;\n  };\n  var unless = function(dictApplicative) {\n    var pure18 = pure(dictApplicative);\n    return function(v) {\n      return function(v1) {\n        if (!v) {\n          return v1;\n        }\n        ;\n        if (v) {\n          return pure18(unit);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Control.Applicative (line 68, column 1 - line 68, column 65): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    };\n  };\n  var when = function(dictApplicative) {\n    var pure18 = pure(dictApplicative);\n    return function(v) {\n      return function(v1) {\n        if (v) {\n          return v1;\n        }\n        ;\n        if (!v) {\n          return pure18(unit);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    };\n  };\n  var liftA1 = function(dictApplicative) {\n    var apply4 = apply(dictApplicative.Apply0());\n    var pure18 = pure(dictApplicative);\n    return function(f2) {\n      return function(a2) {\n        return apply4(pure18(f2))(a2);\n      };\n    };\n  };\n\n  // output/Control.Bind/foreign.js\n  var arrayBind = function(arr) {\n    return function(f2) {\n      var result = [];\n      for (var i2 = 0, l = arr.length; i2 < l; i2++) {\n        Array.prototype.push.apply(result, f2(arr[i2]));\n      }\n      return result;\n    };\n  };\n\n  // output/Control.Bind/index.js\n  var identity3 = /* @__PURE__ */ identity(categoryFn);\n  var discard = function(dict) {\n    return dict.discard;\n  };\n  var bindFn = {\n    bind: function(m) {\n      return function(f2) {\n        return function(x) {\n          return f2(m(x))(x);\n        };\n      };\n    },\n    Apply0: function() {\n      return applyFn;\n    }\n  };\n  var bindArray = {\n    bind: arrayBind,\n    Apply0: function() {\n      return applyArray;\n    }\n  };\n  var bind = function(dict) {\n    return dict.bind;\n  };\n  var bindFlipped = function(dictBind) {\n    return flip(bind(dictBind));\n  };\n  var composeKleisliFlipped = function(dictBind) {\n    var bindFlipped13 = bindFlipped(dictBind);\n    return function(f2) {\n      return function(g) {\n        return function(a2) {\n          return bindFlipped13(f2)(g(a2));\n        };\n      };\n    };\n  };\n  var composeKleisli = function(dictBind) {\n    var bind112 = bind(dictBind);\n    return function(f2) {\n      return function(g) {\n        return function(a2) {\n          return bind112(f2(a2))(g);\n        };\n      };\n    };\n  };\n  var discardUnit = {\n    discard: function(dictBind) {\n      return bind(dictBind);\n    }\n  };\n  var join = function(dictBind) {\n    var bind112 = bind(dictBind);\n    return function(m) {\n      return bind112(m)(identity3);\n    };\n  };\n\n  // output/Control.Monad/index.js\n  var whenM = function(dictMonad) {\n    var bind20 = bind(dictMonad.Bind1());\n    var when8 = when(dictMonad.Applicative0());\n    return function(mb) {\n      return function(m) {\n        return bind20(mb)(function(b2) {\n          return when8(b2)(m);\n        });\n      };\n    };\n  };\n  var unlessM = function(dictMonad) {\n    var bind20 = bind(dictMonad.Bind1());\n    var unless3 = unless(dictMonad.Applicative0());\n    return function(mb) {\n      return function(m) {\n        return bind20(mb)(function(b2) {\n          return unless3(b2)(m);\n        });\n      };\n    };\n  };\n  var liftM1 = function(dictMonad) {\n    var bind20 = bind(dictMonad.Bind1());\n    var pure18 = pure(dictMonad.Applicative0());\n    return function(f2) {\n      return function(a2) {\n        return bind20(a2)(function(a$prime) {\n          return pure18(f2(a$prime));\n        });\n      };\n    };\n  };\n  var ap = function(dictMonad) {\n    var bind20 = bind(dictMonad.Bind1());\n    var pure18 = pure(dictMonad.Applicative0());\n    return function(f2) {\n      return function(a2) {\n        return bind20(f2)(function(f$prime) {\n          return bind20(a2)(function(a$prime) {\n            return pure18(f$prime(a$prime));\n          });\n        });\n      };\n    };\n  };\n\n  // output/Data.Semigroup/foreign.js\n  var concatString = function(s1) {\n    return function(s2) {\n      return s1 + s2;\n    };\n  };\n  var concatArray = function(xs) {\n    return function(ys) {\n      if (xs.length === 0)\n        return ys;\n      if (ys.length === 0)\n        return xs;\n      return xs.concat(ys);\n    };\n  };\n\n  // output/Data.Symbol/index.js\n  var reflectSymbol = function(dict) {\n    return dict.reflectSymbol;\n  };\n\n  // output/Record.Unsafe/foreign.js\n  var unsafeGet = function(label5) {\n    return function(rec) {\n      return rec[label5];\n    };\n  };\n  var unsafeSet = function(label5) {\n    return function(value15) {\n      return function(rec) {\n        var copy2 = {};\n        for (var key in rec) {\n          if ({}.hasOwnProperty.call(rec, key)) {\n            copy2[key] = rec[key];\n          }\n        }\n        copy2[label5] = value15;\n        return copy2;\n      };\n    };\n  };\n\n  // output/Data.Semigroup/index.js\n  var semigroupUnit = {\n    append: function(v) {\n      return function(v1) {\n        return unit;\n      };\n    }\n  };\n  var semigroupString = {\n    append: concatString\n  };\n  var semigroupArray = {\n    append: concatArray\n  };\n  var append = function(dict) {\n    return dict.append;\n  };\n\n  // output/Control.Alt/index.js\n  var alt = function(dict) {\n    return dict.alt;\n  };\n\n  // output/Data.Bounded/foreign.js\n  var topInt = 2147483647;\n  var bottomInt = -2147483648;\n  var topChar = String.fromCharCode(65535);\n  var bottomChar = String.fromCharCode(0);\n  var topNumber = Number.POSITIVE_INFINITY;\n  var bottomNumber = Number.NEGATIVE_INFINITY;\n\n  // output/Data.Ord/foreign.js\n  var unsafeCompareImpl = function(lt) {\n    return function(eq8) {\n      return function(gt) {\n        return function(x) {\n          return function(y) {\n            return x < y ? lt : x === y ? eq8 : gt;\n          };\n        };\n      };\n    };\n  };\n  var ordIntImpl = unsafeCompareImpl;\n  var ordStringImpl = unsafeCompareImpl;\n\n  // output/Data.Eq/foreign.js\n  var refEq = function(r1) {\n    return function(r2) {\n      return r1 === r2;\n    };\n  };\n  var eqBooleanImpl = refEq;\n  var eqIntImpl = refEq;\n  var eqStringImpl = refEq;\n  var eqArrayImpl = function(f2) {\n    return function(xs) {\n      return function(ys) {\n        if (xs.length !== ys.length)\n          return false;\n        for (var i2 = 0; i2 < xs.length; i2++) {\n          if (!f2(xs[i2])(ys[i2]))\n            return false;\n        }\n        return true;\n      };\n    };\n  };\n\n  // output/Data.Eq/index.js\n  var eqUnit = {\n    eq: function(v) {\n      return function(v1) {\n        return true;\n      };\n    }\n  };\n  var eqString = {\n    eq: eqStringImpl\n  };\n  var eqRowNil = {\n    eqRecord: function(v) {\n      return function(v1) {\n        return function(v2) {\n          return true;\n        };\n      };\n    }\n  };\n  var eqRecord = function(dict) {\n    return dict.eqRecord;\n  };\n  var eqRec = function() {\n    return function(dictEqRecord) {\n      return {\n        eq: eqRecord(dictEqRecord)($$Proxy.value)\n      };\n    };\n  };\n  var eqInt = {\n    eq: eqIntImpl\n  };\n  var eqBoolean = {\n    eq: eqBooleanImpl\n  };\n  var eq = function(dict) {\n    return dict.eq;\n  };\n  var eq2 = /* @__PURE__ */ eq(eqBoolean);\n  var eqArray = function(dictEq) {\n    return {\n      eq: eqArrayImpl(eq(dictEq))\n    };\n  };\n  var eqRowCons = function(dictEqRecord) {\n    var eqRecord1 = eqRecord(dictEqRecord);\n    return function() {\n      return function(dictIsSymbol) {\n        var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n        return function(dictEq) {\n          var eq32 = eq(dictEq);\n          return {\n            eqRecord: function(v) {\n              return function(ra) {\n                return function(rb) {\n                  var tail2 = eqRecord1($$Proxy.value)(ra)(rb);\n                  var key = reflectSymbol2($$Proxy.value);\n                  var get7 = unsafeGet(key);\n                  return eq32(get7(ra))(get7(rb)) && tail2;\n                };\n              };\n            }\n          };\n        };\n      };\n    };\n  };\n  var notEq = function(dictEq) {\n    var eq32 = eq(dictEq);\n    return function(x) {\n      return function(y) {\n        return eq2(eq32(x)(y))(false);\n      };\n    };\n  };\n\n  // output/Data.Ordering/index.js\n  var LT = /* @__PURE__ */ function() {\n    function LT2() {\n    }\n    ;\n    LT2.value = new LT2();\n    return LT2;\n  }();\n  var GT = /* @__PURE__ */ function() {\n    function GT2() {\n    }\n    ;\n    GT2.value = new GT2();\n    return GT2;\n  }();\n  var EQ = /* @__PURE__ */ function() {\n    function EQ2() {\n    }\n    ;\n    EQ2.value = new EQ2();\n    return EQ2;\n  }();\n\n  // output/Data.Ring/foreign.js\n  var numSub = function(n1) {\n    return function(n2) {\n      return n1 - n2;\n    };\n  };\n\n  // output/Data.Semiring/foreign.js\n  var intAdd = function(x) {\n    return function(y) {\n      return x + y | 0;\n    };\n  };\n  var intMul = function(x) {\n    return function(y) {\n      return x * y | 0;\n    };\n  };\n  var numAdd = function(n1) {\n    return function(n2) {\n      return n1 + n2;\n    };\n  };\n  var numMul = function(n1) {\n    return function(n2) {\n      return n1 * n2;\n    };\n  };\n\n  // output/Data.Semiring/index.js\n  var zero = function(dict) {\n    return dict.zero;\n  };\n  var semiringNumber = {\n    add: numAdd,\n    zero: 0,\n    mul: numMul,\n    one: 1\n  };\n  var semiringInt = {\n    add: intAdd,\n    zero: 0,\n    mul: intMul,\n    one: 1\n  };\n  var one = function(dict) {\n    return dict.one;\n  };\n  var mul = function(dict) {\n    return dict.mul;\n  };\n  var add = function(dict) {\n    return dict.add;\n  };\n\n  // output/Data.Ring/index.js\n  var sub = function(dict) {\n    return dict.sub;\n  };\n  var ringNumber = {\n    sub: numSub,\n    Semiring0: function() {\n      return semiringNumber;\n    }\n  };\n\n  // output/Data.Ord/index.js\n  var ordUnit = {\n    compare: function(v) {\n      return function(v1) {\n        return EQ.value;\n      };\n    },\n    Eq0: function() {\n      return eqUnit;\n    }\n  };\n  var ordString = /* @__PURE__ */ function() {\n    return {\n      compare: ordStringImpl(LT.value)(EQ.value)(GT.value),\n      Eq0: function() {\n        return eqString;\n      }\n    };\n  }();\n  var ordInt = /* @__PURE__ */ function() {\n    return {\n      compare: ordIntImpl(LT.value)(EQ.value)(GT.value),\n      Eq0: function() {\n        return eqInt;\n      }\n    };\n  }();\n  var compare = function(dict) {\n    return dict.compare;\n  };\n  var greaterThan = function(dictOrd) {\n    var compare32 = compare(dictOrd);\n    return function(a1) {\n      return function(a2) {\n        var v = compare32(a1)(a2);\n        if (v instanceof GT) {\n          return true;\n        }\n        ;\n        return false;\n      };\n    };\n  };\n  var lessThan = function(dictOrd) {\n    var compare32 = compare(dictOrd);\n    return function(a1) {\n      return function(a2) {\n        var v = compare32(a1)(a2);\n        if (v instanceof LT) {\n          return true;\n        }\n        ;\n        return false;\n      };\n    };\n  };\n  var lessThanOrEq = function(dictOrd) {\n    var compare32 = compare(dictOrd);\n    return function(a1) {\n      return function(a2) {\n        var v = compare32(a1)(a2);\n        if (v instanceof GT) {\n          return false;\n        }\n        ;\n        return true;\n      };\n    };\n  };\n  var max = function(dictOrd) {\n    var compare32 = compare(dictOrd);\n    return function(x) {\n      return function(y) {\n        var v = compare32(x)(y);\n        if (v instanceof LT) {\n          return y;\n        }\n        ;\n        if (v instanceof EQ) {\n          return x;\n        }\n        ;\n        if (v instanceof GT) {\n          return x;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Ord (line 181, column 3 - line 184, column 12): \" + [v.constructor.name]);\n      };\n    };\n  };\n  var min = function(dictOrd) {\n    var compare32 = compare(dictOrd);\n    return function(x) {\n      return function(y) {\n        var v = compare32(x)(y);\n        if (v instanceof LT) {\n          return x;\n        }\n        ;\n        if (v instanceof EQ) {\n          return x;\n        }\n        ;\n        if (v instanceof GT) {\n          return y;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): \" + [v.constructor.name]);\n      };\n    };\n  };\n  var clamp = function(dictOrd) {\n    var min1 = min(dictOrd);\n    var max1 = max(dictOrd);\n    return function(low2) {\n      return function(hi) {\n        return function(x) {\n          return min1(hi)(max1(low2)(x));\n        };\n      };\n    };\n  };\n\n  // output/Data.Bounded/index.js\n  var top = function(dict) {\n    return dict.top;\n  };\n  var boundedInt = {\n    top: topInt,\n    bottom: bottomInt,\n    Ord0: function() {\n      return ordInt;\n    }\n  };\n  var bottom = function(dict) {\n    return dict.bottom;\n  };\n\n  // output/Data.Show/foreign.js\n  var showIntImpl = function(n) {\n    return n.toString();\n  };\n  var showNumberImpl = function(n) {\n    var str = n.toString();\n    return isNaN(str + \".0\") ? str : str + \".0\";\n  };\n  var showStringImpl = function(s) {\n    var l = s.length;\n    return '\"' + s.replace(\n      /[\\0-\\x1F\\x7F\"\\\\]/g,\n      // eslint-disable-line no-control-regex\n      function(c, i2) {\n        switch (c) {\n          case '\"':\n          case \"\\\\\":\n            return \"\\\\\" + c;\n          case \"\\x07\":\n            return \"\\\\a\";\n          case \"\\b\":\n            return \"\\\\b\";\n          case \"\\f\":\n            return \"\\\\f\";\n          case \"\\n\":\n            return \"\\\\n\";\n          case \"\\r\":\n            return \"\\\\r\";\n          case \"\t\":\n            return \"\\\\t\";\n          case \"\\v\":\n            return \"\\\\v\";\n        }\n        var k = i2 + 1;\n        var empty8 = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n        return \"\\\\\" + c.charCodeAt(0).toString(10) + empty8;\n      }\n    ) + '\"';\n  };\n\n  // output/Data.Show/index.js\n  var showString = {\n    show: showStringImpl\n  };\n  var showNumber = {\n    show: showNumberImpl\n  };\n  var showInt = {\n    show: showIntImpl\n  };\n  var show = function(dict) {\n    return dict.show;\n  };\n\n  // output/Data.Generic.Rep/index.js\n  var Inl = /* @__PURE__ */ function() {\n    function Inl2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Inl2.create = function(value0) {\n      return new Inl2(value0);\n    };\n    return Inl2;\n  }();\n  var Inr = /* @__PURE__ */ function() {\n    function Inr2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Inr2.create = function(value0) {\n      return new Inr2(value0);\n    };\n    return Inr2;\n  }();\n  var NoArguments = /* @__PURE__ */ function() {\n    function NoArguments2() {\n    }\n    ;\n    NoArguments2.value = new NoArguments2();\n    return NoArguments2;\n  }();\n  var from = function(dict) {\n    return dict.from;\n  };\n\n  // output/Data.Maybe/index.js\n  var identity4 = /* @__PURE__ */ identity(categoryFn);\n  var Nothing = /* @__PURE__ */ function() {\n    function Nothing2() {\n    }\n    ;\n    Nothing2.value = new Nothing2();\n    return Nothing2;\n  }();\n  var Just = /* @__PURE__ */ function() {\n    function Just2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Just2.create = function(value0) {\n      return new Just2(value0);\n    };\n    return Just2;\n  }();\n  var maybe$prime = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v2 instanceof Nothing) {\n          return v(unit);\n        }\n        ;\n        if (v2 instanceof Just) {\n          return v1(v2.value0);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 250, column 1 - line 250, column 62): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  };\n  var maybe = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v2 instanceof Nothing) {\n          return v;\n        }\n        ;\n        if (v2 instanceof Just) {\n          return v1(v2.value0);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  };\n  var isNothing = /* @__PURE__ */ maybe(true)(/* @__PURE__ */ $$const(false));\n  var isJust = /* @__PURE__ */ maybe(false)(/* @__PURE__ */ $$const(true));\n  var functorMaybe = {\n    map: function(v) {\n      return function(v1) {\n        if (v1 instanceof Just) {\n          return new Just(v(v1.value0));\n        }\n        ;\n        return Nothing.value;\n      };\n    }\n  };\n  var map2 = /* @__PURE__ */ map(functorMaybe);\n  var fromMaybe = function(a2) {\n    return maybe(a2)(identity4);\n  };\n  var fromJust = function() {\n    return function(v) {\n      if (v instanceof Just) {\n        return v.value0;\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): \" + [v.constructor.name]);\n    };\n  };\n  var applyMaybe = {\n    apply: function(v) {\n      return function(v1) {\n        if (v instanceof Just) {\n          return map2(v.value0)(v1);\n        }\n        ;\n        if (v instanceof Nothing) {\n          return Nothing.value;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    },\n    Functor0: function() {\n      return functorMaybe;\n    }\n  };\n  var bindMaybe = {\n    bind: function(v) {\n      return function(v1) {\n        if (v instanceof Just) {\n          return v1(v.value0);\n        }\n        ;\n        if (v instanceof Nothing) {\n          return Nothing.value;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    },\n    Apply0: function() {\n      return applyMaybe;\n    }\n  };\n  var applicativeMaybe = /* @__PURE__ */ function() {\n    return {\n      pure: Just.create,\n      Apply0: function() {\n        return applyMaybe;\n      }\n    };\n  }();\n\n  // output/Data.Either/index.js\n  var Left = /* @__PURE__ */ function() {\n    function Left2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Left2.create = function(value0) {\n      return new Left2(value0);\n    };\n    return Left2;\n  }();\n  var Right = /* @__PURE__ */ function() {\n    function Right2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Right2.create = function(value0) {\n      return new Right2(value0);\n    };\n    return Right2;\n  }();\n  var note = function(a2) {\n    return maybe(new Left(a2))(Right.create);\n  };\n  var functorEither = {\n    map: function(f2) {\n      return function(m) {\n        if (m instanceof Left) {\n          return new Left(m.value0);\n        }\n        ;\n        if (m instanceof Right) {\n          return new Right(f2(m.value0));\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): \" + [m.constructor.name]);\n      };\n    }\n  };\n  var map3 = /* @__PURE__ */ map(functorEither);\n  var either = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v2 instanceof Left) {\n          return v(v2.value0);\n        }\n        ;\n        if (v2 instanceof Right) {\n          return v1(v2.value0);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  };\n  var applyEither = {\n    apply: function(v) {\n      return function(v1) {\n        if (v instanceof Left) {\n          return new Left(v.value0);\n        }\n        ;\n        if (v instanceof Right) {\n          return map3(v.value0)(v1);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    },\n    Functor0: function() {\n      return functorEither;\n    }\n  };\n  var bindEither = {\n    bind: /* @__PURE__ */ either(function(e) {\n      return function(v) {\n        return new Left(e);\n      };\n    })(function(a2) {\n      return function(f2) {\n        return f2(a2);\n      };\n    }),\n    Apply0: function() {\n      return applyEither;\n    }\n  };\n  var applicativeEither = /* @__PURE__ */ function() {\n    return {\n      pure: Right.create,\n      Apply0: function() {\n        return applyEither;\n      }\n    };\n  }();\n\n  // output/Effect/foreign.js\n  var pureE = function(a2) {\n    return function() {\n      return a2;\n    };\n  };\n  var bindE = function(a2) {\n    return function(f2) {\n      return function() {\n        return f2(a2())();\n      };\n    };\n  };\n\n  // output/Data.EuclideanRing/foreign.js\n  var numDiv = function(n1) {\n    return function(n2) {\n      return n1 / n2;\n    };\n  };\n\n  // output/Data.CommutativeRing/index.js\n  var commutativeRingNumber = {\n    Ring0: function() {\n      return ringNumber;\n    }\n  };\n\n  // output/Data.EuclideanRing/index.js\n  var mod = function(dict) {\n    return dict.mod;\n  };\n  var euclideanRingNumber = {\n    degree: function(v) {\n      return 1;\n    },\n    div: numDiv,\n    mod: function(v) {\n      return function(v1) {\n        return 0;\n      };\n    },\n    CommutativeRing0: function() {\n      return commutativeRingNumber;\n    }\n  };\n  var div = function(dict) {\n    return dict.div;\n  };\n\n  // output/Data.Monoid/index.js\n  var monoidUnit = {\n    mempty: unit,\n    Semigroup0: function() {\n      return semigroupUnit;\n    }\n  };\n  var monoidString = {\n    mempty: \"\",\n    Semigroup0: function() {\n      return semigroupString;\n    }\n  };\n  var monoidArray = {\n    mempty: [],\n    Semigroup0: function() {\n      return semigroupArray;\n    }\n  };\n  var mempty = function(dict) {\n    return dict.mempty;\n  };\n\n  // output/Effect/index.js\n  var $runtime_lazy = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var monadEffect = {\n    Applicative0: function() {\n      return applicativeEffect;\n    },\n    Bind1: function() {\n      return bindEffect;\n    }\n  };\n  var bindEffect = {\n    bind: bindE,\n    Apply0: function() {\n      return $lazy_applyEffect(0);\n    }\n  };\n  var applicativeEffect = {\n    pure: pureE,\n    Apply0: function() {\n      return $lazy_applyEffect(0);\n    }\n  };\n  var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy(\"functorEffect\", \"Effect\", function() {\n    return {\n      map: liftA1(applicativeEffect)\n    };\n  });\n  var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy(\"applyEffect\", \"Effect\", function() {\n    return {\n      apply: ap(monadEffect),\n      Functor0: function() {\n        return $lazy_functorEffect(0);\n      }\n    };\n  });\n  var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);\n  var applyEffect = /* @__PURE__ */ $lazy_applyEffect(23);\n\n  // output/Effect.Exception/foreign.js\n  function error(msg) {\n    return new Error(msg);\n  }\n  function throwException(e) {\n    return function() {\n      throw e;\n    };\n  }\n\n  // output/Effect.Exception/index.js\n  var $$throw = function($4) {\n    return throwException(error($4));\n  };\n\n  // output/Control.Monad.Error.Class/index.js\n  var throwError = function(dict) {\n    return dict.throwError;\n  };\n  var catchError = function(dict) {\n    return dict.catchError;\n  };\n  var $$try = function(dictMonadError) {\n    var catchError1 = catchError(dictMonadError);\n    var Monad0 = dictMonadError.MonadThrow0().Monad0();\n    var map35 = map(Monad0.Bind1().Apply0().Functor0());\n    var pure18 = pure(Monad0.Applicative0());\n    return function(a2) {\n      return catchError1(map35(Right.create)(a2))(function($52) {\n        return pure18(Left.create($52));\n      });\n    };\n  };\n\n  // output/Data.Identity/index.js\n  var Identity = function(x) {\n    return x;\n  };\n  var functorIdentity = {\n    map: function(f2) {\n      return function(m) {\n        return f2(m);\n      };\n    }\n  };\n  var applyIdentity = {\n    apply: function(v) {\n      return function(v1) {\n        return v(v1);\n      };\n    },\n    Functor0: function() {\n      return functorIdentity;\n    }\n  };\n  var bindIdentity = {\n    bind: function(v) {\n      return function(f2) {\n        return f2(v);\n      };\n    },\n    Apply0: function() {\n      return applyIdentity;\n    }\n  };\n  var applicativeIdentity = {\n    pure: Identity,\n    Apply0: function() {\n      return applyIdentity;\n    }\n  };\n  var monadIdentity = {\n    Applicative0: function() {\n      return applicativeIdentity;\n    },\n    Bind1: function() {\n      return bindIdentity;\n    }\n  };\n\n  // output/Effect.Ref/foreign.js\n  var _new = function(val) {\n    return function() {\n      return { value: val };\n    };\n  };\n  var read = function(ref3) {\n    return function() {\n      return ref3.value;\n    };\n  };\n  var modifyImpl = function(f2) {\n    return function(ref3) {\n      return function() {\n        var t = f2(ref3.value);\n        ref3.value = t.state;\n        return t.value;\n      };\n    };\n  };\n  var write = function(val) {\n    return function(ref3) {\n      return function() {\n        ref3.value = val;\n      };\n    };\n  };\n\n  // output/Effect.Ref/index.js\n  var $$void2 = /* @__PURE__ */ $$void(functorEffect);\n  var $$new = _new;\n  var modify$prime = modifyImpl;\n  var modify = function(f2) {\n    return modify$prime(function(s) {\n      var s$prime = f2(s);\n      return {\n        state: s$prime,\n        value: s$prime\n      };\n    });\n  };\n  var modify_ = function(f2) {\n    return function(s) {\n      return $$void2(modify(f2)(s));\n    };\n  };\n\n  // output/Control.Monad.Rec.Class/index.js\n  var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindEffect);\n  var map4 = /* @__PURE__ */ map(functorEffect);\n  var Loop = /* @__PURE__ */ function() {\n    function Loop2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Loop2.create = function(value0) {\n      return new Loop2(value0);\n    };\n    return Loop2;\n  }();\n  var Done = /* @__PURE__ */ function() {\n    function Done2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Done2.create = function(value0) {\n      return new Done2(value0);\n    };\n    return Done2;\n  }();\n  var tailRecM = function(dict) {\n    return dict.tailRecM;\n  };\n  var monadRecEffect = {\n    tailRecM: function(f2) {\n      return function(a2) {\n        var fromDone = function(v) {\n          if (v instanceof Done) {\n            return v.value0;\n          }\n          ;\n          throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 137, column 30 - line 137, column 44): \" + [v.constructor.name]);\n        };\n        return function __do2() {\n          var r = bindFlipped2($$new)(f2(a2))();\n          (function() {\n            while (!function __do3() {\n              var v = read(r)();\n              if (v instanceof Loop) {\n                var e = f2(v.value0)();\n                write(e)(r)();\n                return false;\n              }\n              ;\n              if (v instanceof Done) {\n                return true;\n              }\n              ;\n              throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 128, column 22 - line 133, column 28): \" + [v.constructor.name]);\n            }()) {\n            }\n            ;\n            return {};\n          })();\n          return map4(fromDone)(read(r))();\n        };\n      };\n    },\n    Monad0: function() {\n      return monadEffect;\n    }\n  };\n\n  // output/Data.HeytingAlgebra/foreign.js\n  var boolConj = function(b1) {\n    return function(b2) {\n      return b1 && b2;\n    };\n  };\n  var boolDisj = function(b1) {\n    return function(b2) {\n      return b1 || b2;\n    };\n  };\n  var boolNot = function(b2) {\n    return !b2;\n  };\n\n  // output/Data.HeytingAlgebra/index.js\n  var tt = function(dict) {\n    return dict.tt;\n  };\n  var not = function(dict) {\n    return dict.not;\n  };\n  var implies = function(dict) {\n    return dict.implies;\n  };\n  var ff = function(dict) {\n    return dict.ff;\n  };\n  var disj = function(dict) {\n    return dict.disj;\n  };\n  var heytingAlgebraBoolean = {\n    ff: false,\n    tt: true,\n    implies: function(a2) {\n      return function(b2) {\n        return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a2))(b2);\n      };\n    },\n    conj: boolConj,\n    disj: boolDisj,\n    not: boolNot\n  };\n  var conj = function(dict) {\n    return dict.conj;\n  };\n  var heytingAlgebraFunction = function(dictHeytingAlgebra) {\n    var ff1 = ff(dictHeytingAlgebra);\n    var tt1 = tt(dictHeytingAlgebra);\n    var implies1 = implies(dictHeytingAlgebra);\n    var conj1 = conj(dictHeytingAlgebra);\n    var disj1 = disj(dictHeytingAlgebra);\n    var not1 = not(dictHeytingAlgebra);\n    return {\n      ff: function(v) {\n        return ff1;\n      },\n      tt: function(v) {\n        return tt1;\n      },\n      implies: function(f2) {\n        return function(g) {\n          return function(a2) {\n            return implies1(f2(a2))(g(a2));\n          };\n        };\n      },\n      conj: function(f2) {\n        return function(g) {\n          return function(a2) {\n            return conj1(f2(a2))(g(a2));\n          };\n        };\n      },\n      disj: function(f2) {\n        return function(g) {\n          return function(a2) {\n            return disj1(f2(a2))(g(a2));\n          };\n        };\n      },\n      not: function(f2) {\n        return function(a2) {\n          return not1(f2(a2));\n        };\n      }\n    };\n  };\n\n  // output/Data.Tuple/index.js\n  var Tuple = /* @__PURE__ */ function() {\n    function Tuple2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Tuple2.create = function(value0) {\n      return function(value1) {\n        return new Tuple2(value0, value1);\n      };\n    };\n    return Tuple2;\n  }();\n  var snd = function(v) {\n    return v.value1;\n  };\n  var functorTuple = {\n    map: function(f2) {\n      return function(m) {\n        return new Tuple(m.value0, f2(m.value1));\n      };\n    }\n  };\n  var fst = function(v) {\n    return v.value0;\n  };\n  var eqTuple = function(dictEq) {\n    var eq8 = eq(dictEq);\n    return function(dictEq1) {\n      var eq13 = eq(dictEq1);\n      return {\n        eq: function(x) {\n          return function(y) {\n            return eq8(x.value0)(y.value0) && eq13(x.value1)(y.value1);\n          };\n        }\n      };\n    };\n  };\n  var ordTuple = function(dictOrd) {\n    var compare4 = compare(dictOrd);\n    var eqTuple1 = eqTuple(dictOrd.Eq0());\n    return function(dictOrd1) {\n      var compare12 = compare(dictOrd1);\n      var eqTuple2 = eqTuple1(dictOrd1.Eq0());\n      return {\n        compare: function(x) {\n          return function(y) {\n            var v = compare4(x.value0)(y.value0);\n            if (v instanceof LT) {\n              return LT.value;\n            }\n            ;\n            if (v instanceof GT) {\n              return GT.value;\n            }\n            ;\n            return compare12(x.value1)(y.value1);\n          };\n        },\n        Eq0: function() {\n          return eqTuple2;\n        }\n      };\n    };\n  };\n\n  // output/Control.Monad.State.Class/index.js\n  var state = function(dict) {\n    return dict.state;\n  };\n  var put = function(dictMonadState) {\n    var state1 = state(dictMonadState);\n    return function(s) {\n      return state1(function(v) {\n        return new Tuple(unit, s);\n      });\n    };\n  };\n  var modify_2 = function(dictMonadState) {\n    var state1 = state(dictMonadState);\n    return function(f2) {\n      return state1(function(s) {\n        return new Tuple(unit, f2(s));\n      });\n    };\n  };\n  var modify2 = function(dictMonadState) {\n    var state1 = state(dictMonadState);\n    return function(f2) {\n      return state1(function(s) {\n        var s$prime = f2(s);\n        return new Tuple(s$prime, s$prime);\n      });\n    };\n  };\n  var gets = function(dictMonadState) {\n    var state1 = state(dictMonadState);\n    return function(f2) {\n      return state1(function(s) {\n        return new Tuple(f2(s), s);\n      });\n    };\n  };\n  var get = function(dictMonadState) {\n    return state(dictMonadState)(function(s) {\n      return new Tuple(s, s);\n    });\n  };\n\n  // output/Control.Monad.Trans.Class/index.js\n  var lift = function(dict) {\n    return dict.lift;\n  };\n\n  // output/Effect.Class/index.js\n  var monadEffectEffect = {\n    liftEffect: /* @__PURE__ */ identity(categoryFn),\n    Monad0: function() {\n      return monadEffect;\n    }\n  };\n  var liftEffect = function(dict) {\n    return dict.liftEffect;\n  };\n\n  // output/Control.Monad.Maybe.Trans/index.js\n  var map5 = /* @__PURE__ */ map(functorMaybe);\n  var MaybeT = function(x) {\n    return x;\n  };\n  var runMaybeT = function(v) {\n    return v;\n  };\n  var monadTransMaybeT = {\n    lift: function(dictMonad) {\n      var $157 = liftM1(dictMonad)(Just.create);\n      return function($158) {\n        return MaybeT($157($158));\n      };\n    }\n  };\n  var lift3 = /* @__PURE__ */ lift(monadTransMaybeT);\n  var functorMaybeT = function(dictFunctor) {\n    var map112 = map(dictFunctor);\n    return {\n      map: function(f2) {\n        return function(v) {\n          return map112(map5(f2))(v);\n        };\n      }\n    };\n  };\n  var monadMaybeT = function(dictMonad) {\n    return {\n      Applicative0: function() {\n        return applicativeMaybeT(dictMonad);\n      },\n      Bind1: function() {\n        return bindMaybeT(dictMonad);\n      }\n    };\n  };\n  var bindMaybeT = function(dictMonad) {\n    var bind20 = bind(dictMonad.Bind1());\n    var pure18 = pure(dictMonad.Applicative0());\n    return {\n      bind: function(v) {\n        return function(f2) {\n          return bind20(v)(function(v1) {\n            if (v1 instanceof Nothing) {\n              return pure18(Nothing.value);\n            }\n            ;\n            if (v1 instanceof Just) {\n              var v2 = f2(v1.value0);\n              return v2;\n            }\n            ;\n            throw new Error(\"Failed pattern match at Control.Monad.Maybe.Trans (line 54, column 11 - line 56, column 42): \" + [v1.constructor.name]);\n          });\n        };\n      },\n      Apply0: function() {\n        return applyMaybeT(dictMonad);\n      }\n    };\n  };\n  var applyMaybeT = function(dictMonad) {\n    var functorMaybeT1 = functorMaybeT(dictMonad.Bind1().Apply0().Functor0());\n    return {\n      apply: ap(monadMaybeT(dictMonad)),\n      Functor0: function() {\n        return functorMaybeT1;\n      }\n    };\n  };\n  var applicativeMaybeT = function(dictMonad) {\n    return {\n      pure: function() {\n        var $159 = pure(dictMonad.Applicative0());\n        return function($160) {\n          return MaybeT($159(Just.create($160)));\n        };\n      }(),\n      Apply0: function() {\n        return applyMaybeT(dictMonad);\n      }\n    };\n  };\n  var monadStateMaybeT = function(dictMonadState) {\n    var Monad0 = dictMonadState.Monad0();\n    var lift1 = lift3(Monad0);\n    var state3 = state(dictMonadState);\n    var monadMaybeT1 = monadMaybeT(Monad0);\n    return {\n      state: function(f2) {\n        return lift1(state3(f2));\n      },\n      Monad0: function() {\n        return monadMaybeT1;\n      }\n    };\n  };\n  var altMaybeT = function(dictMonad) {\n    var Bind1 = dictMonad.Bind1();\n    var bind20 = bind(Bind1);\n    var pure18 = pure(dictMonad.Applicative0());\n    var functorMaybeT1 = functorMaybeT(Bind1.Apply0().Functor0());\n    return {\n      alt: function(v) {\n        return function(v1) {\n          return bind20(v)(function(m) {\n            if (m instanceof Nothing) {\n              return v1;\n            }\n            ;\n            return pure18(m);\n          });\n        };\n      },\n      Functor0: function() {\n        return functorMaybeT1;\n      }\n    };\n  };\n  var plusMaybeT = function(dictMonad) {\n    var altMaybeT1 = altMaybeT(dictMonad);\n    return {\n      empty: pure(dictMonad.Applicative0())(Nothing.value),\n      Alt0: function() {\n        return altMaybeT1;\n      }\n    };\n  };\n  var alternativeMaybeT = function(dictMonad) {\n    var applicativeMaybeT1 = applicativeMaybeT(dictMonad);\n    var plusMaybeT1 = plusMaybeT(dictMonad);\n    return {\n      Applicative0: function() {\n        return applicativeMaybeT1;\n      },\n      Plus1: function() {\n        return plusMaybeT1;\n      }\n    };\n  };\n\n  // output/Data.Array/foreign.js\n  var rangeImpl = function(start2, end) {\n    var step4 = start2 > end ? -1 : 1;\n    var result = new Array(step4 * (end - start2) + 1);\n    var i2 = start2, n = 0;\n    while (i2 !== end) {\n      result[n++] = i2;\n      i2 += step4;\n    }\n    result[n] = i2;\n    return result;\n  };\n  var replicateFill = function(count, value15) {\n    if (count < 1) {\n      return [];\n    }\n    var result = new Array(count);\n    return result.fill(value15);\n  };\n  var replicatePolyfill = function(count, value15) {\n    var result = [];\n    var n = 0;\n    for (var i2 = 0; i2 < count; i2++) {\n      result[n++] = value15;\n    }\n    return result;\n  };\n  var replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n  var fromFoldableImpl = /* @__PURE__ */ function() {\n    function Cons2(head4, tail2) {\n      this.head = head4;\n      this.tail = tail2;\n    }\n    var emptyList = {};\n    function curryCons(head4) {\n      return function(tail2) {\n        return new Cons2(head4, tail2);\n      };\n    }\n    function listToArray(list) {\n      var result = [];\n      var count = 0;\n      var xs = list;\n      while (xs !== emptyList) {\n        result[count++] = xs.head;\n        xs = xs.tail;\n      }\n      return result;\n    }\n    return function(foldr5, xs) {\n      return listToArray(foldr5(curryCons)(emptyList)(xs));\n    };\n  }();\n  var length = function(xs) {\n    return xs.length;\n  };\n  var indexImpl = function(just, nothing, xs, i2) {\n    return i2 < 0 || i2 >= xs.length ? nothing : just(xs[i2]);\n  };\n  var findIndexImpl = function(just, nothing, f2, xs) {\n    for (var i2 = 0, l = xs.length; i2 < l; i2++) {\n      if (f2(xs[i2]))\n        return just(i2);\n    }\n    return nothing;\n  };\n  var _deleteAt = function(just, nothing, i2, l) {\n    if (i2 < 0 || i2 >= l.length)\n      return nothing;\n    var l1 = l.slice();\n    l1.splice(i2, 1);\n    return just(l1);\n  };\n  var _updateAt = function(just, nothing, i2, a2, l) {\n    if (i2 < 0 || i2 >= l.length)\n      return nothing;\n    var l1 = l.slice();\n    l1[i2] = a2;\n    return just(l1);\n  };\n  var filterImpl = function(f2, xs) {\n    return xs.filter(f2);\n  };\n  var zipWithImpl = function(f2, xs, ys) {\n    var l = xs.length < ys.length ? xs.length : ys.length;\n    var result = new Array(l);\n    for (var i2 = 0; i2 < l; i2++) {\n      result[i2] = f2(xs[i2])(ys[i2]);\n    }\n    return result;\n  };\n  var anyImpl = function(p2, xs) {\n    var len = xs.length;\n    for (var i2 = 0; i2 < len; i2++) {\n      if (p2(xs[i2]))\n        return true;\n    }\n    return false;\n  };\n  var allImpl = function(p2, xs) {\n    var len = xs.length;\n    for (var i2 = 0; i2 < len; i2++) {\n      if (!p2(xs[i2]))\n        return false;\n    }\n    return true;\n  };\n  var unsafeIndexImpl = function(xs, n) {\n    return xs[n];\n  };\n\n  // output/Control.Monad.ST.Internal/foreign.js\n  var map_ = function(f2) {\n    return function(a2) {\n      return function() {\n        return f2(a2());\n      };\n    };\n  };\n  var pure_ = function(a2) {\n    return function() {\n      return a2;\n    };\n  };\n  var bind_ = function(a2) {\n    return function(f2) {\n      return function() {\n        return f2(a2())();\n      };\n    };\n  };\n  var foreach = function(as) {\n    return function(f2) {\n      return function() {\n        for (var i2 = 0, l = as.length; i2 < l; i2++) {\n          f2(as[i2])();\n        }\n      };\n    };\n  };\n\n  // output/Control.Monad.ST.Internal/index.js\n  var $runtime_lazy2 = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var functorST = {\n    map: map_\n  };\n  var monadST = {\n    Applicative0: function() {\n      return applicativeST;\n    },\n    Bind1: function() {\n      return bindST;\n    }\n  };\n  var bindST = {\n    bind: bind_,\n    Apply0: function() {\n      return $lazy_applyST(0);\n    }\n  };\n  var applicativeST = {\n    pure: pure_,\n    Apply0: function() {\n      return $lazy_applyST(0);\n    }\n  };\n  var $lazy_applyST = /* @__PURE__ */ $runtime_lazy2(\"applyST\", \"Control.Monad.ST.Internal\", function() {\n    return {\n      apply: ap(monadST),\n      Functor0: function() {\n        return functorST;\n      }\n    };\n  });\n  var applyST = /* @__PURE__ */ $lazy_applyST(47);\n\n  // output/Data.Array.ST/foreign.js\n  function newSTArray() {\n    return [];\n  }\n  var peekImpl = function(just, nothing, i2, xs) {\n    return i2 >= 0 && i2 < xs.length ? just(xs[i2]) : nothing;\n  };\n  var pokeImpl = function(i2, a2, xs) {\n    var ret = i2 >= 0 && i2 < xs.length;\n    if (ret)\n      xs[i2] = a2;\n    return ret;\n  };\n  var spliceImpl = function(i2, howMany, bs, xs) {\n    return xs.splice.apply(xs, [i2, howMany].concat(bs));\n  };\n  function unsafeFreezeThawImpl(xs) {\n    return xs;\n  }\n  var unsafeFreezeImpl = unsafeFreezeThawImpl;\n  function copyImpl(xs) {\n    return xs.slice();\n  }\n  var thawImpl = copyImpl;\n  var pushImpl = function(a2, xs) {\n    return xs.push(a2);\n  };\n\n  // output/Control.Monad.ST.Uncurried/foreign.js\n  var runSTFn1 = function runSTFn12(fn) {\n    return function(a2) {\n      return function() {\n        return fn(a2);\n      };\n    };\n  };\n  var runSTFn2 = function runSTFn22(fn) {\n    return function(a2) {\n      return function(b2) {\n        return function() {\n          return fn(a2, b2);\n        };\n      };\n    };\n  };\n  var runSTFn3 = function runSTFn32(fn) {\n    return function(a2) {\n      return function(b2) {\n        return function(c) {\n          return function() {\n            return fn(a2, b2, c);\n          };\n        };\n      };\n    };\n  };\n  var runSTFn4 = function runSTFn42(fn) {\n    return function(a2) {\n      return function(b2) {\n        return function(c) {\n          return function(d) {\n            return function() {\n              return fn(a2, b2, c, d);\n            };\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Array.ST/index.js\n  var bind2 = /* @__PURE__ */ bind(bindST);\n  var unsafeFreeze = /* @__PURE__ */ runSTFn1(unsafeFreezeImpl);\n  var thaw = /* @__PURE__ */ runSTFn1(thawImpl);\n  var withArray = function(f2) {\n    return function(xs) {\n      return function __do2() {\n        var result = thaw(xs)();\n        f2(result)();\n        return unsafeFreeze(result)();\n      };\n    };\n  };\n  var splice = /* @__PURE__ */ runSTFn4(spliceImpl);\n  var run2 = function(st) {\n    return bind2(st)(unsafeFreeze)();\n  };\n  var push = /* @__PURE__ */ runSTFn2(pushImpl);\n  var poke = /* @__PURE__ */ runSTFn3(pokeImpl);\n  var peek = /* @__PURE__ */ function() {\n    return runSTFn4(peekImpl)(Just.create)(Nothing.value);\n  }();\n\n  // output/Data.Foldable/foreign.js\n  var foldrArray = function(f2) {\n    return function(init3) {\n      return function(xs) {\n        var acc = init3;\n        var len = xs.length;\n        for (var i2 = len - 1; i2 >= 0; i2--) {\n          acc = f2(xs[i2])(acc);\n        }\n        return acc;\n      };\n    };\n  };\n  var foldlArray = function(f2) {\n    return function(init3) {\n      return function(xs) {\n        var acc = init3;\n        var len = xs.length;\n        for (var i2 = 0; i2 < len; i2++) {\n          acc = f2(acc)(xs[i2]);\n        }\n        return acc;\n      };\n    };\n  };\n\n  // output/Control.Plus/index.js\n  var empty = function(dict) {\n    return dict.empty;\n  };\n\n  // output/Data.Bifunctor/index.js\n  var identity5 = /* @__PURE__ */ identity(categoryFn);\n  var bimap = function(dict) {\n    return dict.bimap;\n  };\n  var lmap = function(dictBifunctor) {\n    var bimap1 = bimap(dictBifunctor);\n    return function(f2) {\n      return bimap1(f2)(identity5);\n    };\n  };\n  var bifunctorEither = {\n    bimap: function(v) {\n      return function(v1) {\n        return function(v2) {\n          if (v2 instanceof Left) {\n            return new Left(v(v2.value0));\n          }\n          ;\n          if (v2 instanceof Right) {\n            return new Right(v1(v2.value0));\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n        };\n      };\n    }\n  };\n\n  // output/Unsafe.Coerce/foreign.js\n  var unsafeCoerce2 = function(x) {\n    return x;\n  };\n\n  // output/Safe.Coerce/index.js\n  var coerce = function() {\n    return unsafeCoerce2;\n  };\n\n  // output/Data.Newtype/index.js\n  var coerce2 = /* @__PURE__ */ coerce();\n  var unwrap = function() {\n    return coerce2;\n  };\n  var unwrap1 = /* @__PURE__ */ unwrap();\n  var un = function() {\n    return function(v) {\n      return unwrap1;\n    };\n  };\n  var collect = function() {\n    return function() {\n      return function(v) {\n        return coerce2;\n      };\n    };\n  };\n  var alaF = function() {\n    return function() {\n      return function() {\n        return function() {\n          return function(v) {\n            return coerce2;\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Foldable/index.js\n  var identity6 = /* @__PURE__ */ identity(categoryFn);\n  var foldr = function(dict) {\n    return dict.foldr;\n  };\n  var traverse_ = function(dictApplicative) {\n    var applySecond3 = applySecond(dictApplicative.Apply0());\n    var pure18 = pure(dictApplicative);\n    return function(dictFoldable) {\n      var foldr22 = foldr(dictFoldable);\n      return function(f2) {\n        return foldr22(function($454) {\n          return applySecond3(f2($454));\n        })(pure18(unit));\n      };\n    };\n  };\n  var for_ = function(dictApplicative) {\n    var traverse_15 = traverse_(dictApplicative);\n    return function(dictFoldable) {\n      return flip(traverse_15(dictFoldable));\n    };\n  };\n  var foldl = function(dict) {\n    return dict.foldl;\n  };\n  var indexl = function(dictFoldable) {\n    var foldl2 = foldl(dictFoldable);\n    return function(idx) {\n      var go2 = function(cursor) {\n        return function(a2) {\n          if (cursor.elem instanceof Just) {\n            return cursor;\n          }\n          ;\n          var $296 = cursor.pos === idx;\n          if ($296) {\n            return {\n              elem: new Just(a2),\n              pos: cursor.pos\n            };\n          }\n          ;\n          return {\n            pos: cursor.pos + 1 | 0,\n            elem: cursor.elem\n          };\n        };\n      };\n      var $455 = foldl2(go2)({\n        elem: Nothing.value,\n        pos: 0\n      });\n      return function($456) {\n        return function(v) {\n          return v.elem;\n        }($455($456));\n      };\n    };\n  };\n  var product = function(dictFoldable) {\n    var foldl2 = foldl(dictFoldable);\n    return function(dictSemiring) {\n      return foldl2(mul(dictSemiring))(one(dictSemiring));\n    };\n  };\n  var foldableMaybe = {\n    foldr: function(v) {\n      return function(v1) {\n        return function(v2) {\n          if (v2 instanceof Nothing) {\n            return v1;\n          }\n          ;\n          if (v2 instanceof Just) {\n            return v(v2.value0)(v1);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n        };\n      };\n    },\n    foldl: function(v) {\n      return function(v1) {\n        return function(v2) {\n          if (v2 instanceof Nothing) {\n            return v1;\n          }\n          ;\n          if (v2 instanceof Just) {\n            return v(v1)(v2.value0);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n        };\n      };\n    },\n    foldMap: function(dictMonoid) {\n      var mempty2 = mempty(dictMonoid);\n      return function(v) {\n        return function(v1) {\n          if (v1 instanceof Nothing) {\n            return mempty2;\n          }\n          ;\n          if (v1 instanceof Just) {\n            return v(v1.value0);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [v.constructor.name, v1.constructor.name]);\n        };\n      };\n    }\n  };\n  var foldMapDefaultR = function(dictFoldable) {\n    var foldr22 = foldr(dictFoldable);\n    return function(dictMonoid) {\n      var append7 = append(dictMonoid.Semigroup0());\n      var mempty2 = mempty(dictMonoid);\n      return function(f2) {\n        return foldr22(function(x) {\n          return function(acc) {\n            return append7(f2(x))(acc);\n          };\n        })(mempty2);\n      };\n    };\n  };\n  var foldableArray = {\n    foldr: foldrArray,\n    foldl: foldlArray,\n    foldMap: function(dictMonoid) {\n      return foldMapDefaultR(foldableArray)(dictMonoid);\n    }\n  };\n  var foldMap = function(dict) {\n    return dict.foldMap;\n  };\n  var fold = function(dictFoldable) {\n    var foldMap22 = foldMap(dictFoldable);\n    return function(dictMonoid) {\n      return foldMap22(dictMonoid)(identity6);\n    };\n  };\n\n  // output/Data.Function.Uncurried/foreign.js\n  var runFn2 = function(fn) {\n    return function(a2) {\n      return function(b2) {\n        return fn(a2, b2);\n      };\n    };\n  };\n  var runFn3 = function(fn) {\n    return function(a2) {\n      return function(b2) {\n        return function(c) {\n          return fn(a2, b2, c);\n        };\n      };\n    };\n  };\n  var runFn4 = function(fn) {\n    return function(a2) {\n      return function(b2) {\n        return function(c) {\n          return function(d) {\n            return fn(a2, b2, c, d);\n          };\n        };\n      };\n    };\n  };\n  var runFn5 = function(fn) {\n    return function(a2) {\n      return function(b2) {\n        return function(c) {\n          return function(d) {\n            return function(e) {\n              return fn(a2, b2, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.FunctorWithIndex/foreign.js\n  var mapWithIndexArray = function(f2) {\n    return function(xs) {\n      var l = xs.length;\n      var result = Array(l);\n      for (var i2 = 0; i2 < l; i2++) {\n        result[i2] = f2(i2)(xs[i2]);\n      }\n      return result;\n    };\n  };\n\n  // output/Data.Monoid.Additive/index.js\n  var Additive = function(x) {\n    return x;\n  };\n  var semigroupAdditive = function(dictSemiring) {\n    var add3 = add(dictSemiring);\n    return {\n      append: function(v) {\n        return function(v1) {\n          return add3(v)(v1);\n        };\n      }\n    };\n  };\n  var monoidAdditive = function(dictSemiring) {\n    var semigroupAdditive1 = semigroupAdditive(dictSemiring);\n    return {\n      mempty: zero(dictSemiring),\n      Semigroup0: function() {\n        return semigroupAdditive1;\n      }\n    };\n  };\n\n  // output/Data.FunctorWithIndex/index.js\n  var mapWithIndex = function(dict) {\n    return dict.mapWithIndex;\n  };\n  var functorWithIndexArray = {\n    mapWithIndex: mapWithIndexArray,\n    Functor0: function() {\n      return functorArray;\n    }\n  };\n\n  // output/Data.Traversable/foreign.js\n  var traverseArrayImpl = /* @__PURE__ */ function() {\n    function array1(a2) {\n      return [a2];\n    }\n    function array2(a2) {\n      return function(b2) {\n        return [a2, b2];\n      };\n    }\n    function array3(a2) {\n      return function(b2) {\n        return function(c) {\n          return [a2, b2, c];\n        };\n      };\n    }\n    function concat2(xs) {\n      return function(ys) {\n        return xs.concat(ys);\n      };\n    }\n    return function(apply4) {\n      return function(map35) {\n        return function(pure18) {\n          return function(f2) {\n            return function(array) {\n              function go2(bot, top3) {\n                switch (top3 - bot) {\n                  case 0:\n                    return pure18([]);\n                  case 1:\n                    return map35(array1)(f2(array[bot]));\n                  case 2:\n                    return apply4(map35(array2)(f2(array[bot])))(f2(array[bot + 1]));\n                  case 3:\n                    return apply4(apply4(map35(array3)(f2(array[bot])))(f2(array[bot + 1])))(f2(array[bot + 2]));\n                  default:\n                    var pivot = bot + Math.floor((top3 - bot) / 4) * 2;\n                    return apply4(map35(concat2)(go2(bot, pivot)))(go2(pivot, top3));\n                }\n              }\n              return go2(0, array.length);\n            };\n          };\n        };\n      };\n    };\n  }();\n\n  // output/Data.Traversable/index.js\n  var identity7 = /* @__PURE__ */ identity(categoryFn);\n  var traverse = function(dict) {\n    return dict.traverse;\n  };\n  var sequenceDefault = function(dictTraversable) {\n    var traverse22 = traverse(dictTraversable);\n    return function(dictApplicative) {\n      return traverse22(dictApplicative)(identity7);\n    };\n  };\n  var traversableArray = {\n    traverse: function(dictApplicative) {\n      var Apply0 = dictApplicative.Apply0();\n      return traverseArrayImpl(apply(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));\n    },\n    sequence: function(dictApplicative) {\n      return sequenceDefault(traversableArray)(dictApplicative);\n    },\n    Functor0: function() {\n      return functorArray;\n    },\n    Foldable1: function() {\n      return foldableArray;\n    }\n  };\n  var sequence = function(dict) {\n    return dict.sequence;\n  };\n  var $$for = function(dictApplicative) {\n    return function(dictTraversable) {\n      var traverse22 = traverse(dictTraversable)(dictApplicative);\n      return function(x) {\n        return function(f2) {\n          return traverse22(f2)(x);\n        };\n      };\n    };\n  };\n\n  // output/Data.Unfoldable1/foreign.js\n  var unfoldr1ArrayImpl = function(isNothing2) {\n    return function(fromJust4) {\n      return function(fst2) {\n        return function(snd2) {\n          return function(f2) {\n            return function(b2) {\n              var result = [];\n              var value15 = b2;\n              while (true) {\n                var tuple = f2(value15);\n                result.push(fst2(tuple));\n                var maybe2 = snd2(tuple);\n                if (isNothing2(maybe2))\n                  return result;\n                value15 = fromJust4(maybe2);\n              }\n            };\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Semigroup.Foldable/index.js\n  var JoinWith = function(x) {\n    return x;\n  };\n  var semigroupJoinWith = function(dictSemigroup) {\n    var append7 = append(dictSemigroup);\n    return {\n      append: function(v) {\n        return function(v1) {\n          return function(j) {\n            return append7(v(j))(append7(j)(v1(j)));\n          };\n        };\n      }\n    };\n  };\n  var joinee = function(v) {\n    return v;\n  };\n  var foldMap1 = function(dict) {\n    return dict.foldMap1;\n  };\n  var intercalateMap = function(dictFoldable1) {\n    var foldMap11 = foldMap1(dictFoldable1);\n    return function(dictSemigroup) {\n      var foldMap122 = foldMap11(semigroupJoinWith(dictSemigroup));\n      return function(j) {\n        return function(f2) {\n          return function(foldable) {\n            return joinee(foldMap122(function($171) {\n              return JoinWith($$const(f2($171)));\n            })(foldable))(j);\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Unfoldable1/index.js\n  var fromJust2 = /* @__PURE__ */ fromJust();\n  var unfoldr1 = function(dict) {\n    return dict.unfoldr1;\n  };\n  var unfoldable1Array = {\n    unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust2)(fst)(snd)\n  };\n  var iterateN = function(dictUnfoldable1) {\n    var unfoldr11 = unfoldr1(dictUnfoldable1);\n    return function(n) {\n      return function(f2) {\n        return function(s) {\n          var go2 = function(v) {\n            return new Tuple(v.value0, function() {\n              var $28 = v.value1 > 0;\n              if ($28) {\n                return new Just(new Tuple(f2(v.value0), v.value1 - 1 | 0));\n              }\n              ;\n              return Nothing.value;\n            }());\n          };\n          return unfoldr11(go2)(new Tuple(s, n - 1 | 0));\n        };\n      };\n    };\n  };\n\n  // output/Data.Array/index.js\n  var $$void3 = /* @__PURE__ */ $$void(functorST);\n  var map6 = /* @__PURE__ */ map(functorMaybe);\n  var map22 = /* @__PURE__ */ map(functorST);\n  var fromJust3 = /* @__PURE__ */ fromJust();\n  var when2 = /* @__PURE__ */ when(applicativeST);\n  var foldMap12 = /* @__PURE__ */ foldMap(foldableArray);\n  var zipWith = /* @__PURE__ */ runFn3(zipWithImpl);\n  var updateAt = /* @__PURE__ */ function() {\n    return runFn5(_updateAt)(Just.create)(Nothing.value);\n  }();\n  var unsafeIndex = function() {\n    return runFn2(unsafeIndexImpl);\n  };\n  var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();\n  var snoc = function(xs) {\n    return function(x) {\n      return withArray(push(x))(xs)();\n    };\n  };\n  var singleton2 = function(a2) {\n    return [a2];\n  };\n  var range2 = /* @__PURE__ */ runFn2(rangeImpl);\n  var $$null = function(xs) {\n    return length(xs) === 0;\n  };\n  var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);\n  var index = /* @__PURE__ */ function() {\n    return runFn4(indexImpl)(Just.create)(Nothing.value);\n  }();\n  var modifyAt = function(i2) {\n    return function(f2) {\n      return function(xs) {\n        var go2 = function(x) {\n          return updateAt(i2)(f2(x))(xs);\n        };\n        return maybe(Nothing.value)(go2)(index(xs)(i2));\n      };\n    };\n  };\n  var fromFoldable = function(dictFoldable) {\n    return runFn2(fromFoldableImpl)(foldr(dictFoldable));\n  };\n  var foldr2 = /* @__PURE__ */ foldr(foldableArray);\n  var foldMap2 = function(dictMonoid) {\n    return foldMap12(dictMonoid);\n  };\n  var findIndex = /* @__PURE__ */ function() {\n    return runFn4(findIndexImpl)(Just.create)(Nothing.value);\n  }();\n  var find2 = function(f2) {\n    return function(xs) {\n      return map6(unsafeIndex1(xs))(findIndex(f2)(xs));\n    };\n  };\n  var filter = /* @__PURE__ */ runFn2(filterImpl);\n  var elemIndex = function(dictEq) {\n    var eq22 = eq(dictEq);\n    return function(x) {\n      return findIndex(function(v) {\n        return eq22(v)(x);\n      });\n    };\n  };\n  var notElem2 = function(dictEq) {\n    var elemIndex1 = elemIndex(dictEq);\n    return function(a2) {\n      return function(arr) {\n        return isNothing(elemIndex1(a2)(arr));\n      };\n    };\n  };\n  var elem2 = function(dictEq) {\n    var elemIndex1 = elemIndex(dictEq);\n    return function(a2) {\n      return function(arr) {\n        return isJust(elemIndex1(a2)(arr));\n      };\n    };\n  };\n  var deleteAt = /* @__PURE__ */ function() {\n    return runFn4(_deleteAt)(Just.create)(Nothing.value);\n  }();\n  var deleteBy = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v2.length === 0) {\n          return [];\n        }\n        ;\n        return maybe(v2)(function(i2) {\n          return fromJust3(deleteAt(i2)(v2));\n        })(findIndex(v(v1))(v2));\n      };\n    };\n  };\n  var concatMap = /* @__PURE__ */ flip(/* @__PURE__ */ bind(bindArray));\n  var mapMaybe = function(f2) {\n    return concatMap(function() {\n      var $189 = maybe([])(singleton2);\n      return function($190) {\n        return $189(f2($190));\n      };\n    }());\n  };\n  var any2 = /* @__PURE__ */ runFn2(anyImpl);\n  var nubByEq = function(eq22) {\n    return function(xs) {\n      return function __do2() {\n        var arr = newSTArray();\n        foreach(xs)(function(x) {\n          return function __do3() {\n            var e = map22(function() {\n              var $194 = any2(function(v) {\n                return eq22(v)(x);\n              });\n              return function($195) {\n                return !$194($195);\n              };\n            }())(unsafeFreeze(arr))();\n            return when2(e)($$void3(push(x)(arr)))();\n          };\n        })();\n        return unsafeFreeze(arr)();\n      }();\n    };\n  };\n  var all2 = /* @__PURE__ */ runFn2(allImpl);\n\n  // output/Data.Exists/index.js\n  var runExists = unsafeCoerce2;\n  var mkExists = unsafeCoerce2;\n\n  // output/Data.Coyoneda/index.js\n  var CoyonedaF = /* @__PURE__ */ function() {\n    function CoyonedaF2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    CoyonedaF2.create = function(value0) {\n      return function(value1) {\n        return new CoyonedaF2(value0, value1);\n      };\n    };\n    return CoyonedaF2;\n  }();\n  var unCoyoneda = function(f2) {\n    return function(v) {\n      return runExists(function(v1) {\n        return f2(v1.value0)(v1.value1);\n      })(v);\n    };\n  };\n  var coyoneda = function(k) {\n    return function(fi) {\n      return mkExists(new CoyonedaF(k, fi));\n    };\n  };\n  var functorCoyoneda = {\n    map: function(f2) {\n      return function(v) {\n        return runExists(function(v1) {\n          return coyoneda(function($180) {\n            return f2(v1.value0($180));\n          })(v1.value1);\n        })(v);\n      };\n    }\n  };\n  var liftCoyoneda = /* @__PURE__ */ coyoneda(/* @__PURE__ */ identity(categoryFn));\n\n  // output/Data.FoldableWithIndex/index.js\n  var foldr8 = /* @__PURE__ */ foldr(foldableArray);\n  var mapWithIndex3 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);\n  var foldl8 = /* @__PURE__ */ foldl(foldableArray);\n  var foldrWithIndex = function(dict) {\n    return dict.foldrWithIndex;\n  };\n  var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {\n    var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);\n    return function(dictMonoid) {\n      var append7 = append(dictMonoid.Semigroup0());\n      var mempty2 = mempty(dictMonoid);\n      return function(f2) {\n        return foldrWithIndex1(function(i2) {\n          return function(x) {\n            return function(acc) {\n              return append7(f2(i2)(x))(acc);\n            };\n          };\n        })(mempty2);\n      };\n    };\n  };\n  var foldableWithIndexArray = {\n    foldrWithIndex: function(f2) {\n      return function(z) {\n        var $291 = foldr8(function(v) {\n          return function(y) {\n            return f2(v.value0)(v.value1)(y);\n          };\n        })(z);\n        var $292 = mapWithIndex3(Tuple.create);\n        return function($293) {\n          return $291($292($293));\n        };\n      };\n    },\n    foldlWithIndex: function(f2) {\n      return function(z) {\n        var $294 = foldl8(function(y) {\n          return function(v) {\n            return f2(v.value0)(y)(v.value1);\n          };\n        })(z);\n        var $295 = mapWithIndex3(Tuple.create);\n        return function($296) {\n          return $294($295($296));\n        };\n      };\n    },\n    foldMapWithIndex: function(dictMonoid) {\n      return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);\n    },\n    Foldable0: function() {\n      return foldableArray;\n    }\n  };\n\n  // output/Data.TraversableWithIndex/index.js\n  var traverseWithIndexDefault = function(dictTraversableWithIndex) {\n    var sequence2 = sequence(dictTraversableWithIndex.Traversable2());\n    var mapWithIndex4 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());\n    return function(dictApplicative) {\n      var sequence12 = sequence2(dictApplicative);\n      return function(f2) {\n        var $174 = mapWithIndex4(f2);\n        return function($175) {\n          return sequence12($174($175));\n        };\n      };\n    };\n  };\n  var traverseWithIndex = function(dict) {\n    return dict.traverseWithIndex;\n  };\n  var traversableWithIndexArray = {\n    traverseWithIndex: function(dictApplicative) {\n      return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);\n    },\n    FunctorWithIndex0: function() {\n      return functorWithIndexArray;\n    },\n    FoldableWithIndex1: function() {\n      return foldableWithIndexArray;\n    },\n    Traversable2: function() {\n      return traversableArray;\n    }\n  };\n\n  // output/Data.NonEmpty/index.js\n  var NonEmpty = /* @__PURE__ */ function() {\n    function NonEmpty2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    NonEmpty2.create = function(value0) {\n      return function(value1) {\n        return new NonEmpty2(value0, value1);\n      };\n    };\n    return NonEmpty2;\n  }();\n  var singleton3 = function(dictPlus) {\n    var empty8 = empty(dictPlus);\n    return function(a2) {\n      return new NonEmpty(a2, empty8);\n    };\n  };\n  var foldableNonEmpty = function(dictFoldable) {\n    var foldMap4 = foldMap(dictFoldable);\n    var foldl2 = foldl(dictFoldable);\n    var foldr5 = foldr(dictFoldable);\n    return {\n      foldMap: function(dictMonoid) {\n        var append13 = append(dictMonoid.Semigroup0());\n        var foldMap13 = foldMap4(dictMonoid);\n        return function(f2) {\n          return function(v) {\n            return append13(f2(v.value0))(foldMap13(f2)(v.value1));\n          };\n        };\n      },\n      foldl: function(f2) {\n        return function(b2) {\n          return function(v) {\n            return foldl2(f2)(f2(b2)(v.value0))(v.value1);\n          };\n        };\n      },\n      foldr: function(f2) {\n        return function(b2) {\n          return function(v) {\n            return f2(v.value0)(foldr5(f2)(b2)(v.value1));\n          };\n        };\n      }\n    };\n  };\n  var foldable1NonEmpty = function(dictFoldable) {\n    var foldl2 = foldl(dictFoldable);\n    var foldr5 = foldr(dictFoldable);\n    var foldableNonEmpty1 = foldableNonEmpty(dictFoldable);\n    return {\n      foldMap1: function(dictSemigroup) {\n        var append13 = append(dictSemigroup);\n        return function(f2) {\n          return function(v) {\n            return foldl2(function(s) {\n              return function(a1) {\n                return append13(s)(f2(a1));\n              };\n            })(f2(v.value0))(v.value1);\n          };\n        };\n      },\n      foldr1: function(f2) {\n        return function(v) {\n          return maybe(v.value0)(f2(v.value0))(foldr5(function(a1) {\n            var $250 = maybe(a1)(f2(a1));\n            return function($251) {\n              return Just.create($250($251));\n            };\n          })(Nothing.value)(v.value1));\n        };\n      },\n      foldl1: function(f2) {\n        return function(v) {\n          return foldl2(f2)(v.value0)(v.value1);\n        };\n      },\n      Foldable0: function() {\n        return foldableNonEmpty1;\n      }\n    };\n  };\n\n  // output/Data.List.Types/index.js\n  var Nil = /* @__PURE__ */ function() {\n    function Nil2() {\n    }\n    ;\n    Nil2.value = new Nil2();\n    return Nil2;\n  }();\n  var Cons = /* @__PURE__ */ function() {\n    function Cons2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Cons2.create = function(value0) {\n      return function(value1) {\n        return new Cons2(value0, value1);\n      };\n    };\n    return Cons2;\n  }();\n  var NonEmptyList = function(x) {\n    return x;\n  };\n  var listMap = function(f2) {\n    var chunkedRevMap = function($copy_v) {\n      return function($copy_v1) {\n        var $tco_var_v = $copy_v;\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v, v1) {\n          if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Cons)) {\n            $tco_var_v = new Cons(v1, v);\n            $copy_v1 = v1.value1.value1.value1;\n            return;\n          }\n          ;\n          var unrolledMap = function(v2) {\n            if (v2 instanceof Cons && (v2.value1 instanceof Cons && v2.value1.value1 instanceof Nil)) {\n              return new Cons(f2(v2.value0), new Cons(f2(v2.value1.value0), Nil.value));\n            }\n            ;\n            if (v2 instanceof Cons && v2.value1 instanceof Nil) {\n              return new Cons(f2(v2.value0), Nil.value);\n            }\n            ;\n            return Nil.value;\n          };\n          var reverseUnrolledMap = function($copy_v2) {\n            return function($copy_v3) {\n              var $tco_var_v2 = $copy_v2;\n              var $tco_done1 = false;\n              var $tco_result2;\n              function $tco_loop2(v2, v3) {\n                if (v2 instanceof Cons && (v2.value0 instanceof Cons && (v2.value0.value1 instanceof Cons && v2.value0.value1.value1 instanceof Cons))) {\n                  $tco_var_v2 = v2.value1;\n                  $copy_v3 = new Cons(f2(v2.value0.value0), new Cons(f2(v2.value0.value1.value0), new Cons(f2(v2.value0.value1.value1.value0), v3)));\n                  return;\n                }\n                ;\n                $tco_done1 = true;\n                return v3;\n              }\n              ;\n              while (!$tco_done1) {\n                $tco_result2 = $tco_loop2($tco_var_v2, $copy_v3);\n              }\n              ;\n              return $tco_result2;\n            };\n          };\n          $tco_done = true;\n          return reverseUnrolledMap(v)(unrolledMap(v1));\n        }\n        ;\n        while (!$tco_done) {\n          $tco_result = $tco_loop($tco_var_v, $copy_v1);\n        }\n        ;\n        return $tco_result;\n      };\n    };\n    return chunkedRevMap(Nil.value);\n  };\n  var functorList = {\n    map: listMap\n  };\n  var foldableList = {\n    foldr: function(f2) {\n      return function(b2) {\n        var rev3 = function() {\n          var go2 = function($copy_v) {\n            return function($copy_v1) {\n              var $tco_var_v = $copy_v;\n              var $tco_done = false;\n              var $tco_result;\n              function $tco_loop(v, v1) {\n                if (v1 instanceof Nil) {\n                  $tco_done = true;\n                  return v;\n                }\n                ;\n                if (v1 instanceof Cons) {\n                  $tco_var_v = new Cons(v1.value0, v);\n                  $copy_v1 = v1.value1;\n                  return;\n                }\n                ;\n                throw new Error(\"Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): \" + [v.constructor.name, v1.constructor.name]);\n              }\n              ;\n              while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $copy_v1);\n              }\n              ;\n              return $tco_result;\n            };\n          };\n          return go2(Nil.value);\n        }();\n        var $284 = foldl(foldableList)(flip(f2))(b2);\n        return function($285) {\n          return $284(rev3($285));\n        };\n      };\n    },\n    foldl: function(f2) {\n      var go2 = function($copy_b) {\n        return function($copy_v) {\n          var $tco_var_b = $copy_b;\n          var $tco_done1 = false;\n          var $tco_result;\n          function $tco_loop(b2, v) {\n            if (v instanceof Nil) {\n              $tco_done1 = true;\n              return b2;\n            }\n            ;\n            if (v instanceof Cons) {\n              $tco_var_b = f2(b2)(v.value0);\n              $copy_v = v.value1;\n              return;\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): \" + [v.constructor.name]);\n          }\n          ;\n          while (!$tco_done1) {\n            $tco_result = $tco_loop($tco_var_b, $copy_v);\n          }\n          ;\n          return $tco_result;\n        };\n      };\n      return go2;\n    },\n    foldMap: function(dictMonoid) {\n      var append22 = append(dictMonoid.Semigroup0());\n      var mempty2 = mempty(dictMonoid);\n      return function(f2) {\n        return foldl(foldableList)(function(acc) {\n          var $286 = append22(acc);\n          return function($287) {\n            return $286(f2($287));\n          };\n        })(mempty2);\n      };\n    }\n  };\n  var foldr3 = /* @__PURE__ */ foldr(foldableList);\n  var semigroupList = {\n    append: function(xs) {\n      return function(ys) {\n        return foldr3(Cons.create)(ys)(xs);\n      };\n    }\n  };\n  var append1 = /* @__PURE__ */ append(semigroupList);\n  var foldable1NonEmptyList = /* @__PURE__ */ foldable1NonEmpty(foldableList);\n  var altList = {\n    alt: append1,\n    Functor0: function() {\n      return functorList;\n    }\n  };\n  var plusList = /* @__PURE__ */ function() {\n    return {\n      empty: Nil.value,\n      Alt0: function() {\n        return altList;\n      }\n    };\n  }();\n\n  // output/Data.Map.Internal/index.js\n  var $runtime_lazy3 = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var map7 = /* @__PURE__ */ map(functorMaybe);\n  var identity8 = /* @__PURE__ */ identity(categoryFn);\n  var Leaf = /* @__PURE__ */ function() {\n    function Leaf2() {\n    }\n    ;\n    Leaf2.value = new Leaf2();\n    return Leaf2;\n  }();\n  var Node = /* @__PURE__ */ function() {\n    function Node2(value0, value1, value22, value32, value42, value52) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n      this.value3 = value32;\n      this.value4 = value42;\n      this.value5 = value52;\n    }\n    ;\n    Node2.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return function(value32) {\n            return function(value42) {\n              return function(value52) {\n                return new Node2(value0, value1, value22, value32, value42, value52);\n              };\n            };\n          };\n        };\n      };\n    };\n    return Node2;\n  }();\n  var Split = /* @__PURE__ */ function() {\n    function Split2(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    Split2.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new Split2(value0, value1, value22);\n        };\n      };\n    };\n    return Split2;\n  }();\n  var SplitLast = /* @__PURE__ */ function() {\n    function SplitLast2(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    SplitLast2.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new SplitLast2(value0, value1, value22);\n        };\n      };\n    };\n    return SplitLast2;\n  }();\n  var unsafeNode = function(k, v, l, r) {\n    if (l instanceof Leaf) {\n      if (r instanceof Leaf) {\n        return new Node(1, 1, k, v, l, r);\n      }\n      ;\n      if (r instanceof Node) {\n        return new Node(1 + r.value0 | 0, 1 + r.value1 | 0, k, v, l, r);\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Map.Internal (line 680, column 5 - line 684, column 39): \" + [r.constructor.name]);\n    }\n    ;\n    if (l instanceof Node) {\n      if (r instanceof Leaf) {\n        return new Node(1 + l.value0 | 0, 1 + l.value1 | 0, k, v, l, r);\n      }\n      ;\n      if (r instanceof Node) {\n        return new Node(1 + function() {\n          var $277 = l.value0 > r.value0;\n          if ($277) {\n            return l.value0;\n          }\n          ;\n          return r.value0;\n        }() | 0, (1 + l.value1 | 0) + r.value1 | 0, k, v, l, r);\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Map.Internal (line 686, column 5 - line 690, column 68): \" + [r.constructor.name]);\n    }\n    ;\n    throw new Error(\"Failed pattern match at Data.Map.Internal (line 678, column 32 - line 690, column 68): \" + [l.constructor.name]);\n  };\n  var singleton4 = function(k) {\n    return function(v) {\n      return new Node(1, 1, k, v, Leaf.value, Leaf.value);\n    };\n  };\n  var unsafeBalancedNode = /* @__PURE__ */ function() {\n    var height8 = function(v) {\n      if (v instanceof Leaf) {\n        return 0;\n      }\n      ;\n      if (v instanceof Node) {\n        return v.value0;\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Map.Internal (line 735, column 12 - line 737, column 26): \" + [v.constructor.name]);\n    };\n    var rotateLeft = function(k, v, l, rk, rv, rl, rr) {\n      if (rl instanceof Node && rl.value0 > height8(rr)) {\n        return unsafeNode(rl.value2, rl.value3, unsafeNode(k, v, l, rl.value4), unsafeNode(rk, rv, rl.value5, rr));\n      }\n      ;\n      return unsafeNode(rk, rv, unsafeNode(k, v, l, rl), rr);\n    };\n    var rotateRight = function(k, v, lk, lv, ll, lr, r) {\n      if (lr instanceof Node && height8(ll) <= lr.value0) {\n        return unsafeNode(lr.value2, lr.value3, unsafeNode(lk, lv, ll, lr.value4), unsafeNode(k, v, lr.value5, r));\n      }\n      ;\n      return unsafeNode(lk, lv, ll, unsafeNode(k, v, lr, r));\n    };\n    return function(k, v, l, r) {\n      if (l instanceof Leaf) {\n        if (r instanceof Leaf) {\n          return singleton4(k)(v);\n        }\n        ;\n        if (r instanceof Node && r.value0 > 1) {\n          return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);\n        }\n        ;\n        return unsafeNode(k, v, l, r);\n      }\n      ;\n      if (l instanceof Node) {\n        if (r instanceof Node) {\n          if (r.value0 > (l.value0 + 1 | 0)) {\n            return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);\n          }\n          ;\n          if (l.value0 > (r.value0 + 1 | 0)) {\n            return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);\n          }\n          ;\n        }\n        ;\n        if (r instanceof Leaf && l.value0 > 1) {\n          return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);\n        }\n        ;\n        return unsafeNode(k, v, l, r);\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Map.Internal (line 695, column 40 - line 716, column 34): \" + [l.constructor.name]);\n    };\n  }();\n  var $lazy_unsafeSplit = /* @__PURE__ */ $runtime_lazy3(\"unsafeSplit\", \"Data.Map.Internal\", function() {\n    return function(comp, k, m) {\n      if (m instanceof Leaf) {\n        return new Split(Nothing.value, Leaf.value, Leaf.value);\n      }\n      ;\n      if (m instanceof Node) {\n        var v = comp(k)(m.value2);\n        if (v instanceof LT) {\n          var v1 = $lazy_unsafeSplit(771)(comp, k, m.value4);\n          return new Split(v1.value0, v1.value1, unsafeBalancedNode(m.value2, m.value3, v1.value2, m.value5));\n        }\n        ;\n        if (v instanceof GT) {\n          var v1 = $lazy_unsafeSplit(774)(comp, k, m.value5);\n          return new Split(v1.value0, unsafeBalancedNode(m.value2, m.value3, m.value4, v1.value1), v1.value2);\n        }\n        ;\n        if (v instanceof EQ) {\n          return new Split(new Just(m.value3), m.value4, m.value5);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Map.Internal (line 769, column 5 - line 777, column 30): \" + [v.constructor.name]);\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Map.Internal (line 765, column 34 - line 777, column 30): \" + [m.constructor.name]);\n    };\n  });\n  var unsafeSplit = /* @__PURE__ */ $lazy_unsafeSplit(764);\n  var $lazy_unsafeSplitLast = /* @__PURE__ */ $runtime_lazy3(\"unsafeSplitLast\", \"Data.Map.Internal\", function() {\n    return function(k, v, l, r) {\n      if (r instanceof Leaf) {\n        return new SplitLast(k, v, l);\n      }\n      ;\n      if (r instanceof Node) {\n        var v1 = $lazy_unsafeSplitLast(757)(r.value2, r.value3, r.value4, r.value5);\n        return new SplitLast(v1.value0, v1.value1, unsafeBalancedNode(k, v, l, v1.value2));\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Map.Internal (line 754, column 37 - line 758, column 57): \" + [r.constructor.name]);\n    };\n  });\n  var unsafeSplitLast = /* @__PURE__ */ $lazy_unsafeSplitLast(753);\n  var unsafeJoinNodes = function(v, v1) {\n    if (v instanceof Leaf) {\n      return v1;\n    }\n    ;\n    if (v instanceof Node) {\n      var v2 = unsafeSplitLast(v.value2, v.value3, v.value4, v.value5);\n      return unsafeBalancedNode(v2.value0, v2.value1, v2.value2, v1);\n    }\n    ;\n    throw new Error(\"Failed pattern match at Data.Map.Internal (line 742, column 25 - line 746, column 38): \" + [v.constructor.name, v1.constructor.name]);\n  };\n  var $lazy_unsafeUnionWith = /* @__PURE__ */ $runtime_lazy3(\"unsafeUnionWith\", \"Data.Map.Internal\", function() {\n    return function(comp, app, l, r) {\n      if (l instanceof Leaf) {\n        return r;\n      }\n      ;\n      if (r instanceof Leaf) {\n        return l;\n      }\n      ;\n      if (r instanceof Node) {\n        var v = unsafeSplit(comp, r.value2, l);\n        var l$prime = $lazy_unsafeUnionWith(787)(comp, app, v.value1, r.value4);\n        var r$prime = $lazy_unsafeUnionWith(788)(comp, app, v.value2, r.value5);\n        if (v.value0 instanceof Just) {\n          return unsafeBalancedNode(r.value2, app(v.value0.value0)(r.value3), l$prime, r$prime);\n        }\n        ;\n        if (v.value0 instanceof Nothing) {\n          return unsafeBalancedNode(r.value2, r.value3, l$prime, r$prime);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Map.Internal (line 789, column 5 - line 793, column 46): \" + [v.value0.constructor.name]);\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Map.Internal (line 782, column 42 - line 793, column 46): \" + [l.constructor.name, r.constructor.name]);\n    };\n  });\n  var unsafeUnionWith = /* @__PURE__ */ $lazy_unsafeUnionWith(781);\n  var unionWith = function(dictOrd) {\n    var compare4 = compare(dictOrd);\n    return function(app) {\n      return function(m1) {\n        return function(m2) {\n          return unsafeUnionWith(compare4, app, m1, m2);\n        };\n      };\n    };\n  };\n  var union = function(dictOrd) {\n    return unionWith(dictOrd)($$const);\n  };\n  var pop = function(dictOrd) {\n    var compare4 = compare(dictOrd);\n    return function(k) {\n      return function(m) {\n        var v = unsafeSplit(compare4, k, m);\n        return map7(function(a2) {\n          return new Tuple(a2, unsafeJoinNodes(v.value1, v.value2));\n        })(v.value0);\n      };\n    };\n  };\n  var lookup = function(dictOrd) {\n    var compare4 = compare(dictOrd);\n    return function(k) {\n      var go2 = function($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n          if (v instanceof Leaf) {\n            $tco_done = true;\n            return Nothing.value;\n          }\n          ;\n          if (v instanceof Node) {\n            var v1 = compare4(k)(v.value2);\n            if (v1 instanceof LT) {\n              $copy_v = v.value4;\n              return;\n            }\n            ;\n            if (v1 instanceof GT) {\n              $copy_v = v.value5;\n              return;\n            }\n            ;\n            if (v1 instanceof EQ) {\n              $tco_done = true;\n              return new Just(v.value3);\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 281, column 7 - line 284, column 22): \" + [v1.constructor.name]);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 278, column 8 - line 284, column 22): \" + [v.constructor.name]);\n        }\n        ;\n        while (!$tco_done) {\n          $tco_result = $tco_loop($copy_v);\n        }\n        ;\n        return $tco_result;\n      };\n      return go2;\n    };\n  };\n  var insert = function(dictOrd) {\n    var compare4 = compare(dictOrd);\n    return function(k) {\n      return function(v) {\n        var go2 = function(v1) {\n          if (v1 instanceof Leaf) {\n            return singleton4(k)(v);\n          }\n          ;\n          if (v1 instanceof Node) {\n            var v2 = compare4(k)(v1.value2);\n            if (v2 instanceof LT) {\n              return unsafeBalancedNode(v1.value2, v1.value3, go2(v1.value4), v1.value5);\n            }\n            ;\n            if (v2 instanceof GT) {\n              return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go2(v1.value5));\n            }\n            ;\n            if (v2 instanceof EQ) {\n              return new Node(v1.value0, v1.value1, k, v, v1.value4, v1.value5);\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 469, column 7 - line 472, column 35): \" + [v2.constructor.name]);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 466, column 8 - line 472, column 35): \" + [v1.constructor.name]);\n        };\n        return go2;\n      };\n    };\n  };\n  var functorMap = {\n    map: function(f2) {\n      var go2 = function(v) {\n        if (v instanceof Leaf) {\n          return Leaf.value;\n        }\n        ;\n        if (v instanceof Node) {\n          return new Node(v.value0, v.value1, v.value2, f2(v.value3), go2(v.value4), go2(v.value5));\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Map.Internal (line 145, column 10 - line 148, column 39): \" + [v.constructor.name]);\n      };\n      return go2;\n    }\n  };\n  var foldableMap = {\n    foldr: function(f2) {\n      return function(z) {\n        var $lazy_go = $runtime_lazy3(\"go\", \"Data.Map.Internal\", function() {\n          return function(m$prime, z$prime) {\n            if (m$prime instanceof Leaf) {\n              return z$prime;\n            }\n            ;\n            if (m$prime instanceof Node) {\n              return $lazy_go(170)(m$prime.value4, f2(m$prime.value3)($lazy_go(170)(m$prime.value5, z$prime)));\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 167, column 26 - line 170, column 43): \" + [m$prime.constructor.name]);\n          };\n        });\n        var go2 = $lazy_go(167);\n        return function(m) {\n          return go2(m, z);\n        };\n      };\n    },\n    foldl: function(f2) {\n      return function(z) {\n        var $lazy_go = $runtime_lazy3(\"go\", \"Data.Map.Internal\", function() {\n          return function(z$prime, m$prime) {\n            if (m$prime instanceof Leaf) {\n              return z$prime;\n            }\n            ;\n            if (m$prime instanceof Node) {\n              return $lazy_go(176)(f2($lazy_go(176)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 173, column 26 - line 176, column 43): \" + [m$prime.constructor.name]);\n          };\n        });\n        var go2 = $lazy_go(173);\n        return function(m) {\n          return go2(z, m);\n        };\n      };\n    },\n    foldMap: function(dictMonoid) {\n      var mempty2 = mempty(dictMonoid);\n      var append13 = append(dictMonoid.Semigroup0());\n      return function(f2) {\n        var go2 = function(v) {\n          if (v instanceof Leaf) {\n            return mempty2;\n          }\n          ;\n          if (v instanceof Node) {\n            return append13(go2(v.value4))(append13(f2(v.value3))(go2(v.value5)));\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 179, column 10 - line 182, column 28): \" + [v.constructor.name]);\n        };\n        return go2;\n      };\n    }\n  };\n  var foldableWithIndexMap = {\n    foldrWithIndex: function(f2) {\n      return function(z) {\n        var $lazy_go = $runtime_lazy3(\"go\", \"Data.Map.Internal\", function() {\n          return function(m$prime, z$prime) {\n            if (m$prime instanceof Leaf) {\n              return z$prime;\n            }\n            ;\n            if (m$prime instanceof Node) {\n              return $lazy_go(190)(m$prime.value4, f2(m$prime.value2)(m$prime.value3)($lazy_go(190)(m$prime.value5, z$prime)));\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 187, column 26 - line 190, column 45): \" + [m$prime.constructor.name]);\n          };\n        });\n        var go2 = $lazy_go(187);\n        return function(m) {\n          return go2(m, z);\n        };\n      };\n    },\n    foldlWithIndex: function(f2) {\n      return function(z) {\n        var $lazy_go = $runtime_lazy3(\"go\", \"Data.Map.Internal\", function() {\n          return function(z$prime, m$prime) {\n            if (m$prime instanceof Leaf) {\n              return z$prime;\n            }\n            ;\n            if (m$prime instanceof Node) {\n              return $lazy_go(196)(f2(m$prime.value2)($lazy_go(196)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);\n            }\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 193, column 26 - line 196, column 45): \" + [m$prime.constructor.name]);\n          };\n        });\n        var go2 = $lazy_go(193);\n        return function(m) {\n          return go2(z, m);\n        };\n      };\n    },\n    foldMapWithIndex: function(dictMonoid) {\n      var mempty2 = mempty(dictMonoid);\n      var append13 = append(dictMonoid.Semigroup0());\n      return function(f2) {\n        var go2 = function(v) {\n          if (v instanceof Leaf) {\n            return mempty2;\n          }\n          ;\n          if (v instanceof Node) {\n            return append13(go2(v.value4))(append13(f2(v.value2)(v.value3))(go2(v.value5)));\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 199, column 10 - line 202, column 30): \" + [v.constructor.name]);\n        };\n        return go2;\n      };\n    },\n    Foldable0: function() {\n      return foldableMap;\n    }\n  };\n  var traversableMap = {\n    traverse: function(dictApplicative) {\n      var pure18 = pure(dictApplicative);\n      var Apply0 = dictApplicative.Apply0();\n      var apply4 = apply(Apply0);\n      var map112 = map(Apply0.Functor0());\n      return function(f2) {\n        var go2 = function(v) {\n          if (v instanceof Leaf) {\n            return pure18(Leaf.value);\n          }\n          ;\n          if (v instanceof Node) {\n            return apply4(apply4(map112(function(l$prime) {\n              return function(v$prime) {\n                return function(r$prime) {\n                  return new Node(v.value0, v.value1, v.value2, v$prime, l$prime, r$prime);\n                };\n              };\n            })(go2(v.value4)))(f2(v.value3)))(go2(v.value5));\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 207, column 10 - line 213, column 19): \" + [v.constructor.name]);\n        };\n        return go2;\n      };\n    },\n    sequence: function(dictApplicative) {\n      return traverse(traversableMap)(dictApplicative)(identity8);\n    },\n    Functor0: function() {\n      return functorMap;\n    },\n    Foldable1: function() {\n      return foldableMap;\n    }\n  };\n  var values = /* @__PURE__ */ function() {\n    return foldr(foldableMap)(Cons.create)(Nil.value);\n  }();\n  var foldSubmapBy = function(dictOrd) {\n    var lessThan1 = lessThan(dictOrd);\n    var greaterThan1 = greaterThan(dictOrd);\n    var lessThanOrEq1 = lessThanOrEq(dictOrd);\n    return function(appendFn) {\n      return function(memptyValue) {\n        return function(kmin) {\n          return function(kmax) {\n            return function(f2) {\n              var tooSmall = function() {\n                if (kmin instanceof Just) {\n                  return function(k) {\n                    return lessThan1(k)(kmin.value0);\n                  };\n                }\n                ;\n                if (kmin instanceof Nothing) {\n                  return $$const(false);\n                }\n                ;\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 387, column 7 - line 391, column 22): \" + [kmin.constructor.name]);\n              }();\n              var tooLarge = function() {\n                if (kmax instanceof Just) {\n                  return function(k) {\n                    return greaterThan1(k)(kmax.value0);\n                  };\n                }\n                ;\n                if (kmax instanceof Nothing) {\n                  return $$const(false);\n                }\n                ;\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 394, column 7 - line 398, column 22): \" + [kmax.constructor.name]);\n              }();\n              var inBounds = function() {\n                if (kmin instanceof Just && kmax instanceof Just) {\n                  return function(k) {\n                    return lessThanOrEq1(kmin.value0)(k) && lessThanOrEq1(k)(kmax.value0);\n                  };\n                }\n                ;\n                if (kmin instanceof Just && kmax instanceof Nothing) {\n                  return function(k) {\n                    return lessThanOrEq1(kmin.value0)(k);\n                  };\n                }\n                ;\n                if (kmin instanceof Nothing && kmax instanceof Just) {\n                  return function(k) {\n                    return lessThanOrEq1(k)(kmax.value0);\n                  };\n                }\n                ;\n                if (kmin instanceof Nothing && kmax instanceof Nothing) {\n                  return $$const(true);\n                }\n                ;\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 401, column 7 - line 409, column 21): \" + [kmin.constructor.name, kmax.constructor.name]);\n              }();\n              var go2 = function(v) {\n                if (v instanceof Leaf) {\n                  return memptyValue;\n                }\n                ;\n                if (v instanceof Node) {\n                  return appendFn(appendFn(function() {\n                    var $640 = tooSmall(v.value2);\n                    if ($640) {\n                      return memptyValue;\n                    }\n                    ;\n                    return go2(v.value4);\n                  }())(function() {\n                    var $641 = inBounds(v.value2);\n                    if ($641) {\n                      return f2(v.value2)(v.value3);\n                    }\n                    ;\n                    return memptyValue;\n                  }()))(function() {\n                    var $642 = tooLarge(v.value2);\n                    if ($642) {\n                      return memptyValue;\n                    }\n                    ;\n                    return go2(v.value5);\n                  }());\n                }\n                ;\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 411, column 10 - line 417, column 66): \" + [v.constructor.name]);\n              };\n              return go2;\n            };\n          };\n        };\n      };\n    };\n  };\n  var foldSubmap = function(dictOrd) {\n    var foldSubmapBy1 = foldSubmapBy(dictOrd);\n    return function(dictMonoid) {\n      return foldSubmapBy1(append(dictMonoid.Semigroup0()))(mempty(dictMonoid));\n    };\n  };\n  var filterKeys = function(dictOrd) {\n    return function(f2) {\n      var go2 = function(v) {\n        if (v instanceof Leaf) {\n          return Leaf.value;\n        }\n        ;\n        if (v instanceof Node) {\n          if (f2(v.value2)) {\n            return unsafeBalancedNode(v.value2, v.value3, go2(v.value4), go2(v.value5));\n          }\n          ;\n          if (otherwise) {\n            return unsafeJoinNodes(go2(v.value4), go2(v.value5));\n          }\n          ;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Map.Internal (line 638, column 8 - line 644, column 47): \" + [v.constructor.name]);\n      };\n      return go2;\n    };\n  };\n  var empty2 = /* @__PURE__ */ function() {\n    return Leaf.value;\n  }();\n  var $$delete = function(dictOrd) {\n    var compare4 = compare(dictOrd);\n    return function(k) {\n      var go2 = function(v) {\n        if (v instanceof Leaf) {\n          return Leaf.value;\n        }\n        ;\n        if (v instanceof Node) {\n          var v1 = compare4(k)(v.value2);\n          if (v1 instanceof LT) {\n            return unsafeBalancedNode(v.value2, v.value3, go2(v.value4), v.value5);\n          }\n          ;\n          if (v1 instanceof GT) {\n            return unsafeBalancedNode(v.value2, v.value3, v.value4, go2(v.value5));\n          }\n          ;\n          if (v1 instanceof EQ) {\n            return unsafeJoinNodes(v.value4, v.value5);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 496, column 7 - line 499, column 43): \" + [v1.constructor.name]);\n        }\n        ;\n        throw new Error(\"Failed pattern match at Data.Map.Internal (line 493, column 8 - line 499, column 43): \" + [v.constructor.name]);\n      };\n      return go2;\n    };\n  };\n  var alter = function(dictOrd) {\n    var compare4 = compare(dictOrd);\n    return function(f2) {\n      return function(k) {\n        return function(m) {\n          var v = unsafeSplit(compare4, k, m);\n          var v2 = f2(v.value0);\n          if (v2 instanceof Nothing) {\n            return unsafeJoinNodes(v.value1, v.value2);\n          }\n          ;\n          if (v2 instanceof Just) {\n            return unsafeBalancedNode(k, v2.value0, v.value1, v.value2);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 512, column 3 - line 516, column 41): \" + [v2.constructor.name]);\n        };\n      };\n    };\n  };\n  var altMap = function(dictOrd) {\n    return {\n      alt: union(dictOrd),\n      Functor0: function() {\n        return functorMap;\n      }\n    };\n  };\n  var plusMap = function(dictOrd) {\n    var altMap1 = altMap(dictOrd);\n    return {\n      empty: empty2,\n      Alt0: function() {\n        return altMap1;\n      }\n    };\n  };\n\n  // output/Data.Monoid.Alternate/index.js\n  var Alternate = function(x) {\n    return x;\n  };\n  var semigroupAlternate = function(dictAlt) {\n    var alt5 = alt(dictAlt);\n    return {\n      append: function(v) {\n        return function(v1) {\n          return alt5(v)(v1);\n        };\n      }\n    };\n  };\n  var monoidAlternate = function(dictPlus) {\n    var semigroupAlternate1 = semigroupAlternate(dictPlus.Alt0());\n    return {\n      mempty: empty(dictPlus),\n      Semigroup0: function() {\n        return semigroupAlternate1;\n      }\n    };\n  };\n\n  // output/Halogen.Data.OrdBox/index.js\n  var OrdBox = /* @__PURE__ */ function() {\n    function OrdBox2(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    OrdBox2.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new OrdBox2(value0, value1, value22);\n        };\n      };\n    };\n    return OrdBox2;\n  }();\n  var unOrdBox = function(v) {\n    return v.value2;\n  };\n  var mkOrdBox = function(dictOrd) {\n    return OrdBox.create(eq(dictOrd.Eq0()))(compare(dictOrd));\n  };\n  var eqOrdBox = {\n    eq: function(v) {\n      return function(v1) {\n        return v.value0(v.value2)(v1.value2);\n      };\n    }\n  };\n  var ordOrdBox = {\n    compare: function(v) {\n      return function(v1) {\n        return v.value1(v.value2)(v1.value2);\n      };\n    },\n    Eq0: function() {\n      return eqOrdBox;\n    }\n  };\n\n  // output/Halogen.Data.Slot/index.js\n  var un2 = /* @__PURE__ */ un();\n  var ordTuple2 = /* @__PURE__ */ ordTuple(ordString)(ordOrdBox);\n  var foldSubmap2 = /* @__PURE__ */ foldSubmap(ordTuple2);\n  var pop1 = /* @__PURE__ */ pop(ordTuple2);\n  var lookup1 = /* @__PURE__ */ lookup(ordTuple2);\n  var insert1 = /* @__PURE__ */ insert(ordTuple2);\n  var slots = function() {\n    return function(dictIsSymbol) {\n      var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n      return function(dictOrd) {\n        var foldSubmap1 = foldSubmap2(monoidAlternate(plusMap(dictOrd)));\n        return function(sym) {\n          return function(v) {\n            var key = reflectSymbol2(sym);\n            var go2 = function(v1) {\n              return function(val) {\n                if (key === v1.value0) {\n                  return singleton4(unOrdBox(v1.value1))(val);\n                }\n                ;\n                if (otherwise) {\n                  return empty2;\n                }\n                ;\n                throw new Error(\"Failed pattern match at Halogen.Data.Slot (line 121, column 3 - line 123, column 38): \" + [v1.constructor.name, val.constructor.name]);\n              };\n            };\n            return un2(Alternate)(foldSubmap1(Nothing.value)(Nothing.value)(go2)(v));\n          };\n        };\n      };\n    };\n  };\n  var pop2 = function() {\n    return function(dictIsSymbol) {\n      var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n      return function(dictOrd) {\n        var mkOrdBox2 = mkOrdBox(dictOrd);\n        return function(sym) {\n          return function(key) {\n            return function(v) {\n              return pop1(new Tuple(reflectSymbol2(sym), mkOrdBox2(key)))(v);\n            };\n          };\n        };\n      };\n    };\n  };\n  var lookup2 = function() {\n    return function(dictIsSymbol) {\n      var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n      return function(dictOrd) {\n        var mkOrdBox2 = mkOrdBox(dictOrd);\n        return function(sym) {\n          return function(key) {\n            return function(v) {\n              return lookup1(new Tuple(reflectSymbol2(sym), mkOrdBox2(key)))(v);\n            };\n          };\n        };\n      };\n    };\n  };\n  var insert2 = function() {\n    return function(dictIsSymbol) {\n      var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n      return function(dictOrd) {\n        var mkOrdBox2 = mkOrdBox(dictOrd);\n        return function(sym) {\n          return function(key) {\n            return function(val) {\n              return function(v) {\n                return insert1(new Tuple(reflectSymbol2(sym), mkOrdBox2(key)))(val)(v);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  var foreachSlot = function(dictApplicative) {\n    var traverse_10 = traverse_(dictApplicative)(foldableMap);\n    return function(v) {\n      return function(k) {\n        return traverse_10(function($54) {\n          return k($54);\n        })(v);\n      };\n    };\n  };\n  var empty3 = empty2;\n\n  // output/Data.String.Common/foreign.js\n  var joinWith = function(s) {\n    return function(xs) {\n      return xs.join(s);\n    };\n  };\n\n  // output/Data.String.Common/index.js\n  var $$null2 = function(s) {\n    return s === \"\";\n  };\n\n  // output/DOM.HTML.Indexed.InputType/index.js\n  var InputButton = /* @__PURE__ */ function() {\n    function InputButton2() {\n    }\n    ;\n    InputButton2.value = new InputButton2();\n    return InputButton2;\n  }();\n  var InputCheckbox = /* @__PURE__ */ function() {\n    function InputCheckbox2() {\n    }\n    ;\n    InputCheckbox2.value = new InputCheckbox2();\n    return InputCheckbox2;\n  }();\n  var InputColor = /* @__PURE__ */ function() {\n    function InputColor2() {\n    }\n    ;\n    InputColor2.value = new InputColor2();\n    return InputColor2;\n  }();\n  var InputDate = /* @__PURE__ */ function() {\n    function InputDate2() {\n    }\n    ;\n    InputDate2.value = new InputDate2();\n    return InputDate2;\n  }();\n  var InputDatetimeLocal = /* @__PURE__ */ function() {\n    function InputDatetimeLocal2() {\n    }\n    ;\n    InputDatetimeLocal2.value = new InputDatetimeLocal2();\n    return InputDatetimeLocal2;\n  }();\n  var InputEmail = /* @__PURE__ */ function() {\n    function InputEmail2() {\n    }\n    ;\n    InputEmail2.value = new InputEmail2();\n    return InputEmail2;\n  }();\n  var InputFile = /* @__PURE__ */ function() {\n    function InputFile2() {\n    }\n    ;\n    InputFile2.value = new InputFile2();\n    return InputFile2;\n  }();\n  var InputHidden = /* @__PURE__ */ function() {\n    function InputHidden2() {\n    }\n    ;\n    InputHidden2.value = new InputHidden2();\n    return InputHidden2;\n  }();\n  var InputImage = /* @__PURE__ */ function() {\n    function InputImage2() {\n    }\n    ;\n    InputImage2.value = new InputImage2();\n    return InputImage2;\n  }();\n  var InputMonth = /* @__PURE__ */ function() {\n    function InputMonth2() {\n    }\n    ;\n    InputMonth2.value = new InputMonth2();\n    return InputMonth2;\n  }();\n  var InputNumber = /* @__PURE__ */ function() {\n    function InputNumber2() {\n    }\n    ;\n    InputNumber2.value = new InputNumber2();\n    return InputNumber2;\n  }();\n  var InputPassword = /* @__PURE__ */ function() {\n    function InputPassword2() {\n    }\n    ;\n    InputPassword2.value = new InputPassword2();\n    return InputPassword2;\n  }();\n  var InputRadio = /* @__PURE__ */ function() {\n    function InputRadio2() {\n    }\n    ;\n    InputRadio2.value = new InputRadio2();\n    return InputRadio2;\n  }();\n  var InputRange = /* @__PURE__ */ function() {\n    function InputRange2() {\n    }\n    ;\n    InputRange2.value = new InputRange2();\n    return InputRange2;\n  }();\n  var InputReset = /* @__PURE__ */ function() {\n    function InputReset2() {\n    }\n    ;\n    InputReset2.value = new InputReset2();\n    return InputReset2;\n  }();\n  var InputSearch = /* @__PURE__ */ function() {\n    function InputSearch2() {\n    }\n    ;\n    InputSearch2.value = new InputSearch2();\n    return InputSearch2;\n  }();\n  var InputSubmit = /* @__PURE__ */ function() {\n    function InputSubmit2() {\n    }\n    ;\n    InputSubmit2.value = new InputSubmit2();\n    return InputSubmit2;\n  }();\n  var InputTel = /* @__PURE__ */ function() {\n    function InputTel2() {\n    }\n    ;\n    InputTel2.value = new InputTel2();\n    return InputTel2;\n  }();\n  var InputText = /* @__PURE__ */ function() {\n    function InputText2() {\n    }\n    ;\n    InputText2.value = new InputText2();\n    return InputText2;\n  }();\n  var InputTime = /* @__PURE__ */ function() {\n    function InputTime2() {\n    }\n    ;\n    InputTime2.value = new InputTime2();\n    return InputTime2;\n  }();\n  var InputUrl = /* @__PURE__ */ function() {\n    function InputUrl2() {\n    }\n    ;\n    InputUrl2.value = new InputUrl2();\n    return InputUrl2;\n  }();\n  var InputWeek = /* @__PURE__ */ function() {\n    function InputWeek2() {\n    }\n    ;\n    InputWeek2.value = new InputWeek2();\n    return InputWeek2;\n  }();\n  var renderInputType = function(v) {\n    if (v instanceof InputButton) {\n      return \"button\";\n    }\n    ;\n    if (v instanceof InputCheckbox) {\n      return \"checkbox\";\n    }\n    ;\n    if (v instanceof InputColor) {\n      return \"color\";\n    }\n    ;\n    if (v instanceof InputDate) {\n      return \"date\";\n    }\n    ;\n    if (v instanceof InputDatetimeLocal) {\n      return \"datetime-local\";\n    }\n    ;\n    if (v instanceof InputEmail) {\n      return \"email\";\n    }\n    ;\n    if (v instanceof InputFile) {\n      return \"file\";\n    }\n    ;\n    if (v instanceof InputHidden) {\n      return \"hidden\";\n    }\n    ;\n    if (v instanceof InputImage) {\n      return \"image\";\n    }\n    ;\n    if (v instanceof InputMonth) {\n      return \"month\";\n    }\n    ;\n    if (v instanceof InputNumber) {\n      return \"number\";\n    }\n    ;\n    if (v instanceof InputPassword) {\n      return \"password\";\n    }\n    ;\n    if (v instanceof InputRadio) {\n      return \"radio\";\n    }\n    ;\n    if (v instanceof InputRange) {\n      return \"range\";\n    }\n    ;\n    if (v instanceof InputReset) {\n      return \"reset\";\n    }\n    ;\n    if (v instanceof InputSearch) {\n      return \"search\";\n    }\n    ;\n    if (v instanceof InputSubmit) {\n      return \"submit\";\n    }\n    ;\n    if (v instanceof InputTel) {\n      return \"tel\";\n    }\n    ;\n    if (v instanceof InputText) {\n      return \"text\";\n    }\n    ;\n    if (v instanceof InputTime) {\n      return \"time\";\n    }\n    ;\n    if (v instanceof InputUrl) {\n      return \"url\";\n    }\n    ;\n    if (v instanceof InputWeek) {\n      return \"week\";\n    }\n    ;\n    throw new Error(\"Failed pattern match at DOM.HTML.Indexed.InputType (line 33, column 19 - line 55, column 22): \" + [v.constructor.name]);\n  };\n\n  // output/DOM.HTML.Indexed.StepValue/index.js\n  var show2 = /* @__PURE__ */ show(showNumber);\n  var Any = /* @__PURE__ */ function() {\n    function Any2() {\n    }\n    ;\n    Any2.value = new Any2();\n    return Any2;\n  }();\n  var Step = /* @__PURE__ */ function() {\n    function Step3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Step3.create = function(value0) {\n      return new Step3(value0);\n    };\n    return Step3;\n  }();\n  var renderStepValue = function(v) {\n    if (v instanceof Any) {\n      return \"any\";\n    }\n    ;\n    if (v instanceof Step) {\n      return show2(v.value0);\n    }\n    ;\n    throw new Error(\"Failed pattern match at DOM.HTML.Indexed.StepValue (line 13, column 19 - line 15, column 19): \" + [v.constructor.name]);\n  };\n\n  // output/Halogen.Query.Input/index.js\n  var RefUpdate = /* @__PURE__ */ function() {\n    function RefUpdate2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    RefUpdate2.create = function(value0) {\n      return function(value1) {\n        return new RefUpdate2(value0, value1);\n      };\n    };\n    return RefUpdate2;\n  }();\n  var Action = /* @__PURE__ */ function() {\n    function Action3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Action3.create = function(value0) {\n      return new Action3(value0);\n    };\n    return Action3;\n  }();\n\n  // output/Data.Nullable/foreign.js\n  var nullImpl = null;\n  function nullable(a2, r, f2) {\n    return a2 == null ? r : f2(a2);\n  }\n  function notNull(x) {\n    return x;\n  }\n\n  // output/Data.Nullable/index.js\n  var toNullable = /* @__PURE__ */ maybe(nullImpl)(notNull);\n  var toMaybe = function(n) {\n    return nullable(n, Nothing.value, Just.create);\n  };\n\n  // output/Halogen.VDom.Machine/index.js\n  var Step2 = /* @__PURE__ */ function() {\n    function Step3(value0, value1, value22, value32) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n      this.value3 = value32;\n    }\n    ;\n    Step3.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return function(value32) {\n            return new Step3(value0, value1, value22, value32);\n          };\n        };\n      };\n    };\n    return Step3;\n  }();\n  var unStep = unsafeCoerce2;\n  var step = function(v, a2) {\n    return v.value2(v.value1, a2);\n  };\n  var mkStep = unsafeCoerce2;\n  var halt = function(v) {\n    return v.value3(v.value1);\n  };\n  var extract2 = /* @__PURE__ */ unStep(function(v) {\n    return v.value0;\n  });\n\n  // output/Halogen.VDom.Types/index.js\n  var map8 = /* @__PURE__ */ map(functorArray);\n  var map1 = /* @__PURE__ */ map(functorTuple);\n  var Text = /* @__PURE__ */ function() {\n    function Text2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Text2.create = function(value0) {\n      return new Text2(value0);\n    };\n    return Text2;\n  }();\n  var Elem = /* @__PURE__ */ function() {\n    function Elem2(value0, value1, value22, value32) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n      this.value3 = value32;\n    }\n    ;\n    Elem2.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return function(value32) {\n            return new Elem2(value0, value1, value22, value32);\n          };\n        };\n      };\n    };\n    return Elem2;\n  }();\n  var Keyed = /* @__PURE__ */ function() {\n    function Keyed2(value0, value1, value22, value32) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n      this.value3 = value32;\n    }\n    ;\n    Keyed2.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return function(value32) {\n            return new Keyed2(value0, value1, value22, value32);\n          };\n        };\n      };\n    };\n    return Keyed2;\n  }();\n  var Widget = /* @__PURE__ */ function() {\n    function Widget2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Widget2.create = function(value0) {\n      return new Widget2(value0);\n    };\n    return Widget2;\n  }();\n  var Grafted = /* @__PURE__ */ function() {\n    function Grafted2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Grafted2.create = function(value0) {\n      return new Grafted2(value0);\n    };\n    return Grafted2;\n  }();\n  var Graft = /* @__PURE__ */ function() {\n    function Graft2(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    Graft2.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new Graft2(value0, value1, value22);\n        };\n      };\n    };\n    return Graft2;\n  }();\n  var unGraft = function(f2) {\n    return function($61) {\n      return f2($61);\n    };\n  };\n  var graft = unsafeCoerce2;\n  var bifunctorGraft = {\n    bimap: function(f2) {\n      return function(g) {\n        return unGraft(function(v) {\n          return graft(new Graft(function($63) {\n            return f2(v.value0($63));\n          }, function($64) {\n            return g(v.value1($64));\n          }, v.value2));\n        });\n      };\n    }\n  };\n  var bimap2 = /* @__PURE__ */ bimap(bifunctorGraft);\n  var runGraft = /* @__PURE__ */ unGraft(function(v) {\n    var go2 = function(v2) {\n      if (v2 instanceof Text) {\n        return new Text(v2.value0);\n      }\n      ;\n      if (v2 instanceof Elem) {\n        return new Elem(v2.value0, v2.value1, v.value0(v2.value2), map8(go2)(v2.value3));\n      }\n      ;\n      if (v2 instanceof Keyed) {\n        return new Keyed(v2.value0, v2.value1, v.value0(v2.value2), map8(map1(go2))(v2.value3));\n      }\n      ;\n      if (v2 instanceof Widget) {\n        return new Widget(v.value1(v2.value0));\n      }\n      ;\n      if (v2 instanceof Grafted) {\n        return new Grafted(bimap2(v.value0)(v.value1)(v2.value0));\n      }\n      ;\n      throw new Error(\"Failed pattern match at Halogen.VDom.Types (line 86, column 7 - line 86, column 27): \" + [v2.constructor.name]);\n    };\n    return go2(v.value2);\n  });\n\n  // output/Halogen.VDom.Util/foreign.js\n  function unsafeGetAny(key, obj) {\n    return obj[key];\n  }\n  function unsafeHasAny(key, obj) {\n    return obj.hasOwnProperty(key);\n  }\n  function unsafeSetAny(key, val, obj) {\n    obj[key] = val;\n  }\n  function forE2(a2, f2) {\n    var b2 = [];\n    for (var i2 = 0; i2 < a2.length; i2++) {\n      b2.push(f2(i2, a2[i2]));\n    }\n    return b2;\n  }\n  function forEachE(a2, f2) {\n    for (var i2 = 0; i2 < a2.length; i2++) {\n      f2(a2[i2]);\n    }\n  }\n  function forInE(o, f2) {\n    var ks = Object.keys(o);\n    for (var i2 = 0; i2 < ks.length; i2++) {\n      var k = ks[i2];\n      f2(k, o[k]);\n    }\n  }\n  function diffWithIxE(a1, a2, f1, f2, f3) {\n    var a3 = [];\n    var l1 = a1.length;\n    var l2 = a2.length;\n    var i2 = 0;\n    while (1) {\n      if (i2 < l1) {\n        if (i2 < l2) {\n          a3.push(f1(i2, a1[i2], a2[i2]));\n        } else {\n          f2(i2, a1[i2]);\n        }\n      } else if (i2 < l2) {\n        a3.push(f3(i2, a2[i2]));\n      } else {\n        break;\n      }\n      i2++;\n    }\n    return a3;\n  }\n  function strMapWithIxE(as, fk, f2) {\n    var o = {};\n    for (var i2 = 0; i2 < as.length; i2++) {\n      var a2 = as[i2];\n      var k = fk(a2);\n      o[k] = f2(k, i2, a2);\n    }\n    return o;\n  }\n  function diffWithKeyAndIxE(o1, as, fk, f1, f2, f3) {\n    var o2 = {};\n    for (var i2 = 0; i2 < as.length; i2++) {\n      var a2 = as[i2];\n      var k = fk(a2);\n      if (o1.hasOwnProperty(k)) {\n        o2[k] = f1(k, i2, o1[k], a2);\n      } else {\n        o2[k] = f3(k, i2, a2);\n      }\n    }\n    for (var k in o1) {\n      if (k in o2) {\n        continue;\n      }\n      f2(k, o1[k]);\n    }\n    return o2;\n  }\n  function refEq2(a2, b2) {\n    return a2 === b2;\n  }\n  function createTextNode(s, doc) {\n    return doc.createTextNode(s);\n  }\n  function setTextContent(s, n) {\n    n.textContent = s;\n  }\n  function createElement(ns, name15, doc) {\n    if (ns != null) {\n      return doc.createElementNS(ns, name15);\n    } else {\n      return doc.createElement(name15);\n    }\n  }\n  function insertChildIx(i2, a2, b2) {\n    var n = b2.childNodes.item(i2) || null;\n    if (n !== a2) {\n      b2.insertBefore(a2, n);\n    }\n  }\n  function removeChild(a2, b2) {\n    if (b2 && a2.parentNode === b2) {\n      b2.removeChild(a2);\n    }\n  }\n  function parentNode(a2) {\n    return a2.parentNode;\n  }\n  function setAttribute(ns, attr3, val, el) {\n    if (ns != null) {\n      el.setAttributeNS(ns, attr3, val);\n    } else {\n      el.setAttribute(attr3, val);\n    }\n  }\n  function removeAttribute(ns, attr3, el) {\n    if (ns != null) {\n      el.removeAttributeNS(ns, attr3);\n    } else {\n      el.removeAttribute(attr3);\n    }\n  }\n  function hasAttribute(ns, attr3, el) {\n    if (ns != null) {\n      return el.hasAttributeNS(ns, attr3);\n    } else {\n      return el.hasAttribute(attr3);\n    }\n  }\n  function addEventListener(ev, listener, el) {\n    el.addEventListener(ev, listener, false);\n  }\n  function removeEventListener(ev, listener, el) {\n    el.removeEventListener(ev, listener, false);\n  }\n  var jsUndefined = void 0;\n\n  // output/Foreign.Object.ST/foreign.js\n  var newImpl = function() {\n    return {};\n  };\n  function poke2(k) {\n    return function(v) {\n      return function(m) {\n        return function() {\n          m[k] = v;\n          return m;\n        };\n      };\n    };\n  }\n\n  // output/Halogen.VDom.Util/index.js\n  var unsafeLookup = unsafeGetAny;\n  var unsafeFreeze2 = unsafeCoerce2;\n  var pokeMutMap = unsafeSetAny;\n  var newMutMap = newImpl;\n\n  // output/Web.DOM.Element/foreign.js\n  var getProp = function(name15) {\n    return function(doctype) {\n      return doctype[name15];\n    };\n  };\n  var _namespaceURI = getProp(\"namespaceURI\");\n  var _prefix = getProp(\"prefix\");\n  var localName = getProp(\"localName\");\n  var tagName = getProp(\"tagName\");\n\n  // output/Web.DOM.ParentNode/foreign.js\n  var getEffProp = function(name15) {\n    return function(node) {\n      return function() {\n        return node[name15];\n      };\n    };\n  };\n  var children = getEffProp(\"children\");\n  var _firstElementChild = getEffProp(\"firstElementChild\");\n  var _lastElementChild = getEffProp(\"lastElementChild\");\n  var childElementCount = getEffProp(\"childElementCount\");\n  function _querySelector(selector) {\n    return function(node) {\n      return function() {\n        return node.querySelector(selector);\n      };\n    };\n  }\n\n  // output/Web.DOM.ParentNode/index.js\n  var map9 = /* @__PURE__ */ map(functorEffect);\n  var querySelector = function(qs) {\n    var $2 = map9(toMaybe);\n    var $3 = _querySelector(qs);\n    return function($4) {\n      return $2($3($4));\n    };\n  };\n\n  // output/Web.Internal.FFI/foreign.js\n  function _unsafeReadProtoTagged(nothing, just, name15, value15) {\n    if (typeof window !== \"undefined\") {\n      var ty = window[name15];\n      if (ty != null && value15 instanceof ty) {\n        return just(value15);\n      }\n    }\n    var obj = value15;\n    while (obj != null) {\n      var proto = Object.getPrototypeOf(obj);\n      var constructorName = proto.constructor.name;\n      if (constructorName === name15) {\n        return just(value15);\n      } else if (constructorName === \"Object\") {\n        return nothing;\n      }\n      obj = proto;\n    }\n    return nothing;\n  }\n\n  // output/Web.Internal.FFI/index.js\n  var unsafeReadProtoTagged = function(name15) {\n    return function(value15) {\n      return _unsafeReadProtoTagged(Nothing.value, Just.create, name15, value15);\n    };\n  };\n\n  // output/Web.DOM.Element/index.js\n  var toNode = unsafeCoerce2;\n\n  // output/Halogen.VDom.DOM/index.js\n  var $runtime_lazy4 = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var haltWidget = function(v) {\n    return halt(v.widget);\n  };\n  var $lazy_patchWidget = /* @__PURE__ */ $runtime_lazy4(\"patchWidget\", \"Halogen.VDom.DOM\", function() {\n    return function(state3, vdom) {\n      if (vdom instanceof Grafted) {\n        return $lazy_patchWidget(291)(state3, runGraft(vdom.value0));\n      }\n      ;\n      if (vdom instanceof Widget) {\n        var res = step(state3.widget, vdom.value0);\n        var res$prime = unStep(function(v) {\n          return mkStep(new Step2(v.value0, {\n            build: state3.build,\n            widget: res\n          }, $lazy_patchWidget(296), haltWidget));\n        })(res);\n        return res$prime;\n      }\n      ;\n      haltWidget(state3);\n      return state3.build(vdom);\n    };\n  });\n  var patchWidget = /* @__PURE__ */ $lazy_patchWidget(286);\n  var haltText = function(v) {\n    var parent2 = parentNode(v.node);\n    return removeChild(v.node, parent2);\n  };\n  var $lazy_patchText = /* @__PURE__ */ $runtime_lazy4(\"patchText\", \"Halogen.VDom.DOM\", function() {\n    return function(state3, vdom) {\n      if (vdom instanceof Grafted) {\n        return $lazy_patchText(82)(state3, runGraft(vdom.value0));\n      }\n      ;\n      if (vdom instanceof Text) {\n        if (state3.value === vdom.value0) {\n          return mkStep(new Step2(state3.node, state3, $lazy_patchText(85), haltText));\n        }\n        ;\n        if (otherwise) {\n          var nextState = {\n            build: state3.build,\n            node: state3.node,\n            value: vdom.value0\n          };\n          setTextContent(vdom.value0, state3.node);\n          return mkStep(new Step2(state3.node, nextState, $lazy_patchText(89), haltText));\n        }\n        ;\n      }\n      ;\n      haltText(state3);\n      return state3.build(vdom);\n    };\n  });\n  var patchText = /* @__PURE__ */ $lazy_patchText(77);\n  var haltKeyed = function(v) {\n    var parent2 = parentNode(v.node);\n    removeChild(v.node, parent2);\n    forInE(v.children, function(v1, s) {\n      return halt(s);\n    });\n    return halt(v.attrs);\n  };\n  var haltElem = function(v) {\n    var parent2 = parentNode(v.node);\n    removeChild(v.node, parent2);\n    forEachE(v.children, halt);\n    return halt(v.attrs);\n  };\n  var eqElemSpec = function(ns1, v, ns2, v1) {\n    var $63 = v === v1;\n    if ($63) {\n      if (ns1 instanceof Just && (ns2 instanceof Just && ns1.value0 === ns2.value0)) {\n        return true;\n      }\n      ;\n      if (ns1 instanceof Nothing && ns2 instanceof Nothing) {\n        return true;\n      }\n      ;\n      return false;\n    }\n    ;\n    return false;\n  };\n  var $lazy_patchElem = /* @__PURE__ */ $runtime_lazy4(\"patchElem\", \"Halogen.VDom.DOM\", function() {\n    return function(state3, vdom) {\n      if (vdom instanceof Grafted) {\n        return $lazy_patchElem(135)(state3, runGraft(vdom.value0));\n      }\n      ;\n      if (vdom instanceof Elem && eqElemSpec(state3.ns, state3.name, vdom.value0, vdom.value1)) {\n        var v = length(vdom.value3);\n        var v1 = length(state3.children);\n        if (v1 === 0 && v === 0) {\n          var attrs2 = step(state3.attrs, vdom.value2);\n          var nextState = {\n            build: state3.build,\n            node: state3.node,\n            attrs: attrs2,\n            ns: vdom.value0,\n            name: vdom.value1,\n            children: state3.children\n          };\n          return mkStep(new Step2(state3.node, nextState, $lazy_patchElem(149), haltElem));\n        }\n        ;\n        var onThis = function(v2, s) {\n          return halt(s);\n        };\n        var onThese = function(ix, s, v2) {\n          var res = step(s, v2);\n          insertChildIx(ix, extract2(res), state3.node);\n          return res;\n        };\n        var onThat = function(ix, v2) {\n          var res = state3.build(v2);\n          insertChildIx(ix, extract2(res), state3.node);\n          return res;\n        };\n        var children2 = diffWithIxE(state3.children, vdom.value3, onThese, onThis, onThat);\n        var attrs2 = step(state3.attrs, vdom.value2);\n        var nextState = {\n          build: state3.build,\n          node: state3.node,\n          attrs: attrs2,\n          ns: vdom.value0,\n          name: vdom.value1,\n          children: children2\n        };\n        return mkStep(new Step2(state3.node, nextState, $lazy_patchElem(172), haltElem));\n      }\n      ;\n      haltElem(state3);\n      return state3.build(vdom);\n    };\n  });\n  var patchElem = /* @__PURE__ */ $lazy_patchElem(130);\n  var $lazy_patchKeyed = /* @__PURE__ */ $runtime_lazy4(\"patchKeyed\", \"Halogen.VDom.DOM\", function() {\n    return function(state3, vdom) {\n      if (vdom instanceof Grafted) {\n        return $lazy_patchKeyed(222)(state3, runGraft(vdom.value0));\n      }\n      ;\n      if (vdom instanceof Keyed && eqElemSpec(state3.ns, state3.name, vdom.value0, vdom.value1)) {\n        var v = length(vdom.value3);\n        if (state3.length === 0 && v === 0) {\n          var attrs2 = step(state3.attrs, vdom.value2);\n          var nextState = {\n            build: state3.build,\n            node: state3.node,\n            attrs: attrs2,\n            ns: vdom.value0,\n            name: vdom.value1,\n            children: state3.children,\n            length: 0\n          };\n          return mkStep(new Step2(state3.node, nextState, $lazy_patchKeyed(237), haltKeyed));\n        }\n        ;\n        var onThis = function(v2, s) {\n          return halt(s);\n        };\n        var onThese = function(v2, ix$prime, s, v3) {\n          var res = step(s, v3.value1);\n          insertChildIx(ix$prime, extract2(res), state3.node);\n          return res;\n        };\n        var onThat = function(v2, ix, v3) {\n          var res = state3.build(v3.value1);\n          insertChildIx(ix, extract2(res), state3.node);\n          return res;\n        };\n        var children2 = diffWithKeyAndIxE(state3.children, vdom.value3, fst, onThese, onThis, onThat);\n        var attrs2 = step(state3.attrs, vdom.value2);\n        var nextState = {\n          build: state3.build,\n          node: state3.node,\n          attrs: attrs2,\n          ns: vdom.value0,\n          name: vdom.value1,\n          children: children2,\n          length: v\n        };\n        return mkStep(new Step2(state3.node, nextState, $lazy_patchKeyed(261), haltKeyed));\n      }\n      ;\n      haltKeyed(state3);\n      return state3.build(vdom);\n    };\n  });\n  var patchKeyed = /* @__PURE__ */ $lazy_patchKeyed(217);\n  var buildWidget = function(v, build, w) {\n    var res = v.buildWidget(v)(w);\n    var res$prime = unStep(function(v1) {\n      return mkStep(new Step2(v1.value0, {\n        build,\n        widget: res\n      }, patchWidget, haltWidget));\n    })(res);\n    return res$prime;\n  };\n  var buildText = function(v, build, s) {\n    var node = createTextNode(s, v.document);\n    var state3 = {\n      build,\n      node,\n      value: s\n    };\n    return mkStep(new Step2(node, state3, patchText, haltText));\n  };\n  var buildKeyed = function(v, build, ns1, name1, as1, ch1) {\n    var el = createElement(toNullable(ns1), name1, v.document);\n    var node = toNode(el);\n    var onChild = function(v1, ix, v2) {\n      var res = build(v2.value1);\n      insertChildIx(ix, extract2(res), node);\n      return res;\n    };\n    var children2 = strMapWithIxE(ch1, fst, onChild);\n    var attrs = v.buildAttributes(el)(as1);\n    var state3 = {\n      build,\n      node,\n      attrs,\n      ns: ns1,\n      name: name1,\n      children: children2,\n      length: length(ch1)\n    };\n    return mkStep(new Step2(node, state3, patchKeyed, haltKeyed));\n  };\n  var buildElem = function(v, build, ns1, name1, as1, ch1) {\n    var el = createElement(toNullable(ns1), name1, v.document);\n    var node = toNode(el);\n    var onChild = function(ix, child) {\n      var res = build(child);\n      insertChildIx(ix, extract2(res), node);\n      return res;\n    };\n    var children2 = forE2(ch1, onChild);\n    var attrs = v.buildAttributes(el)(as1);\n    var state3 = {\n      build,\n      node,\n      attrs,\n      ns: ns1,\n      name: name1,\n      children: children2\n    };\n    return mkStep(new Step2(node, state3, patchElem, haltElem));\n  };\n  var buildVDom = function(spec) {\n    var $lazy_build = $runtime_lazy4(\"build\", \"Halogen.VDom.DOM\", function() {\n      return function(v) {\n        if (v instanceof Text) {\n          return buildText(spec, $lazy_build(59), v.value0);\n        }\n        ;\n        if (v instanceof Elem) {\n          return buildElem(spec, $lazy_build(60), v.value0, v.value1, v.value2, v.value3);\n        }\n        ;\n        if (v instanceof Keyed) {\n          return buildKeyed(spec, $lazy_build(61), v.value0, v.value1, v.value2, v.value3);\n        }\n        ;\n        if (v instanceof Widget) {\n          return buildWidget(spec, $lazy_build(62), v.value0);\n        }\n        ;\n        if (v instanceof Grafted) {\n          return $lazy_build(63)(runGraft(v.value0));\n        }\n        ;\n        throw new Error(\"Failed pattern match at Halogen.VDom.DOM (line 58, column 27 - line 63, column 52): \" + [v.constructor.name]);\n      };\n    });\n    var build = $lazy_build(58);\n    return build;\n  };\n\n  // output/Foreign/foreign.js\n  function typeOf(value15) {\n    return typeof value15;\n  }\n  function tagOf(value15) {\n    return Object.prototype.toString.call(value15).slice(8, -1);\n  }\n  var isArray = Array.isArray || function(value15) {\n    return Object.prototype.toString.call(value15) === \"[object Array]\";\n  };\n\n  // output/Control.Monad.Except.Trans/index.js\n  var map10 = /* @__PURE__ */ map(functorEither);\n  var ExceptT = function(x) {\n    return x;\n  };\n  var runExceptT = function(v) {\n    return v;\n  };\n  var mapExceptT = function(f2) {\n    return function(v) {\n      return f2(v);\n    };\n  };\n  var functorExceptT = function(dictFunctor) {\n    var map112 = map(dictFunctor);\n    return {\n      map: function(f2) {\n        return mapExceptT(map112(map10(f2)));\n      }\n    };\n  };\n  var monadExceptT = function(dictMonad) {\n    return {\n      Applicative0: function() {\n        return applicativeExceptT(dictMonad);\n      },\n      Bind1: function() {\n        return bindExceptT(dictMonad);\n      }\n    };\n  };\n  var bindExceptT = function(dictMonad) {\n    var bind20 = bind(dictMonad.Bind1());\n    var pure18 = pure(dictMonad.Applicative0());\n    return {\n      bind: function(v) {\n        return function(k) {\n          return bind20(v)(either(function($187) {\n            return pure18(Left.create($187));\n          })(function(a2) {\n            var v1 = k(a2);\n            return v1;\n          }));\n        };\n      },\n      Apply0: function() {\n        return applyExceptT(dictMonad);\n      }\n    };\n  };\n  var applyExceptT = function(dictMonad) {\n    var functorExceptT1 = functorExceptT(dictMonad.Bind1().Apply0().Functor0());\n    return {\n      apply: ap(monadExceptT(dictMonad)),\n      Functor0: function() {\n        return functorExceptT1;\n      }\n    };\n  };\n  var applicativeExceptT = function(dictMonad) {\n    return {\n      pure: function() {\n        var $188 = pure(dictMonad.Applicative0());\n        return function($189) {\n          return ExceptT($188(Right.create($189)));\n        };\n      }(),\n      Apply0: function() {\n        return applyExceptT(dictMonad);\n      }\n    };\n  };\n  var monadThrowExceptT = function(dictMonad) {\n    var monadExceptT1 = monadExceptT(dictMonad);\n    return {\n      throwError: function() {\n        var $198 = pure(dictMonad.Applicative0());\n        return function($199) {\n          return ExceptT($198(Left.create($199)));\n        };\n      }(),\n      Monad0: function() {\n        return monadExceptT1;\n      }\n    };\n  };\n\n  // output/Data.Int/foreign.js\n  var fromNumberImpl = function(just) {\n    return function(nothing) {\n      return function(n) {\n        return (n | 0) === n ? just(n) : nothing;\n      };\n    };\n  };\n  var toNumber = function(n) {\n    return n;\n  };\n  var fromStringAsImpl = function(just) {\n    return function(nothing) {\n      return function(radix) {\n        var digits;\n        if (radix < 11) {\n          digits = \"[0-\" + (radix - 1).toString() + \"]\";\n        } else if (radix === 11) {\n          digits = \"[0-9a]\";\n        } else {\n          digits = \"[0-9a-\" + String.fromCharCode(86 + radix) + \"]\";\n        }\n        var pattern2 = new RegExp(\"^[\\\\+\\\\-]?\" + digits + \"+$\", \"i\");\n        return function(s) {\n          if (pattern2.test(s)) {\n            var i2 = parseInt(s, radix);\n            return (i2 | 0) === i2 ? just(i2) : nothing;\n          } else {\n            return nothing;\n          }\n        };\n      };\n    };\n  };\n\n  // output/Data.Number/foreign.js\n  var isFiniteImpl = isFinite;\n  var floor = Math.floor;\n\n  // output/Data.Int/index.js\n  var top2 = /* @__PURE__ */ top(boundedInt);\n  var bottom2 = /* @__PURE__ */ bottom(boundedInt);\n  var fromStringAs = /* @__PURE__ */ function() {\n    return fromStringAsImpl(Just.create)(Nothing.value);\n  }();\n  var fromString = /* @__PURE__ */ fromStringAs(10);\n  var fromNumber = /* @__PURE__ */ function() {\n    return fromNumberImpl(Just.create)(Nothing.value);\n  }();\n  var unsafeClamp = function(x) {\n    if (!isFiniteImpl(x)) {\n      return 0;\n    }\n    ;\n    if (x >= toNumber(top2)) {\n      return top2;\n    }\n    ;\n    if (x <= toNumber(bottom2)) {\n      return bottom2;\n    }\n    ;\n    if (otherwise) {\n      return fromMaybe(0)(fromNumber(x));\n    }\n    ;\n    throw new Error(\"Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): \" + [x.constructor.name]);\n  };\n  var floor2 = function($39) {\n    return unsafeClamp(floor($39));\n  };\n\n  // output/Data.List/index.js\n  var reverse2 = /* @__PURE__ */ function() {\n    var go2 = function($copy_v) {\n      return function($copy_v1) {\n        var $tco_var_v = $copy_v;\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v, v1) {\n          if (v1 instanceof Nil) {\n            $tco_done = true;\n            return v;\n          }\n          ;\n          if (v1 instanceof Cons) {\n            $tco_var_v = new Cons(v1.value0, v);\n            $copy_v1 = v1.value1;\n            return;\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.List (line 368, column 3 - line 368, column 19): \" + [v.constructor.name, v1.constructor.name]);\n        }\n        ;\n        while (!$tco_done) {\n          $tco_result = $tco_loop($tco_var_v, $copy_v1);\n        }\n        ;\n        return $tco_result;\n      };\n    };\n    return go2(Nil.value);\n  }();\n  var $$null3 = function(v) {\n    if (v instanceof Nil) {\n      return true;\n    }\n    ;\n    return false;\n  };\n\n  // output/Partial.Unsafe/foreign.js\n  var _unsafePartial = function(f2) {\n    return f2();\n  };\n\n  // output/Partial/foreign.js\n  var _crashWith = function(msg) {\n    throw new Error(msg);\n  };\n\n  // output/Partial/index.js\n  var crashWith = function() {\n    return _crashWith;\n  };\n\n  // output/Partial.Unsafe/index.js\n  var crashWith2 = /* @__PURE__ */ crashWith();\n  var unsafePartial = _unsafePartial;\n  var unsafeCrashWith = function(msg) {\n    return unsafePartial(function() {\n      return crashWith2(msg);\n    });\n  };\n\n  // output/Data.List.NonEmpty/index.js\n  var singleton5 = /* @__PURE__ */ function() {\n    var $200 = singleton3(plusList);\n    return function($201) {\n      return NonEmptyList($200($201));\n    };\n  }();\n  var cons = function(y) {\n    return function(v) {\n      return new NonEmpty(y, new Cons(v.value0, v.value1));\n    };\n  };\n\n  // output/Data.String.CodeUnits/foreign.js\n  var length3 = function(s) {\n    return s.length;\n  };\n  var splitAt = function(i2) {\n    return function(s) {\n      return { before: s.substring(0, i2), after: s.substring(i2) };\n    };\n  };\n\n  // output/Data.String.CodeUnits/index.js\n  var stripPrefix = function(v) {\n    return function(str) {\n      var v1 = splitAt(length3(v))(str);\n      var $20 = v1.before === v;\n      if ($20) {\n        return new Just(v1.after);\n      }\n      ;\n      return Nothing.value;\n    };\n  };\n\n  // output/Foreign/index.js\n  var show3 = /* @__PURE__ */ show(showString);\n  var show1 = /* @__PURE__ */ show(showInt);\n  var ForeignError = /* @__PURE__ */ function() {\n    function ForeignError2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    ForeignError2.create = function(value0) {\n      return new ForeignError2(value0);\n    };\n    return ForeignError2;\n  }();\n  var TypeMismatch = /* @__PURE__ */ function() {\n    function TypeMismatch3(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    TypeMismatch3.create = function(value0) {\n      return function(value1) {\n        return new TypeMismatch3(value0, value1);\n      };\n    };\n    return TypeMismatch3;\n  }();\n  var ErrorAtIndex = /* @__PURE__ */ function() {\n    function ErrorAtIndex2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    ErrorAtIndex2.create = function(value0) {\n      return function(value1) {\n        return new ErrorAtIndex2(value0, value1);\n      };\n    };\n    return ErrorAtIndex2;\n  }();\n  var ErrorAtProperty = /* @__PURE__ */ function() {\n    function ErrorAtProperty2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    ErrorAtProperty2.create = function(value0) {\n      return function(value1) {\n        return new ErrorAtProperty2(value0, value1);\n      };\n    };\n    return ErrorAtProperty2;\n  }();\n  var unsafeToForeign = unsafeCoerce2;\n  var unsafeFromForeign = unsafeCoerce2;\n  var renderForeignError = function(v) {\n    if (v instanceof ForeignError) {\n      return v.value0;\n    }\n    ;\n    if (v instanceof ErrorAtIndex) {\n      return \"Error at array index \" + (show1(v.value0) + (\": \" + renderForeignError(v.value1)));\n    }\n    ;\n    if (v instanceof ErrorAtProperty) {\n      return \"Error at property \" + (show3(v.value0) + (\": \" + renderForeignError(v.value1)));\n    }\n    ;\n    if (v instanceof TypeMismatch) {\n      return \"Type mismatch: expected \" + (v.value0 + (\", found \" + v.value1));\n    }\n    ;\n    throw new Error(\"Failed pattern match at Foreign (line 78, column 1 - line 78, column 45): \" + [v.constructor.name]);\n  };\n  var fail = function(dictMonad) {\n    var $153 = throwError(monadThrowExceptT(dictMonad));\n    return function($154) {\n      return $153(singleton5($154));\n    };\n  };\n  var unsafeReadTagged = function(dictMonad) {\n    var pure18 = pure(applicativeExceptT(dictMonad));\n    var fail1 = fail(dictMonad);\n    return function(tag) {\n      return function(value15) {\n        if (tagOf(value15) === tag) {\n          return pure18(unsafeFromForeign(value15));\n        }\n        ;\n        if (otherwise) {\n          return fail1(new TypeMismatch(tag, tagOf(value15)));\n        }\n        ;\n        throw new Error(\"Failed pattern match at Foreign (line 123, column 1 - line 123, column 104): \" + [tag.constructor.name, value15.constructor.name]);\n      };\n    };\n  };\n  var readString = function(dictMonad) {\n    return unsafeReadTagged(dictMonad)(\"String\");\n  };\n\n  // output/Foreign.Object/foreign.js\n  function _copyST(m) {\n    return function() {\n      var r = {};\n      for (var k in m) {\n        if (hasOwnProperty.call(m, k)) {\n          r[k] = m[k];\n        }\n      }\n      return r;\n    };\n  }\n  var empty4 = {};\n  function runST(f2) {\n    return f2();\n  }\n  function _lookup(no, yes, k, m) {\n    return k in m ? yes(m[k]) : no;\n  }\n  function toArrayWithKey(f2) {\n    return function(m) {\n      var r = [];\n      for (var k in m) {\n        if (hasOwnProperty.call(m, k)) {\n          r.push(f2(k)(m[k]));\n        }\n      }\n      return r;\n    };\n  }\n  var keys = Object.keys || toArrayWithKey(function(k) {\n    return function() {\n      return k;\n    };\n  });\n\n  // output/Foreign.Object/index.js\n  var thawST = _copyST;\n  var mutate = function(f2) {\n    return function(m) {\n      return runST(function __do2() {\n        var s = thawST(m)();\n        f2(s)();\n        return s;\n      });\n    };\n  };\n  var lookup3 = /* @__PURE__ */ function() {\n    return runFn4(_lookup)(Nothing.value)(Just.create);\n  }();\n  var insert3 = function(k) {\n    return function(v) {\n      return mutate(poke2(k)(v));\n    };\n  };\n\n  // output/Web.Event.EventTarget/foreign.js\n  function eventListener(fn) {\n    return function() {\n      return function(event) {\n        return fn(event)();\n      };\n    };\n  }\n  function addEventListener2(type) {\n    return function(listener) {\n      return function(useCapture) {\n        return function(target7) {\n          return function() {\n            return target7.addEventListener(type, listener, useCapture);\n          };\n        };\n      };\n    };\n  }\n  function removeEventListener2(type) {\n    return function(listener) {\n      return function(useCapture) {\n        return function(target7) {\n          return function() {\n            return target7.removeEventListener(type, listener, useCapture);\n          };\n        };\n      };\n    };\n  }\n\n  // output/Halogen.VDom.DOM.Prop/index.js\n  var $runtime_lazy5 = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var Created = /* @__PURE__ */ function() {\n    function Created2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Created2.create = function(value0) {\n      return new Created2(value0);\n    };\n    return Created2;\n  }();\n  var Removed = /* @__PURE__ */ function() {\n    function Removed2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Removed2.create = function(value0) {\n      return new Removed2(value0);\n    };\n    return Removed2;\n  }();\n  var Attribute = /* @__PURE__ */ function() {\n    function Attribute2(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    Attribute2.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new Attribute2(value0, value1, value22);\n        };\n      };\n    };\n    return Attribute2;\n  }();\n  var Property = /* @__PURE__ */ function() {\n    function Property2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Property2.create = function(value0) {\n      return function(value1) {\n        return new Property2(value0, value1);\n      };\n    };\n    return Property2;\n  }();\n  var Handler = /* @__PURE__ */ function() {\n    function Handler2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Handler2.create = function(value0) {\n      return function(value1) {\n        return new Handler2(value0, value1);\n      };\n    };\n    return Handler2;\n  }();\n  var Ref = /* @__PURE__ */ function() {\n    function Ref2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Ref2.create = function(value0) {\n      return new Ref2(value0);\n    };\n    return Ref2;\n  }();\n  var unsafeGetProperty = unsafeGetAny;\n  var setProperty = unsafeSetAny;\n  var removeProperty = function(key, el) {\n    var v = hasAttribute(nullImpl, key, el);\n    if (v) {\n      return removeAttribute(nullImpl, key, el);\n    }\n    ;\n    var v1 = typeOf(unsafeGetAny(key, el));\n    if (v1 === \"string\") {\n      return unsafeSetAny(key, \"\", el);\n    }\n    ;\n    if (key === \"rowSpan\") {\n      return unsafeSetAny(key, 1, el);\n    }\n    ;\n    if (key === \"colSpan\") {\n      return unsafeSetAny(key, 1, el);\n    }\n    ;\n    return unsafeSetAny(key, jsUndefined, el);\n  };\n  var propToStrKey = function(v) {\n    if (v instanceof Attribute && v.value0 instanceof Just) {\n      return \"attr/\" + (v.value0.value0 + (\":\" + v.value1));\n    }\n    ;\n    if (v instanceof Attribute) {\n      return \"attr/:\" + v.value1;\n    }\n    ;\n    if (v instanceof Property) {\n      return \"prop/\" + v.value0;\n    }\n    ;\n    if (v instanceof Handler) {\n      return \"handler/\" + v.value0;\n    }\n    ;\n    if (v instanceof Ref) {\n      return \"ref\";\n    }\n    ;\n    throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 182, column 16 - line 187, column 16): \" + [v.constructor.name]);\n  };\n  var propFromString = unsafeCoerce2;\n  var propFromNumber = unsafeCoerce2;\n  var propFromBoolean = unsafeCoerce2;\n  var buildProp = function(emit) {\n    return function(el) {\n      var removeProp = function(prevEvents) {\n        return function(v, v1) {\n          if (v1 instanceof Attribute) {\n            return removeAttribute(toNullable(v1.value0), v1.value1, el);\n          }\n          ;\n          if (v1 instanceof Property) {\n            return removeProperty(v1.value0, el);\n          }\n          ;\n          if (v1 instanceof Handler) {\n            var handler3 = unsafeLookup(v1.value0, prevEvents);\n            return removeEventListener(v1.value0, fst(handler3), el);\n          }\n          ;\n          if (v1 instanceof Ref) {\n            return unit;\n          }\n          ;\n          throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 169, column 5 - line 179, column 18): \" + [v1.constructor.name]);\n        };\n      };\n      var mbEmit = function(v) {\n        if (v instanceof Just) {\n          return emit(v.value0)();\n        }\n        ;\n        return unit;\n      };\n      var haltProp = function(state3) {\n        var v = lookup3(\"ref\")(state3.props);\n        if (v instanceof Just && v.value0 instanceof Ref) {\n          return mbEmit(v.value0.value0(new Removed(el)));\n        }\n        ;\n        return unit;\n      };\n      var diffProp = function(prevEvents, events) {\n        return function(v, v1, v11, v2) {\n          if (v11 instanceof Attribute && v2 instanceof Attribute) {\n            var $66 = v11.value2 === v2.value2;\n            if ($66) {\n              return v2;\n            }\n            ;\n            setAttribute(toNullable(v2.value0), v2.value1, v2.value2, el);\n            return v2;\n          }\n          ;\n          if (v11 instanceof Property && v2 instanceof Property) {\n            var v42 = refEq2(v11.value1, v2.value1);\n            if (v42) {\n              return v2;\n            }\n            ;\n            if (v2.value0 === \"value\") {\n              var elVal = unsafeGetProperty(\"value\", el);\n              var $75 = refEq2(elVal, v2.value1);\n              if ($75) {\n                return v2;\n              }\n              ;\n              setProperty(v2.value0, v2.value1, el);\n              return v2;\n            }\n            ;\n            setProperty(v2.value0, v2.value1, el);\n            return v2;\n          }\n          ;\n          if (v11 instanceof Handler && v2 instanceof Handler) {\n            var handler3 = unsafeLookup(v2.value0, prevEvents);\n            write(v2.value1)(snd(handler3))();\n            pokeMutMap(v2.value0, handler3, events);\n            return v2;\n          }\n          ;\n          return v2;\n        };\n      };\n      var applyProp = function(events) {\n        return function(v, v1, v2) {\n          if (v2 instanceof Attribute) {\n            setAttribute(toNullable(v2.value0), v2.value1, v2.value2, el);\n            return v2;\n          }\n          ;\n          if (v2 instanceof Property) {\n            setProperty(v2.value0, v2.value1, el);\n            return v2;\n          }\n          ;\n          if (v2 instanceof Handler) {\n            var v3 = unsafeGetAny(v2.value0, events);\n            if (unsafeHasAny(v2.value0, events)) {\n              write(v2.value1)(snd(v3))();\n              return v2;\n            }\n            ;\n            var ref3 = $$new(v2.value1)();\n            var listener = eventListener(function(ev) {\n              return function __do2() {\n                var f$prime = read(ref3)();\n                return mbEmit(f$prime(ev));\n              };\n            })();\n            pokeMutMap(v2.value0, new Tuple(listener, ref3), events);\n            addEventListener(v2.value0, listener, el);\n            return v2;\n          }\n          ;\n          if (v2 instanceof Ref) {\n            mbEmit(v2.value0(new Created(el)));\n            return v2;\n          }\n          ;\n          throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 113, column 5 - line 135, column 15): \" + [v2.constructor.name]);\n        };\n      };\n      var $lazy_patchProp = $runtime_lazy5(\"patchProp\", \"Halogen.VDom.DOM.Prop\", function() {\n        return function(state3, ps2) {\n          var events = newMutMap();\n          var onThis = removeProp(state3.events);\n          var onThese = diffProp(state3.events, events);\n          var onThat = applyProp(events);\n          var props = diffWithKeyAndIxE(state3.props, ps2, propToStrKey, onThese, onThis, onThat);\n          var nextState = {\n            events: unsafeFreeze2(events),\n            props\n          };\n          return mkStep(new Step2(unit, nextState, $lazy_patchProp(100), haltProp));\n        };\n      });\n      var patchProp = $lazy_patchProp(87);\n      var renderProp = function(ps1) {\n        var events = newMutMap();\n        var ps1$prime = strMapWithIxE(ps1, propToStrKey, applyProp(events));\n        var state3 = {\n          events: unsafeFreeze2(events),\n          props: ps1$prime\n        };\n        return mkStep(new Step2(unit, state3, patchProp, haltProp));\n      };\n      return renderProp;\n    };\n  };\n\n  // output/Web.HTML.Common/index.js\n  var ClassName = function(x) {\n    return x;\n  };\n\n  // output/Halogen.HTML.Core/index.js\n  var HTML = function(x) {\n    return x;\n  };\n  var widget = function($28) {\n    return HTML(Widget.create($28));\n  };\n  var toPropValue = function(dict) {\n    return dict.toPropValue;\n  };\n  var text = function($29) {\n    return HTML(Text.create($29));\n  };\n  var ref = function(f2) {\n    return new Ref(function($30) {\n      return f2(function(v) {\n        if (v instanceof Created) {\n          return new Just(v.value0);\n        }\n        ;\n        if (v instanceof Removed) {\n          return Nothing.value;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Halogen.HTML.Core (line 109, column 21 - line 111, column 23): \" + [v.constructor.name]);\n      }($30));\n    });\n  };\n  var prop = function(dictIsProp) {\n    var toPropValue1 = toPropValue(dictIsProp);\n    return function(v) {\n      var $31 = Property.create(v);\n      return function($32) {\n        return $31(toPropValue1($32));\n      };\n    };\n  };\n  var isPropString = {\n    toPropValue: propFromString\n  };\n  var isPropStepValue = {\n    toPropValue: function($36) {\n      return propFromString(renderStepValue($36));\n    }\n  };\n  var isPropNumber = {\n    toPropValue: propFromNumber\n  };\n  var isPropInputType = {\n    toPropValue: function($45) {\n      return propFromString(renderInputType($45));\n    }\n  };\n  var isPropBoolean = {\n    toPropValue: propFromBoolean\n  };\n  var handler = /* @__PURE__ */ function() {\n    return Handler.create;\n  }();\n  var element = function(ns) {\n    return function(name15) {\n      return function(props) {\n        return function(children2) {\n          return new Elem(ns, name15, props, children2);\n        };\n      };\n    };\n  };\n\n  // output/Control.Applicative.Free/index.js\n  var identity9 = /* @__PURE__ */ identity(categoryFn);\n  var Pure = /* @__PURE__ */ function() {\n    function Pure2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Pure2.create = function(value0) {\n      return new Pure2(value0);\n    };\n    return Pure2;\n  }();\n  var Lift = /* @__PURE__ */ function() {\n    function Lift3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Lift3.create = function(value0) {\n      return new Lift3(value0);\n    };\n    return Lift3;\n  }();\n  var Ap = /* @__PURE__ */ function() {\n    function Ap2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Ap2.create = function(value0) {\n      return function(value1) {\n        return new Ap2(value0, value1);\n      };\n    };\n    return Ap2;\n  }();\n  var mkAp = function(fba) {\n    return function(fb) {\n      return new Ap(fba, fb);\n    };\n  };\n  var liftFreeAp = /* @__PURE__ */ function() {\n    return Lift.create;\n  }();\n  var goLeft = function(dictApplicative) {\n    var pure18 = pure(dictApplicative);\n    return function(fStack) {\n      return function(valStack) {\n        return function(nat) {\n          return function(func) {\n            return function(count) {\n              if (func instanceof Pure) {\n                return new Tuple(new Cons({\n                  func: pure18(func.value0),\n                  count\n                }, fStack), valStack);\n              }\n              ;\n              if (func instanceof Lift) {\n                return new Tuple(new Cons({\n                  func: nat(func.value0),\n                  count\n                }, fStack), valStack);\n              }\n              ;\n              if (func instanceof Ap) {\n                return goLeft(dictApplicative)(fStack)(cons(func.value1)(valStack))(nat)(func.value0)(count + 1 | 0);\n              }\n              ;\n              throw new Error(\"Failed pattern match at Control.Applicative.Free (line 102, column 41 - line 105, column 81): \" + [func.constructor.name]);\n            };\n          };\n        };\n      };\n    };\n  };\n  var goApply = function(dictApplicative) {\n    var apply4 = apply(dictApplicative.Apply0());\n    return function(fStack) {\n      return function(vals) {\n        return function(gVal) {\n          if (fStack instanceof Nil) {\n            return new Left(gVal);\n          }\n          ;\n          if (fStack instanceof Cons) {\n            var gRes = apply4(fStack.value0.func)(gVal);\n            var $31 = fStack.value0.count === 1;\n            if ($31) {\n              if (fStack.value1 instanceof Nil) {\n                return new Left(gRes);\n              }\n              ;\n              return goApply(dictApplicative)(fStack.value1)(vals)(gRes);\n            }\n            ;\n            if (vals instanceof Nil) {\n              return new Left(gRes);\n            }\n            ;\n            if (vals instanceof Cons) {\n              return new Right(new Tuple(new Cons({\n                func: gRes,\n                count: fStack.value0.count - 1 | 0\n              }, fStack.value1), new NonEmpty(vals.value0, vals.value1)));\n            }\n            ;\n            throw new Error(\"Failed pattern match at Control.Applicative.Free (line 83, column 11 - line 88, column 50): \" + [vals.constructor.name]);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Control.Applicative.Free (line 72, column 3 - line 88, column 50): \" + [fStack.constructor.name]);\n        };\n      };\n    };\n  };\n  var functorFreeAp = {\n    map: function(f2) {\n      return function(x) {\n        return mkAp(new Pure(f2))(x);\n      };\n    }\n  };\n  var foldFreeAp = function(dictApplicative) {\n    var goApply1 = goApply(dictApplicative);\n    var pure18 = pure(dictApplicative);\n    var goLeft1 = goLeft(dictApplicative);\n    return function(nat) {\n      return function(z) {\n        var go2 = function($copy_v) {\n          var $tco_done = false;\n          var $tco_result;\n          function $tco_loop(v) {\n            if (v.value1.value0 instanceof Pure) {\n              var v1 = goApply1(v.value0)(v.value1.value1)(pure18(v.value1.value0.value0));\n              if (v1 instanceof Left) {\n                $tco_done = true;\n                return v1.value0;\n              }\n              ;\n              if (v1 instanceof Right) {\n                $copy_v = v1.value0;\n                return;\n              }\n              ;\n              throw new Error(\"Failed pattern match at Control.Applicative.Free (line 54, column 17 - line 56, column 24): \" + [v1.constructor.name]);\n            }\n            ;\n            if (v.value1.value0 instanceof Lift) {\n              var v1 = goApply1(v.value0)(v.value1.value1)(nat(v.value1.value0.value0));\n              if (v1 instanceof Left) {\n                $tco_done = true;\n                return v1.value0;\n              }\n              ;\n              if (v1 instanceof Right) {\n                $copy_v = v1.value0;\n                return;\n              }\n              ;\n              throw new Error(\"Failed pattern match at Control.Applicative.Free (line 57, column 17 - line 59, column 24): \" + [v1.constructor.name]);\n            }\n            ;\n            if (v.value1.value0 instanceof Ap) {\n              var nextVals = new NonEmpty(v.value1.value0.value1, v.value1.value1);\n              $copy_v = goLeft1(v.value0)(nextVals)(nat)(v.value1.value0.value0)(1);\n              return;\n            }\n            ;\n            throw new Error(\"Failed pattern match at Control.Applicative.Free (line 53, column 5 - line 62, column 47): \" + [v.value1.value0.constructor.name]);\n          }\n          ;\n          while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n          }\n          ;\n          return $tco_result;\n        };\n        return go2(new Tuple(Nil.value, singleton5(z)));\n      };\n    };\n  };\n  var retractFreeAp = function(dictApplicative) {\n    return foldFreeAp(dictApplicative)(identity9);\n  };\n  var applyFreeAp = {\n    apply: function(fba) {\n      return function(fb) {\n        return mkAp(fba)(fb);\n      };\n    },\n    Functor0: function() {\n      return functorFreeAp;\n    }\n  };\n  var applicativeFreeAp = /* @__PURE__ */ function() {\n    return {\n      pure: Pure.create,\n      Apply0: function() {\n        return applyFreeAp;\n      }\n    };\n  }();\n  var foldFreeAp1 = /* @__PURE__ */ foldFreeAp(applicativeFreeAp);\n  var hoistFreeAp = function(f2) {\n    return foldFreeAp1(function($54) {\n      return liftFreeAp(f2($54));\n    });\n  };\n\n  // output/Data.CatQueue/index.js\n  var CatQueue = /* @__PURE__ */ function() {\n    function CatQueue2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    CatQueue2.create = function(value0) {\n      return function(value1) {\n        return new CatQueue2(value0, value1);\n      };\n    };\n    return CatQueue2;\n  }();\n  var uncons2 = function($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n    function $tco_loop(v) {\n      if (v.value0 instanceof Nil && v.value1 instanceof Nil) {\n        $tco_done = true;\n        return Nothing.value;\n      }\n      ;\n      if (v.value0 instanceof Nil) {\n        $copy_v = new CatQueue(reverse2(v.value1), Nil.value);\n        return;\n      }\n      ;\n      if (v.value0 instanceof Cons) {\n        $tco_done = true;\n        return new Just(new Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.CatQueue (line 82, column 1 - line 82, column 63): \" + [v.constructor.name]);\n    }\n    ;\n    while (!$tco_done) {\n      $tco_result = $tco_loop($copy_v);\n    }\n    ;\n    return $tco_result;\n  };\n  var snoc3 = function(v) {\n    return function(a2) {\n      return new CatQueue(v.value0, new Cons(a2, v.value1));\n    };\n  };\n  var $$null4 = function(v) {\n    if (v.value0 instanceof Nil && v.value1 instanceof Nil) {\n      return true;\n    }\n    ;\n    return false;\n  };\n  var empty5 = /* @__PURE__ */ function() {\n    return new CatQueue(Nil.value, Nil.value);\n  }();\n\n  // output/Data.CatList/index.js\n  var CatNil = /* @__PURE__ */ function() {\n    function CatNil2() {\n    }\n    ;\n    CatNil2.value = new CatNil2();\n    return CatNil2;\n  }();\n  var CatCons = /* @__PURE__ */ function() {\n    function CatCons2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    CatCons2.create = function(value0) {\n      return function(value1) {\n        return new CatCons2(value0, value1);\n      };\n    };\n    return CatCons2;\n  }();\n  var link = function(v) {\n    return function(v1) {\n      if (v instanceof CatNil) {\n        return v1;\n      }\n      ;\n      if (v1 instanceof CatNil) {\n        return v;\n      }\n      ;\n      if (v instanceof CatCons) {\n        return new CatCons(v.value0, snoc3(v.value1)(v1));\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.CatList (line 108, column 1 - line 108, column 54): \" + [v.constructor.name, v1.constructor.name]);\n    };\n  };\n  var foldr4 = function(k) {\n    return function(b2) {\n      return function(q2) {\n        var foldl2 = function($copy_v) {\n          return function($copy_v1) {\n            return function($copy_v2) {\n              var $tco_var_v = $copy_v;\n              var $tco_var_v1 = $copy_v1;\n              var $tco_done = false;\n              var $tco_result;\n              function $tco_loop(v, v1, v2) {\n                if (v2 instanceof Nil) {\n                  $tco_done = true;\n                  return v1;\n                }\n                ;\n                if (v2 instanceof Cons) {\n                  $tco_var_v = v;\n                  $tco_var_v1 = v(v1)(v2.value0);\n                  $copy_v2 = v2.value1;\n                  return;\n                }\n                ;\n                throw new Error(\"Failed pattern match at Data.CatList (line 124, column 3 - line 124, column 59): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n              }\n              ;\n              while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);\n              }\n              ;\n              return $tco_result;\n            };\n          };\n        };\n        var go2 = function($copy_xs) {\n          return function($copy_ys) {\n            var $tco_var_xs = $copy_xs;\n            var $tco_done1 = false;\n            var $tco_result;\n            function $tco_loop(xs, ys) {\n              var v = uncons2(xs);\n              if (v instanceof Nothing) {\n                $tco_done1 = true;\n                return foldl2(function(x) {\n                  return function(i2) {\n                    return i2(x);\n                  };\n                })(b2)(ys);\n              }\n              ;\n              if (v instanceof Just) {\n                $tco_var_xs = v.value0.value1;\n                $copy_ys = new Cons(k(v.value0.value0), ys);\n                return;\n              }\n              ;\n              throw new Error(\"Failed pattern match at Data.CatList (line 120, column 14 - line 122, column 67): \" + [v.constructor.name]);\n            }\n            ;\n            while (!$tco_done1) {\n              $tco_result = $tco_loop($tco_var_xs, $copy_ys);\n            }\n            ;\n            return $tco_result;\n          };\n        };\n        return go2(q2)(Nil.value);\n      };\n    };\n  };\n  var uncons3 = function(v) {\n    if (v instanceof CatNil) {\n      return Nothing.value;\n    }\n    ;\n    if (v instanceof CatCons) {\n      return new Just(new Tuple(v.value0, function() {\n        var $66 = $$null4(v.value1);\n        if ($66) {\n          return CatNil.value;\n        }\n        ;\n        return foldr4(link)(CatNil.value)(v.value1);\n      }()));\n    }\n    ;\n    throw new Error(\"Failed pattern match at Data.CatList (line 99, column 1 - line 99, column 61): \" + [v.constructor.name]);\n  };\n  var empty6 = /* @__PURE__ */ function() {\n    return CatNil.value;\n  }();\n  var append2 = link;\n  var semigroupCatList = {\n    append: append2\n  };\n  var snoc4 = function(cat) {\n    return function(a2) {\n      return append2(cat)(new CatCons(a2, empty5));\n    };\n  };\n\n  // output/Control.Monad.Free/index.js\n  var $runtime_lazy6 = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var append3 = /* @__PURE__ */ append(semigroupCatList);\n  var Free = /* @__PURE__ */ function() {\n    function Free2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Free2.create = function(value0) {\n      return function(value1) {\n        return new Free2(value0, value1);\n      };\n    };\n    return Free2;\n  }();\n  var Return = /* @__PURE__ */ function() {\n    function Return2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Return2.create = function(value0) {\n      return new Return2(value0);\n    };\n    return Return2;\n  }();\n  var Bind = /* @__PURE__ */ function() {\n    function Bind2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Bind2.create = function(value0) {\n      return function(value1) {\n        return new Bind2(value0, value1);\n      };\n    };\n    return Bind2;\n  }();\n  var toView = function($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n    function $tco_loop(v) {\n      var runExpF = function(v22) {\n        return v22;\n      };\n      var concatF = function(v22) {\n        return function(r) {\n          return new Free(v22.value0, append3(v22.value1)(r));\n        };\n      };\n      if (v.value0 instanceof Return) {\n        var v2 = uncons3(v.value1);\n        if (v2 instanceof Nothing) {\n          $tco_done = true;\n          return new Return(v.value0.value0);\n        }\n        ;\n        if (v2 instanceof Just) {\n          $copy_v = concatF(runExpF(v2.value0.value0)(v.value0.value0))(v2.value0.value1);\n          return;\n        }\n        ;\n        throw new Error(\"Failed pattern match at Control.Monad.Free (line 227, column 7 - line 231, column 64): \" + [v2.constructor.name]);\n      }\n      ;\n      if (v.value0 instanceof Bind) {\n        $tco_done = true;\n        return new Bind(v.value0.value0, function(a2) {\n          return concatF(v.value0.value1(a2))(v.value1);\n        });\n      }\n      ;\n      throw new Error(\"Failed pattern match at Control.Monad.Free (line 225, column 3 - line 233, column 56): \" + [v.value0.constructor.name]);\n    }\n    ;\n    while (!$tco_done) {\n      $tco_result = $tco_loop($copy_v);\n    }\n    ;\n    return $tco_result;\n  };\n  var fromView = function(f2) {\n    return new Free(f2, empty6);\n  };\n  var freeMonad = {\n    Applicative0: function() {\n      return freeApplicative;\n    },\n    Bind1: function() {\n      return freeBind;\n    }\n  };\n  var freeFunctor = {\n    map: function(k) {\n      return function(f2) {\n        return bindFlipped(freeBind)(function() {\n          var $189 = pure(freeApplicative);\n          return function($190) {\n            return $189(k($190));\n          };\n        }())(f2);\n      };\n    }\n  };\n  var freeBind = {\n    bind: function(v) {\n      return function(k) {\n        return new Free(v.value0, snoc4(v.value1)(k));\n      };\n    },\n    Apply0: function() {\n      return $lazy_freeApply(0);\n    }\n  };\n  var freeApplicative = {\n    pure: function($191) {\n      return fromView(Return.create($191));\n    },\n    Apply0: function() {\n      return $lazy_freeApply(0);\n    }\n  };\n  var $lazy_freeApply = /* @__PURE__ */ $runtime_lazy6(\"freeApply\", \"Control.Monad.Free\", function() {\n    return {\n      apply: ap(freeMonad),\n      Functor0: function() {\n        return freeFunctor;\n      }\n    };\n  });\n  var freeApply = /* @__PURE__ */ $lazy_freeApply(77);\n  var lift22 = /* @__PURE__ */ lift2(freeApply);\n  var pure2 = /* @__PURE__ */ pure(freeApplicative);\n  var semigroupFree = function(dictSemigroup) {\n    return {\n      append: lift22(append(dictSemigroup))\n    };\n  };\n  var liftF = function(f2) {\n    return fromView(new Bind(f2, function($192) {\n      return pure2($192);\n    }));\n  };\n  var monoidFree = function(dictMonoid) {\n    var semigroupFree1 = semigroupFree(dictMonoid.Semigroup0());\n    return {\n      mempty: pure2(mempty(dictMonoid)),\n      Semigroup0: function() {\n        return semigroupFree1;\n      }\n    };\n  };\n  var foldFree = function(dictMonadRec) {\n    var Monad0 = dictMonadRec.Monad0();\n    var map112 = map(Monad0.Bind1().Apply0().Functor0());\n    var pure18 = pure(Monad0.Applicative0());\n    var tailRecM4 = tailRecM(dictMonadRec);\n    return function(k) {\n      var go2 = function(f2) {\n        var v = toView(f2);\n        if (v instanceof Return) {\n          return map112(Done.create)(pure18(v.value0));\n        }\n        ;\n        if (v instanceof Bind) {\n          return map112(function($199) {\n            return Loop.create(v.value1($199));\n          })(k(v.value0));\n        }\n        ;\n        throw new Error(\"Failed pattern match at Control.Monad.Free (line 158, column 10 - line 160, column 37): \" + [v.constructor.name]);\n      };\n      return tailRecM4(go2);\n    };\n  };\n\n  // output/Effect.Aff/foreign.js\n  var Aff = function() {\n    var EMPTY = {};\n    var PURE = \"Pure\";\n    var THROW = \"Throw\";\n    var CATCH = \"Catch\";\n    var SYNC = \"Sync\";\n    var ASYNC = \"Async\";\n    var BIND = \"Bind\";\n    var BRACKET = \"Bracket\";\n    var FORK = \"Fork\";\n    var SEQ = \"Sequential\";\n    var MAP = \"Map\";\n    var APPLY = \"Apply\";\n    var ALT = \"Alt\";\n    var CONS = \"Cons\";\n    var RESUME = \"Resume\";\n    var RELEASE = \"Release\";\n    var FINALIZER = \"Finalizer\";\n    var FINALIZED = \"Finalized\";\n    var FORKED = \"Forked\";\n    var FIBER = \"Fiber\";\n    var THUNK = \"Thunk\";\n    function Aff2(tag, _1, _2, _3) {\n      this.tag = tag;\n      this._1 = _1;\n      this._2 = _2;\n      this._3 = _3;\n    }\n    function AffCtr(tag) {\n      var fn = function(_1, _2, _3) {\n        return new Aff2(tag, _1, _2, _3);\n      };\n      fn.tag = tag;\n      return fn;\n    }\n    function nonCanceler2(error6) {\n      return new Aff2(PURE, void 0);\n    }\n    function runEff(eff) {\n      try {\n        eff();\n      } catch (error6) {\n        setTimeout(function() {\n          throw error6;\n        }, 0);\n      }\n    }\n    function runSync(left, right, eff) {\n      try {\n        return right(eff());\n      } catch (error6) {\n        return left(error6);\n      }\n    }\n    function runAsync(left, eff, k) {\n      try {\n        return eff(k)();\n      } catch (error6) {\n        k(left(error6))();\n        return nonCanceler2;\n      }\n    }\n    var Scheduler = function() {\n      var limit = 1024;\n      var size5 = 0;\n      var ix = 0;\n      var queue = new Array(limit);\n      var draining = false;\n      function drain() {\n        var thunk;\n        draining = true;\n        while (size5 !== 0) {\n          size5--;\n          thunk = queue[ix];\n          queue[ix] = void 0;\n          ix = (ix + 1) % limit;\n          thunk();\n        }\n        draining = false;\n      }\n      return {\n        isDraining: function() {\n          return draining;\n        },\n        enqueue: function(cb) {\n          var i2, tmp;\n          if (size5 === limit) {\n            tmp = draining;\n            drain();\n            draining = tmp;\n          }\n          queue[(ix + size5) % limit] = cb;\n          size5++;\n          if (!draining) {\n            drain();\n          }\n        }\n      };\n    }();\n    function Supervisor(util) {\n      var fibers = {};\n      var fiberId = 0;\n      var count = 0;\n      return {\n        register: function(fiber) {\n          var fid = fiberId++;\n          fiber.onComplete({\n            rethrow: true,\n            handler: function(result) {\n              return function() {\n                count--;\n                delete fibers[fid];\n              };\n            }\n          })();\n          fibers[fid] = fiber;\n          count++;\n        },\n        isEmpty: function() {\n          return count === 0;\n        },\n        killAll: function(killError, cb) {\n          return function() {\n            if (count === 0) {\n              return cb();\n            }\n            var killCount = 0;\n            var kills = {};\n            function kill2(fid) {\n              kills[fid] = fibers[fid].kill(killError, function(result) {\n                return function() {\n                  delete kills[fid];\n                  killCount--;\n                  if (util.isLeft(result) && util.fromLeft(result)) {\n                    setTimeout(function() {\n                      throw util.fromLeft(result);\n                    }, 0);\n                  }\n                  if (killCount === 0) {\n                    cb();\n                  }\n                };\n              })();\n            }\n            for (var k in fibers) {\n              if (fibers.hasOwnProperty(k)) {\n                killCount++;\n                kill2(k);\n              }\n            }\n            fibers = {};\n            fiberId = 0;\n            count = 0;\n            return function(error6) {\n              return new Aff2(SYNC, function() {\n                for (var k2 in kills) {\n                  if (kills.hasOwnProperty(k2)) {\n                    kills[k2]();\n                  }\n                }\n              });\n            };\n          };\n        }\n      };\n    }\n    var SUSPENDED = 0;\n    var CONTINUE = 1;\n    var STEP_BIND = 2;\n    var STEP_RESULT = 3;\n    var PENDING = 4;\n    var RETURN = 5;\n    var COMPLETED = 6;\n    function Fiber(util, supervisor, aff) {\n      var runTick = 0;\n      var status = SUSPENDED;\n      var step4 = aff;\n      var fail2 = null;\n      var interrupt = null;\n      var bhead = null;\n      var btail = null;\n      var attempts = null;\n      var bracketCount = 0;\n      var joinId = 0;\n      var joins = null;\n      var rethrow = true;\n      function run4(localRunTick) {\n        var tmp, result, attempt2;\n        while (true) {\n          tmp = null;\n          result = null;\n          attempt2 = null;\n          switch (status) {\n            case STEP_BIND:\n              status = CONTINUE;\n              try {\n                step4 = bhead(step4);\n                if (btail === null) {\n                  bhead = null;\n                } else {\n                  bhead = btail._1;\n                  btail = btail._2;\n                }\n              } catch (e) {\n                status = RETURN;\n                fail2 = util.left(e);\n                step4 = null;\n              }\n              break;\n            case STEP_RESULT:\n              if (util.isLeft(step4)) {\n                status = RETURN;\n                fail2 = step4;\n                step4 = null;\n              } else if (bhead === null) {\n                status = RETURN;\n              } else {\n                status = STEP_BIND;\n                step4 = util.fromRight(step4);\n              }\n              break;\n            case CONTINUE:\n              switch (step4.tag) {\n                case BIND:\n                  if (bhead) {\n                    btail = new Aff2(CONS, bhead, btail);\n                  }\n                  bhead = step4._2;\n                  status = CONTINUE;\n                  step4 = step4._1;\n                  break;\n                case PURE:\n                  if (bhead === null) {\n                    status = RETURN;\n                    step4 = util.right(step4._1);\n                  } else {\n                    status = STEP_BIND;\n                    step4 = step4._1;\n                  }\n                  break;\n                case SYNC:\n                  status = STEP_RESULT;\n                  step4 = runSync(util.left, util.right, step4._1);\n                  break;\n                case ASYNC:\n                  status = PENDING;\n                  step4 = runAsync(util.left, step4._1, function(result2) {\n                    return function() {\n                      if (runTick !== localRunTick) {\n                        return;\n                      }\n                      runTick++;\n                      Scheduler.enqueue(function() {\n                        if (runTick !== localRunTick + 1) {\n                          return;\n                        }\n                        status = STEP_RESULT;\n                        step4 = result2;\n                        run4(runTick);\n                      });\n                    };\n                  });\n                  return;\n                case THROW:\n                  status = RETURN;\n                  fail2 = util.left(step4._1);\n                  step4 = null;\n                  break;\n                case CATCH:\n                  if (bhead === null) {\n                    attempts = new Aff2(CONS, step4, attempts, interrupt);\n                  } else {\n                    attempts = new Aff2(CONS, step4, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);\n                  }\n                  bhead = null;\n                  btail = null;\n                  status = CONTINUE;\n                  step4 = step4._1;\n                  break;\n                case BRACKET:\n                  bracketCount++;\n                  if (bhead === null) {\n                    attempts = new Aff2(CONS, step4, attempts, interrupt);\n                  } else {\n                    attempts = new Aff2(CONS, step4, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);\n                  }\n                  bhead = null;\n                  btail = null;\n                  status = CONTINUE;\n                  step4 = step4._1;\n                  break;\n                case FORK:\n                  status = STEP_RESULT;\n                  tmp = Fiber(util, supervisor, step4._2);\n                  if (supervisor) {\n                    supervisor.register(tmp);\n                  }\n                  if (step4._1) {\n                    tmp.run();\n                  }\n                  step4 = util.right(tmp);\n                  break;\n                case SEQ:\n                  status = CONTINUE;\n                  step4 = sequential3(util, supervisor, step4._1);\n                  break;\n              }\n              break;\n            case RETURN:\n              bhead = null;\n              btail = null;\n              if (attempts === null) {\n                status = COMPLETED;\n                step4 = interrupt || fail2 || step4;\n              } else {\n                tmp = attempts._3;\n                attempt2 = attempts._1;\n                attempts = attempts._2;\n                switch (attempt2.tag) {\n                  case CATCH:\n                    if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                      status = RETURN;\n                    } else if (fail2) {\n                      status = CONTINUE;\n                      step4 = attempt2._2(util.fromLeft(fail2));\n                      fail2 = null;\n                    }\n                    break;\n                  case RESUME:\n                    if (interrupt && interrupt !== tmp && bracketCount === 0 || fail2) {\n                      status = RETURN;\n                    } else {\n                      bhead = attempt2._1;\n                      btail = attempt2._2;\n                      status = STEP_BIND;\n                      step4 = util.fromRight(step4);\n                    }\n                    break;\n                  case BRACKET:\n                    bracketCount--;\n                    if (fail2 === null) {\n                      result = util.fromRight(step4);\n                      attempts = new Aff2(CONS, new Aff2(RELEASE, attempt2._2, result), attempts, tmp);\n                      if (interrupt === tmp || bracketCount > 0) {\n                        status = CONTINUE;\n                        step4 = attempt2._3(result);\n                      }\n                    }\n                    break;\n                  case RELEASE:\n                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step4, fail2), attempts, interrupt);\n                    status = CONTINUE;\n                    if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                      step4 = attempt2._1.killed(util.fromLeft(interrupt))(attempt2._2);\n                    } else if (fail2) {\n                      step4 = attempt2._1.failed(util.fromLeft(fail2))(attempt2._2);\n                    } else {\n                      step4 = attempt2._1.completed(util.fromRight(step4))(attempt2._2);\n                    }\n                    fail2 = null;\n                    bracketCount++;\n                    break;\n                  case FINALIZER:\n                    bracketCount++;\n                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step4, fail2), attempts, interrupt);\n                    status = CONTINUE;\n                    step4 = attempt2._1;\n                    break;\n                  case FINALIZED:\n                    bracketCount--;\n                    status = RETURN;\n                    step4 = attempt2._1;\n                    fail2 = attempt2._2;\n                    break;\n                }\n              }\n              break;\n            case COMPLETED:\n              for (var k in joins) {\n                if (joins.hasOwnProperty(k)) {\n                  rethrow = rethrow && joins[k].rethrow;\n                  runEff(joins[k].handler(step4));\n                }\n              }\n              joins = null;\n              if (interrupt && fail2) {\n                setTimeout(function() {\n                  throw util.fromLeft(fail2);\n                }, 0);\n              } else if (util.isLeft(step4) && rethrow) {\n                setTimeout(function() {\n                  if (rethrow) {\n                    throw util.fromLeft(step4);\n                  }\n                }, 0);\n              }\n              return;\n            case SUSPENDED:\n              status = CONTINUE;\n              break;\n            case PENDING:\n              return;\n          }\n        }\n      }\n      function onComplete(join5) {\n        return function() {\n          if (status === COMPLETED) {\n            rethrow = rethrow && join5.rethrow;\n            join5.handler(step4)();\n            return function() {\n            };\n          }\n          var jid = joinId++;\n          joins = joins || {};\n          joins[jid] = join5;\n          return function() {\n            if (joins !== null) {\n              delete joins[jid];\n            }\n          };\n        };\n      }\n      function kill2(error6, cb) {\n        return function() {\n          if (status === COMPLETED) {\n            cb(util.right(void 0))();\n            return function() {\n            };\n          }\n          var canceler = onComplete({\n            rethrow: false,\n            handler: function() {\n              return cb(util.right(void 0));\n            }\n          })();\n          switch (status) {\n            case SUSPENDED:\n              interrupt = util.left(error6);\n              status = COMPLETED;\n              step4 = interrupt;\n              run4(runTick);\n              break;\n            case PENDING:\n              if (interrupt === null) {\n                interrupt = util.left(error6);\n              }\n              if (bracketCount === 0) {\n                if (status === PENDING) {\n                  attempts = new Aff2(CONS, new Aff2(FINALIZER, step4(error6)), attempts, interrupt);\n                }\n                status = RETURN;\n                step4 = null;\n                fail2 = null;\n                run4(++runTick);\n              }\n              break;\n            default:\n              if (interrupt === null) {\n                interrupt = util.left(error6);\n              }\n              if (bracketCount === 0) {\n                status = RETURN;\n                step4 = null;\n                fail2 = null;\n              }\n          }\n          return canceler;\n        };\n      }\n      function join4(cb) {\n        return function() {\n          var canceler = onComplete({\n            rethrow: false,\n            handler: cb\n          })();\n          if (status === SUSPENDED) {\n            run4(runTick);\n          }\n          return canceler;\n        };\n      }\n      return {\n        kill: kill2,\n        join: join4,\n        onComplete,\n        isSuspended: function() {\n          return status === SUSPENDED;\n        },\n        run: function() {\n          if (status === SUSPENDED) {\n            if (!Scheduler.isDraining()) {\n              Scheduler.enqueue(function() {\n                run4(runTick);\n              });\n            } else {\n              run4(runTick);\n            }\n          }\n        }\n      };\n    }\n    function runPar(util, supervisor, par, cb) {\n      var fiberId = 0;\n      var fibers = {};\n      var killId = 0;\n      var kills = {};\n      var early = new Error(\"[ParAff] Early exit\");\n      var interrupt = null;\n      var root = EMPTY;\n      function kill2(error6, par2, cb2) {\n        var step4 = par2;\n        var head4 = null;\n        var tail2 = null;\n        var count = 0;\n        var kills2 = {};\n        var tmp, kid;\n        loop:\n          while (true) {\n            tmp = null;\n            switch (step4.tag) {\n              case FORKED:\n                if (step4._3 === EMPTY) {\n                  tmp = fibers[step4._1];\n                  kills2[count++] = tmp.kill(error6, function(result) {\n                    return function() {\n                      count--;\n                      if (count === 0) {\n                        cb2(result)();\n                      }\n                    };\n                  });\n                }\n                if (head4 === null) {\n                  break loop;\n                }\n                step4 = head4._2;\n                if (tail2 === null) {\n                  head4 = null;\n                } else {\n                  head4 = tail2._1;\n                  tail2 = tail2._2;\n                }\n                break;\n              case MAP:\n                step4 = step4._2;\n                break;\n              case APPLY:\n              case ALT:\n                if (head4) {\n                  tail2 = new Aff2(CONS, head4, tail2);\n                }\n                head4 = step4;\n                step4 = step4._1;\n                break;\n            }\n          }\n        if (count === 0) {\n          cb2(util.right(void 0))();\n        } else {\n          kid = 0;\n          tmp = count;\n          for (; kid < tmp; kid++) {\n            kills2[kid] = kills2[kid]();\n          }\n        }\n        return kills2;\n      }\n      function join4(result, head4, tail2) {\n        var fail2, step4, lhs, rhs, tmp, kid;\n        if (util.isLeft(result)) {\n          fail2 = result;\n          step4 = null;\n        } else {\n          step4 = result;\n          fail2 = null;\n        }\n        loop:\n          while (true) {\n            lhs = null;\n            rhs = null;\n            tmp = null;\n            kid = null;\n            if (interrupt !== null) {\n              return;\n            }\n            if (head4 === null) {\n              cb(fail2 || step4)();\n              return;\n            }\n            if (head4._3 !== EMPTY) {\n              return;\n            }\n            switch (head4.tag) {\n              case MAP:\n                if (fail2 === null) {\n                  head4._3 = util.right(head4._1(util.fromRight(step4)));\n                  step4 = head4._3;\n                } else {\n                  head4._3 = fail2;\n                }\n                break;\n              case APPLY:\n                lhs = head4._1._3;\n                rhs = head4._2._3;\n                if (fail2) {\n                  head4._3 = fail2;\n                  tmp = true;\n                  kid = killId++;\n                  kills[kid] = kill2(early, fail2 === lhs ? head4._2 : head4._1, function() {\n                    return function() {\n                      delete kills[kid];\n                      if (tmp) {\n                        tmp = false;\n                      } else if (tail2 === null) {\n                        join4(fail2, null, null);\n                      } else {\n                        join4(fail2, tail2._1, tail2._2);\n                      }\n                    };\n                  });\n                  if (tmp) {\n                    tmp = false;\n                    return;\n                  }\n                } else if (lhs === EMPTY || rhs === EMPTY) {\n                  return;\n                } else {\n                  step4 = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n                  head4._3 = step4;\n                }\n                break;\n              case ALT:\n                lhs = head4._1._3;\n                rhs = head4._2._3;\n                if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {\n                  return;\n                }\n                if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n                  fail2 = step4 === lhs ? rhs : lhs;\n                  step4 = null;\n                  head4._3 = fail2;\n                } else {\n                  head4._3 = step4;\n                  tmp = true;\n                  kid = killId++;\n                  kills[kid] = kill2(early, step4 === lhs ? head4._2 : head4._1, function() {\n                    return function() {\n                      delete kills[kid];\n                      if (tmp) {\n                        tmp = false;\n                      } else if (tail2 === null) {\n                        join4(step4, null, null);\n                      } else {\n                        join4(step4, tail2._1, tail2._2);\n                      }\n                    };\n                  });\n                  if (tmp) {\n                    tmp = false;\n                    return;\n                  }\n                }\n                break;\n            }\n            if (tail2 === null) {\n              head4 = null;\n            } else {\n              head4 = tail2._1;\n              tail2 = tail2._2;\n            }\n          }\n      }\n      function resolve(fiber) {\n        return function(result) {\n          return function() {\n            delete fibers[fiber._1];\n            fiber._3 = result;\n            join4(result, fiber._2._1, fiber._2._2);\n          };\n        };\n      }\n      function run4() {\n        var status = CONTINUE;\n        var step4 = par;\n        var head4 = null;\n        var tail2 = null;\n        var tmp, fid;\n        loop:\n          while (true) {\n            tmp = null;\n            fid = null;\n            switch (status) {\n              case CONTINUE:\n                switch (step4.tag) {\n                  case MAP:\n                    if (head4) {\n                      tail2 = new Aff2(CONS, head4, tail2);\n                    }\n                    head4 = new Aff2(MAP, step4._1, EMPTY, EMPTY);\n                    step4 = step4._2;\n                    break;\n                  case APPLY:\n                    if (head4) {\n                      tail2 = new Aff2(CONS, head4, tail2);\n                    }\n                    head4 = new Aff2(APPLY, EMPTY, step4._2, EMPTY);\n                    step4 = step4._1;\n                    break;\n                  case ALT:\n                    if (head4) {\n                      tail2 = new Aff2(CONS, head4, tail2);\n                    }\n                    head4 = new Aff2(ALT, EMPTY, step4._2, EMPTY);\n                    step4 = step4._1;\n                    break;\n                  default:\n                    fid = fiberId++;\n                    status = RETURN;\n                    tmp = step4;\n                    step4 = new Aff2(FORKED, fid, new Aff2(CONS, head4, tail2), EMPTY);\n                    tmp = Fiber(util, supervisor, tmp);\n                    tmp.onComplete({\n                      rethrow: false,\n                      handler: resolve(step4)\n                    })();\n                    fibers[fid] = tmp;\n                    if (supervisor) {\n                      supervisor.register(tmp);\n                    }\n                }\n                break;\n              case RETURN:\n                if (head4 === null) {\n                  break loop;\n                }\n                if (head4._1 === EMPTY) {\n                  head4._1 = step4;\n                  status = CONTINUE;\n                  step4 = head4._2;\n                  head4._2 = EMPTY;\n                } else {\n                  head4._2 = step4;\n                  step4 = head4;\n                  if (tail2 === null) {\n                    head4 = null;\n                  } else {\n                    head4 = tail2._1;\n                    tail2 = tail2._2;\n                  }\n                }\n            }\n          }\n        root = step4;\n        for (fid = 0; fid < fiberId; fid++) {\n          fibers[fid].run();\n        }\n      }\n      function cancel(error6, cb2) {\n        interrupt = util.left(error6);\n        var innerKills;\n        for (var kid in kills) {\n          if (kills.hasOwnProperty(kid)) {\n            innerKills = kills[kid];\n            for (kid in innerKills) {\n              if (innerKills.hasOwnProperty(kid)) {\n                innerKills[kid]();\n              }\n            }\n          }\n        }\n        kills = null;\n        var newKills = kill2(error6, root, cb2);\n        return function(killError) {\n          return new Aff2(ASYNC, function(killCb) {\n            return function() {\n              for (var kid2 in newKills) {\n                if (newKills.hasOwnProperty(kid2)) {\n                  newKills[kid2]();\n                }\n              }\n              return nonCanceler2;\n            };\n          });\n        };\n      }\n      run4();\n      return function(killError) {\n        return new Aff2(ASYNC, function(killCb) {\n          return function() {\n            return cancel(killError, killCb);\n          };\n        });\n      };\n    }\n    function sequential3(util, supervisor, par) {\n      return new Aff2(ASYNC, function(cb) {\n        return function() {\n          return runPar(util, supervisor, par, cb);\n        };\n      });\n    }\n    Aff2.EMPTY = EMPTY;\n    Aff2.Pure = AffCtr(PURE);\n    Aff2.Throw = AffCtr(THROW);\n    Aff2.Catch = AffCtr(CATCH);\n    Aff2.Sync = AffCtr(SYNC);\n    Aff2.Async = AffCtr(ASYNC);\n    Aff2.Bind = AffCtr(BIND);\n    Aff2.Bracket = AffCtr(BRACKET);\n    Aff2.Fork = AffCtr(FORK);\n    Aff2.Seq = AffCtr(SEQ);\n    Aff2.ParMap = AffCtr(MAP);\n    Aff2.ParApply = AffCtr(APPLY);\n    Aff2.ParAlt = AffCtr(ALT);\n    Aff2.Fiber = Fiber;\n    Aff2.Supervisor = Supervisor;\n    Aff2.Scheduler = Scheduler;\n    Aff2.nonCanceler = nonCanceler2;\n    return Aff2;\n  }();\n  var _pure = Aff.Pure;\n  var _throwError = Aff.Throw;\n  function _catchError(aff) {\n    return function(k) {\n      return Aff.Catch(aff, k);\n    };\n  }\n  function _map(f2) {\n    return function(aff) {\n      if (aff.tag === Aff.Pure.tag) {\n        return Aff.Pure(f2(aff._1));\n      } else {\n        return Aff.Bind(aff, function(value15) {\n          return Aff.Pure(f2(value15));\n        });\n      }\n    };\n  }\n  function _bind(aff) {\n    return function(k) {\n      return Aff.Bind(aff, k);\n    };\n  }\n  function _fork(immediate) {\n    return function(aff) {\n      return Aff.Fork(immediate, aff);\n    };\n  }\n  var _liftEffect = Aff.Sync;\n  function _parAffMap(f2) {\n    return function(aff) {\n      return Aff.ParMap(f2, aff);\n    };\n  }\n  function _parAffApply(aff1) {\n    return function(aff2) {\n      return Aff.ParApply(aff1, aff2);\n    };\n  }\n  var makeAff = Aff.Async;\n  function generalBracket(acquire) {\n    return function(options2) {\n      return function(k) {\n        return Aff.Bracket(acquire, options2, k);\n      };\n    };\n  }\n  function _makeFiber(util, aff) {\n    return function() {\n      return Aff.Fiber(util, null, aff);\n    };\n  }\n  var _sequential = Aff.Seq;\n\n  // output/Control.Parallel.Class/index.js\n  var sequential = function(dict) {\n    return dict.sequential;\n  };\n  var parallel = function(dict) {\n    return dict.parallel;\n  };\n\n  // output/Control.Parallel/index.js\n  var identity10 = /* @__PURE__ */ identity(categoryFn);\n  var parTraverse_ = function(dictParallel) {\n    var sequential3 = sequential(dictParallel);\n    var parallel4 = parallel(dictParallel);\n    return function(dictApplicative) {\n      var traverse_10 = traverse_(dictApplicative);\n      return function(dictFoldable) {\n        var traverse_15 = traverse_10(dictFoldable);\n        return function(f2) {\n          var $51 = traverse_15(function($53) {\n            return parallel4(f2($53));\n          });\n          return function($52) {\n            return sequential3($51($52));\n          };\n        };\n      };\n    };\n  };\n  var parSequence_ = function(dictParallel) {\n    var parTraverse_1 = parTraverse_(dictParallel);\n    return function(dictApplicative) {\n      var parTraverse_2 = parTraverse_1(dictApplicative);\n      return function(dictFoldable) {\n        return parTraverse_2(dictFoldable)(identity10);\n      };\n    };\n  };\n\n  // output/Effect.Unsafe/foreign.js\n  var unsafePerformEffect = function(f2) {\n    return f2();\n  };\n\n  // output/Effect.Aff/index.js\n  var $runtime_lazy7 = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var pure3 = /* @__PURE__ */ pure(applicativeEffect);\n  var $$void4 = /* @__PURE__ */ $$void(functorEffect);\n  var map11 = /* @__PURE__ */ map(functorEffect);\n  var Canceler = function(x) {\n    return x;\n  };\n  var suspendAff = /* @__PURE__ */ _fork(false);\n  var functorParAff = {\n    map: _parAffMap\n  };\n  var functorAff = {\n    map: _map\n  };\n  var map12 = /* @__PURE__ */ map(functorAff);\n  var forkAff = /* @__PURE__ */ _fork(true);\n  var ffiUtil = /* @__PURE__ */ function() {\n    var unsafeFromRight = function(v) {\n      if (v instanceof Right) {\n        return v.value0;\n      }\n      ;\n      if (v instanceof Left) {\n        return unsafeCrashWith(\"unsafeFromRight: Left\");\n      }\n      ;\n      throw new Error(\"Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): \" + [v.constructor.name]);\n    };\n    var unsafeFromLeft = function(v) {\n      if (v instanceof Left) {\n        return v.value0;\n      }\n      ;\n      if (v instanceof Right) {\n        return unsafeCrashWith(\"unsafeFromLeft: Right\");\n      }\n      ;\n      throw new Error(\"Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): \" + [v.constructor.name]);\n    };\n    var isLeft = function(v) {\n      if (v instanceof Left) {\n        return true;\n      }\n      ;\n      if (v instanceof Right) {\n        return false;\n      }\n      ;\n      throw new Error(\"Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): \" + [v.constructor.name]);\n    };\n    return {\n      isLeft,\n      fromLeft: unsafeFromLeft,\n      fromRight: unsafeFromRight,\n      left: Left.create,\n      right: Right.create\n    };\n  }();\n  var makeFiber = function(aff) {\n    return _makeFiber(ffiUtil, aff);\n  };\n  var launchAff = function(aff) {\n    return function __do2() {\n      var fiber = makeFiber(aff)();\n      fiber.run();\n      return fiber;\n    };\n  };\n  var bracket = function(acquire) {\n    return function(completed) {\n      return generalBracket(acquire)({\n        killed: $$const(completed),\n        failed: $$const(completed),\n        completed: $$const(completed)\n      });\n    };\n  };\n  var applyParAff = {\n    apply: _parAffApply,\n    Functor0: function() {\n      return functorParAff;\n    }\n  };\n  var monadAff = {\n    Applicative0: function() {\n      return applicativeAff;\n    },\n    Bind1: function() {\n      return bindAff;\n    }\n  };\n  var bindAff = {\n    bind: _bind,\n    Apply0: function() {\n      return $lazy_applyAff(0);\n    }\n  };\n  var applicativeAff = {\n    pure: _pure,\n    Apply0: function() {\n      return $lazy_applyAff(0);\n    }\n  };\n  var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy7(\"applyAff\", \"Effect.Aff\", function() {\n    return {\n      apply: ap(monadAff),\n      Functor0: function() {\n        return functorAff;\n      }\n    };\n  });\n  var applyAff = /* @__PURE__ */ $lazy_applyAff(73);\n  var pure22 = /* @__PURE__ */ pure(applicativeAff);\n  var bind1 = /* @__PURE__ */ bind(bindAff);\n  var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindAff);\n  var $$finally = function(fin) {\n    return function(a2) {\n      return bracket(pure22(unit))($$const(fin))($$const(a2));\n    };\n  };\n  var parallelAff = {\n    parallel: unsafeCoerce2,\n    sequential: _sequential,\n    Apply0: function() {\n      return applyAff;\n    },\n    Apply1: function() {\n      return applyParAff;\n    }\n  };\n  var parallel2 = /* @__PURE__ */ parallel(parallelAff);\n  var applicativeParAff = {\n    pure: function($76) {\n      return parallel2(pure22($76));\n    },\n    Apply0: function() {\n      return applyParAff;\n    }\n  };\n  var monadEffectAff = {\n    liftEffect: _liftEffect,\n    Monad0: function() {\n      return monadAff;\n    }\n  };\n  var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);\n  var effectCanceler = function($77) {\n    return Canceler($$const(liftEffect2($77)));\n  };\n  var joinFiber = function(v) {\n    return makeAff(function(k) {\n      return map11(effectCanceler)(v.join(k));\n    });\n  };\n  var functorFiber = {\n    map: function(f2) {\n      return function(t) {\n        return unsafePerformEffect(makeFiber(map12(f2)(joinFiber(t))));\n      };\n    }\n  };\n  var killFiber = function(e) {\n    return function(v) {\n      return bind1(liftEffect2(v.isSuspended))(function(suspended) {\n        if (suspended) {\n          return liftEffect2($$void4(v.kill(e, $$const(pure3(unit)))));\n        }\n        ;\n        return makeAff(function(k) {\n          return map11(effectCanceler)(v.kill(e, k));\n        });\n      });\n    };\n  };\n  var monadThrowAff = {\n    throwError: _throwError,\n    Monad0: function() {\n      return monadAff;\n    }\n  };\n  var monadErrorAff = {\n    catchError: _catchError,\n    MonadThrow0: function() {\n      return monadThrowAff;\n    }\n  };\n  var $$try2 = /* @__PURE__ */ $$try(monadErrorAff);\n  var attempt = $$try2;\n  var runAff = function(k) {\n    return function(aff) {\n      return launchAff(bindFlipped3(function($83) {\n        return liftEffect2(k($83));\n      })($$try2(aff)));\n    };\n  };\n  var runAff_ = function(k) {\n    return function(aff) {\n      return $$void4(runAff(k)(aff));\n    };\n  };\n  var monadRecAff = {\n    tailRecM: function(k) {\n      var go2 = function(a2) {\n        return bind1(k(a2))(function(res) {\n          if (res instanceof Done) {\n            return pure22(res.value0);\n          }\n          ;\n          if (res instanceof Loop) {\n            return go2(res.value0);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Effect.Aff (line 104, column 7 - line 106, column 23): \" + [res.constructor.name]);\n        });\n      };\n      return go2;\n    },\n    Monad0: function() {\n      return monadAff;\n    }\n  };\n  var nonCanceler = /* @__PURE__ */ $$const(/* @__PURE__ */ pure22(unit));\n\n  // output/Effect.Aff.Class/index.js\n  var monadAffAff = {\n    liftAff: /* @__PURE__ */ identity(categoryFn),\n    MonadEffect0: function() {\n      return monadEffectAff;\n    }\n  };\n  var liftAff = function(dict) {\n    return dict.liftAff;\n  };\n\n  // output/Halogen.Query.ChildQuery/index.js\n  var ChildQuery = /* @__PURE__ */ function() {\n    function ChildQuery3(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    ChildQuery3.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new ChildQuery3(value0, value1, value22);\n        };\n      };\n    };\n    return ChildQuery3;\n  }();\n  var unChildQueryBox = unsafeCoerce2;\n  var mkChildQueryBox = unsafeCoerce2;\n\n  // output/Unsafe.Reference/foreign.js\n  function reallyUnsafeRefEq(a2) {\n    return function(b2) {\n      return a2 === b2;\n    };\n  }\n\n  // output/Unsafe.Reference/index.js\n  var unsafeRefEq = reallyUnsafeRefEq;\n\n  // output/Halogen.Subscription/index.js\n  var $$void5 = /* @__PURE__ */ $$void(functorEffect);\n  var bind3 = /* @__PURE__ */ bind(bindEffect);\n  var append4 = /* @__PURE__ */ append(semigroupArray);\n  var traverse_2 = /* @__PURE__ */ traverse_(applicativeEffect);\n  var traverse_1 = /* @__PURE__ */ traverse_2(foldableArray);\n  var unsubscribe = function(v) {\n    return v;\n  };\n  var subscribe = function(v) {\n    return function(k) {\n      return v(function($76) {\n        return $$void5(k($76));\n      });\n    };\n  };\n  var notify = function(v) {\n    return function(a2) {\n      return v(a2);\n    };\n  };\n  var create = function __do() {\n    var subscribers = $$new([])();\n    return {\n      emitter: function(k) {\n        return function __do2() {\n          modify_(function(v) {\n            return append4(v)([k]);\n          })(subscribers)();\n          return modify_(deleteBy(unsafeRefEq)(k))(subscribers);\n        };\n      },\n      listener: function(a2) {\n        return bind3(read(subscribers))(traverse_1(function(k) {\n          return k(a2);\n        }));\n      }\n    };\n  };\n\n  // output/Halogen.Query.HalogenM/index.js\n  var identity11 = /* @__PURE__ */ identity(categoryFn);\n  var foldrWithIndex2 = /* @__PURE__ */ foldrWithIndex(foldableWithIndexMap);\n  var traverse2 = /* @__PURE__ */ traverse(traversableMap);\n  var slots2 = /* @__PURE__ */ slots();\n  var lookup4 = /* @__PURE__ */ lookup2();\n  var SubscriptionId = function(x) {\n    return x;\n  };\n  var ForkId = function(x) {\n    return x;\n  };\n  var State = /* @__PURE__ */ function() {\n    function State2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    State2.create = function(value0) {\n      return new State2(value0);\n    };\n    return State2;\n  }();\n  var Subscribe = /* @__PURE__ */ function() {\n    function Subscribe2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Subscribe2.create = function(value0) {\n      return function(value1) {\n        return new Subscribe2(value0, value1);\n      };\n    };\n    return Subscribe2;\n  }();\n  var Unsubscribe = /* @__PURE__ */ function() {\n    function Unsubscribe2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Unsubscribe2.create = function(value0) {\n      return function(value1) {\n        return new Unsubscribe2(value0, value1);\n      };\n    };\n    return Unsubscribe2;\n  }();\n  var Lift2 = /* @__PURE__ */ function() {\n    function Lift3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Lift3.create = function(value0) {\n      return new Lift3(value0);\n    };\n    return Lift3;\n  }();\n  var ChildQuery2 = /* @__PURE__ */ function() {\n    function ChildQuery3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    ChildQuery3.create = function(value0) {\n      return new ChildQuery3(value0);\n    };\n    return ChildQuery3;\n  }();\n  var Raise = /* @__PURE__ */ function() {\n    function Raise2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Raise2.create = function(value0) {\n      return function(value1) {\n        return new Raise2(value0, value1);\n      };\n    };\n    return Raise2;\n  }();\n  var Par = /* @__PURE__ */ function() {\n    function Par2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Par2.create = function(value0) {\n      return new Par2(value0);\n    };\n    return Par2;\n  }();\n  var Fork = /* @__PURE__ */ function() {\n    function Fork2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Fork2.create = function(value0) {\n      return function(value1) {\n        return new Fork2(value0, value1);\n      };\n    };\n    return Fork2;\n  }();\n  var Join = /* @__PURE__ */ function() {\n    function Join2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Join2.create = function(value0) {\n      return function(value1) {\n        return new Join2(value0, value1);\n      };\n    };\n    return Join2;\n  }();\n  var Kill = /* @__PURE__ */ function() {\n    function Kill2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Kill2.create = function(value0) {\n      return function(value1) {\n        return new Kill2(value0, value1);\n      };\n    };\n    return Kill2;\n  }();\n  var GetRef = /* @__PURE__ */ function() {\n    function GetRef2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    GetRef2.create = function(value0) {\n      return function(value1) {\n        return new GetRef2(value0, value1);\n      };\n    };\n    return GetRef2;\n  }();\n  var HalogenM = function(x) {\n    return x;\n  };\n  var subscribe2 = function(es) {\n    return liftF(new Subscribe(function(v) {\n      return es;\n    }, identity11));\n  };\n  var raise = function(o) {\n    return liftF(new Raise(o, unit));\n  };\n  var queryAll = function() {\n    return function(dictIsSymbol) {\n      var slots1 = slots2(dictIsSymbol);\n      return function(dictOrd) {\n        var slots22 = slots1(dictOrd);\n        return function(label5) {\n          return function(q2) {\n            var catMapMaybes = function(dictOrd1) {\n              var insert10 = insert(dictOrd1);\n              return foldrWithIndex2(function(k) {\n                return function(v) {\n                  return function(acc) {\n                    return maybe(acc)(flip(insert10(k))(acc))(v);\n                  };\n                };\n              })(empty2);\n            };\n            var catMapMaybes1 = catMapMaybes(dictOrd);\n            return liftF(new ChildQuery2(mkChildQueryBox(new ChildQuery(function(dictApplicative) {\n              var map42 = map(dictApplicative.Apply0().Functor0());\n              var traverse12 = traverse2(dictApplicative);\n              return function(k) {\n                var $173 = map42(catMapMaybes1);\n                var $174 = traverse12(k);\n                var $175 = slots22(label5);\n                return function($176) {\n                  return $173($174($175($176)));\n                };\n              };\n            }, q2, identity11))));\n          };\n        };\n      };\n    };\n  };\n  var query = function() {\n    return function(dictIsSymbol) {\n      var lookup13 = lookup4(dictIsSymbol);\n      return function(dictOrd) {\n        var lookup23 = lookup13(dictOrd);\n        return function(label5) {\n          return function(p2) {\n            return function(q2) {\n              return liftF(new ChildQuery2(mkChildQueryBox(new ChildQuery(function(dictApplicative) {\n                var pure18 = pure(dictApplicative);\n                return function(k) {\n                  var $177 = maybe(pure18(Nothing.value))(k);\n                  var $178 = lookup23(label5)(p2);\n                  return function($179) {\n                    return $177($178($179));\n                  };\n                };\n              }, q2, identity11))));\n            };\n          };\n        };\n      };\n    };\n  };\n  var ordSubscriptionId = ordInt;\n  var ordForkId = ordInt;\n  var monoidHalogenM = function(dictMonoid) {\n    return monoidFree(dictMonoid);\n  };\n  var monadHalogenM = freeMonad;\n  var monadStateHalogenM = {\n    state: function($181) {\n      return HalogenM(liftF(State.create($181)));\n    },\n    Monad0: function() {\n      return monadHalogenM;\n    }\n  };\n  var monadThrowHalogenM = function(dictMonadThrow) {\n    return {\n      throwError: function() {\n        var $184 = throwError(dictMonadThrow);\n        return function($185) {\n          return HalogenM(liftF(Lift2.create($184($185))));\n        };\n      }(),\n      Monad0: function() {\n        return monadHalogenM;\n      }\n    };\n  };\n  var monadEffectHalogenM = function(dictMonadEffect) {\n    return {\n      liftEffect: function() {\n        var $186 = liftEffect(dictMonadEffect);\n        return function($187) {\n          return HalogenM(liftF(Lift2.create($186($187))));\n        };\n      }(),\n      Monad0: function() {\n        return monadHalogenM;\n      }\n    };\n  };\n  var monadAffHalogenM = function(dictMonadAff) {\n    var monadEffectHalogenM1 = monadEffectHalogenM(dictMonadAff.MonadEffect0());\n    return {\n      liftAff: function() {\n        var $188 = liftAff(dictMonadAff);\n        return function($189) {\n          return HalogenM(liftF(Lift2.create($188($189))));\n        };\n      }(),\n      MonadEffect0: function() {\n        return monadEffectHalogenM1;\n      }\n    };\n  };\n  var kill = function(fid) {\n    return liftF(new Kill(fid, unit));\n  };\n  var getRef = function(p2) {\n    return liftF(new GetRef(p2, identity11));\n  };\n  var functorHalogenM = freeFunctor;\n  var fork = function(hmu) {\n    return liftF(new Fork(hmu, identity11));\n  };\n  var bindHalogenM = freeBind;\n  var applyHalogenM = freeApply;\n  var applicativeHalogenM = freeApplicative;\n\n  // output/Halogen.Query.HalogenQ/index.js\n  var Initialize = /* @__PURE__ */ function() {\n    function Initialize5(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Initialize5.create = function(value0) {\n      return new Initialize5(value0);\n    };\n    return Initialize5;\n  }();\n  var Finalize = /* @__PURE__ */ function() {\n    function Finalize2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Finalize2.create = function(value0) {\n      return new Finalize2(value0);\n    };\n    return Finalize2;\n  }();\n  var Receive = /* @__PURE__ */ function() {\n    function Receive5(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Receive5.create = function(value0) {\n      return function(value1) {\n        return new Receive5(value0, value1);\n      };\n    };\n    return Receive5;\n  }();\n  var Action2 = /* @__PURE__ */ function() {\n    function Action3(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Action3.create = function(value0) {\n      return function(value1) {\n        return new Action3(value0, value1);\n      };\n    };\n    return Action3;\n  }();\n  var Query = /* @__PURE__ */ function() {\n    function Query3(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Query3.create = function(value0) {\n      return function(value1) {\n        return new Query3(value0, value1);\n      };\n    };\n    return Query3;\n  }();\n\n  // output/Halogen.VDom.Thunk/index.js\n  var $runtime_lazy8 = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var unsafeEqThunk = function(v, v1) {\n    return refEq2(v.value0, v1.value0) && (refEq2(v.value1, v1.value1) && v.value1(v.value3, v1.value3));\n  };\n  var runThunk = function(v) {\n    return v.value2(v.value3);\n  };\n  var buildThunk = function(toVDom) {\n    var haltThunk = function(state3) {\n      return halt(state3.vdom);\n    };\n    var $lazy_patchThunk = $runtime_lazy8(\"patchThunk\", \"Halogen.VDom.Thunk\", function() {\n      return function(state3, t2) {\n        var $48 = unsafeEqThunk(state3.thunk, t2);\n        if ($48) {\n          return mkStep(new Step2(extract2(state3.vdom), state3, $lazy_patchThunk(112), haltThunk));\n        }\n        ;\n        var vdom = step(state3.vdom, toVDom(runThunk(t2)));\n        return mkStep(new Step2(extract2(vdom), {\n          vdom,\n          thunk: t2\n        }, $lazy_patchThunk(115), haltThunk));\n      };\n    });\n    var patchThunk = $lazy_patchThunk(108);\n    var renderThunk = function(spec) {\n      return function(t) {\n        var vdom = buildVDom(spec)(toVDom(runThunk(t)));\n        return mkStep(new Step2(extract2(vdom), {\n          thunk: t,\n          vdom\n        }, patchThunk, haltThunk));\n      };\n    };\n    return renderThunk;\n  };\n\n  // output/Halogen.Component/index.js\n  var voidLeft2 = /* @__PURE__ */ voidLeft(functorHalogenM);\n  var traverse_3 = /* @__PURE__ */ traverse_(applicativeHalogenM)(foldableMaybe);\n  var map13 = /* @__PURE__ */ map(functorHalogenM);\n  var pure4 = /* @__PURE__ */ pure(applicativeHalogenM);\n  var lookup5 = /* @__PURE__ */ lookup2();\n  var pop3 = /* @__PURE__ */ pop2();\n  var insert4 = /* @__PURE__ */ insert2();\n  var ComponentSlot = /* @__PURE__ */ function() {\n    function ComponentSlot2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    ComponentSlot2.create = function(value0) {\n      return new ComponentSlot2(value0);\n    };\n    return ComponentSlot2;\n  }();\n  var ThunkSlot = /* @__PURE__ */ function() {\n    function ThunkSlot2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    ThunkSlot2.create = function(value0) {\n      return new ThunkSlot2(value0);\n    };\n    return ThunkSlot2;\n  }();\n  var unComponentSlot = unsafeCoerce2;\n  var unComponent = unsafeCoerce2;\n  var mkEval = function(args) {\n    return function(v) {\n      if (v instanceof Initialize) {\n        return voidLeft2(traverse_3(args.handleAction)(args.initialize))(v.value0);\n      }\n      ;\n      if (v instanceof Finalize) {\n        return voidLeft2(traverse_3(args.handleAction)(args.finalize))(v.value0);\n      }\n      ;\n      if (v instanceof Receive) {\n        return voidLeft2(traverse_3(args.handleAction)(args.receive(v.value0)))(v.value1);\n      }\n      ;\n      if (v instanceof Action2) {\n        return voidLeft2(args.handleAction(v.value0))(v.value1);\n      }\n      ;\n      if (v instanceof Query) {\n        return unCoyoneda(function(g) {\n          var $45 = map13(maybe(v.value1(unit))(g));\n          return function($46) {\n            return $45(args.handleQuery($46));\n          };\n        })(v.value0);\n      }\n      ;\n      throw new Error(\"Failed pattern match at Halogen.Component (line 182, column 15 - line 192, column 71): \" + [v.constructor.name]);\n    };\n  };\n  var mkComponentSlot = unsafeCoerce2;\n  var mkComponent = unsafeCoerce2;\n  var defaultEval = /* @__PURE__ */ function() {\n    return {\n      handleAction: $$const(pure4(unit)),\n      handleQuery: $$const(pure4(Nothing.value)),\n      receive: $$const(Nothing.value),\n      initialize: Nothing.value,\n      finalize: Nothing.value\n    };\n  }();\n  var componentSlot = function() {\n    return function(dictIsSymbol) {\n      var lookup13 = lookup5(dictIsSymbol);\n      var pop12 = pop3(dictIsSymbol);\n      var insert13 = insert4(dictIsSymbol);\n      return function(dictOrd) {\n        var lookup23 = lookup13(dictOrd);\n        var pop22 = pop12(dictOrd);\n        var insert22 = insert13(dictOrd);\n        return function(label5) {\n          return function(p2) {\n            return function(comp) {\n              return function(input3) {\n                return function(output2) {\n                  return mkComponentSlot({\n                    get: lookup23(label5)(p2),\n                    pop: pop22(label5)(p2),\n                    set: insert22(label5)(p2),\n                    component: comp,\n                    input: input3,\n                    output: output2\n                  });\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n\n  // output/Halogen.HTML.Elements/index.js\n  var element2 = /* @__PURE__ */ function() {\n    return element(Nothing.value);\n  }();\n  var footer = /* @__PURE__ */ element2(\"footer\");\n  var h1 = /* @__PURE__ */ element2(\"h1\");\n  var h2 = /* @__PURE__ */ element2(\"h2\");\n  var header = /* @__PURE__ */ element2(\"header\");\n  var i = /* @__PURE__ */ element2(\"i\");\n  var input = function(props) {\n    return element2(\"input\")(props)([]);\n  };\n  var li = /* @__PURE__ */ element2(\"li\");\n  var main = /* @__PURE__ */ element2(\"main\");\n  var option = /* @__PURE__ */ element2(\"option\");\n  var select = /* @__PURE__ */ element2(\"select\");\n  var ul = /* @__PURE__ */ element2(\"ul\");\n  var div2 = /* @__PURE__ */ element2(\"div\");\n  var div_ = /* @__PURE__ */ div2([]);\n  var button = /* @__PURE__ */ element2(\"button\");\n  var a = /* @__PURE__ */ element2(\"a\");\n\n  // output/Control.Monad.Except/index.js\n  var unwrap2 = /* @__PURE__ */ unwrap();\n  var runExcept = function($3) {\n    return unwrap2(runExceptT($3));\n  };\n\n  // output/Foreign.Index/foreign.js\n  function unsafeReadPropImpl(f2, s, key, value15) {\n    return value15 == null ? f2 : s(value15[key]);\n  }\n\n  // output/Foreign.Index/index.js\n  var unsafeReadProp = function(dictMonad) {\n    var fail2 = fail(dictMonad);\n    var pure18 = pure(applicativeExceptT(dictMonad));\n    return function(k) {\n      return function(value15) {\n        return unsafeReadPropImpl(fail2(new TypeMismatch(\"object\", typeOf(value15))), pure18, k, value15);\n      };\n    };\n  };\n  var readProp = function(dictMonad) {\n    return unsafeReadProp(dictMonad);\n  };\n\n  // output/Web.Event.Event/foreign.js\n  function _currentTarget(e) {\n    return e.currentTarget;\n  }\n  function _target(e) {\n    return e.target;\n  }\n  function preventDefault(e) {\n    return function() {\n      return e.preventDefault();\n    };\n  }\n\n  // output/Control.Alternative/index.js\n  var guard = function(dictAlternative) {\n    var pure18 = pure(dictAlternative.Applicative0());\n    var empty8 = empty(dictAlternative.Plus1());\n    return function(v) {\n      if (v) {\n        return pure18(unit);\n      }\n      ;\n      if (!v) {\n        return empty8;\n      }\n      ;\n      throw new Error(\"Failed pattern match at Control.Alternative (line 48, column 1 - line 48, column 54): \" + [v.constructor.name]);\n    };\n  };\n\n  // output/Web.Event.Event/index.js\n  var target = function($3) {\n    return toMaybe(_target($3));\n  };\n  var currentTarget = function($5) {\n    return toMaybe(_currentTarget($5));\n  };\n\n  // output/Web.HTML.Event.DragEvent.EventTypes/index.js\n  var drop3 = \"drop\";\n  var dragstart = \"dragstart\";\n  var dragover = \"dragover\";\n  var dragenter = \"dragenter\";\n\n  // output/Web.HTML.Event.EventTypes/index.js\n  var domcontentloaded = \"DOMContentLoaded\";\n  var change = \"change\";\n\n  // output/Web.HTML.HTMLInputElement/foreign.js\n  function select2(input3) {\n    return function() {\n      input3.select();\n    };\n  }\n\n  // output/Web.HTML.HTMLInputElement/index.js\n  var fromEventTarget = /* @__PURE__ */ unsafeReadProtoTagged(\"HTMLInputElement\");\n\n  // output/Web.UIEvent.FocusEvent.EventTypes/index.js\n  var focus = \"focus\";\n\n  // output/Web.UIEvent.MouseEvent.EventTypes/index.js\n  var click = \"click\";\n\n  // output/Halogen.HTML.Events/index.js\n  var map14 = /* @__PURE__ */ map(functorMaybe);\n  var composeKleisli2 = /* @__PURE__ */ composeKleisli(bindMaybe);\n  var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(/* @__PURE__ */ bindExceptT(monadIdentity));\n  var readProp2 = /* @__PURE__ */ readProp(monadIdentity);\n  var readString2 = /* @__PURE__ */ readString(monadIdentity);\n  var mouseHandler = unsafeCoerce2;\n  var handler$prime = function(et) {\n    return function(f2) {\n      return handler(et)(function(ev) {\n        return map14(Action.create)(f2(ev));\n      });\n    };\n  };\n  var handler2 = function(et) {\n    return function(f2) {\n      return handler(et)(function(ev) {\n        return new Just(new Action(f2(ev)));\n      });\n    };\n  };\n  var onClick = /* @__PURE__ */ function() {\n    var $15 = handler2(click);\n    return function($16) {\n      return $15(mouseHandler($16));\n    };\n  }();\n  var focusHandler = unsafeCoerce2;\n  var onFocus = /* @__PURE__ */ function() {\n    var $57 = handler2(focus);\n    return function($58) {\n      return $57(focusHandler($58));\n    };\n  }();\n  var dragHandler = unsafeCoerce2;\n  var onDragEnter = /* @__PURE__ */ function() {\n    var $67 = handler2(dragenter);\n    return function($68) {\n      return $67(dragHandler($68));\n    };\n  }();\n  var onDragOver = /* @__PURE__ */ function() {\n    var $73 = handler2(dragover);\n    return function($74) {\n      return $73(dragHandler($74));\n    };\n  }();\n  var onDragStart = /* @__PURE__ */ function() {\n    var $75 = handler2(dragstart);\n    return function($76) {\n      return $75(dragHandler($76));\n    };\n  }();\n  var onDrop = /* @__PURE__ */ function() {\n    var $77 = handler2(drop3);\n    return function($78) {\n      return $77(dragHandler($78));\n    };\n  }();\n  var addForeignPropHandler = function(key) {\n    return function(prop3) {\n      return function(reader) {\n        return function(f2) {\n          var go2 = function(a2) {\n            return composeKleisliFlipped2(reader)(readProp2(prop3))(unsafeToForeign(a2));\n          };\n          return handler$prime(key)(composeKleisli2(currentTarget)(function(e) {\n            return either($$const(Nothing.value))(function($85) {\n              return Just.create(f2($85));\n            })(runExcept(go2(e)));\n          }));\n        };\n      };\n    };\n  };\n  var onValueChange = /* @__PURE__ */ addForeignPropHandler(change)(\"value\")(readString2);\n\n  // output/Halogen.HTML.Properties/index.js\n  var unwrap3 = /* @__PURE__ */ unwrap();\n  var ref2 = /* @__PURE__ */ function() {\n    var go2 = function(p2) {\n      return function(mel) {\n        return new Just(new RefUpdate(p2, mel));\n      };\n    };\n    return function($29) {\n      return ref(go2($29));\n    };\n  }();\n  var prop2 = function(dictIsProp) {\n    return prop(dictIsProp);\n  };\n  var prop1 = /* @__PURE__ */ prop2(isPropBoolean);\n  var prop22 = /* @__PURE__ */ prop2(isPropString);\n  var prop4 = /* @__PURE__ */ prop2(isPropNumber);\n  var rel = /* @__PURE__ */ prop22(\"rel\");\n  var step3 = /* @__PURE__ */ prop2(isPropStepValue)(\"step\");\n  var target2 = /* @__PURE__ */ prop22(\"target\");\n  var type_3 = function(dictIsProp) {\n    return prop2(dictIsProp)(\"type\");\n  };\n  var value2 = function(dictIsProp) {\n    return prop2(dictIsProp)(\"value\");\n  };\n  var min4 = /* @__PURE__ */ prop4(\"min\");\n  var max4 = /* @__PURE__ */ prop4(\"max\");\n  var href = /* @__PURE__ */ prop22(\"href\");\n  var draggable = /* @__PURE__ */ prop1(\"draggable\");\n  var classes = /* @__PURE__ */ function() {\n    var $32 = prop22(\"className\");\n    var $33 = joinWith(\" \");\n    var $34 = map(functorArray)(unwrap3);\n    return function($35) {\n      return $32($33($34($35)));\n    };\n  }();\n  var class_ = /* @__PURE__ */ function() {\n    var $36 = prop22(\"className\");\n    return function($37) {\n      return $36(unwrap3($37));\n    };\n  }();\n\n  // output/Record/index.js\n  var insert5 = function(dictIsSymbol) {\n    var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n    return function() {\n      return function() {\n        return function(l) {\n          return function(a2) {\n            return function(r) {\n              return unsafeSet(reflectSymbol2(l))(a2)(r);\n            };\n          };\n        };\n      };\n    };\n  };\n  var get2 = function(dictIsSymbol) {\n    var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n    return function() {\n      return function(l) {\n        return function(r) {\n          return unsafeGet(reflectSymbol2(l))(r);\n        };\n      };\n    };\n  };\n\n  // output/Util.Halogen/index.js\n  var append12 = /* @__PURE__ */ append(semigroupArray);\n  var fa_ = function(s) {\n    return i([class_(\"fa-solid \" + s)])([]);\n  };\n  var fa = function(s) {\n    return function(c) {\n      return i([classes(append12([\"fa-solid \" + s])(c))])([]);\n    };\n  };\n  var empty7 = /* @__PURE__ */ text(/* @__PURE__ */ mempty(monoidString));\n  var button2 = function(content3) {\n    return function(style2) {\n      return function(h) {\n        return button([classes([\"rounded w-full h-full py-1 px-2 transition-colors duration-75\", style2]), onClick($$const(h))])([content3]);\n      };\n    };\n  };\n  var downButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-angle-down\"))(\"text-gray-500 hover:bg-gray-200\");\n  var plusButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-plus\"))(\"border border-sky-500 text-sky-700 hover:bg-sky-200\");\n  var removeButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-xmark\"))(\"text-gray-500 hover:bg-gray-200\");\n  var toggleButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-arrows-rotate\"))(\"text-gray-500 hover:bg-gray-200\");\n  var upButton = /* @__PURE__ */ button2(/* @__PURE__ */ fa_(\"fa-angle-up\"))(\"text-gray-500 hover:bg-gray-200\");\n\n  // output/App.Selector/index.js\n  var not2 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));\n  var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorArray);\n  var discard2 = /* @__PURE__ */ discard(discardUnit)(/* @__PURE__ */ bindMaybeT(monadHalogenM));\n  var put2 = /* @__PURE__ */ put(/* @__PURE__ */ monadStateMaybeT(monadStateHalogenM));\n  var pure5 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeMaybeT(monadHalogenM));\n  var map15 = /* @__PURE__ */ map(functorArray);\n  var insert6 = /* @__PURE__ */ insert5({\n    reflectSymbol: function() {\n      return \"selected\";\n    }\n  })()();\n  var modify_3 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n  var bind4 = /* @__PURE__ */ bind(bindHalogenM);\n  var modify5 = /* @__PURE__ */ modify2(monadStateHalogenM);\n  var whenM2 = /* @__PURE__ */ whenM(monadHalogenM);\n  var gets2 = /* @__PURE__ */ gets(monadStateHalogenM);\n  var bind12 = /* @__PURE__ */ bind(bindFn);\n  var SetItems = /* @__PURE__ */ function() {\n    function SetItems2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    SetItems2.create = function(value0) {\n      return function(value1) {\n        return new SetItems2(value0, value1);\n      };\n    };\n    return SetItems2;\n  }();\n  var EnterEdit = /* @__PURE__ */ function() {\n    function EnterEdit2() {\n    }\n    ;\n    EnterEdit2.value = new EnterEdit2();\n    return EnterEdit2;\n  }();\n  var LeaveEdit = /* @__PURE__ */ function() {\n    function LeaveEdit2() {\n    }\n    ;\n    LeaveEdit2.value = new LeaveEdit2();\n    return LeaveEdit2;\n  }();\n  var Toggle = /* @__PURE__ */ function() {\n    function Toggle2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Toggle2.create = function(value0) {\n      return new Toggle2(value0);\n    };\n    return Toggle2;\n  }();\n  var Receive2 = /* @__PURE__ */ function() {\n    function Receive5(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Receive5.create = function(value0) {\n      return new Receive5(value0);\n    };\n    return Receive5;\n  }();\n  var component = function(dictEq) {\n    var eq8 = eq(dictEq);\n    var renderItem = function(isEditMode) {\n      return function(item) {\n        return li([class_(function() {\n          var $48 = item.selected || isEditMode;\n          if ($48) {\n            return \"min-w-0\";\n          }\n          ;\n          return \"hidden\";\n        }())])([button([classes([\"h-full w-full rounded border px-3 py-1 transition-colors duration-75\", function() {\n          if (item.selected) {\n            return \"border-sky-700 bg-sky-500 text-white hover:bg-sky-600\";\n          }\n          ;\n          return \"border-gray-800 bg-gray-300 text-black hover:bg-gray-400\";\n        }()]), onClick($$const(new Toggle(item.id)))])([text(item.value)])]);\n      };\n    };\n    var renderBackground = function(isEditMode) {\n      return div2([class_(function() {\n        if (isEditMode) {\n          return \"fixed inset-0 bg-black opacity-20\";\n        }\n        ;\n        return \"hidden\";\n      }()), onClick($$const(LeaveEdit.value))])([]);\n    };\n    var renderAddButton = div_([plusButton(EnterEdit.value)]);\n    var render = function(v) {\n      return div2([class_(\"mx-1 flex\")])([function() {\n        var $52 = all2(not2(function(v1) {\n          return v1.selected;\n        }))(v.items) || v.isEditMode;\n        if ($52) {\n          return renderAddButton;\n        }\n        ;\n        return empty7;\n      }(), renderBackground(v.isEditMode), ul([class_(function() {\n        if (v.isEditMode) {\n          return \"break-anywhere absolute flex min-w-48 flex-col gap-0.5 bg-white p-4 shadow-md\";\n        }\n        ;\n        return \"break-anywhere flex w-full flex-wrap gap-1\";\n      }()), onClick($$const(EnterEdit.value))])(mapFlipped2(v.items)(renderItem(v.isEditMode)))]);\n    };\n    var query3 = function(v) {\n      return discard2(put2({\n        items: v.value0,\n        isEditMode: false\n      }))(function() {\n        return pure5(v.value1);\n      });\n    };\n    var initialState = function() {\n      var $83 = map15(insert6($$Proxy.value)(false));\n      return function($84) {\n        return /* @__PURE__ */ function(v) {\n          return {\n            items: v,\n            isEditMode: false\n          };\n        }($83($84));\n      };\n    }();\n    var action2 = function(v) {\n      if (v instanceof EnterEdit) {\n        return modify_3(function(v1) {\n          var $60 = {};\n          for (var $61 in v1) {\n            if ({}.hasOwnProperty.call(v1, $61)) {\n              $60[$61] = v1[$61];\n            }\n            ;\n          }\n          ;\n          $60.isEditMode = true;\n          return $60;\n        });\n      }\n      ;\n      if (v instanceof LeaveEdit) {\n        return bind4(modify5(function(v1) {\n          var $63 = {};\n          for (var $64 in v1) {\n            if ({}.hasOwnProperty.call(v1, $64)) {\n              $63[$64] = v1[$64];\n            }\n            ;\n          }\n          ;\n          $63.isEditMode = false;\n          return $63;\n        }))(function(v1) {\n          return raise(mapFlipped2(filter(function(v2) {\n            return v2.selected;\n          })(v1.items))(function(v2) {\n            return v2.id;\n          }));\n        });\n      }\n      ;\n      if (v instanceof Toggle) {\n        return whenM2(gets2(function(v1) {\n          return v1.isEditMode;\n        }))(modify_3(bind12(function(v1) {\n          return v1.items;\n        })(function(items3) {\n          var items$prime = mapFlipped2(items3)(function(item) {\n            var $68 = eq8(item.id)(v.value0);\n            if ($68) {\n              var $69 = {};\n              for (var $70 in item) {\n                if ({}.hasOwnProperty.call(item, $70)) {\n                  $69[$70] = item[$70];\n                }\n                ;\n              }\n              ;\n              $69.selected = !item.selected;\n              return $69;\n            }\n            ;\n            return item;\n          });\n          return function(v1) {\n            var $72 = {};\n            for (var $73 in v1) {\n              if ({}.hasOwnProperty.call(v1, $73)) {\n                $72[$73] = v1[$73];\n              }\n              ;\n            }\n            ;\n            $72.items = items$prime;\n            return $72;\n          };\n        })));\n      }\n      ;\n      if (v instanceof Receive2) {\n        return modify_3(bind12(function(v1) {\n          return v1.items;\n        })(function(items3) {\n          var items$prime = mapFlipped2(v.value0)(function(v1) {\n            return {\n              id: v1.id,\n              value: v1.value,\n              selected: maybe(false)(function(v2) {\n                return v2.selected;\n              })(find2(function($85) {\n                return function(v2) {\n                  return eq8(v2)(v1.id);\n                }(function(v2) {\n                  return v2.id;\n                }($85));\n              })(items3))\n            };\n          });\n          return function(v1) {\n            var $79 = {};\n            for (var $80 in v1) {\n              if ({}.hasOwnProperty.call(v1, $80)) {\n                $79[$80] = v1[$80];\n              }\n              ;\n            }\n            ;\n            $79.items = items$prime;\n            return $79;\n          };\n        }));\n      }\n      ;\n      throw new Error(\"Failed pattern match at App.Selector (line 92, column 12 - line 108, column 29): \" + [v.constructor.name]);\n    };\n    return mkComponent({\n      initialState,\n      render,\n      \"eval\": mkEval({\n        initialize: defaultEval.initialize,\n        finalize: defaultEval.finalize,\n        handleAction: action2,\n        handleQuery: function($86) {\n          return runMaybeT(query3($86));\n        },\n        receive: function($87) {\n          return Just.create(Receive2.create($87));\n        }\n      })\n    });\n  };\n\n  // output/Halogen.HTML/index.js\n  var componentSlot2 = /* @__PURE__ */ componentSlot();\n  var slot_ = function() {\n    return function(dictIsSymbol) {\n      var componentSlot1 = componentSlot2(dictIsSymbol);\n      return function(dictOrd) {\n        var componentSlot22 = componentSlot1(dictOrd);\n        return function(label5) {\n          return function(p2) {\n            return function(component7) {\n              return function(input3) {\n                return widget(new ComponentSlot(componentSlot22(label5)(p2)(component7)(input3)($$const(Nothing.value))));\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  var slot = function() {\n    return function(dictIsSymbol) {\n      var componentSlot1 = componentSlot2(dictIsSymbol);\n      return function(dictOrd) {\n        var componentSlot22 = componentSlot1(dictOrd);\n        return function(label5) {\n          return function(p2) {\n            return function(component7) {\n              return function(input3) {\n                return function(outputQuery) {\n                  return widget(new ComponentSlot(componentSlot22(label5)(p2)(component7)(input3)(function($11) {\n                    return Just.create(outputQuery($11));\n                  })));\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n\n  // output/Web.HTML.HTMLElement/foreign.js\n  function _read(nothing, just, value15) {\n    var tag = Object.prototype.toString.call(value15);\n    if (tag.indexOf(\"[object HTML\") === 0 && tag.indexOf(\"Element]\") === tag.length - 8) {\n      return just(value15);\n    } else {\n      return nothing;\n    }\n  }\n\n  // output/Web.HTML.HTMLElement/index.js\n  var toNode2 = unsafeCoerce2;\n  var fromElement = function(x) {\n    return _read(Nothing.value, Just.create, x);\n  };\n\n  // output/Halogen.Query/index.js\n  var $$void6 = /* @__PURE__ */ $$void(functorHalogenM);\n  var queryAll2 = /* @__PURE__ */ queryAll();\n  var query2 = /* @__PURE__ */ query();\n  var identity12 = /* @__PURE__ */ identity(categoryFn);\n  var tell2 = function() {\n    return function(dictIsSymbol) {\n      var query1 = query2(dictIsSymbol);\n      return function(dictOrd) {\n        var query22 = query1(dictOrd);\n        return function(slot5) {\n          return function(label5) {\n            return function(req) {\n              return $$void6(query22(slot5)(label5)(req(unit)));\n            };\n          };\n        };\n      };\n    };\n  };\n  var requestAll = function() {\n    return function(dictIsSymbol) {\n      var queryAll1 = queryAll2(dictIsSymbol);\n      return function(dictOrd) {\n        var queryAll22 = queryAll1(dictOrd);\n        return function(label5) {\n          return function(req) {\n            return queryAll22(label5)(req(identity12));\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Argonaut.Core/foreign.js\n  function id2(x) {\n    return x;\n  }\n  function stringify(j) {\n    return JSON.stringify(j);\n  }\n  function _caseJson(isNull3, isBool, isNum, isStr, isArr, isObj, j) {\n    if (j == null)\n      return isNull3();\n    else if (typeof j === \"boolean\")\n      return isBool(j);\n    else if (typeof j === \"number\")\n      return isNum(j);\n    else if (typeof j === \"string\")\n      return isStr(j);\n    else if (Object.prototype.toString.call(j) === \"[object Array]\")\n      return isArr(j);\n    else\n      return isObj(j);\n  }\n\n  // output/Data.Argonaut.Core/index.js\n  var verbJsonType = function(def) {\n    return function(f2) {\n      return function(g) {\n        return g(def)(f2);\n      };\n    };\n  };\n  var toJsonType = /* @__PURE__ */ function() {\n    return verbJsonType(Nothing.value)(Just.create);\n  }();\n  var caseJsonString = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), $$const(d), $$const(d), f2, $$const(d), $$const(d), j);\n      };\n    };\n  };\n  var caseJsonObject = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), $$const(d), f2, j);\n      };\n    };\n  };\n  var toObject = /* @__PURE__ */ toJsonType(caseJsonObject);\n  var caseJsonNumber = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), $$const(d), f2, $$const(d), $$const(d), $$const(d), j);\n      };\n    };\n  };\n  var caseJsonBoolean = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), f2, $$const(d), $$const(d), $$const(d), $$const(d), j);\n      };\n    };\n  };\n  var caseJsonArray = function(d) {\n    return function(f2) {\n      return function(j) {\n        return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), f2, $$const(d), j);\n      };\n    };\n  };\n  var toArray = /* @__PURE__ */ toJsonType(caseJsonArray);\n\n  // output/Data.Argonaut.Decode.Error/index.js\n  var show12 = /* @__PURE__ */ show(showInt);\n  var TypeMismatch2 = /* @__PURE__ */ function() {\n    function TypeMismatch3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    TypeMismatch3.create = function(value0) {\n      return new TypeMismatch3(value0);\n    };\n    return TypeMismatch3;\n  }();\n  var UnexpectedValue = /* @__PURE__ */ function() {\n    function UnexpectedValue2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UnexpectedValue2.create = function(value0) {\n      return new UnexpectedValue2(value0);\n    };\n    return UnexpectedValue2;\n  }();\n  var AtIndex = /* @__PURE__ */ function() {\n    function AtIndex2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    AtIndex2.create = function(value0) {\n      return function(value1) {\n        return new AtIndex2(value0, value1);\n      };\n    };\n    return AtIndex2;\n  }();\n  var AtKey = /* @__PURE__ */ function() {\n    function AtKey2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    AtKey2.create = function(value0) {\n      return function(value1) {\n        return new AtKey2(value0, value1);\n      };\n    };\n    return AtKey2;\n  }();\n  var Named = /* @__PURE__ */ function() {\n    function Named2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Named2.create = function(value0) {\n      return function(value1) {\n        return new Named2(value0, value1);\n      };\n    };\n    return Named2;\n  }();\n  var MissingValue = /* @__PURE__ */ function() {\n    function MissingValue2() {\n    }\n    ;\n    MissingValue2.value = new MissingValue2();\n    return MissingValue2;\n  }();\n  var printJsonDecodeError = function(err) {\n    var go2 = function(v) {\n      if (v instanceof TypeMismatch2) {\n        return \"  Expected value of type '\" + (v.value0 + \"'.\");\n      }\n      ;\n      if (v instanceof UnexpectedValue) {\n        return \"  Unexpected value \" + (stringify(v.value0) + \".\");\n      }\n      ;\n      if (v instanceof AtIndex) {\n        return \"  At array index \" + (show12(v.value0) + (\":\\n\" + go2(v.value1)));\n      }\n      ;\n      if (v instanceof AtKey) {\n        return \"  At object key '\" + (v.value0 + (\"':\\n\" + go2(v.value1)));\n      }\n      ;\n      if (v instanceof Named) {\n        return \"  Under '\" + (v.value0 + (\"':\\n\" + go2(v.value1)));\n      }\n      ;\n      if (v instanceof MissingValue) {\n        return \"  No value was found.\";\n      }\n      ;\n      throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Error (line 37, column 8 - line 43, column 44): \" + [v.constructor.name]);\n    };\n    return \"An error occurred while decoding a JSON value:\\n\" + go2(err);\n  };\n\n  // output/Data.Array.NonEmpty.Internal/index.js\n  var NonEmptyArray = function(x) {\n    return x;\n  };\n\n  // output/Data.Array.NonEmpty/index.js\n  var unsafeFromArray = NonEmptyArray;\n  var toArray2 = function(v) {\n    return v;\n  };\n  var fromArray = function(xs) {\n    if (length(xs) > 0) {\n      return new Just(unsafeFromArray(xs));\n    }\n    ;\n    if (otherwise) {\n      return Nothing.value;\n    }\n    ;\n    throw new Error(\"Failed pattern match at Data.Array.NonEmpty (line 161, column 1 - line 161, column 58): \" + [xs.constructor.name]);\n  };\n  var fromFoldable3 = function(dictFoldable) {\n    var $119 = fromFoldable(dictFoldable);\n    return function($120) {\n      return fromArray($119($120));\n    };\n  };\n\n  // output/Data.String.CodePoints/foreign.js\n  var hasArrayFrom = typeof Array.from === \"function\";\n  var hasStringIterator = typeof Symbol !== \"undefined\" && Symbol != null && typeof Symbol.iterator !== \"undefined\" && typeof String.prototype[Symbol.iterator] === \"function\";\n  var hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\n  var hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\n  // output/Data.Argonaut.Decode.Decoders/index.js\n  var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);\n  var composeKleisliFlipped3 = /* @__PURE__ */ composeKleisliFlipped(bindEither);\n  var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeEither);\n  var decodeString = /* @__PURE__ */ function() {\n    return caseJsonString(new Left(new TypeMismatch2(\"String\")))(Right.create);\n  }();\n  var decodeNumber = /* @__PURE__ */ function() {\n    return caseJsonNumber(new Left(new TypeMismatch2(\"Number\")))(Right.create);\n  }();\n  var decodeJArray = /* @__PURE__ */ function() {\n    var $52 = note(new TypeMismatch2(\"Array\"));\n    return function($53) {\n      return $52(toArray($53));\n    };\n  }();\n  var decodeInt = /* @__PURE__ */ composeKleisliFlipped3(/* @__PURE__ */ function() {\n    var $84 = note(new TypeMismatch2(\"Integer\"));\n    return function($85) {\n      return $84(fromNumber($85));\n    };\n  }())(decodeNumber);\n  var decodeBoolean = /* @__PURE__ */ function() {\n    return caseJsonBoolean(new Left(new TypeMismatch2(\"Boolean\")))(Right.create);\n  }();\n  var decodeArray = function(decoder) {\n    return composeKleisliFlipped3(function() {\n      var $89 = lmap2(Named.create(\"Array\"));\n      var $90 = traverseWithIndex2(function(i2) {\n        var $92 = lmap2(AtIndex.create(i2));\n        return function($93) {\n          return $92(decoder($93));\n        };\n      });\n      return function($91) {\n        return $89($90($91));\n      };\n    }())(decodeJArray);\n  };\n\n  // output/Data.Argonaut.Decode.Class/index.js\n  var bind5 = /* @__PURE__ */ bind(bindEither);\n  var lmap3 = /* @__PURE__ */ lmap(bifunctorEither);\n  var map17 = /* @__PURE__ */ map(functorMaybe);\n  var gDecodeJsonNil = {\n    gDecodeJson: function(v) {\n      return function(v1) {\n        return new Right({});\n      };\n    }\n  };\n  var gDecodeJson = function(dict) {\n    return dict.gDecodeJson;\n  };\n  var decodeRecord = function(dictGDecodeJson) {\n    var gDecodeJson1 = gDecodeJson(dictGDecodeJson);\n    return function() {\n      return {\n        decodeJson: function(json) {\n          var v = toObject(json);\n          if (v instanceof Just) {\n            return gDecodeJson1(v.value0)($$Proxy.value);\n          }\n          ;\n          if (v instanceof Nothing) {\n            return new Left(new TypeMismatch2(\"Object\"));\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Class (line 103, column 5 - line 105, column 46): \" + [v.constructor.name]);\n        }\n      };\n    };\n  };\n  var decodeJsonString = {\n    decodeJson: decodeString\n  };\n  var decodeJsonInt = {\n    decodeJson: decodeInt\n  };\n  var decodeJsonField = function(dict) {\n    return dict.decodeJsonField;\n  };\n  var gDecodeJsonCons = function(dictDecodeJsonField) {\n    var decodeJsonField1 = decodeJsonField(dictDecodeJsonField);\n    return function(dictGDecodeJson) {\n      var gDecodeJson1 = gDecodeJson(dictGDecodeJson);\n      return function(dictIsSymbol) {\n        var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n        var insert10 = insert5(dictIsSymbol)()();\n        return function() {\n          return function() {\n            return {\n              gDecodeJson: function(object2) {\n                return function(v) {\n                  var fieldName = reflectSymbol2($$Proxy.value);\n                  var fieldValue = lookup3(fieldName)(object2);\n                  var v1 = decodeJsonField1(fieldValue);\n                  if (v1 instanceof Just) {\n                    return bind5(lmap3(AtKey.create(fieldName))(v1.value0))(function(val) {\n                      return bind5(gDecodeJson1(object2)($$Proxy.value))(function(rest) {\n                        return new Right(insert10($$Proxy.value)(val)(rest));\n                      });\n                    });\n                  }\n                  ;\n                  if (v1 instanceof Nothing) {\n                    return new Left(new AtKey(fieldName, MissingValue.value));\n                  }\n                  ;\n                  throw new Error(\"Failed pattern match at Data.Argonaut.Decode.Class (line 127, column 5 - line 134, column 44): \" + [v1.constructor.name]);\n                };\n              }\n            };\n          };\n        };\n      };\n    };\n  };\n  var decodeJsonBoolean = {\n    decodeJson: decodeBoolean\n  };\n  var decodeJson = function(dict) {\n    return dict.decodeJson;\n  };\n  var decodeFieldId = function(dictDecodeJson) {\n    var decodeJson1 = decodeJson(dictDecodeJson);\n    return {\n      decodeJsonField: function(j) {\n        return map17(decodeJson1)(j);\n      }\n    };\n  };\n  var decodeArray2 = function(dictDecodeJson) {\n    return {\n      decodeJson: decodeArray(decodeJson(dictDecodeJson))\n    };\n  };\n\n  // output/Data.Argonaut.Encode.Encoders/index.js\n  var map18 = /* @__PURE__ */ map(functorArray);\n  var encodeString = id2;\n  var encodeInt = function($53) {\n    return id2(toNumber($53));\n  };\n  var encodeBoolean = id2;\n  var encodeArray = function(encoder) {\n    var $58 = map18(encoder);\n    return function($59) {\n      return id2($58($59));\n    };\n  };\n  var encodeNonEmptyArray = function(encoder) {\n    var $60 = encodeArray(encoder);\n    return function($61) {\n      return $60(toArray2($61));\n    };\n  };\n\n  // output/Data.Argonaut.Encode.Class/index.js\n  var gEncodeJsonNil = {\n    gEncodeJson: function(v) {\n      return function(v1) {\n        return empty4;\n      };\n    }\n  };\n  var gEncodeJson = function(dict) {\n    return dict.gEncodeJson;\n  };\n  var encodeRecord = function(dictGEncodeJson) {\n    var gEncodeJson1 = gEncodeJson(dictGEncodeJson);\n    return function() {\n      return {\n        encodeJson: function(rec) {\n          return id2(gEncodeJson1(rec)($$Proxy.value));\n        }\n      };\n    };\n  };\n  var encodeJsonJString = {\n    encodeJson: encodeString\n  };\n  var encodeJsonJBoolean = {\n    encodeJson: encodeBoolean\n  };\n  var encodeJsonInt = {\n    encodeJson: encodeInt\n  };\n  var encodeJson = function(dict) {\n    return dict.encodeJson;\n  };\n  var encodeJsonArray = function(dictEncodeJson) {\n    return {\n      encodeJson: encodeArray(encodeJson(dictEncodeJson))\n    };\n  };\n  var encodeJsonNonEmptyArray = function(dictEncodeJson) {\n    return {\n      encodeJson: encodeNonEmptyArray(encodeJson(dictEncodeJson))\n    };\n  };\n  var gEncodeJsonCons = function(dictEncodeJson) {\n    var encodeJson1 = encodeJson(dictEncodeJson);\n    return function(dictGEncodeJson) {\n      var gEncodeJson1 = gEncodeJson(dictGEncodeJson);\n      return function(dictIsSymbol) {\n        var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n        var get7 = get2(dictIsSymbol)();\n        return function() {\n          return {\n            gEncodeJson: function(row) {\n              return function(v) {\n                return insert3(reflectSymbol2($$Proxy.value))(encodeJson1(get7($$Proxy.value)(row)))(gEncodeJson1(row)($$Proxy.value));\n              };\n            }\n          };\n        };\n      };\n    };\n  };\n\n  // output/Data.Show.Generic/foreign.js\n  var intercalate3 = function(separator) {\n    return function(xs) {\n      return xs.join(separator);\n    };\n  };\n\n  // output/Data.Show.Generic/index.js\n  var append5 = /* @__PURE__ */ append(semigroupArray);\n  var genericShowArgsNoArguments = {\n    genericShowArgs: function(v) {\n      return [];\n    }\n  };\n  var genericShowArgs = function(dict) {\n    return dict.genericShowArgs;\n  };\n  var genericShowConstructor = function(dictGenericShowArgs) {\n    var genericShowArgs1 = genericShowArgs(dictGenericShowArgs);\n    return function(dictIsSymbol) {\n      var reflectSymbol2 = reflectSymbol(dictIsSymbol);\n      return {\n        \"genericShow'\": function(v) {\n          var ctor = reflectSymbol2($$Proxy.value);\n          var v1 = genericShowArgs1(v);\n          if (v1.length === 0) {\n            return ctor;\n          }\n          ;\n          return \"(\" + (intercalate3(\" \")(append5([ctor])(v1)) + \")\");\n        }\n      };\n    };\n  };\n  var genericShow$prime = function(dict) {\n    return dict[\"genericShow'\"];\n  };\n  var genericShowSum = function(dictGenericShow) {\n    var genericShow$prime1 = genericShow$prime(dictGenericShow);\n    return function(dictGenericShow1) {\n      var genericShow$prime2 = genericShow$prime(dictGenericShow1);\n      return {\n        \"genericShow'\": function(v) {\n          if (v instanceof Inl) {\n            return genericShow$prime1(v.value0);\n          }\n          ;\n          if (v instanceof Inr) {\n            return genericShow$prime2(v.value0);\n          }\n          ;\n          throw new Error(\"Failed pattern match at Data.Show.Generic (line 26, column 1 - line 28, column 40): \" + [v.constructor.name]);\n        }\n      };\n    };\n  };\n  var genericShow = function(dictGeneric) {\n    var from3 = from(dictGeneric);\n    return function(dictGenericShow) {\n      var genericShow$prime1 = genericShow$prime(dictGenericShow);\n      return function(x) {\n        return genericShow$prime1(from3(x));\n      };\n    };\n  };\n\n  // node_modules/uuid/dist/esm-browser/rng.js\n  var getRandomValues;\n  var rnds8 = new Uint8Array(16);\n  function rng() {\n    if (!getRandomValues) {\n      getRandomValues = typeof crypto !== \"undefined\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n      if (!getRandomValues) {\n        throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n      }\n    }\n    return getRandomValues(rnds8);\n  }\n\n  // node_modules/uuid/dist/esm-browser/regex.js\n  var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\n  // node_modules/uuid/dist/esm-browser/validate.js\n  function validate(uuid) {\n    return typeof uuid === \"string\" && regex_default.test(uuid);\n  }\n  var validate_default = validate;\n\n  // node_modules/uuid/dist/esm-browser/stringify.js\n  var byteToHex = [];\n  for (let i2 = 0; i2 < 256; ++i2) {\n    byteToHex.push((i2 + 256).toString(16).slice(1));\n  }\n  function unsafeStringify(arr, offset = 0) {\n    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n  }\n\n  // node_modules/uuid/dist/esm-browser/parse.js\n  function parse(uuid) {\n    if (!validate_default(uuid)) {\n      throw TypeError(\"Invalid UUID\");\n    }\n    let v;\n    const arr = new Uint8Array(16);\n    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n    arr[1] = v >>> 16 & 255;\n    arr[2] = v >>> 8 & 255;\n    arr[3] = v & 255;\n    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n    arr[5] = v & 255;\n    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n    arr[7] = v & 255;\n    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n    arr[9] = v & 255;\n    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;\n    arr[11] = v / 4294967296 & 255;\n    arr[12] = v >>> 24 & 255;\n    arr[13] = v >>> 16 & 255;\n    arr[14] = v >>> 8 & 255;\n    arr[15] = v & 255;\n    return arr;\n  }\n  var parse_default = parse;\n\n  // node_modules/uuid/dist/esm-browser/v35.js\n  function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = [];\n    for (let i2 = 0; i2 < str.length; ++i2) {\n      bytes.push(str.charCodeAt(i2));\n    }\n    return bytes;\n  }\n  var DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n  var URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\n  function v35(name15, version, hashfunc) {\n    function generateUUID(value15, namespace, buf, offset) {\n      var _namespace;\n      if (typeof value15 === \"string\") {\n        value15 = stringToBytes(value15);\n      }\n      if (typeof namespace === \"string\") {\n        namespace = parse_default(namespace);\n      }\n      if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n        throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n      }\n      let bytes = new Uint8Array(16 + value15.length);\n      bytes.set(namespace);\n      bytes.set(value15, namespace.length);\n      bytes = hashfunc(bytes);\n      bytes[6] = bytes[6] & 15 | version;\n      bytes[8] = bytes[8] & 63 | 128;\n      if (buf) {\n        offset = offset || 0;\n        for (let i2 = 0; i2 < 16; ++i2) {\n          buf[offset + i2] = bytes[i2];\n        }\n        return buf;\n      }\n      return unsafeStringify(bytes);\n    }\n    try {\n      generateUUID.name = name15;\n    } catch (err) {\n    }\n    generateUUID.DNS = DNS;\n    generateUUID.URL = URL;\n    return generateUUID;\n  }\n\n  // node_modules/uuid/dist/esm-browser/native.js\n  var randomUUID = typeof crypto !== \"undefined\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n  var native_default = {\n    randomUUID\n  };\n\n  // node_modules/uuid/dist/esm-browser/v4.js\n  function v4(options2, buf, offset) {\n    if (native_default.randomUUID && !buf && !options2) {\n      return native_default.randomUUID();\n    }\n    options2 = options2 || {};\n    const rnds = options2.random || (options2.rng || rng)();\n    rnds[6] = rnds[6] & 15 | 64;\n    rnds[8] = rnds[8] & 63 | 128;\n    if (buf) {\n      offset = offset || 0;\n      for (let i2 = 0; i2 < 16; ++i2) {\n        buf[offset + i2] = rnds[i2];\n      }\n      return buf;\n    }\n    return unsafeStringify(rnds);\n  }\n  var v4_default = v4;\n\n  // node_modules/uuid/dist/esm-browser/sha1.js\n  function f(s, x, y, z) {\n    switch (s) {\n      case 0:\n        return x & y ^ ~x & z;\n      case 1:\n        return x ^ y ^ z;\n      case 2:\n        return x & y ^ x & z ^ y & z;\n      case 3:\n        return x ^ y ^ z;\n    }\n  }\n  function ROTL(x, n) {\n    return x << n | x >>> 32 - n;\n  }\n  function sha1(bytes) {\n    const K = [1518500249, 1859775393, 2400959708, 3395469782];\n    const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n    if (typeof bytes === \"string\") {\n      const msg = unescape(encodeURIComponent(bytes));\n      bytes = [];\n      for (let i2 = 0; i2 < msg.length; ++i2) {\n        bytes.push(msg.charCodeAt(i2));\n      }\n    } else if (!Array.isArray(bytes)) {\n      bytes = Array.prototype.slice.call(bytes);\n    }\n    bytes.push(128);\n    const l = bytes.length / 4 + 2;\n    const N = Math.ceil(l / 16);\n    const M = new Array(N);\n    for (let i2 = 0; i2 < N; ++i2) {\n      const arr = new Uint32Array(16);\n      for (let j = 0; j < 16; ++j) {\n        arr[j] = bytes[i2 * 64 + j * 4] << 24 | bytes[i2 * 64 + j * 4 + 1] << 16 | bytes[i2 * 64 + j * 4 + 2] << 8 | bytes[i2 * 64 + j * 4 + 3];\n      }\n      M[i2] = arr;\n    }\n    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n    for (let i2 = 0; i2 < N; ++i2) {\n      const W = new Uint32Array(80);\n      for (let t = 0; t < 16; ++t) {\n        W[t] = M[i2][t];\n      }\n      for (let t = 16; t < 80; ++t) {\n        W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n      }\n      let a2 = H[0];\n      let b2 = H[1];\n      let c = H[2];\n      let d = H[3];\n      let e = H[4];\n      for (let t = 0; t < 80; ++t) {\n        const s = Math.floor(t / 20);\n        const T = ROTL(a2, 5) + f(s, b2, c, d) + e + K[s] + W[t] >>> 0;\n        e = d;\n        d = c;\n        c = ROTL(b2, 30) >>> 0;\n        b2 = a2;\n        a2 = T;\n      }\n      H[0] = H[0] + a2 >>> 0;\n      H[1] = H[1] + b2 >>> 0;\n      H[2] = H[2] + c >>> 0;\n      H[3] = H[3] + d >>> 0;\n      H[4] = H[4] + e >>> 0;\n    }\n    return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];\n  }\n  var sha1_default = sha1;\n\n  // node_modules/uuid/dist/esm-browser/v5.js\n  var v5 = v35(\"v5\", 80, sha1_default);\n  var v5_default = v5;\n\n  // output/Data.UUID/foreign.js\n  var getUUIDImpl = v4_default;\n  var getUUID5Impl = function(str) {\n    return function(namespace) {\n      return v5_default(str, namespace);\n    };\n  };\n  var validateV4UUID = validate_default;\n\n  // output/Data.UUID/index.js\n  var compare2 = /* @__PURE__ */ compare(ordString);\n  var UUID = function(x) {\n    return x;\n  };\n  var toString3 = function(v) {\n    return v;\n  };\n  var parseUUID = function(str) {\n    var v = validateV4UUID(str);\n    if (v) {\n      return new Just(str);\n    }\n    ;\n    return Nothing.value;\n  };\n  var genv5UUID = function(s) {\n    return function(v) {\n      return getUUID5Impl(s)(v);\n    };\n  };\n  var genUUID = /* @__PURE__ */ bind(bindEffect)(getUUIDImpl)(/* @__PURE__ */ function() {\n    var $30 = pure(applicativeEffect);\n    return function($31) {\n      return $30(UUID($31));\n    };\n  }());\n  var eqUUID = {\n    eq: function(x) {\n      return function(y) {\n        return x === y;\n      };\n    }\n  };\n  var ordUUID = {\n    compare: function(x) {\n      return function(y) {\n        return compare2(x)(y);\n      };\n    },\n    Eq0: function() {\n      return eqUUID;\n    }\n  };\n  var emptyUUID = \"00000000-0000-0000-0000-000000000000\";\n\n  // output/TcgCalculator.Types.Id/index.js\n  var eq3 = /* @__PURE__ */ eq(eqUUID);\n  var compare3 = /* @__PURE__ */ compare(ordUUID);\n  var encodeJson2 = /* @__PURE__ */ encodeJson(encodeJsonJString);\n  var mapFlipped3 = /* @__PURE__ */ mapFlipped(functorEither);\n  var decodeJson2 = /* @__PURE__ */ decodeJson(decodeJsonString);\n  var map19 = /* @__PURE__ */ map(functorEffect);\n  var Id = function(x) {\n    return x;\n  };\n  var eqId = {\n    eq: function(x) {\n      return function(y) {\n        return eq3(x)(y);\n      };\n    }\n  };\n  var ordId = {\n    compare: function(x) {\n      return function(y) {\n        return compare3(x)(y);\n      };\n    },\n    Eq0: function() {\n      return eqId;\n    }\n  };\n  var encodeJsonId = {\n    encodeJson: function(v) {\n      return encodeJson2(toString3(v));\n    }\n  };\n  var toString4 = function(v) {\n    return toString3(v);\n  };\n  var namespaceTcgCalculator = /* @__PURE__ */ genv5UUID(\"tcg-calculator\")(emptyUUID);\n  var mkId = function(s) {\n    return genv5UUID(s)(namespaceTcgCalculator);\n  };\n  var decodeJsonId = {\n    decodeJson: function(json) {\n      return mapFlipped3(decodeJson2(json))(function(id3) {\n        return maybe$prime(function(v) {\n          return mkId(id3);\n        })(Id)(parseUUID(id3));\n      });\n    }\n  };\n  var generateId = function(dictMonadEffect) {\n    return liftEffect(dictMonadEffect)(map19(Id)(genUUID));\n  };\n  var fromString3 = /* @__PURE__ */ function() {\n    var $36 = map(functorMaybe)(Id);\n    return function($37) {\n      return $36(parseUUID($37));\n    };\n  }();\n\n  // output/TcgCalculator.Types/index.js\n  var genericShowConstructor2 = /* @__PURE__ */ genericShowConstructor(genericShowArgsNoArguments);\n  var cardsIsSymbol = {\n    reflectSymbol: function() {\n      return \"cards\";\n    }\n  };\n  var countIsSymbol = {\n    reflectSymbol: function() {\n      return \"count\";\n    }\n  };\n  var modeIsSymbol = {\n    reflectSymbol: function() {\n      return \"mode\";\n    }\n  };\n  var idIsSymbol = {\n    reflectSymbol: function() {\n      return \"id\";\n    }\n  };\n  var nameIsSymbol = {\n    reflectSymbol: function() {\n      return \"name\";\n    }\n  };\n  var gEncodeJsonCons2 = /* @__PURE__ */ gEncodeJsonCons(encodeJsonInt);\n  var bindFlipped4 = /* @__PURE__ */ bindFlipped(bindEither);\n  var decodeJson3 = /* @__PURE__ */ decodeJson(decodeJsonString);\n  var AtLeast = /* @__PURE__ */ function() {\n    function AtLeast2() {\n    }\n    ;\n    AtLeast2.value = new AtLeast2();\n    return AtLeast2;\n  }();\n  var JustDraw = /* @__PURE__ */ function() {\n    function JustDraw2() {\n    }\n    ;\n    JustDraw2.value = new JustDraw2();\n    return JustDraw2;\n  }();\n  var Remains = /* @__PURE__ */ function() {\n    function Remains2() {\n    }\n    ;\n    Remains2.value = new Remains2();\n    return Remains2;\n  }();\n  var JustRemains = /* @__PURE__ */ function() {\n    function JustRemains2() {\n    }\n    ;\n    JustRemains2.value = new JustRemains2();\n    return JustRemains2;\n  }();\n  var Choice = /* @__PURE__ */ function() {\n    function Choice2() {\n    }\n    ;\n    Choice2.value = new Choice2();\n    return Choice2;\n  }();\n  var LeftOne = /* @__PURE__ */ function() {\n    function LeftOne2() {\n    }\n    ;\n    LeftOne2.value = new LeftOne2();\n    return LeftOne2;\n  }();\n  var LeftAll = /* @__PURE__ */ function() {\n    function LeftAll2() {\n    }\n    ;\n    LeftAll2.value = new LeftAll2();\n    return LeftAll2;\n  }();\n  var Condition = function(x) {\n    return x;\n  };\n  var genericConditionMode_ = {\n    to: function(x) {\n      if (x instanceof Inl) {\n        return AtLeast.value;\n      }\n      ;\n      if (x instanceof Inr && x.value0 instanceof Inl) {\n        return JustDraw.value;\n      }\n      ;\n      if (x instanceof Inr && (x.value0 instanceof Inr && x.value0.value0 instanceof Inl)) {\n        return Remains.value;\n      }\n      ;\n      if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inl))) {\n        return JustRemains.value;\n      }\n      ;\n      if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && (x.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0 instanceof Inl)))) {\n        return Choice.value;\n      }\n      ;\n      if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && (x.value0.value0.value0 instanceof Inr && (x.value0.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0.value0 instanceof Inl))))) {\n        return LeftOne.value;\n      }\n      ;\n      if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && (x.value0.value0.value0 instanceof Inr && (x.value0.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0.value0 instanceof Inr))))) {\n        return LeftAll.value;\n      }\n      ;\n      throw new Error(\"Failed pattern match at TcgCalculator.Types (line 46, column 1 - line 46, column 40): \" + [x.constructor.name]);\n    },\n    from: function(x) {\n      if (x instanceof AtLeast) {\n        return new Inl(NoArguments.value);\n      }\n      ;\n      if (x instanceof JustDraw) {\n        return new Inr(new Inl(NoArguments.value));\n      }\n      ;\n      if (x instanceof Remains) {\n        return new Inr(new Inr(new Inl(NoArguments.value)));\n      }\n      ;\n      if (x instanceof JustRemains) {\n        return new Inr(new Inr(new Inr(new Inl(NoArguments.value))));\n      }\n      ;\n      if (x instanceof Choice) {\n        return new Inr(new Inr(new Inr(new Inr(new Inl(NoArguments.value)))));\n      }\n      ;\n      if (x instanceof LeftOne) {\n        return new Inr(new Inr(new Inr(new Inr(new Inr(new Inl(NoArguments.value))))));\n      }\n      ;\n      if (x instanceof LeftAll) {\n        return new Inr(new Inr(new Inr(new Inr(new Inr(new Inr(NoArguments.value))))));\n      }\n      ;\n      throw new Error(\"Failed pattern match at TcgCalculator.Types (line 46, column 1 - line 46, column 40): \" + [x.constructor.name]);\n    }\n  };\n  var showConditionMode = {\n    show: /* @__PURE__ */ genericShow(genericConditionMode_)(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n      reflectSymbol: function() {\n        return \"AtLeast\";\n      }\n    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n      reflectSymbol: function() {\n        return \"JustDraw\";\n      }\n    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n      reflectSymbol: function() {\n        return \"Remains\";\n      }\n    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n      reflectSymbol: function() {\n        return \"JustRemains\";\n      }\n    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n      reflectSymbol: function() {\n        return \"Choice\";\n      }\n    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2({\n      reflectSymbol: function() {\n        return \"LeftOne\";\n      }\n    }))(/* @__PURE__ */ genericShowConstructor2({\n      reflectSymbol: function() {\n        return \"LeftAll\";\n      }\n    }))))))))\n  };\n  var encodeJsonConditionMode = {\n    encodeJson: /* @__PURE__ */ function() {\n      var $231 = encodeJson(encodeJsonJString);\n      var $232 = show(showConditionMode);\n      return function($233) {\n        return $231($232($233));\n      };\n    }()\n  };\n  var encodeJsonCondition = /* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons2(/* @__PURE__ */ gEncodeJsonCons(encodeJsonId)(/* @__PURE__ */ gEncodeJsonCons(encodeJsonJString)(gEncodeJsonNil)(nameIsSymbol)())(idIsSymbol)())(countIsSymbol)())()))(/* @__PURE__ */ gEncodeJsonCons2(/* @__PURE__ */ gEncodeJsonCons(encodeJsonConditionMode)(gEncodeJsonNil)(modeIsSymbol)())(countIsSymbol)())(cardsIsSymbol)())();\n  var readConditionMode = function(v) {\n    if (v === \"AtLeast\") {\n      return new Just(AtLeast.value);\n    }\n    ;\n    if (v === \"JustDraw\") {\n      return new Just(JustDraw.value);\n    }\n    ;\n    if (v === \"Remains\") {\n      return new Just(Remains.value);\n    }\n    ;\n    if (v === \"JustRemains\") {\n      return new Just(JustRemains.value);\n    }\n    ;\n    if (v === \"Choice\") {\n      return new Just(Choice.value);\n    }\n    ;\n    if (v === \"LeftOne\") {\n      return new Just(LeftOne.value);\n    }\n    ;\n    if (v === \"LeftAll\") {\n      return new Just(LeftAll.value);\n    }\n    ;\n    return Nothing.value;\n  };\n  var decodeJsonConditionMode = {\n    decodeJson: function(json) {\n      return bindFlipped4(function() {\n        var $234 = note(new UnexpectedValue(json));\n        return function($235) {\n          return $234(readConditionMode($235));\n        };\n      }())(decodeJson3(json));\n    }\n  };\n\n  // output/Web.UIEvent.FocusEvent/index.js\n  var toEvent = unsafeCoerce2;\n\n  // output/App.ConditionLine/index.js\n  var value3 = /* @__PURE__ */ value2(isPropString);\n  var show4 = /* @__PURE__ */ show(showConditionMode);\n  var mapFlipped4 = /* @__PURE__ */ mapFlipped(functorArray);\n  var selectorIsSymbol = {\n    reflectSymbol: function() {\n      return \"selector\";\n    }\n  };\n  var slot2 = /* @__PURE__ */ slot()(selectorIsSymbol)(ordUnit);\n  var component1 = /* @__PURE__ */ component(eqId);\n  var type_4 = /* @__PURE__ */ type_3(isPropInputType);\n  var show13 = /* @__PURE__ */ show(showInt);\n  var alaF2 = /* @__PURE__ */ alaF()()()();\n  var foldMap3 = /* @__PURE__ */ foldMap2(/* @__PURE__ */ monoidAdditive(semiringInt));\n  var min5 = /* @__PURE__ */ min(ordInt);\n  var map20 = /* @__PURE__ */ map(/* @__PURE__ */ functorMaybeT(functorHalogenM));\n  var gets3 = /* @__PURE__ */ gets(/* @__PURE__ */ monadStateMaybeT(monadStateHalogenM));\n  var lift4 = /* @__PURE__ */ lift(monadTransMaybeT)(monadHalogenM);\n  var discard3 = /* @__PURE__ */ discard(discardUnit)(bindHalogenM);\n  var put3 = /* @__PURE__ */ put(monadStateHalogenM);\n  var elem3 = /* @__PURE__ */ elem2(/* @__PURE__ */ eqRec()(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(eqRowNil)()({\n    reflectSymbol: function() {\n      return \"name\";\n    }\n  })(eqString))()({\n    reflectSymbol: function() {\n      return \"id\";\n    }\n  })(eqId))()({\n    reflectSymbol: function() {\n      return \"count\";\n    }\n  })(eqInt)));\n  var tell3 = /* @__PURE__ */ tell2()(selectorIsSymbol)(ordUnit);\n  var pure6 = /* @__PURE__ */ pure(applicativeHalogenM);\n  var clamp2 = /* @__PURE__ */ clamp(ordInt);\n  var bind6 = /* @__PURE__ */ bind(bindHalogenM);\n  var get3 = /* @__PURE__ */ get(monadStateHalogenM);\n  var elem1 = /* @__PURE__ */ elem2(eqId);\n  var traverse_4 = /* @__PURE__ */ traverse_(applicativeHalogenM)(foldableMaybe);\n  var modify6 = /* @__PURE__ */ modify2(monadStateHalogenM);\n  var composeKleisliFlipped4 = /* @__PURE__ */ composeKleisliFlipped(bindMaybe);\n  var liftEffect3 = /* @__PURE__ */ liftEffect(/* @__PURE__ */ monadEffectHalogenM(monadEffectAff));\n  var traverse_12 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableMaybe);\n  var GetCondition = /* @__PURE__ */ function() {\n    function GetCondition2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    GetCondition2.create = function(value0) {\n      return new GetCondition2(value0);\n    };\n    return GetCondition2;\n  }();\n  var RestoreState = /* @__PURE__ */ function() {\n    function RestoreState4(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    RestoreState4.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new RestoreState4(value0, value1, value22);\n        };\n      };\n    };\n    return RestoreState4;\n  }();\n  var Updated = /* @__PURE__ */ function() {\n    function Updated3() {\n    }\n    ;\n    Updated3.value = new Updated3();\n    return Updated3;\n  }();\n  var Initialize2 = /* @__PURE__ */ function() {\n    function Initialize5() {\n    }\n    ;\n    Initialize5.value = new Initialize5();\n    return Initialize5;\n  }();\n  var UpdateConditionMode = /* @__PURE__ */ function() {\n    function UpdateConditionMode2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UpdateConditionMode2.create = function(value0) {\n      return new UpdateConditionMode2(value0);\n    };\n    return UpdateConditionMode2;\n  }();\n  var UpdateCardSelected = /* @__PURE__ */ function() {\n    function UpdateCardSelected2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UpdateCardSelected2.create = function(value0) {\n      return new UpdateCardSelected2(value0);\n    };\n    return UpdateCardSelected2;\n  }();\n  var UpdateCardCount = /* @__PURE__ */ function() {\n    function UpdateCardCount2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UpdateCardCount2.create = function(value0) {\n      return new UpdateCardCount2(value0);\n    };\n    return UpdateCardCount2;\n  }();\n  var Receive3 = /* @__PURE__ */ function() {\n    function Receive5(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Receive5.create = function(value0) {\n      return new Receive5(value0);\n    };\n    return Receive5;\n  }();\n  var SelectOnFocus = /* @__PURE__ */ function() {\n    function SelectOnFocus3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    SelectOnFocus3.create = function(value0) {\n      return new SelectOnFocus3(value0);\n    };\n    return SelectOnFocus3;\n  }();\n  var component2 = /* @__PURE__ */ function() {\n    var renderModeSelector = function(mode) {\n      return select([classes([\"w-full appearance-none rounded border border-gray-400 bg-transparent px-3 py-1\", \"transition ease-in-out hover:border-gray-500 focus:border-blue-600 focus:outline-none\"]), value3(show4(mode)), onValueChange(UpdateConditionMode.create)])([option([value3(show4(AtLeast.value))])([text(\"\\u679A\\u4EE5\\u4E0A\\u30C9\\u30ED\\u30FC\\u3059\\u308B\")]), option([value3(show4(JustDraw.value))])([text(\"\\u679A\\u3061\\u3087\\u3046\\u3069\\u30C9\\u30ED\\u30FC\\u3059\\u308B\")]), option([value3(show4(Remains.value))])([text(\"\\u679A\\u4EE5\\u4E0A\\u30C7\\u30C3\\u30AD\\u306B\\u6B8B\\u3059\")]), option([value3(show4(JustRemains.value))])([text(\"\\u679A\\u3061\\u3087\\u3046\\u3069\\u30C7\\u30C3\\u30AD\\u306B\\u6B8B\\u3059\")]), option([value3(show4(Choice.value))])([text(\"\\u7A2E\\u985E\\u4EE5\\u4E0A\\u30C9\\u30ED\\u30FC\\u3059\\u308B\")]), option([value3(show4(LeftOne.value))])([text(\"\\u7A2E\\u985E\\u4EE5\\u4E0A\\u30C7\\u30C3\\u30AD\\u306B\\u6B8B\\u3059\")]), option([value3(show4(LeftAll.value))])([text(\"\\u7A2E\\u985E\\u4EE5\\u4E0A\\u30C9\\u30ED\\u30FC\\u3057\\u306A\\u3044\")])]);\n    };\n    var renderCardSelector = function(cards) {\n      var cards$prime = mapFlipped4(cards)(function(card) {\n        return {\n          id: card.id,\n          value: card.name\n        };\n      });\n      return slot2($$Proxy.value)(unit)(component1)(cards$prime)(UpdateCardSelected.create);\n    };\n    var renderCardCounter = function(count) {\n      return function(min1) {\n        return function(max7) {\n          return input([classes([\"w-12 appearance-none rounded border border-gray-400 bg-transparent p-1 text-right\", \"transition ease-in-out hover:border-gray-500 focus:border-blue-600 focus:outline-none\"]), type_4(InputNumber.value), step3(new Step(1)), value3(show13(count)), min4(toNumber(min1)), max4(toNumber(max7)), onFocus(SelectOnFocus.create), onValueChange(UpdateCardCount.create)]);\n        };\n      };\n    };\n    var render = function(v) {\n      return div2([class_(\"flex flex-wrap items-center justify-end\")])([div2([class_(\"w-48 grow rounded border p-0.5\")])([renderCardSelector(v.cards)]), div2([class_(\"flex items-center\")])([div2([class_(\"mx-1\")])([text(\"\\u3092\")]), renderCardCounter(v.condition.count)(v.minValue)(v.maxValue), renderModeSelector(v.condition.mode)])]);\n    };\n    var initialState = function(v) {\n      return {\n        cards: v,\n        condition: {\n          mode: AtLeast.value,\n          count: 0,\n          cards: []\n        },\n        minValue: 0,\n        maxValue: 0\n      };\n    };\n    var getMinMax = function(cards) {\n      var countCards = alaF2(Additive)(foldMap3)(function(v) {\n        return v.count;\n      });\n      return function(v) {\n        if (v instanceof AtLeast) {\n          var max7 = countCards(cards);\n          return {\n            min: min5(1)(max7),\n            max: max7\n          };\n        }\n        ;\n        if (v instanceof JustDraw) {\n          var max7 = countCards(cards);\n          return {\n            min: 0,\n            max: max7\n          };\n        }\n        ;\n        if (v instanceof Remains) {\n          var max7 = countCards(cards);\n          return {\n            min: min5(1)(max7),\n            max: max7\n          };\n        }\n        ;\n        if (v instanceof JustRemains) {\n          var max7 = countCards(cards);\n          return {\n            min: 0,\n            max: max7\n          };\n        }\n        ;\n        if (v instanceof Choice) {\n          var max7 = length(cards);\n          return {\n            min: min5(1)(max7),\n            max: max7\n          };\n        }\n        ;\n        if (v instanceof LeftOne) {\n          var max7 = length(cards);\n          return {\n            min: min5(1)(max7),\n            max: max7\n          };\n        }\n        ;\n        if (v instanceof LeftAll) {\n          var max7 = length(cards);\n          return {\n            min: min5(1)(max7),\n            max: max7\n          };\n        }\n        ;\n        throw new Error(\"Failed pattern match at App.ConditionLine (line 143, column 21 - line 164, column 30): \" + [v.constructor.name]);\n      };\n    };\n    var query3 = function(v) {\n      if (v instanceof GetCondition) {\n        return map20(function($133) {\n          return v.value0(Condition($133));\n        })(gets3(function(v1) {\n          return v1.condition;\n        }));\n      }\n      ;\n      if (v instanceof RestoreState) {\n        return lift4(function() {\n          var v1 = getMinMax(v.value1.cards)(v.value1.mode);\n          return discard3(put3({\n            cards: v.value0,\n            condition: v.value1,\n            minValue: v1.min,\n            maxValue: v1.max\n          }))(function() {\n            var items3 = mapFlipped4(v.value0)(function(card) {\n              return {\n                id: card.id,\n                value: card.name,\n                selected: elem3(card)(v.value1.cards)\n              };\n            });\n            return discard3(tell3($$Proxy.value)(unit)(SetItems.create(items3)))(function() {\n              return pure6(v.value2);\n            });\n          });\n        }());\n      }\n      ;\n      throw new Error(\"Failed pattern match at App.ConditionLine (line 169, column 11 - line 177, column 13): \" + [v.constructor.name]);\n    };\n    var action2 = /* @__PURE__ */ function() {\n      var updateStatus = function(cards) {\n        return function(selected2) {\n          return function(mode) {\n            return function(count) {\n              var v = getMinMax(selected2)(mode);\n              return put3({\n                cards,\n                condition: {\n                  mode,\n                  cards: selected2,\n                  count: clamp2(v.min)(v.max)(count)\n                },\n                minValue: v.min,\n                maxValue: v.max\n              });\n            };\n          };\n        };\n      };\n      var updateCardSelected = function(selected2) {\n        return bind6(get3)(function(v) {\n          var selected$prime = filter(function(v1) {\n            return elem1(v1.id)(selected2);\n          })(v.cards);\n          return updateStatus(v.cards)(selected$prime)(v.condition.mode)(v.condition.count);\n        });\n      };\n      return function(v) {\n        if (v instanceof Initialize2) {\n          return bind6(get3)(function(v1) {\n            return updateStatus(v1.cards)(v1.condition.cards)(v1.condition.mode)(v1.condition.count);\n          });\n        }\n        ;\n        if (v instanceof UpdateCardSelected) {\n          return discard3(updateCardSelected(v.value0))(function() {\n            return raise(Updated.value);\n          });\n        }\n        ;\n        if (v instanceof UpdateConditionMode) {\n          return traverse_4(function(mode$prime) {\n            return bind6(get3)(function(v1) {\n              return discard3(updateStatus(v1.cards)(v1.condition.cards)(mode$prime)(v1.condition.count))(function() {\n                return raise(Updated.value);\n              });\n            });\n          })(readConditionMode(v.value0));\n        }\n        ;\n        if (v instanceof UpdateCardCount) {\n          return traverse_4(function(count$prime) {\n            return bind6(get3)(function(v1) {\n              return discard3(updateStatus(v1.cards)(v1.condition.cards)(v1.condition.mode)(count$prime))(function() {\n                return raise(Updated.value);\n              });\n            });\n          })(fromString(v.value0));\n        }\n        ;\n        if (v instanceof Receive3) {\n          return bind6(modify6(function(v1) {\n            var $125 = {};\n            for (var $126 in v1) {\n              if ({}.hasOwnProperty.call(v1, $126)) {\n                $125[$126] = v1[$126];\n              }\n              ;\n            }\n            ;\n            $125.cards = v.value0;\n            return $125;\n          }))(function(v1) {\n            return updateCardSelected(mapFlipped4(v1.condition.cards)(function(v2) {\n              return v2.id;\n            }));\n          });\n        }\n        ;\n        if (v instanceof SelectOnFocus) {\n          var element3 = composeKleisliFlipped4(fromEventTarget)(function($134) {\n            return target(toEvent($134));\n          })(v.value0);\n          return liftEffect3(traverse_12(select2)(element3));\n        }\n        ;\n        throw new Error(\"Failed pattern match at App.ConditionLine (line 110, column 12 - line 132, column 52): \" + [v.constructor.name]);\n      };\n    }();\n    return mkComponent({\n      initialState,\n      render,\n      \"eval\": mkEval({\n        finalize: defaultEval.finalize,\n        handleAction: action2,\n        handleQuery: function($135) {\n          return runMaybeT(query3($135));\n        },\n        initialize: new Just(Initialize2.value),\n        receive: function($136) {\n          return Just.create(Receive3.create($136));\n        }\n      })\n    });\n  }();\n\n  // output/Data.BigInt/foreign.js\n  var import_big_integer = __toESM(require_BigInteger(), 1);\n  function fromBaseImpl(just) {\n    return function(nothing) {\n      return function(b2) {\n        return function(s) {\n          try {\n            var x = (0, import_big_integer.default)(s, b2);\n            return just(x);\n          } catch (err) {\n            return nothing;\n          }\n        };\n      };\n    };\n  }\n  function fromInt(n) {\n    return (0, import_big_integer.default)(n);\n  }\n  function toBase(base2) {\n    return function(x) {\n      return x.toString(base2);\n    };\n  }\n  function toNumber2(x) {\n    return x.toJSNumber();\n  }\n  function biAdd(x) {\n    return function(y) {\n      return x.add(y);\n    };\n  }\n  function biMul(x) {\n    return function(y) {\n      return x.multiply(y);\n    };\n  }\n  function biSub(x) {\n    return function(y) {\n      return x.minus(y);\n    };\n  }\n  function biMod(x) {\n    return function(y) {\n      return x.mod(y);\n    };\n  }\n  function biDiv(x) {\n    return function(y) {\n      return x.divide(y);\n    };\n  }\n  function biEquals(x) {\n    return function(y) {\n      return x.equals(y);\n    };\n  }\n  function abs3(x) {\n    return x.abs();\n  }\n\n  // output/Data.BigInt/index.js\n  var toString5 = /* @__PURE__ */ toBase(10);\n  var semiringBigInt = {\n    add: biAdd,\n    zero: /* @__PURE__ */ fromInt(0),\n    mul: biMul,\n    one: /* @__PURE__ */ fromInt(1)\n  };\n  var add2 = /* @__PURE__ */ add(semiringBigInt);\n  var ringBigInt = {\n    sub: biSub,\n    Semiring0: function() {\n      return semiringBigInt;\n    }\n  };\n  var sub3 = /* @__PURE__ */ sub(ringBigInt);\n  var fromBase = /* @__PURE__ */ function() {\n    return fromBaseImpl(Just.create)(Nothing.value);\n  }();\n  var fromString4 = /* @__PURE__ */ fromBase(10);\n  var eqBigInt = {\n    eq: biEquals\n  };\n  var commutativeRingBigInt = {\n    Ring0: function() {\n      return ringBigInt;\n    }\n  };\n  var euclideanRingBigInt = {\n    div: function(x) {\n      return function(y) {\n        return biDiv(sub3(x)(mod(euclideanRingBigInt)(x)(y)))(y);\n      };\n    },\n    mod: function(x) {\n      return function(y) {\n        var yy = abs3(y);\n        return biMod(add2(biMod(x)(yy))(yy))(yy);\n      };\n    },\n    degree: function($13) {\n      return floor2(toNumber2(abs3($13)));\n    },\n    CommutativeRing0: function() {\n      return commutativeRingBigInt;\n    }\n  };\n\n  // output/Web.HTML.Event.ErrorEvent/foreign.js\n  function message2(e) {\n    return e.message;\n  }\n\n  // output/Web.HTML.Event.ErrorEvent/index.js\n  var fromEvent = /* @__PURE__ */ unsafeReadProtoTagged(\"ErrorEvent\");\n\n  // output/Web.Worker.MessageEvent/foreign.js\n  function data_(ev) {\n    return ev.data;\n  }\n\n  // output/Web.Worker.Worker/foreign.js\n  function _new2(src9) {\n    return function(opts) {\n      return function() {\n        return new Worker(src9, opts);\n      };\n    };\n  }\n  function postMessageImpl(data) {\n    return function(transfer) {\n      return function(worker) {\n        return function() {\n          worker.postMessage(data, transfer.length > 0 ? transfer : void 0);\n        };\n      };\n    };\n  }\n  function terminate(worker) {\n    return function() {\n      worker.terminate();\n    };\n  }\n  function onMessage(f2) {\n    return function(worker) {\n      return function() {\n        worker.onmessage = function(ev) {\n          f2(ev)();\n        };\n      };\n    };\n  }\n  function onError(f2) {\n    return function(worker) {\n      return function() {\n        worker.onerror = function(ev) {\n          f2(ev)();\n        };\n      };\n    };\n  }\n\n  // output/Web.Worker.Worker/index.js\n  var Classic = /* @__PURE__ */ function() {\n    function Classic2() {\n    }\n    ;\n    Classic2.value = new Classic2();\n    return Classic2;\n  }();\n  var Module = /* @__PURE__ */ function() {\n    function Module2() {\n    }\n    ;\n    Module2.value = new Module2();\n    return Module2;\n  }();\n  var Omit = /* @__PURE__ */ function() {\n    function Omit2() {\n    }\n    ;\n    Omit2.value = new Omit2();\n    return Omit2;\n  }();\n  var SameOrigin = /* @__PURE__ */ function() {\n    function SameOrigin2() {\n    }\n    ;\n    SameOrigin2.value = new SameOrigin2();\n    return SameOrigin2;\n  }();\n  var Include = /* @__PURE__ */ function() {\n    function Include2() {\n    }\n    ;\n    Include2.value = new Include2();\n    return Include2;\n  }();\n  var showWorkerType = {\n    show: function(v) {\n      if (v instanceof Classic) {\n        return \"classic\";\n      }\n      ;\n      if (v instanceof Module) {\n        return \"module\";\n      }\n      ;\n      throw new Error(\"Failed pattern match at Web.Worker.Worker (line 85, column 10 - line 87, column 24): \" + [v.constructor.name]);\n    }\n  };\n  var show5 = /* @__PURE__ */ show(showWorkerType);\n  var showCredentials = {\n    show: function(v) {\n      if (v instanceof Omit) {\n        return \"omit\";\n      }\n      ;\n      if (v instanceof SameOrigin) {\n        return \"same-origin\";\n      }\n      ;\n      if (v instanceof Include) {\n        return \"include\";\n      }\n      ;\n      throw new Error(\"Failed pattern match at Web.Worker.Worker (line 90, column 10 - line 93, column 28): \" + [v.constructor.name]);\n    }\n  };\n  var show14 = /* @__PURE__ */ show(showCredentials);\n  var postMessage = function(msg) {\n    return postMessageImpl(msg)([]);\n  };\n  var $$new2 = function(url) {\n    return function(v) {\n      return _new2(url)({\n        name: v.name,\n        credentials: show14(v.credentials),\n        type: show5(v.type)\n      });\n    };\n  };\n  var defaultWorkerOptions = /* @__PURE__ */ function() {\n    return {\n      name: \"\",\n      credentials: Omit.value,\n      type: Classic.value\n    };\n  }();\n\n  // output/App.Worker/index.js\n  var bind13 = /* @__PURE__ */ bind(bindEither);\n  var lmap4 = /* @__PURE__ */ lmap(bifunctorEither);\n  var intercalateMap2 = /* @__PURE__ */ intercalateMap(foldable1NonEmptyList)(semigroupString);\n  var readString3 = /* @__PURE__ */ readString(monadIdentity);\n  var gEncodeJsonCons3 = /* @__PURE__ */ gEncodeJsonCons(encodeJsonInt);\n  var encodeJson3 = /* @__PURE__ */ encodeJson(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeJsonNonEmptyArray(encodeJsonCondition)))(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons3(/* @__PURE__ */ gEncodeJsonCons(encodeJsonId)(/* @__PURE__ */ gEncodeJsonCons(encodeJsonJString)(gEncodeJsonNil)({\n    reflectSymbol: function() {\n      return \"name\";\n    }\n  })())({\n    reflectSymbol: function() {\n      return \"id\";\n    }\n  })())({\n    reflectSymbol: function() {\n      return \"count\";\n    }\n  })())()))(/* @__PURE__ */ gEncodeJsonCons3(/* @__PURE__ */ gEncodeJsonCons3(gEncodeJsonNil)({\n    reflectSymbol: function() {\n      return \"others\";\n    }\n  })())({\n    reflectSymbol: function() {\n      return \"hand\";\n    }\n  })())({\n    reflectSymbol: function() {\n      return \"cards\";\n    }\n  })())())(gEncodeJsonNil)({\n    reflectSymbol: function() {\n      return \"deck\";\n    }\n  })())({\n    reflectSymbol: function() {\n      return \"conditions\";\n    }\n  })())());\n  var run3 = function(param2) {\n    return makeAff(function(reply) {\n      return function __do2() {\n        var worker = $$new2(\"bundle/worker.js\")({\n          credentials: defaultWorkerOptions.credentials,\n          name: defaultWorkerOptions.name,\n          type: Module.value\n        })();\n        onMessage(function(event) {\n          return reply(bind13(lmap4(function() {\n            var $59 = intercalateMap2(\"\\n\")(renderForeignError);\n            return function($60) {\n              return error($59($60));\n            };\n          }())(runExcept(readString3(data_(event)))))(function(result) {\n            return note(error(\"BigInt.fromString\"))(fromString4(result));\n          }));\n        })(worker)();\n        onError(function(event) {\n          return function __do3() {\n            terminate(worker)();\n            var message3 = maybe(\"Unknown worker error\")(message2)(fromEvent(event));\n            return reply(new Left(error(message3)))();\n          };\n        })(worker)();\n        postMessage(encodeJson3(param2))(worker)();\n        return effectCanceler(terminate(worker));\n      };\n    });\n  };\n\n  // output/Data.Number.Format/foreign.js\n  function wrap2(method2) {\n    return function(d) {\n      return function(num) {\n        return method2.apply(num, [d]);\n      };\n    };\n  }\n  var toPrecisionNative = wrap2(Number.prototype.toPrecision);\n  var toFixedNative = wrap2(Number.prototype.toFixed);\n  var toExponentialNative = wrap2(Number.prototype.toExponential);\n\n  // output/Data.Number.Format/index.js\n  var clamp3 = /* @__PURE__ */ clamp(ordInt);\n  var Precision = /* @__PURE__ */ function() {\n    function Precision2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Precision2.create = function(value0) {\n      return new Precision2(value0);\n    };\n    return Precision2;\n  }();\n  var Fixed = /* @__PURE__ */ function() {\n    function Fixed2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Fixed2.create = function(value0) {\n      return new Fixed2(value0);\n    };\n    return Fixed2;\n  }();\n  var Exponential = /* @__PURE__ */ function() {\n    function Exponential2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Exponential2.create = function(value0) {\n      return new Exponential2(value0);\n    };\n    return Exponential2;\n  }();\n  var toStringWith = function(v) {\n    if (v instanceof Precision) {\n      return toPrecisionNative(v.value0);\n    }\n    ;\n    if (v instanceof Fixed) {\n      return toFixedNative(v.value0);\n    }\n    ;\n    if (v instanceof Exponential) {\n      return toExponentialNative(v.value0);\n    }\n    ;\n    throw new Error(\"Failed pattern match at Data.Number.Format (line 59, column 1 - line 59, column 43): \" + [v.constructor.name]);\n  };\n  var fixed = /* @__PURE__ */ function() {\n    var $9 = clamp3(0)(20);\n    return function($10) {\n      return Fixed.create($9($10));\n    };\n  }();\n\n  // output/Util.Array/index.js\n  var $$void7 = /* @__PURE__ */ $$void(functorST);\n  var applySecond2 = /* @__PURE__ */ applySecond(applyST);\n  var swapST = function(x) {\n    return function(y) {\n      return function(st) {\n        return function __do2() {\n          var a2 = peek(x)(st)();\n          var b2 = peek(y)(st)();\n          if (a2 instanceof Just && b2 instanceof Just) {\n            return $$void7(applySecond2(poke(x)(b2.value0)(st))(poke(y)(a2.value0)(st)))();\n          }\n          ;\n          return unit;\n        };\n      };\n    };\n  };\n  var swap = function(x) {\n    return function(y) {\n      return function(array) {\n        return run2(function __do2() {\n          var st = thaw(array)();\n          swapST(x)(y)(st)();\n          return st;\n        });\n      };\n    };\n  };\n  var shiftInsert = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v === v1) {\n          return v2;\n        }\n        ;\n        return run2(function __do2() {\n          var st = thaw(v2)();\n          var item = splice(v)(1)([])(st)();\n          splice(v1)(0)(item)(st)();\n          return st;\n        });\n      };\n    };\n  };\n\n  // output/TcgCalculator.Math/index.js\n  var iterateN2 = /* @__PURE__ */ iterateN(unfoldable1Array);\n  var add1 = /* @__PURE__ */ add(semiringBigInt);\n  var append6 = /* @__PURE__ */ append(semigroupArray);\n  var zero2 = /* @__PURE__ */ zero(semiringBigInt);\n  var one2 = /* @__PURE__ */ one(semiringBigInt);\n  var map21 = /* @__PURE__ */ map(functorArray);\n  var unsafeIndex2 = /* @__PURE__ */ unsafeIndex();\n  var product3 = /* @__PURE__ */ product(foldableArray)(semiringBigInt);\n  var div3 = /* @__PURE__ */ div(euclideanRingBigInt);\n  var ptCacheSize = 64;\n  var createPascalTriangle = function(v) {\n    if (v <= 0) {\n      return [];\n    }\n    ;\n    return iterateN2(v)(function(r) {\n      return zipWith(add1)(append6([zero2])(r))(append6(r)([zero2]));\n    })([one2]);\n  };\n  var pascalTriangle = /* @__PURE__ */ createPascalTriangle(ptCacheSize);\n  var combinationNumber = function($copy_n) {\n    return function($copy_r) {\n      var $tco_var_n = $copy_n;\n      var $tco_done = false;\n      var $tco_result;\n      function $tco_loop(n, r) {\n        if (n < 0 || r < 0) {\n          $tco_done = true;\n          return zero2;\n        }\n        ;\n        if (r === 0) {\n          $tco_done = true;\n          return one2;\n        }\n        ;\n        if (r === 1) {\n          $tco_done = true;\n          return fromInt(n);\n        }\n        ;\n        if ((n - r | 0) < r) {\n          $tco_var_n = n;\n          $copy_r = n - r | 0;\n          return;\n        }\n        ;\n        if (n < ptCacheSize) {\n          $tco_done = true;\n          return unsafeIndex2(unsafeIndex2(pascalTriangle)(n))(r);\n        }\n        ;\n        if (otherwise) {\n          var product$prime = function() {\n            var $58 = map21(fromInt);\n            return function($59) {\n              return product3($58($59));\n            };\n          }();\n          $tco_done = true;\n          return div3(product$prime(range2((n - r | 0) + 1 | 0)(n)))(product$prime(range2(1)(r)));\n        }\n        ;\n        throw new Error(\"Failed pattern match at TcgCalculator.Math (line 45, column 1 - line 45, column 42): \" + [n.constructor.name, r.constructor.name]);\n      }\n      ;\n      while (!$tco_done) {\n        $tco_result = $tco_loop($tco_var_n, $copy_r);\n      }\n      ;\n      return $tco_result;\n    };\n  };\n\n  // output/TcgCalculator/index.js\n  var alaF3 = /* @__PURE__ */ alaF()()()();\n  var eq4 = /* @__PURE__ */ eq(eqId);\n  var unwrap4 = /* @__PURE__ */ unwrap();\n  var sumBy = function(dictSemiring) {\n    return alaF3(Additive)(foldMap2(monoidAdditive(dictSemiring)));\n  };\n  var sumBy1 = /* @__PURE__ */ sumBy(semiringInt);\n  var normalizeDeck = function(deck) {\n    return function(conditions) {\n      var usedCards = function() {\n        var $132 = nubByEq(on(eq4)(function(v) {\n          return v.id;\n        }));\n        var $133 = concatMap(function($136) {\n          return function(v) {\n            return v.cards;\n          }(unwrap4($136));\n        });\n        var $134 = concatMap(toArray2);\n        return function($135) {\n          return $132($133($134($135)));\n        };\n      }();\n      var diffCards = foldr2(deleteBy(on(eq4)(function(v) {\n        return v.id;\n      })));\n      var used = usedCards(conditions);\n      var unused = diffCards(deck.cards)(used);\n      return {\n        hand: deck.hand,\n        cards: used,\n        others: deck.others + sumBy1(function(v1) {\n          return v1.count;\n        })(unused) | 0\n      };\n    };\n  };\n  var calculateTotal = function(v) {\n    return combinationNumber(sumBy1(function(v1) {\n      return v1.count;\n    })(v.cards) + v.others | 0)(v.hand);\n  };\n\n  // output/App.Result/index.js\n  var eq5 = /* @__PURE__ */ eq(eqBigInt);\n  var zero3 = /* @__PURE__ */ zero(semiringBigInt);\n  var div4 = /* @__PURE__ */ div(euclideanRingNumber);\n  var lift5 = /* @__PURE__ */ lift(monadTransMaybeT)(monadHalogenM);\n  var bind7 = /* @__PURE__ */ bind(bindHalogenM);\n  var liftAff2 = /* @__PURE__ */ liftAff(/* @__PURE__ */ monadAffHalogenM(monadAffAff));\n  var discard4 = /* @__PURE__ */ discard(discardUnit)(bindHalogenM);\n  var put4 = /* @__PURE__ */ put(monadStateHalogenM);\n  var throwError2 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowHalogenM(monadThrowAff));\n  var gets4 = /* @__PURE__ */ gets(monadStateHalogenM);\n  var modify_4 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n  var traverse_5 = /* @__PURE__ */ traverse_(applicativeHalogenM)(foldableMaybe);\n  var pure7 = /* @__PURE__ */ pure(applicativeHalogenM);\n  var Calculate = /* @__PURE__ */ function() {\n    function Calculate4(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    Calculate4.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new Calculate4(value0, value1, value22);\n        };\n      };\n    };\n    return Calculate4;\n  }();\n  var component3 = /* @__PURE__ */ function() {\n    var render = function(v) {\n      return div2([class_(\"flex min-w-60 items-center\")])([div2([class_(\"mx-1 flex w-36 items-center justify-end gap-1\")])(function() {\n        if (v.calculation instanceof Just) {\n          return [div2([class_(\"text-2xl\")])([text(\"Calculating\")]), fa_(\"fa-spinner fa-pulse\")];\n        }\n        ;\n        return [div2([class_(\"text-2xl\")])([text(function() {\n          var $30 = eq5(v.total)(zero3);\n          if ($30) {\n            return \"N/A\";\n          }\n          ;\n          return toStringWith(fixed(4))(100 * on(div4)(toNumber2)(v.combination)(v.total)) + \"%\";\n        }())])];\n      }()), div2([class_(\"mx-1 flex min-w-20 flex-col items-end divide-y divide-gray-400\")])([div2([class_(\"px-1\")])([text(toString5(v.combination))]), div2([class_(\"px-1\")])([text(toString5(v.total))])])]);\n    };\n    var query3 = function(v) {\n      return lift5(bind7(fork(function() {\n        var deck$prime = normalizeDeck(v.value0)(v.value1);\n        return bind7(liftAff2(attempt(run3({\n          deck: deck$prime,\n          conditions: v.value1\n        }))))(function(result) {\n          if (result instanceof Left) {\n            return discard4(put4({\n              combination: zero3,\n              total: zero3,\n              calculation: Nothing.value\n            }))(function() {\n              return throwError2(result.value0);\n            });\n          }\n          ;\n          if (result instanceof Right) {\n            var total = calculateTotal(deck$prime);\n            return put4({\n              combination: result.value0,\n              total,\n              calculation: Nothing.value\n            });\n          }\n          ;\n          throw new Error(\"Failed pattern match at App.Result (line 73, column 9 - line 79, column 63): \" + [result.constructor.name]);\n        });\n      }()))(function(newCalculation) {\n        return bind7(gets4(function(v1) {\n          return v1.calculation;\n        }))(function(currentCalculation) {\n          return discard4(modify_4(function(v1) {\n            var $38 = {};\n            for (var $39 in v1) {\n              if ({}.hasOwnProperty.call(v1, $39)) {\n                $38[$39] = v1[$39];\n              }\n              ;\n            }\n            ;\n            $38.calculation = new Just(newCalculation);\n            return $38;\n          }))(function() {\n            return discard4(traverse_5(kill)(currentCalculation))(function() {\n              return pure7(v.value2);\n            });\n          });\n        });\n      }));\n    };\n    var initialState = function(v) {\n      return {\n        combination: zero3,\n        total: zero3,\n        calculation: Nothing.value\n      };\n    };\n    return mkComponent({\n      initialState,\n      render,\n      \"eval\": mkEval({\n        handleAction: defaultEval.handleAction,\n        receive: defaultEval.receive,\n        initialize: defaultEval.initialize,\n        finalize: defaultEval.finalize,\n        handleQuery: function($44) {\n          return runMaybeT(query3($44));\n        }\n      })\n    });\n  }();\n\n  // output/App.Condition/index.js\n  var lineIsSymbol = {\n    reflectSymbol: function() {\n      return \"line\";\n    }\n  };\n  var slot3 = /* @__PURE__ */ slot()(lineIsSymbol)(ordId);\n  var resultIsSymbol = {\n    reflectSymbol: function() {\n      return \"result\";\n    }\n  };\n  var slot_2 = /* @__PURE__ */ slot_()(resultIsSymbol)(ordUnit);\n  var map23 = /* @__PURE__ */ map(functorArray);\n  var apply2 = /* @__PURE__ */ apply(applyHalogenM);\n  var map110 = /* @__PURE__ */ map(functorHalogenM);\n  var fromFoldable7 = /* @__PURE__ */ fromFoldable3(foldableList);\n  var filterKeys2 = /* @__PURE__ */ filterKeys(ordId);\n  var flap2 = /* @__PURE__ */ flap(functorFn);\n  var notElem3 = /* @__PURE__ */ notElem2(eqId);\n  var gets5 = /* @__PURE__ */ gets(monadStateHalogenM);\n  var requestAll2 = /* @__PURE__ */ requestAll()(lineIsSymbol)(ordId);\n  var bind8 = /* @__PURE__ */ bind(bindHalogenM);\n  var fromFoldable1 = /* @__PURE__ */ fromFoldable(foldableMaybe);\n  var tell4 = /* @__PURE__ */ tell2();\n  var tell1 = /* @__PURE__ */ tell4(resultIsSymbol)(ordUnit);\n  var apply1 = /* @__PURE__ */ apply(/* @__PURE__ */ applyMaybeT(monadHalogenM));\n  var map24 = /* @__PURE__ */ map(/* @__PURE__ */ functorMaybeT(functorHalogenM));\n  var bindMaybeT2 = /* @__PURE__ */ bindMaybeT(monadHalogenM);\n  var bindFlipped5 = /* @__PURE__ */ bindFlipped(bindMaybeT2);\n  var guard2 = /* @__PURE__ */ guard(/* @__PURE__ */ alternativeMaybeT(monadHalogenM));\n  var monadStateMaybeT2 = /* @__PURE__ */ monadStateMaybeT(monadStateHalogenM);\n  var gets1 = /* @__PURE__ */ gets(monadStateMaybeT2);\n  var map32 = /* @__PURE__ */ map(functorMaybe);\n  var $$for2 = /* @__PURE__ */ $$for(applicativeMaybe)(traversableArray);\n  var mapFlipped5 = /* @__PURE__ */ mapFlipped(functorMaybe);\n  var lookup6 = /* @__PURE__ */ lookup(ordId);\n  var mapFlipped1 = /* @__PURE__ */ mapFlipped(functorArray);\n  var get4 = /* @__PURE__ */ get(monadStateHalogenM);\n  var lift6 = /* @__PURE__ */ lift(monadTransMaybeT)(monadHalogenM);\n  var traverse3 = /* @__PURE__ */ traverse(traversableArray)(applicativeHalogenM);\n  var flap1 = /* @__PURE__ */ flap(functorHalogenM);\n  var idIsSymbol2 = {\n    reflectSymbol: function() {\n      return \"id\";\n    }\n  };\n  var insert8 = /* @__PURE__ */ insert5(idIsSymbol2)()();\n  var generateId2 = /* @__PURE__ */ generateId(/* @__PURE__ */ monadEffectHalogenM(monadEffectAff));\n  var discard5 = /* @__PURE__ */ discard(discardUnit);\n  var discard1 = /* @__PURE__ */ discard5(bindHalogenM);\n  var put5 = /* @__PURE__ */ put(monadStateHalogenM);\n  var for_2 = /* @__PURE__ */ for_(applicativeHalogenM)(foldableArray);\n  var eq6 = /* @__PURE__ */ eq(eqId);\n  var tell22 = /* @__PURE__ */ tell4(lineIsSymbol)(ordId);\n  var pure8 = /* @__PURE__ */ pure(applicativeHalogenM);\n  var discard22 = /* @__PURE__ */ discard5(bindMaybeT2);\n  var modify_5 = /* @__PURE__ */ modify_2(monadStateMaybeT2);\n  var bind14 = /* @__PURE__ */ bind(bindFn);\n  var pure1 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeMaybeT(monadHalogenM));\n  var modify_1 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n  var modify7 = /* @__PURE__ */ modify2(monadStateHalogenM);\n  var notEq2 = /* @__PURE__ */ notEq(eqId);\n  var identity13 = /* @__PURE__ */ identity(categoryFn);\n  var bind22 = /* @__PURE__ */ bind(bindMaybe);\n  var pure23 = /* @__PURE__ */ pure(applicativeMaybe);\n  var when3 = /* @__PURE__ */ when(applicativeHalogenM);\n  var eqRec2 = /* @__PURE__ */ eqRec();\n  var eqRowCons2 = /* @__PURE__ */ eqRowCons(eqRowNil)();\n  var notEq1 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({\n    reflectSymbol: function() {\n      return \"others\";\n    }\n  })(eqInt))()({\n    reflectSymbol: function() {\n      return \"hand\";\n    }\n  })(eqInt))()({\n    reflectSymbol: function() {\n      return \"cards\";\n    }\n  })(/* @__PURE__ */ eqArray(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({\n    reflectSymbol: function() {\n      return \"name\";\n    }\n  })(eqString))()(idIsSymbol2)(eqId))()({\n    reflectSymbol: function() {\n      return \"count\";\n    }\n  })(eqInt))))));\n  var Updated2 = /* @__PURE__ */ function() {\n    function Updated3() {\n    }\n    ;\n    Updated3.value = new Updated3();\n    return Updated3;\n  }();\n  var AllConditionDeleted = /* @__PURE__ */ function() {\n    function AllConditionDeleted2() {\n    }\n    ;\n    AllConditionDeleted2.value = new AllConditionDeleted2();\n    return AllConditionDeleted2;\n  }();\n  var GetConditions = /* @__PURE__ */ function() {\n    function GetConditions2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    GetConditions2.create = function(value0) {\n      return new GetConditions2(value0);\n    };\n    return GetConditions2;\n  }();\n  var GetState = /* @__PURE__ */ function() {\n    function GetState2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    GetState2.create = function(value0) {\n      return new GetState2(value0);\n    };\n    return GetState2;\n  }();\n  var RestoreState2 = /* @__PURE__ */ function() {\n    function RestoreState4(value0, value1, value22) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value22;\n    }\n    ;\n    RestoreState4.create = function(value0) {\n      return function(value1) {\n        return function(value22) {\n          return new RestoreState4(value0, value1, value22);\n        };\n      };\n    };\n    return RestoreState4;\n  }();\n  var ToggleDisabled = /* @__PURE__ */ function() {\n    function ToggleDisabled3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    ToggleDisabled3.create = function(value0) {\n      return new ToggleDisabled3(value0);\n    };\n    return ToggleDisabled3;\n  }();\n  var Initialize3 = /* @__PURE__ */ function() {\n    function Initialize5() {\n    }\n    ;\n    Initialize5.value = new Initialize5();\n    return Initialize5;\n  }();\n  var AddCondition = /* @__PURE__ */ function() {\n    function AddCondition3() {\n    }\n    ;\n    AddCondition3.value = new AddCondition3();\n    return AddCondition3;\n  }();\n  var RemoveCondition = /* @__PURE__ */ function() {\n    function RemoveCondition3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    RemoveCondition3.create = function(value0) {\n      return new RemoveCondition3(value0);\n    };\n    return RemoveCondition3;\n  }();\n  var ToggleItemDisabled = /* @__PURE__ */ function() {\n    function ToggleItemDisabled2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    ToggleItemDisabled2.create = function(value0) {\n      return new ToggleItemDisabled2(value0);\n    };\n    return ToggleItemDisabled2;\n  }();\n  var Receive4 = /* @__PURE__ */ function() {\n    function Receive5(value0) {\n      this.value0 = value0;\n    }\n    ;\n    Receive5.create = function(value0) {\n      return new Receive5(value0);\n    };\n    return Receive5;\n  }();\n  var Calculate2 = /* @__PURE__ */ function() {\n    function Calculate4() {\n    }\n    ;\n    Calculate4.value = new Calculate4();\n    return Calculate4;\n  }();\n  var component4 = /* @__PURE__ */ function() {\n    var renderConditionLine = function(cards) {\n      return function(v) {\n        return li([classes([\"flex gap-1 rounded px-1\", function() {\n          if (v.disabled) {\n            return \"bg-slate-100 text-gray-400 line-through\";\n          }\n          ;\n          return \"bg-transparent\";\n        }()])])([div2([class_(\"mx-1 flex\")])([removeButton(new RemoveCondition(v.id)), toggleButton(new ToggleItemDisabled(v.id))]), div2([class_(\"min-w-0 grow\")])([slot3($$Proxy.value)(v.id)(component2)(cards)($$const(Calculate2.value))])]);\n      };\n    };\n    var renderConditionHeader = function(disabled10) {\n      return div2([class_(\"flex items-center justify-end gap-1\")])([div2([class_(function() {\n        if (disabled10) {\n          return \"mr-auto w-0 py-1 pl-3 text-xl\";\n        }\n        ;\n        return \"hidden\";\n      }())])([text(\"Disabled\")]), div2([class_(function() {\n        if (disabled10) {\n          return \"text-gray-400\";\n        }\n        ;\n        return \"text-black\";\n      }())])([slot_2($$Proxy.value)(unit)(component3)(unit)])]);\n    };\n    var renderConditionAddButton = div2([class_(\"px-1\")])([plusButton(AddCondition.value)]);\n    var render = function(v) {\n      return div2([classes([\"grow rounded border-2 border-violet-300 p-1\", function() {\n        if (v.disabled) {\n          return \"bg-slate-100 text-gray-400\";\n        }\n        ;\n        return \"bg-white text-gray-700\";\n      }()])])([renderConditionHeader(v.disabled), ul([class_(\"my-1\")])(map23(renderConditionLine(v.deck.cards))(v.conditions)), renderConditionAddButton]);\n    };\n    var initialState = function(v) {\n      return {\n        conditions: [],\n        deck: v,\n        disabled: false\n      };\n    };\n    var getConditions = apply2(map110(function(v) {\n      return function(v1) {\n        return fromFoldable7(values(filterKeys2(flap2(notElem3)(v))(v1)));\n      };\n    })(map110(function() {\n      var $218 = map23(function(v) {\n        return v.id;\n      });\n      var $219 = filter(function(v) {\n        return v.disabled;\n      });\n      return function($220) {\n        return $218($219($220));\n      };\n    }())(gets5(function(v) {\n      return v.conditions;\n    }))))(requestAll2($$Proxy.value)(GetCondition.create));\n    var calculate = bind8(gets5(function(v) {\n      return v.deck;\n    }))(function(deck) {\n      return bind8(map110(fromFoldable1)(getConditions))(function(conditions) {\n        return tell1($$Proxy.value)(unit)(Calculate.create(deck)(conditions));\n      });\n    });\n    var query3 = function(v) {\n      if (v instanceof GetConditions) {\n        return apply1(map24(function(v1) {\n          return function(v2) {\n            return v.value0(v2);\n          };\n        })(bindFlipped5(function($221) {\n          return guard2(!$221);\n        })(gets1(function(v1) {\n          return v1.disabled;\n        }))))(getConditions);\n      }\n      ;\n      if (v instanceof GetState) {\n        return apply2(map110(function(v1) {\n          return function(v2) {\n            return map32(function(v3) {\n              return v.value0({\n                conditions: v3,\n                disabled: v1.disabled\n              });\n            })($$for2(v1.conditions)(function(v3) {\n              return mapFlipped5(lookup6(v3.id)(v2))(function(v42) {\n                return {\n                  mode: v42.mode,\n                  count: v42.count,\n                  cards: mapFlipped1(v42.cards)(function(v52) {\n                    return v52.id;\n                  }),\n                  disabled: v3.disabled\n                };\n              });\n            }));\n          };\n        })(get4))(requestAll2($$Proxy.value)(GetCondition.create));\n      }\n      ;\n      if (v instanceof RestoreState2) {\n        return lift6(bind8(traverse3(flap1(map110(insert8($$Proxy.value))(generateId2)))(v.value1.conditions))(function(conditions$prime) {\n          return discard1(put5({\n            conditions: mapFlipped1(conditions$prime)(function(v1) {\n              return {\n                id: v1.id,\n                disabled: v1.disabled\n              };\n            }),\n            deck: v.value0,\n            disabled: v.value1.disabled\n          }))(function() {\n            return discard1(for_2(conditions$prime)(function(v1) {\n              var cards$prime = flap2(mapMaybe)(v1.cards)(function(cardId) {\n                return find2(function($222) {\n                  return function(v2) {\n                    return eq6(v2)(cardId);\n                  }(function(v2) {\n                    return v2.id;\n                  }($222));\n                })(v.value0.cards);\n              });\n              return tell22($$Proxy.value)(v1.id)(RestoreState.create(v.value0.cards)({\n                mode: v1.mode,\n                count: v1.count,\n                cards: cards$prime\n              }));\n            }))(function() {\n              return discard1(calculate)(function() {\n                return pure8(v.value2);\n              });\n            });\n          });\n        }));\n      }\n      ;\n      if (v instanceof ToggleDisabled) {\n        return discard22(modify_5(bind14(function(v1) {\n          return v1.disabled;\n        })(function(disabled10) {\n          return function(v1) {\n            var $192 = {};\n            for (var $193 in v1) {\n              if ({}.hasOwnProperty.call(v1, $193)) {\n                $192[$193] = v1[$193];\n              }\n              ;\n            }\n            ;\n            $192.disabled = !disabled10;\n            return $192;\n          };\n        })))(function() {\n          return pure1(v.value0);\n        });\n      }\n      ;\n      throw new Error(\"Failed pattern match at App.Condition (line 158, column 11 - line 182, column 13): \" + [v.constructor.name]);\n    };\n    var action2 = function(v) {\n      if (v instanceof Initialize3) {\n        return discard1(action2(AddCondition.value))(function() {\n          return calculate;\n        });\n      }\n      ;\n      if (v instanceof AddCondition) {\n        return bind8(gets5(function(v1) {\n          return v1.conditions;\n        }))(function(conditions) {\n          return bind8(generateId2)(function(id3) {\n            return modify_1(function(v1) {\n              var $197 = {};\n              for (var $198 in v1) {\n                if ({}.hasOwnProperty.call(v1, $198)) {\n                  $197[$198] = v1[$198];\n                }\n                ;\n              }\n              ;\n              $197.conditions = snoc(conditions)({\n                id: id3,\n                disabled: false\n              });\n              return $197;\n            });\n          });\n        });\n      }\n      ;\n      if (v instanceof RemoveCondition) {\n        return bind8(modify7(bind14(function(v1) {\n          return v1.conditions;\n        })(function(conditions) {\n          return function(v1) {\n            var $200 = {};\n            for (var $201 in v1) {\n              if ({}.hasOwnProperty.call(v1, $201)) {\n                $200[$201] = v1[$201];\n              }\n              ;\n            }\n            ;\n            $200.conditions = filter(function($223) {\n              return function(v2) {\n                return notEq2(v2)(v.value0);\n              }(function(v2) {\n                return v2.id;\n              }($223));\n            })(conditions);\n            return $200;\n          };\n        })))(function(v1) {\n          var $204 = $$null(v1.conditions);\n          if ($204) {\n            return raise(AllConditionDeleted.value);\n          }\n          ;\n          return action2(Calculate2.value);\n        });\n      }\n      ;\n      if (v instanceof ToggleItemDisabled) {\n        return discard1(modify_1(bind14(function(v1) {\n          return v1.conditions;\n        })(function(conditions) {\n          return fromMaybe(identity13)(bind22(findIndex(function($224) {\n            return function(v1) {\n              return eq6(v1)(v.value0);\n            }(function(v1) {\n              return v1.id;\n            }($224));\n          })(conditions))(function(i2) {\n            return bind22(modifyAt(i2)(function(s) {\n              var $207 = {};\n              for (var $208 in s) {\n                if ({}.hasOwnProperty.call(s, $208)) {\n                  $207[$208] = s[$208];\n                }\n                ;\n              }\n              ;\n              $207.disabled = !s.disabled;\n              return $207;\n            })(conditions))(function(conditions$prime) {\n              return pure23(function(v1) {\n                var $210 = {};\n                for (var $211 in v1) {\n                  if ({}.hasOwnProperty.call(v1, $211)) {\n                    $210[$211] = v1[$211];\n                  }\n                  ;\n                }\n                ;\n                $210.conditions = conditions$prime;\n                return $210;\n              });\n            });\n          }));\n        })))(function() {\n          return action2(Calculate2.value);\n        });\n      }\n      ;\n      if (v instanceof Receive4) {\n        return bind8(gets5(function(v1) {\n          return v1.deck;\n        }))(function(current) {\n          return when3(notEq1(v.value0)(current))(discard1(modify_1(function(v1) {\n            var $214 = {};\n            for (var $215 in v1) {\n              if ({}.hasOwnProperty.call(v1, $215)) {\n                $214[$215] = v1[$215];\n              }\n              ;\n            }\n            ;\n            $214.deck = v.value0;\n            return $214;\n          }))(function() {\n            return calculate;\n          }));\n        });\n      }\n      ;\n      if (v instanceof Calculate2) {\n        return discard1(calculate)(function() {\n          return raise(Updated2.value);\n        });\n      }\n      ;\n      throw new Error(\"Failed pattern match at App.Condition (line 115, column 12 - line 145, column 22): \" + [v.constructor.name]);\n    };\n    return mkComponent({\n      initialState,\n      render,\n      \"eval\": mkEval({\n        finalize: defaultEval.finalize,\n        handleAction: action2,\n        handleQuery: function($225) {\n          return runMaybeT(query3($225));\n        },\n        initialize: new Just(Initialize3.value),\n        receive: function($226) {\n          return Just.create(Receive4.create($226));\n        }\n      })\n    });\n  }();\n\n  // output/Web.HTML/foreign.js\n  var windowImpl = function() {\n    return window;\n  };\n\n  // output/Web.HTML.HTMLDocument/foreign.js\n  function _readyState(doc) {\n    return doc.readyState;\n  }\n\n  // output/Web.HTML.HTMLDocument.ReadyState/index.js\n  var Loading = /* @__PURE__ */ function() {\n    function Loading2() {\n    }\n    ;\n    Loading2.value = new Loading2();\n    return Loading2;\n  }();\n  var Interactive = /* @__PURE__ */ function() {\n    function Interactive2() {\n    }\n    ;\n    Interactive2.value = new Interactive2();\n    return Interactive2;\n  }();\n  var Complete = /* @__PURE__ */ function() {\n    function Complete2() {\n    }\n    ;\n    Complete2.value = new Complete2();\n    return Complete2;\n  }();\n  var parse2 = function(v) {\n    if (v === \"loading\") {\n      return new Just(Loading.value);\n    }\n    ;\n    if (v === \"interactive\") {\n      return new Just(Interactive.value);\n    }\n    ;\n    if (v === \"complete\") {\n      return new Just(Complete.value);\n    }\n    ;\n    return Nothing.value;\n  };\n\n  // output/Web.HTML.HTMLDocument/index.js\n  var map25 = /* @__PURE__ */ map(functorEffect);\n  var toParentNode = unsafeCoerce2;\n  var toDocument = unsafeCoerce2;\n  var readyState = function(doc) {\n    return map25(function() {\n      var $4 = fromMaybe(Loading.value);\n      return function($5) {\n        return $4(parse2($5));\n      };\n    }())(function() {\n      return _readyState(doc);\n    });\n  };\n\n  // output/Web.HTML.Location/foreign.js\n  function hash(location2) {\n    return function() {\n      return location2.hash;\n    };\n  }\n  function setHash(hash2) {\n    return function(location2) {\n      return function() {\n        location2.hash = hash2;\n      };\n    };\n  }\n\n  // output/Web.HTML.Window/foreign.js\n  function document(window2) {\n    return function() {\n      return window2.document;\n    };\n  }\n  function location(window2) {\n    return function() {\n      return window2.location;\n    };\n  }\n  function confirm(str) {\n    return function(window2) {\n      return function() {\n        return window2.confirm(str);\n      };\n    };\n  }\n\n  // output/Web.HTML.Window/index.js\n  var toEventTarget = unsafeCoerce2;\n\n  // output/Web.HTML.Event.DataTransfer/foreign.js\n  function types(dataTransfer2) {\n    return dataTransfer2.types;\n  }\n  function _getData(format) {\n    return function(dataTransfer2) {\n      return function() {\n        return dataTransfer2.getData(format);\n      };\n    };\n  }\n  function _setData(format) {\n    return function(data) {\n      return function(dataTransfer2) {\n        return function() {\n          return dataTransfer2.setData(format, data);\n        };\n      };\n    };\n  }\n  function _setDragImage(dataTransfer2) {\n    return function(image) {\n      return function(x) {\n        return function(y) {\n          return function() {\n            return dataTransfer2.setDragImage(image, x, y);\n          };\n        };\n      };\n    };\n  }\n\n  // output/Web.HTML.Event.DataTransfer/index.js\n  var setDragImage = _setDragImage;\n  var setData2 = function(v) {\n    return function(dat) {\n      return function(dt2) {\n        return _setData(v)(dat)(dt2);\n      };\n    };\n  };\n  var getData = function(v) {\n    return function(dt2) {\n      return _getData(v)(dt2);\n    };\n  };\n\n  // output/Web.HTML.Event.DragEvent/foreign.js\n  function dataTransfer(e) {\n    return e.dataTransfer;\n  }\n\n  // output/Web.HTML.Event.DragEvent/index.js\n  var toEvent2 = unsafeCoerce2;\n\n  // output/App.Deck/index.js\n  var collect3 = /* @__PURE__ */ collect()();\n  var type_20 = /* @__PURE__ */ type_3(isPropInputType);\n  var value14 = /* @__PURE__ */ value2(isPropString);\n  var show6 = /* @__PURE__ */ show(showInt);\n  var map26 = /* @__PURE__ */ map(functorArray);\n  var not4 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));\n  var discard6 = /* @__PURE__ */ discard(discardUnit);\n  var discard12 = /* @__PURE__ */ discard6(/* @__PURE__ */ bindMaybeT(monadHalogenM));\n  var put6 = /* @__PURE__ */ put(/* @__PURE__ */ monadStateMaybeT(monadStateHalogenM));\n  var pure9 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeMaybeT(monadHalogenM));\n  var bind9 = /* @__PURE__ */ bind(bindHalogenM);\n  var monadEffectHalogenM2 = /* @__PURE__ */ monadEffectHalogenM(monadEffectAff);\n  var generateId3 = /* @__PURE__ */ generateId(monadEffectHalogenM2);\n  var modify_6 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n  var bind15 = /* @__PURE__ */ bind(bindFn);\n  var $$void8 = /* @__PURE__ */ $$void(functorHalogenM);\n  var whenM3 = /* @__PURE__ */ whenM(monadHalogenM);\n  var pure12 = /* @__PURE__ */ pure(applicativeHalogenM);\n  var liftEffect4 = /* @__PURE__ */ liftEffect(monadEffectHalogenM2);\n  var bindFlipped6 = /* @__PURE__ */ bindFlipped(bindEffect);\n  var get5 = /* @__PURE__ */ get(monadStateHalogenM);\n  var eq7 = /* @__PURE__ */ eq(eqId);\n  var bindFlipped1 = /* @__PURE__ */ bindFlipped(bindHalogenM);\n  var modify8 = /* @__PURE__ */ modify2(monadStateHalogenM);\n  var fold2 = /* @__PURE__ */ fold(foldableMaybe);\n  var fold12 = /* @__PURE__ */ fold2(/* @__PURE__ */ monoidHalogenM(monoidUnit));\n  var bind23 = /* @__PURE__ */ bind(bindMaybe);\n  var clamp4 = /* @__PURE__ */ clamp(ordInt);\n  var pure24 = /* @__PURE__ */ pure(applicativeMaybe);\n  var gets6 = /* @__PURE__ */ gets(monadStateHalogenM);\n  var identity14 = /* @__PURE__ */ identity(categoryFn);\n  var min7 = /* @__PURE__ */ min(ordInt);\n  var composeKleisliFlipped5 = /* @__PURE__ */ composeKleisliFlipped(bindMaybe);\n  var traverse_6 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableMaybe);\n  var discard23 = /* @__PURE__ */ discard6(bindHalogenM);\n  var when4 = /* @__PURE__ */ when(applicativeHalogenM);\n  var eq12 = /* @__PURE__ */ eq(/* @__PURE__ */ eqArray(eqString));\n  var unless2 = /* @__PURE__ */ unless(applicativeHalogenM);\n  var fold22 = /* @__PURE__ */ fold2(monoidArray);\n  var SetDeck = /* @__PURE__ */ function() {\n    function SetDeck2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    SetDeck2.create = function(value0) {\n      return function(value1) {\n        return new SetDeck2(value0, value1);\n      };\n    };\n    return SetDeck2;\n  }();\n  var AddCard = /* @__PURE__ */ function() {\n    function AddCard2() {\n    }\n    ;\n    AddCard2.value = new AddCard2();\n    return AddCard2;\n  }();\n  var RemoveCard = /* @__PURE__ */ function() {\n    function RemoveCard2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    RemoveCard2.create = function(value0) {\n      return new RemoveCard2(value0);\n    };\n    return RemoveCard2;\n  }();\n  var UpdateCard = /* @__PURE__ */ function() {\n    function UpdateCard2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UpdateCard2.create = function(value0) {\n      return new UpdateCard2(value0);\n    };\n    return UpdateCard2;\n  }();\n  var UpdateDeck = /* @__PURE__ */ function() {\n    function UpdateDeck3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UpdateDeck3.create = function(value0) {\n      return new UpdateDeck3(value0);\n    };\n    return UpdateDeck3;\n  }();\n  var UpdateHand = /* @__PURE__ */ function() {\n    function UpdateHand2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UpdateHand2.create = function(value0) {\n      return new UpdateHand2(value0);\n    };\n    return UpdateHand2;\n  }();\n  var UpdateOthers = /* @__PURE__ */ function() {\n    function UpdateOthers2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UpdateOthers2.create = function(value0) {\n      return new UpdateOthers2(value0);\n    };\n    return UpdateOthers2;\n  }();\n  var SelectOnFocus2 = /* @__PURE__ */ function() {\n    function SelectOnFocus3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    SelectOnFocus3.create = function(value0) {\n      return new SelectOnFocus3(value0);\n    };\n    return SelectOnFocus3;\n  }();\n  var StartReorder = /* @__PURE__ */ function() {\n    function StartReorder2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    StartReorder2.create = function(value0) {\n      return function(value1) {\n        return new StartReorder2(value0, value1);\n      };\n    };\n    return StartReorder2;\n  }();\n  var HandleDragBehavior = /* @__PURE__ */ function() {\n    function HandleDragBehavior2(value0) {\n      this.value0 = value0;\n    }\n    ;\n    HandleDragBehavior2.create = function(value0) {\n      return new HandleDragBehavior2(value0);\n    };\n    return HandleDragBehavior2;\n  }();\n  var ExecuteReorder = /* @__PURE__ */ function() {\n    function ExecuteReorder2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    ExecuteReorder2.create = function(value0) {\n      return function(value1) {\n        return new ExecuteReorder2(value0, value1);\n      };\n    };\n    return ExecuteReorder2;\n  }();\n  var component5 = /* @__PURE__ */ function() {\n    var styleFormInput = collect3(ClassName)(joinWith(\" \"))([\"appearance-none border-b border-transparent bg-white p-1 text-gray-700\", \"transition-colors duration-75 hover:border-gray-500 focus:border-slate-800 focus:outline-none\"]);\n    var styleFormNumber = collect3(ClassName)(joinWith(\" \"))([\"w-16 text-right\", styleFormInput]);\n    var renderIntegerInput = function(text6) {\n      return function(count) {\n        return function(min1) {\n          return function(max7) {\n            return function(h) {\n              return div2([class_(\"mx-1 flex flex-wrap items-baseline justify-end border-b border-gray-500\")])([div2([class_(\"m-1\")])([text(text6)]), input([class_(styleFormNumber), type_20(InputNumber.value), value14(show6(count)), step3(new Step(1)), min4(toNumber(min1)), max4(toNumber(max7)), onFocus(SelectOnFocus2.create), onValueChange(function() {\n                var $129 = fromMaybe(0);\n                return function($130) {\n                  return h($129(fromString($130)));\n                };\n              }())])]);\n            };\n          };\n        };\n      };\n    };\n    var renderCard = function(others) {\n      return function(card) {\n        return li([class_(\"flex\"), ref2(toString4(card.id)), onDrop(ExecuteReorder.create(card.id))])([div2([class_(\"mx-1 flex items-center\")])([div2([class_(\"hidden cursor-grab px-1 text-gray-500 active:cursor-grabbing md:block\"), draggable(true), onDragStart(StartReorder.create(card.id))])([fa_(\"fa-grip-vertical\")]), removeButton(new RemoveCard(card))]), div2([class_(\"flex grow border-b border-gray-500\")])([input([classes([\"grow\", styleFormInput]), type_20(InputText.value), value14(card.name), onValueChange(function($131) {\n          return UpdateCard.create(function(v) {\n            return {\n              id: card.id,\n              count: card.count,\n              name: v\n            };\n          }($131));\n        })]), input([class_(styleFormNumber), type_20(InputNumber.value), step3(new Step(1)), value14(show6(card.count)), min4(0), max4(function() {\n          var $92 = $$null2(card.name);\n          if ($92) {\n            return 0;\n          }\n          ;\n          return toNumber(card.count + others | 0);\n        }()), onFocus(SelectOnFocus2.create), onValueChange(function() {\n          var $132 = fromMaybe(0);\n          return function($133) {\n            return UpdateCard.create(function(v) {\n              return {\n                id: card.id,\n                name: card.name,\n                count: v\n              };\n            }($132(fromString($133))));\n          };\n        }())])])]);\n      };\n    };\n    var renderCardList = function(others) {\n      return function(cards) {\n        return ul([class_(\"m-1\"), onDragEnter(HandleDragBehavior.create), onDragOver(HandleDragBehavior.create)])(map26(renderCard(others))(cards));\n      };\n    };\n    var raiseUpdated = function(deck) {\n      return raise({\n        others: deck.others,\n        hand: deck.hand,\n        cards: filter(function() {\n          var $134 = not4($$null2);\n          return function($135) {\n            return $134(function(v1) {\n              return v1.name;\n            }($135));\n          };\n        }())(deck.cards)\n      });\n    };\n    var query3 = function(v) {\n      return discard12(put6(v.value0))(function() {\n        return pure9(v.value1);\n      });\n    };\n    var initialState = function(v) {\n      return {\n        cards: [],\n        others: 40,\n        hand: 5\n      };\n    };\n    var renderFooter = function(otherCount) {\n      return function(cardCount) {\n        return div2([class_(\"flex items-baseline gap-1\")])([div2([class_(\"mx-1 grow\")])([plusButton(AddCard.value)]), renderIntegerInput(\"\\u305D\\u306E\\u4ED6\\u306E\\u30AB\\u30FC\\u30C9:\")(otherCount)(0)(255 - cardCount | 0)(UpdateOthers.create)]);\n      };\n    };\n    var renderHeader = function(deckCount) {\n      return function(handCount) {\n        return function(cardCount) {\n          return div2([class_(\"flex items-baseline gap-1\")])([div2([class_(\"mx-1 flex grow flex-wrap items-baseline text-sky-900\")])([fa(\"fa-layer-group\")([\"m-1 text-2xl\"]), div2([class_(\"m-1\")])([text(\"\\u30C7\\u30C3\\u30AD\\u60C5\\u5831\")])]), renderIntegerInput(\"\\u624B\\u672D\\u679A\\u6570:\")(handCount)(1)(deckCount)(UpdateHand.create), renderIntegerInput(\"\\u30C7\\u30C3\\u30AD\\u679A\\u6570:\")(deckCount)(cardCount)(255)(UpdateDeck.create)]);\n        };\n      };\n    };\n    var countCards = alaF()()()()(Additive)(foldMap2(monoidAdditive(semiringInt)))(function(v) {\n      return v.count;\n    });\n    var render = function(v) {\n      var cardCount = countCards(v.cards);\n      var deckCount = cardCount + v.others | 0;\n      return div2([class_(\"rounded border-2 border-amber-500 p-1\")])([renderHeader(deckCount)(v.hand)(cardCount), renderCardList(v.others)(v.cards), renderFooter(v.others)(cardCount)]);\n    };\n    var action2 = function(v) {\n      if (v instanceof AddCard) {\n        return bind9(generateId3)(function(id3) {\n          return modify_6(bind15(function(v1) {\n            return v1.cards;\n          })(function(cards) {\n            return function(v1) {\n              var $101 = {};\n              for (var $102 in v1) {\n                if ({}.hasOwnProperty.call(v1, $102)) {\n                  $101[$102] = v1[$102];\n                }\n                ;\n              }\n              ;\n              $101.cards = snoc(cards)({\n                id: id3,\n                name: \"\",\n                count: 0\n              });\n              return $101;\n            };\n          }));\n        });\n      }\n      ;\n      if (v instanceof RemoveCard) {\n        return $$void8(fork(whenM3(function() {\n          var $104 = $$null2(v.value0.name);\n          if ($104) {\n            return pure12(true);\n          }\n          ;\n          return liftEffect4(bindFlipped6(confirm(\"\\u30AB\\u30FC\\u30C9\\u300C\" + (v.value0.name + \"\\u300D\\u3092\\u524A\\u9664\\u3057\\u307E\\u3059\\u3002\")))(windowImpl));\n        }())(bind9(get5)(function(v1) {\n          var cards$prime = deleteBy(on(eq7)(function(v2) {\n            return v2.id;\n          }))(v.value0)(v1.cards);\n          return bindFlipped1(raiseUpdated)(modify8(function(v2) {\n            return {\n              hand: v2.hand,\n              cards: cards$prime,\n              others: v1.others + v.value0.count | 0\n            };\n          }));\n        }))));\n      }\n      ;\n      if (v instanceof UpdateCard) {\n        return bind9(get5)(function(v1) {\n          return fold12(bind23(findIndex(function($136) {\n            return function(v2) {\n              return eq7(v2)(v.value0.id);\n            }(function(v2) {\n              return v2.id;\n            }($136));\n          })(v1.cards))(function(i2) {\n            return bind23(index(v1.cards)(i2))(function(old) {\n              var $$new3 = function() {\n                var $110 = $$null2(v.value0.name);\n                if ($110) {\n                  return {\n                    id: v.value0.id,\n                    name: v.value0.name,\n                    count: 0\n                  };\n                }\n                ;\n                return {\n                  id: v.value0.id,\n                  name: v.value0.name,\n                  count: clamp4(0)(old.count + v1.others | 0)(v.value0.count)\n                };\n              }();\n              return bind23(updateAt(i2)($$new3)(v1.cards))(function(cards$prime) {\n                return pure24(bindFlipped1(raiseUpdated)(modify8(function(v2) {\n                  return {\n                    hand: v2.hand,\n                    cards: cards$prime,\n                    others: v1.others - ($$new3.count - old.count | 0) | 0\n                  };\n                })));\n              });\n            });\n          }));\n        });\n      }\n      ;\n      if (v instanceof UpdateDeck) {\n        return bind9(gets6(function(v1) {\n          return v1.cards;\n        }))(function(cards) {\n          var cardCount = countCards(cards);\n          return action2(new UpdateOthers(v.value0 - cardCount | 0));\n        });\n      }\n      ;\n      if (v instanceof UpdateHand) {\n        return bindFlipped1(raiseUpdated)(modify8(bind15(identity14)(function(v1) {\n          var deckCount = countCards(v1.cards) + v1.others | 0;\n          return function(v2) {\n            return {\n              cards: v2.cards,\n              others: v2.others,\n              hand: clamp4(1)(deckCount)(v.value0)\n            };\n          };\n        })));\n      }\n      ;\n      if (v instanceof UpdateOthers) {\n        return bindFlipped1(raiseUpdated)(modify8(bind15(identity14)(function(v1) {\n          var cardCount = countCards(v1.cards);\n          var deckCount = clamp4(cardCount)(255)(cardCount + v.value0 | 0);\n          return function(v2) {\n            return {\n              cards: v2.cards,\n              others: deckCount - cardCount | 0,\n              hand: min7(v1.hand)(deckCount)\n            };\n          };\n        })));\n      }\n      ;\n      if (v instanceof SelectOnFocus2) {\n        var element3 = composeKleisliFlipped5(fromEventTarget)(function($137) {\n          return target(toEvent($137));\n        })(v.value0);\n        return liftEffect4(traverse_6(select2)(element3));\n      }\n      ;\n      if (v instanceof StartReorder) {\n        var transfer = dataTransfer(v.value1);\n        return discard23(liftEffect4(setData2(\"tcg-calculator/card\")(toString4(v.value0))(transfer)))(function() {\n          return bind9(getRef(toString4(v.value0)))(function(elem4) {\n            return liftEffect4(traverse_6(function(e) {\n              return setDragImage(transfer)(e)(5)(15);\n            })(elem4));\n          });\n        });\n      }\n      ;\n      if (v instanceof HandleDragBehavior) {\n        var transfer = dataTransfer(v.value0);\n        return when4(eq12(types(transfer))([\"tcg-calculator/card\"]))(liftEffect4(preventDefault(toEvent2(v.value0))));\n      }\n      ;\n      if (v instanceof ExecuteReorder) {\n        var transfer = dataTransfer(v.value1);\n        return bind9(liftEffect4(getData(\"tcg-calculator/card\")(transfer)))(function(id3) {\n          return unless2($$null2(id3))(discard23(bindFlipped1(raiseUpdated)(modify8(bind15(function(v1) {\n            return v1.cards;\n          })(function(cards) {\n            var cards$prime = fold22(bind23(fromString3(id3))(function(target7) {\n              return bind23(findIndex(function($138) {\n                return function(v1) {\n                  return eq7(v1)(target7);\n                }(function(v1) {\n                  return v1.id;\n                }($138));\n              })(cards))(function(from3) {\n                return bind23(findIndex(function($139) {\n                  return function(v1) {\n                    return eq7(v1)(v.value0);\n                  }(function(v1) {\n                    return v1.id;\n                  }($139));\n                })(cards))(function(to) {\n                  return pure24(shiftInsert(from3)(to)(cards));\n                });\n              });\n            }));\n            return function(v1) {\n              return {\n                hand: v1.hand,\n                others: v1.others,\n                cards: cards$prime\n              };\n            };\n          }))))(function() {\n            return liftEffect4(preventDefault(toEvent2(v.value1)));\n          }));\n        });\n      }\n      ;\n      throw new Error(\"Failed pattern match at App.Deck (line 170, column 12 - line 229, column 67): \" + [v.constructor.name]);\n    };\n    return mkComponent({\n      initialState,\n      render,\n      \"eval\": mkEval({\n        receive: defaultEval.receive,\n        initialize: defaultEval.initialize,\n        finalize: defaultEval.finalize,\n        handleAction: action2,\n        handleQuery: function($140) {\n          return runMaybeT(query3($140));\n        }\n      })\n    });\n  }();\n\n  // output/Data.Argonaut.Parser/foreign.js\n  function _jsonParser(fail2, succ, s) {\n    try {\n      return succ(JSON.parse(s));\n    } catch (e) {\n      return fail2(e.message);\n    }\n  }\n\n  // output/Data.Argonaut.Parser/index.js\n  var jsonParser = function(j) {\n    return _jsonParser(Left.create, Right.create, j);\n  };\n\n  // output/Data.Argonaut.Decode.Parser/index.js\n  var parseJson = /* @__PURE__ */ function() {\n    var $3 = lmap(bifunctorEither)(function(v) {\n      return new TypeMismatch2(\"JSON\");\n    });\n    return function($4) {\n      return $3(jsonParser($4));\n    };\n  }();\n\n  // output/Effect.Console/foreign.js\n  var warn = function(s) {\n    return function() {\n      console.warn(s);\n    };\n  };\n  var error3 = function(s) {\n    return function() {\n      console.error(s);\n    };\n  };\n\n  // output/Effect.Class.Console/index.js\n  var error4 = function(dictMonadEffect) {\n    var $79 = liftEffect(dictMonadEffect);\n    return function($80) {\n      return $79(error3($80));\n    };\n  };\n\n  // output/JSURI/foreign.js\n  function _decodeURIComponent(fail2, succeed, input3) {\n    try {\n      return succeed(decodeURIComponent(input3));\n    } catch (err) {\n      return fail2(err);\n    }\n  }\n\n  // output/JSURI/index.js\n  var $$decodeURIComponent = /* @__PURE__ */ function() {\n    return runFn3(_decodeURIComponent)($$const(Nothing.value))(Just.create);\n  }();\n\n  // output/Web.HTML.Event.HashChangeEvent.EventTypes/index.js\n  var hashchange = \"hashchange\";\n\n  // output/Routing.Hash/index.js\n  var bind10 = /* @__PURE__ */ bind(bindEffect);\n  var map27 = /* @__PURE__ */ map(functorEffect);\n  var bindFlipped7 = /* @__PURE__ */ bindFlipped(bindEffect);\n  var join3 = /* @__PURE__ */ join(bindEffect);\n  var apply3 = /* @__PURE__ */ apply(applyEffect);\n  var pure10 = /* @__PURE__ */ pure(applicativeEffect);\n  var voidRight2 = /* @__PURE__ */ voidRight(functorEffect);\n  var setHash2 = function(h) {\n    return bind10(bind10(windowImpl)(location))(setHash(h));\n  };\n  var getHash = /* @__PURE__ */ bind10(/* @__PURE__ */ bind10(windowImpl)(location))(/* @__PURE__ */ function() {\n    var $16 = map27(function() {\n      var $18 = fromMaybe(\"\");\n      var $19 = stripPrefix(\"#\");\n      return function($20) {\n        return $18($19($20));\n      };\n    }());\n    return function($17) {\n      return $16(hash($17));\n    };\n  }());\n  var foldHashes = function(cb) {\n    return function(init3) {\n      return function __do2() {\n        var ref3 = bindFlipped7($$new)(bindFlipped7(init3)(getHash))();\n        var win = map27(toEventTarget)(windowImpl)();\n        var listener = eventListener(function(v) {\n          return bindFlipped7(flip(write)(ref3))(join3(apply3(map27(cb)(read(ref3)))(getHash)));\n        })();\n        addEventListener2(hashchange)(listener)(false)(win)();\n        return removeEventListener2(hashchange)(listener)(false)(win);\n      };\n    };\n  };\n  var matchesWith = function(dictFoldable) {\n    var indexl2 = indexl(dictFoldable);\n    return function(parser) {\n      return function(cb) {\n        var go2 = function(a2) {\n          var $21 = maybe(pure10(a2))(function(b2) {\n            return voidRight2(new Just(b2))(cb(a2)(b2));\n          });\n          var $22 = indexl2(0);\n          return function($23) {\n            return $21($22(parser($23)));\n          };\n        };\n        return foldHashes(go2)(go2(Nothing.value));\n      };\n    };\n  };\n\n  // output/App.App/index.js\n  var resultIsSymbol2 = {\n    reflectSymbol: function() {\n      return \"result\";\n    }\n  };\n  var slot4 = /* @__PURE__ */ slot();\n  var deckIsSymbol = {\n    reflectSymbol: function() {\n      return \"deck\";\n    }\n  };\n  var conditionIsSymbol = {\n    reflectSymbol: function() {\n      return \"condition\";\n    }\n  };\n  var slot1 = /* @__PURE__ */ slot4(conditionIsSymbol)(ordId);\n  var bind11 = /* @__PURE__ */ bind(bindHalogenM);\n  var monadEffectHalogenM3 = /* @__PURE__ */ monadEffectHalogenM(monadEffectAff);\n  var liftEffect5 = /* @__PURE__ */ liftEffect(monadEffectHalogenM3);\n  var $$void9 = /* @__PURE__ */ $$void(functorHalogenM);\n  var matchesWith2 = /* @__PURE__ */ matchesWith(foldableMaybe);\n  var get6 = /* @__PURE__ */ get(monadStateHalogenM);\n  var when5 = /* @__PURE__ */ when(applicativeHalogenM);\n  var generateId4 = /* @__PURE__ */ generateId(monadEffectHalogenM3);\n  var discard7 = /* @__PURE__ */ discard(discardUnit)(bindHalogenM);\n  var modify_7 = /* @__PURE__ */ modify_2(monadStateHalogenM);\n  var tell5 = /* @__PURE__ */ tell2();\n  var tell12 = /* @__PURE__ */ tell5(deckIsSymbol)(ordUnit);\n  var gets7 = /* @__PURE__ */ gets(monadStateHalogenM);\n  var eqRec3 = /* @__PURE__ */ eqRec();\n  var eqRowCons3 = /* @__PURE__ */ eqRowCons(eqRowNil)();\n  var othersIsSymbol = {\n    reflectSymbol: function() {\n      return \"others\";\n    }\n  };\n  var handIsSymbol = {\n    reflectSymbol: function() {\n      return \"hand\";\n    }\n  };\n  var cardsIsSymbol2 = {\n    reflectSymbol: function() {\n      return \"cards\";\n    }\n  };\n  var nameIsSymbol2 = {\n    reflectSymbol: function() {\n      return \"name\";\n    }\n  };\n  var idIsSymbol3 = {\n    reflectSymbol: function() {\n      return \"id\";\n    }\n  };\n  var countIsSymbol2 = {\n    reflectSymbol: function() {\n      return \"count\";\n    }\n  };\n  var notEq3 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons3(othersIsSymbol)(eqInt))()(handIsSymbol)(eqInt))()(cardsIsSymbol2)(/* @__PURE__ */ eqArray(/* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons3(nameIsSymbol2)(eqString))()(idIsSymbol3)(eqId))()(countIsSymbol2)(eqInt))))));\n  var bind16 = /* @__PURE__ */ bind(bindFn);\n  var notEq12 = /* @__PURE__ */ notEq(eqId);\n  var tell23 = /* @__PURE__ */ tell5(conditionIsSymbol)(ordId);\n  var requestAll3 = /* @__PURE__ */ requestAll()(conditionIsSymbol)(ordId);\n  var fromFoldable8 = /* @__PURE__ */ fromFoldable(foldableList);\n  var tell32 = /* @__PURE__ */ tell5(resultIsSymbol2)(ordUnit);\n  var bind24 = /* @__PURE__ */ bind(bindEither);\n  var gDecodeJsonCons2 = /* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonInt));\n  var gDecodeJsonCons1 = /* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonBoolean));\n  var modeIsSymbol2 = {\n    reflectSymbol: function() {\n      return \"mode\";\n    }\n  };\n  var disabledIsSymbol = {\n    reflectSymbol: function() {\n      return \"disabled\";\n    }\n  };\n  var conditionsIsSymbol = {\n    reflectSymbol: function() {\n      return \"conditions\";\n    }\n  };\n  var decodeJson4 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(decodeJsonId)))(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons1(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonConditionMode))(gDecodeJsonNil)(modeIsSymbol2)()())(disabledIsSymbol)()())(countIsSymbol2)()())(cardsIsSymbol2)()())())))(/* @__PURE__ */ gDecodeJsonCons1(gDecodeJsonNil)(disabledIsSymbol)()())(conditionsIsSymbol)()())())))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeRecord(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonId))(/* @__PURE__ */ gDecodeJsonCons(/* @__PURE__ */ decodeFieldId(decodeJsonString))(gDecodeJsonNil)(nameIsSymbol2)()())(idIsSymbol3)()())(countIsSymbol2)()())())))(/* @__PURE__ */ gDecodeJsonCons2(/* @__PURE__ */ gDecodeJsonCons2(gDecodeJsonNil)(othersIsSymbol)()())(handIsSymbol)()())(cardsIsSymbol2)()())()))(gDecodeJsonNil)(deckIsSymbol)()())(conditionsIsSymbol)()())());\n  var error5 = /* @__PURE__ */ error4(monadEffectHalogenM3);\n  var traverse4 = /* @__PURE__ */ traverse(traversableArray)(applicativeHalogenM);\n  var flap3 = /* @__PURE__ */ flap(functorHalogenM);\n  var map28 = /* @__PURE__ */ map(functorHalogenM);\n  var put7 = /* @__PURE__ */ put(monadStateHalogenM);\n  var mapFlipped6 = /* @__PURE__ */ mapFlipped(functorArray);\n  var for_3 = /* @__PURE__ */ for_(applicativeHalogenM)(foldableArray);\n  var flap12 = /* @__PURE__ */ flap(functorFn);\n  var lookup7 = /* @__PURE__ */ lookup(ordId);\n  var gEncodeJsonCons4 = /* @__PURE__ */ gEncodeJsonCons(encodeJsonInt);\n  var gEncodeJsonCons1 = /* @__PURE__ */ gEncodeJsonCons(encodeJsonJBoolean);\n  var encodeJson4 = /* @__PURE__ */ encodeJson(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(encodeJsonId))(/* @__PURE__ */ gEncodeJsonCons4(/* @__PURE__ */ gEncodeJsonCons1(/* @__PURE__ */ gEncodeJsonCons(encodeJsonConditionMode)(gEncodeJsonNil)(modeIsSymbol2)())(disabledIsSymbol)())(countIsSymbol2)())(cardsIsSymbol2)())()))(/* @__PURE__ */ gEncodeJsonCons1(gEncodeJsonNil)(disabledIsSymbol)())(conditionsIsSymbol)())()))(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons(/* @__PURE__ */ encodeJsonArray(/* @__PURE__ */ encodeRecord(/* @__PURE__ */ gEncodeJsonCons4(/* @__PURE__ */ gEncodeJsonCons(encodeJsonId)(/* @__PURE__ */ gEncodeJsonCons(encodeJsonJString)(gEncodeJsonNil)(nameIsSymbol2)())(idIsSymbol3)())(countIsSymbol2)())()))(/* @__PURE__ */ gEncodeJsonCons4(/* @__PURE__ */ gEncodeJsonCons4(gEncodeJsonNil)(othersIsSymbol)())(handIsSymbol)())(cardsIsSymbol2)())())(gEncodeJsonNil)(deckIsSymbol)())(conditionsIsSymbol)())());\n  var Initialize4 = /* @__PURE__ */ function() {\n    function Initialize5() {\n    }\n    ;\n    Initialize5.value = new Initialize5();\n    return Initialize5;\n  }();\n  var PrepareDefaultState = /* @__PURE__ */ function() {\n    function PrepareDefaultState2() {\n    }\n    ;\n    PrepareDefaultState2.value = new PrepareDefaultState2();\n    return PrepareDefaultState2;\n  }();\n  var UpdateDeck2 = /* @__PURE__ */ function() {\n    function UpdateDeck3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    UpdateDeck3.create = function(value0) {\n      return new UpdateDeck3(value0);\n    };\n    return UpdateDeck3;\n  }();\n  var AddCondition2 = /* @__PURE__ */ function() {\n    function AddCondition3() {\n    }\n    ;\n    AddCondition3.value = new AddCondition3();\n    return AddCondition3;\n  }();\n  var RemoveCondition2 = /* @__PURE__ */ function() {\n    function RemoveCondition3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    RemoveCondition3.create = function(value0) {\n      return new RemoveCondition3(value0);\n    };\n    return RemoveCondition3;\n  }();\n  var ToggleDisabled2 = /* @__PURE__ */ function() {\n    function ToggleDisabled3(value0) {\n      this.value0 = value0;\n    }\n    ;\n    ToggleDisabled3.create = function(value0) {\n      return new ToggleDisabled3(value0);\n    };\n    return ToggleDisabled3;\n  }();\n  var Swap = /* @__PURE__ */ function() {\n    function Swap2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    Swap2.create = function(value0) {\n      return function(value1) {\n        return new Swap2(value0, value1);\n      };\n    };\n    return Swap2;\n  }();\n  var ReceiveConditionUpdated = /* @__PURE__ */ function() {\n    function ReceiveConditionUpdated2(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n    ;\n    ReceiveConditionUpdated2.create = function(value0) {\n      return function(value1) {\n        return new ReceiveConditionUpdated2(value0, value1);\n      };\n    };\n    return ReceiveConditionUpdated2;\n  }();\n  var Calculate3 = /* @__PURE__ */ function() {\n    function Calculate4() {\n    }\n    ;\n    Calculate4.value = new Calculate4();\n    return Calculate4;\n  }();\n  var RestoreState3 = /* @__PURE__ */ function() {\n    function RestoreState4(value0) {\n      this.value0 = value0;\n    }\n    ;\n    RestoreState4.create = function(value0) {\n      return new RestoreState4(value0);\n    };\n    return RestoreState4;\n  }();\n  var SaveState = /* @__PURE__ */ function() {\n    function SaveState2() {\n    }\n    ;\n    SaveState2.value = new SaveState2();\n    return SaveState2;\n  }();\n  var component6 = /* @__PURE__ */ function() {\n    var renderResult = div2([class_(\"flex grow basis-0 items-center rounded border-2 border-cyan-400 p-1\")])([div2([class_(\"flex w-full justify-end gap-3\")])([div_([button2(text(\"Save\"))(\"border border-rose-500 hover:bg-rose-100\")(SaveState.value)]), slot_()(resultIsSymbol2)(ordUnit)($$Proxy.value)(unit)(component3)(unit)])]);\n    var renderDeck = div2([class_(\"grow\")])([slot4(deckIsSymbol)(ordUnit)($$Proxy.value)(unit)(component5)(unit)(UpdateDeck2.create)]);\n    var renderConditionAddButton = div_([plusButton(AddCondition2.value)]);\n    var renderCondition = function(deck) {\n      return function(i2) {\n        return function(id3) {\n          return li([class_(\"flex items-start gap-1\")])([div2([class_(\"flex flex-col\")])([upButton(new Swap(i2 - 1 | 0, i2)), removeButton(new RemoveCondition2(id3)), toggleButton(new ToggleDisabled2(id3)), downButton(new Swap(i2, i2 + 1 | 0))]), slot1($$Proxy.value)(id3)(component4)(deck)(ReceiveConditionUpdated.create(id3))]);\n        };\n      };\n    };\n    var render = function(v) {\n      return div2([class_(\"relative overflow-x-clip\")])([header([class_(\"flex items-baseline px-2\")])([h1([class_(\"p-1 text-lg\")])([a([href(\".\")])([text(\"Draw Calculator\")])]), text(\"-\"), h2([class_(\"p-1\")])([text(\"TCG \\u7528\\u30C9\\u30ED\\u30FC\\u78BA\\u7387\\u8A08\\u7B97\\u6A5F\")])]), main([class_(\"relative mb-[80vh] flex max-w-4xl flex-col gap-3 p-1\")])([div2([class_(\"flex flex-wrap gap-1\")])([renderDeck, renderResult]), ul([class_(\"flex flex-col gap-1\")])(mapWithIndex2(renderCondition(v.deck))(v.conditions)), renderConditionAddButton]), footer([class_(\"flex items-baseline px-2\")])([a([class_(\"m-1 rounded border border-sky-500 px-2 py-1 text-sm\"), href(\"https://github.com/acple/tcg-calculator\"), target2(\"_blank\"), rel(\"noopener noreferrer\")])([text(\"\\u2192 \\u4F7F\\u3044\\u65B9\\u3068\\u304B\\u30BD\\u30FC\\u30B9\")])])]);\n    };\n    var initialState = function(v) {\n      return {\n        deck: {\n          cards: [],\n          others: 0,\n          hand: 0\n        },\n        conditions: []\n      };\n    };\n    var action2 = function(v) {\n      if (v instanceof Initialize4) {\n        return bind11(liftEffect5(create))(function(v12) {\n          return bind11(subscribe2(v12.emitter))(function() {\n            return $$void9(liftEffect5(matchesWith2($$decodeURIComponent)(function(v2) {\n              return function(hash2) {\n                return notify(v12.listener)(function() {\n                  var $275 = $$null2(hash2);\n                  if ($275) {\n                    return PrepareDefaultState.value;\n                  }\n                  ;\n                  return new RestoreState3(hash2);\n                }());\n              };\n            })));\n          });\n        });\n      }\n      ;\n      if (v instanceof PrepareDefaultState) {\n        return bind11(get6)(function(v12) {\n          return when5($$null(v12.deck.cards) && $$null(v12.conditions))(bind11(generateId4)(function(id3) {\n            var defaultDeck = {\n              cards: [{\n                id: id3,\n                name: \"Card1\",\n                count: 3\n              }],\n              others: 37,\n              hand: 5\n            };\n            return discard7(modify_7(function(v2) {\n              var $279 = {};\n              for (var $280 in v2) {\n                if ({}.hasOwnProperty.call(v2, $280)) {\n                  $279[$280] = v2[$280];\n                }\n                ;\n              }\n              ;\n              $279.deck = defaultDeck;\n              return $279;\n            }))(function() {\n              return discard7(tell12($$Proxy.value)(unit)(SetDeck.create(defaultDeck)))(function() {\n                return action2(AddCondition2.value);\n              });\n            });\n          }));\n        });\n      }\n      ;\n      if (v instanceof UpdateDeck2) {\n        return bind11(gets7(function(v12) {\n          return v12.deck;\n        }))(function(current) {\n          return when5(notEq3(v.value0)(current))(discard7(modify_7(function(v12) {\n            var $284 = {};\n            for (var $285 in v12) {\n              if ({}.hasOwnProperty.call(v12, $285)) {\n                $284[$285] = v12[$285];\n              }\n              ;\n            }\n            ;\n            $284.deck = v.value0;\n            return $284;\n          }))(function() {\n            return action2(Calculate3.value);\n          }));\n        });\n      }\n      ;\n      if (v instanceof AddCondition2) {\n        return bind11(generateId4)(function(id3) {\n          return discard7(modify_7(bind16(function(v12) {\n            return v12.conditions;\n          })(function(conditions) {\n            return function(v12) {\n              var $288 = {};\n              for (var $289 in v12) {\n                if ({}.hasOwnProperty.call(v12, $289)) {\n                  $288[$289] = v12[$289];\n                }\n                ;\n              }\n              ;\n              $288.conditions = snoc(conditions)(id3);\n              return $288;\n            };\n          })))(function() {\n            return action2(Calculate3.value);\n          });\n        });\n      }\n      ;\n      if (v instanceof RemoveCondition2) {\n        return discard7(modify_7(bind16(function(v12) {\n          return v12.conditions;\n        })(function(conditions) {\n          return function(v12) {\n            var $291 = {};\n            for (var $292 in v12) {\n              if ({}.hasOwnProperty.call(v12, $292)) {\n                $291[$292] = v12[$292];\n              }\n              ;\n            }\n            ;\n            $291.conditions = filter(function(v2) {\n              return notEq12(v2)(v.value0);\n            })(conditions);\n            return $291;\n          };\n        })))(function() {\n          return action2(Calculate3.value);\n        });\n      }\n      ;\n      if (v instanceof ToggleDisabled2) {\n        return discard7(tell23($$Proxy.value)(v.value0)(ToggleDisabled.create))(function() {\n          return action2(Calculate3.value);\n        });\n      }\n      ;\n      if (v instanceof Swap) {\n        return modify_7(bind16(function(v12) {\n          return v12.conditions;\n        })(function(conditions) {\n          return function(v12) {\n            var $296 = {};\n            for (var $297 in v12) {\n              if ({}.hasOwnProperty.call(v12, $297)) {\n                $296[$297] = v12[$297];\n              }\n              ;\n            }\n            ;\n            $296.conditions = swap(v.value0)(v.value1)(conditions);\n            return $296;\n          };\n        }));\n      }\n      ;\n      if (v instanceof ReceiveConditionUpdated && v.value1 instanceof Updated2) {\n        return action2(Calculate3.value);\n      }\n      ;\n      if (v instanceof ReceiveConditionUpdated && v.value1 instanceof AllConditionDeleted) {\n        return action2(new RemoveCondition2(v.value0));\n      }\n      ;\n      if (v instanceof Calculate3) {\n        return bind11(gets7(function(v12) {\n          return v12.deck;\n        }))(function(deck) {\n          return bind11(requestAll3($$Proxy.value)(GetConditions.create))(function(conditions) {\n            var conditions$prime = fromFoldable8(values(conditions));\n            return tell32($$Proxy.value)(unit)(Calculate.create(deck)(conditions$prime));\n          });\n        });\n      }\n      ;\n      if (v instanceof RestoreState3) {\n        var v1 = bind24(parseJson(v.value0))(decodeJson4);\n        if (v1 instanceof Left) {\n          return discard7(error5(printJsonDecodeError(v1.value0)))(function() {\n            return action2(PrepareDefaultState.value);\n          });\n        }\n        ;\n        if (v1 instanceof Right) {\n          return bind11(traverse4(flap3(map28(function(v2) {\n            return function(v3) {\n              return {\n                id: v2,\n                condition: v3\n              };\n            };\n          })(generateId4)))(v1.value0.conditions))(function(conditions$prime) {\n            return discard7(put7({\n              deck: v1.value0.deck,\n              conditions: mapFlipped6(conditions$prime)(function(v2) {\n                return v2.id;\n              })\n            }))(function() {\n              return discard7(tell12($$Proxy.value)(unit)(SetDeck.create(v1.value0.deck)))(function() {\n                return discard7(for_3(conditions$prime)(function(v2) {\n                  return tell23($$Proxy.value)(v2.id)(RestoreState2.create(v1.value0.deck)(v2.condition));\n                }))(function() {\n                  return action2(Calculate3.value);\n                });\n              });\n            });\n          });\n        }\n        ;\n        throw new Error(\"Failed pattern match at App.App (line 180, column 7 - line 190, column 27): \" + [v1.constructor.name]);\n      }\n      ;\n      if (v instanceof SaveState) {\n        return bind11(get6)(function(v12) {\n          return bind11(requestAll3($$Proxy.value)(GetState.create))(function(conditions) {\n            var conditions$prime = mapMaybe(flap12(lookup7)(conditions))(v12.conditions);\n            var json = encodeJson4({\n              deck: v12.deck,\n              conditions: conditions$prime\n            });\n            return liftEffect5(setHash2(stringify(json)));\n          });\n        });\n      }\n      ;\n      throw new Error(\"Failed pattern match at App.App (line 131, column 12 - line 196, column 51): \" + [v.constructor.name]);\n    };\n    return mkComponent({\n      initialState,\n      render,\n      \"eval\": mkEval({\n        handleQuery: defaultEval.handleQuery,\n        receive: defaultEval.receive,\n        finalize: defaultEval.finalize,\n        handleAction: action2,\n        initialize: new Just(Initialize4.value)\n      })\n    });\n  }();\n\n  // output/Halogen.Aff.Util/index.js\n  var bind17 = /* @__PURE__ */ bind(bindAff);\n  var liftEffect6 = /* @__PURE__ */ liftEffect(monadEffectAff);\n  var bindFlipped8 = /* @__PURE__ */ bindFlipped(bindEffect);\n  var composeKleisliFlipped6 = /* @__PURE__ */ composeKleisliFlipped(bindEffect);\n  var pure11 = /* @__PURE__ */ pure(applicativeAff);\n  var bindFlipped12 = /* @__PURE__ */ bindFlipped(bindMaybe);\n  var pure13 = /* @__PURE__ */ pure(applicativeEffect);\n  var map29 = /* @__PURE__ */ map(functorEffect);\n  var discard8 = /* @__PURE__ */ discard(discardUnit);\n  var throwError3 = /* @__PURE__ */ throwError(monadThrowAff);\n  var selectElement = function(query3) {\n    return bind17(liftEffect6(bindFlipped8(composeKleisliFlipped6(function() {\n      var $16 = querySelector(query3);\n      return function($17) {\n        return $16(toParentNode($17));\n      };\n    }())(document))(windowImpl)))(function(mel) {\n      return pure11(bindFlipped12(fromElement)(mel));\n    });\n  };\n  var runHalogenAff = /* @__PURE__ */ runAff_(/* @__PURE__ */ either(throwException)(/* @__PURE__ */ $$const(/* @__PURE__ */ pure13(unit))));\n  var awaitLoad = /* @__PURE__ */ makeAff(function(callback) {\n    return function __do2() {\n      var rs = bindFlipped8(readyState)(bindFlipped8(document)(windowImpl))();\n      if (rs instanceof Loading) {\n        var et = map29(toEventTarget)(windowImpl)();\n        var listener = eventListener(function(v) {\n          return callback(new Right(unit));\n        })();\n        addEventListener2(domcontentloaded)(listener)(false)(et)();\n        return effectCanceler(removeEventListener2(domcontentloaded)(listener)(false)(et));\n      }\n      ;\n      callback(new Right(unit))();\n      return nonCanceler;\n    };\n  });\n  var awaitBody = /* @__PURE__ */ discard8(bindAff)(awaitLoad)(function() {\n    return bind17(selectElement(\"body\"))(function(body2) {\n      return maybe(throwError3(error(\"Could not find body\")))(pure11)(body2);\n    });\n  });\n\n  // output/Control.Monad.Fork.Class/index.js\n  var monadForkAff = {\n    suspend: suspendAff,\n    fork: forkAff,\n    join: joinFiber,\n    Monad0: function() {\n      return monadAff;\n    },\n    Functor1: function() {\n      return functorFiber;\n    }\n  };\n  var fork2 = function(dict) {\n    return dict.fork;\n  };\n\n  // output/Halogen.Aff.Driver.State/index.js\n  var unRenderStateX = unsafeCoerce2;\n  var unDriverStateX = unsafeCoerce2;\n  var renderStateX_ = function(dictApplicative) {\n    var traverse_10 = traverse_(dictApplicative)(foldableMaybe);\n    return function(f2) {\n      return unDriverStateX(function(st) {\n        return traverse_10(f2)(st.rendering);\n      });\n    };\n  };\n  var mkRenderStateX = unsafeCoerce2;\n  var renderStateX = function(dictFunctor) {\n    return function(f2) {\n      return unDriverStateX(function(st) {\n        return mkRenderStateX(f2(st.rendering));\n      });\n    };\n  };\n  var mkDriverStateXRef = unsafeCoerce2;\n  var mapDriverState = function(f2) {\n    return function(v) {\n      return f2(v);\n    };\n  };\n  var initDriverState = function(component7) {\n    return function(input3) {\n      return function(handler3) {\n        return function(lchs) {\n          return function __do2() {\n            var selfRef = $$new({})();\n            var childrenIn = $$new(empty3)();\n            var childrenOut = $$new(empty3)();\n            var handlerRef = $$new(handler3)();\n            var pendingQueries = $$new(new Just(Nil.value))();\n            var pendingOuts = $$new(new Just(Nil.value))();\n            var pendingHandlers = $$new(Nothing.value)();\n            var fresh2 = $$new(1)();\n            var subscriptions = $$new(new Just(empty2))();\n            var forks = $$new(empty2)();\n            var ds = {\n              component: component7,\n              state: component7.initialState(input3),\n              refs: empty2,\n              children: empty3,\n              childrenIn,\n              childrenOut,\n              selfRef,\n              handlerRef,\n              pendingQueries,\n              pendingOuts,\n              pendingHandlers,\n              rendering: Nothing.value,\n              fresh: fresh2,\n              subscriptions,\n              forks,\n              lifecycleHandlers: lchs\n            };\n            write(ds)(selfRef)();\n            return mkDriverStateXRef(selfRef);\n          };\n        };\n      };\n    };\n  };\n\n  // output/Halogen.Aff.Driver.Eval/index.js\n  var traverse_7 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableMaybe);\n  var bindFlipped9 = /* @__PURE__ */ bindFlipped(bindMaybe);\n  var lookup8 = /* @__PURE__ */ lookup(ordSubscriptionId);\n  var bind18 = /* @__PURE__ */ bind(bindAff);\n  var liftEffect7 = /* @__PURE__ */ liftEffect(monadEffectAff);\n  var discard9 = /* @__PURE__ */ discard(discardUnit);\n  var discard13 = /* @__PURE__ */ discard9(bindAff);\n  var traverse_13 = /* @__PURE__ */ traverse_(applicativeAff);\n  var traverse_22 = /* @__PURE__ */ traverse_13(foldableList);\n  var fork3 = /* @__PURE__ */ fork2(monadForkAff);\n  var parSequence_2 = /* @__PURE__ */ parSequence_(parallelAff)(applicativeParAff)(foldableList);\n  var pure14 = /* @__PURE__ */ pure(applicativeAff);\n  var map30 = /* @__PURE__ */ map(functorCoyoneda);\n  var parallel3 = /* @__PURE__ */ parallel(parallelAff);\n  var map111 = /* @__PURE__ */ map(functorAff);\n  var sequential2 = /* @__PURE__ */ sequential(parallelAff);\n  var map210 = /* @__PURE__ */ map(functorMaybe);\n  var insert9 = /* @__PURE__ */ insert(ordSubscriptionId);\n  var retractFreeAp2 = /* @__PURE__ */ retractFreeAp(applicativeParAff);\n  var $$delete3 = /* @__PURE__ */ $$delete(ordForkId);\n  var unlessM2 = /* @__PURE__ */ unlessM(monadEffect);\n  var insert12 = /* @__PURE__ */ insert(ordForkId);\n  var traverse_32 = /* @__PURE__ */ traverse_13(foldableMaybe);\n  var lookup12 = /* @__PURE__ */ lookup(ordForkId);\n  var lookup22 = /* @__PURE__ */ lookup(ordString);\n  var foldFree2 = /* @__PURE__ */ foldFree(monadRecAff);\n  var alter2 = /* @__PURE__ */ alter(ordString);\n  var unsubscribe3 = function(sid) {\n    return function(ref3) {\n      return function __do2() {\n        var v = read(ref3)();\n        var subs = read(v.subscriptions)();\n        return traverse_7(unsubscribe)(bindFlipped9(lookup8(sid))(subs))();\n      };\n    };\n  };\n  var queueOrRun = function(ref3) {\n    return function(au) {\n      return bind18(liftEffect7(read(ref3)))(function(v) {\n        if (v instanceof Nothing) {\n          return au;\n        }\n        ;\n        if (v instanceof Just) {\n          return liftEffect7(write(new Just(new Cons(au, v.value0)))(ref3));\n        }\n        ;\n        throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 188, column 33 - line 190, column 57): \" + [v.constructor.name]);\n      });\n    };\n  };\n  var handleLifecycle = function(lchs) {\n    return function(f2) {\n      return discard13(liftEffect7(write({\n        initializers: Nil.value,\n        finalizers: Nil.value\n      })(lchs)))(function() {\n        return bind18(liftEffect7(f2))(function(result) {\n          return bind18(liftEffect7(read(lchs)))(function(v) {\n            return discard13(traverse_22(fork3)(v.finalizers))(function() {\n              return discard13(parSequence_2(v.initializers))(function() {\n                return pure14(result);\n              });\n            });\n          });\n        });\n      });\n    };\n  };\n  var handleAff = /* @__PURE__ */ runAff_(/* @__PURE__ */ either(throwException)(/* @__PURE__ */ $$const(/* @__PURE__ */ pure(applicativeEffect)(unit))));\n  var fresh = function(f2) {\n    return function(ref3) {\n      return bind18(liftEffect7(read(ref3)))(function(v) {\n        return liftEffect7(modify$prime(function(i2) {\n          return {\n            state: i2 + 1 | 0,\n            value: f2(i2)\n          };\n        })(v.fresh));\n      });\n    };\n  };\n  var evalQ = function(render) {\n    return function(ref3) {\n      return function(q2) {\n        return bind18(liftEffect7(read(ref3)))(function(v) {\n          return evalM(render)(ref3)(v[\"component\"][\"eval\"](new Query(map30(Just.create)(liftCoyoneda(q2)), $$const(Nothing.value))));\n        });\n      };\n    };\n  };\n  var evalM = function(render) {\n    return function(initRef) {\n      return function(v) {\n        var evalChildQuery = function(ref3) {\n          return function(cqb) {\n            return bind18(liftEffect7(read(ref3)))(function(v1) {\n              return unChildQueryBox(function(v2) {\n                var evalChild = function(v3) {\n                  return parallel3(bind18(liftEffect7(read(v3)))(function(dsx) {\n                    return unDriverStateX(function(ds) {\n                      return evalQ(render)(ds.selfRef)(v2.value1);\n                    })(dsx);\n                  }));\n                };\n                return map111(v2.value2)(sequential2(v2.value0(applicativeParAff)(evalChild)(v1.children)));\n              })(cqb);\n            });\n          };\n        };\n        var go2 = function(ref3) {\n          return function(v1) {\n            if (v1 instanceof State) {\n              return bind18(liftEffect7(read(ref3)))(function(v2) {\n                var v3 = v1.value0(v2.state);\n                if (unsafeRefEq(v2.state)(v3.value1)) {\n                  return pure14(v3.value0);\n                }\n                ;\n                if (otherwise) {\n                  return discard13(liftEffect7(write({\n                    component: v2.component,\n                    refs: v2.refs,\n                    children: v2.children,\n                    childrenIn: v2.childrenIn,\n                    childrenOut: v2.childrenOut,\n                    selfRef: v2.selfRef,\n                    handlerRef: v2.handlerRef,\n                    pendingQueries: v2.pendingQueries,\n                    pendingOuts: v2.pendingOuts,\n                    pendingHandlers: v2.pendingHandlers,\n                    rendering: v2.rendering,\n                    fresh: v2.fresh,\n                    subscriptions: v2.subscriptions,\n                    forks: v2.forks,\n                    lifecycleHandlers: v2.lifecycleHandlers,\n                    state: v3.value1\n                  })(ref3)))(function() {\n                    return discard13(handleLifecycle(v2.lifecycleHandlers)(render(v2.lifecycleHandlers)(ref3)))(function() {\n                      return pure14(v3.value0);\n                    });\n                  });\n                }\n                ;\n                throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 86, column 7 - line 92, column 21): \" + [v3.constructor.name]);\n              });\n            }\n            ;\n            if (v1 instanceof Subscribe) {\n              return bind18(fresh(SubscriptionId)(ref3))(function(sid) {\n                return bind18(liftEffect7(subscribe(v1.value0(sid))(function(act) {\n                  return handleAff(evalF(render)(ref3)(new Action(act)));\n                })))(function(finalize) {\n                  return bind18(liftEffect7(read(ref3)))(function(v2) {\n                    return discard13(liftEffect7(modify_(map210(insert9(sid)(finalize)))(v2.subscriptions)))(function() {\n                      return pure14(v1.value1(sid));\n                    });\n                  });\n                });\n              });\n            }\n            ;\n            if (v1 instanceof Unsubscribe) {\n              return discard13(liftEffect7(unsubscribe3(v1.value0)(ref3)))(function() {\n                return pure14(v1.value1);\n              });\n            }\n            ;\n            if (v1 instanceof Lift2) {\n              return v1.value0;\n            }\n            ;\n            if (v1 instanceof ChildQuery2) {\n              return evalChildQuery(ref3)(v1.value0);\n            }\n            ;\n            if (v1 instanceof Raise) {\n              return bind18(liftEffect7(read(ref3)))(function(v2) {\n                return bind18(liftEffect7(read(v2.handlerRef)))(function(handler3) {\n                  return discard13(queueOrRun(v2.pendingOuts)(handler3(v1.value0)))(function() {\n                    return pure14(v1.value1);\n                  });\n                });\n              });\n            }\n            ;\n            if (v1 instanceof Par) {\n              return sequential2(retractFreeAp2(hoistFreeAp(function() {\n                var $119 = evalM(render)(ref3);\n                return function($120) {\n                  return parallel3($119($120));\n                };\n              }())(v1.value0)));\n            }\n            ;\n            if (v1 instanceof Fork) {\n              return bind18(fresh(ForkId)(ref3))(function(fid) {\n                return bind18(liftEffect7(read(ref3)))(function(v2) {\n                  return bind18(liftEffect7($$new(false)))(function(doneRef) {\n                    return bind18(fork3($$finally(liftEffect7(function __do2() {\n                      modify_($$delete3(fid))(v2.forks)();\n                      return write(true)(doneRef)();\n                    }))(evalM(render)(ref3)(v1.value0))))(function(fiber) {\n                      return discard13(liftEffect7(unlessM2(read(doneRef))(modify_(insert12(fid)(fiber))(v2.forks))))(function() {\n                        return pure14(v1.value1(fid));\n                      });\n                    });\n                  });\n                });\n              });\n            }\n            ;\n            if (v1 instanceof Join) {\n              return bind18(liftEffect7(read(ref3)))(function(v2) {\n                return bind18(liftEffect7(read(v2.forks)))(function(forkMap) {\n                  return discard13(traverse_32(joinFiber)(lookup12(v1.value0)(forkMap)))(function() {\n                    return pure14(v1.value1);\n                  });\n                });\n              });\n            }\n            ;\n            if (v1 instanceof Kill) {\n              return bind18(liftEffect7(read(ref3)))(function(v2) {\n                return bind18(liftEffect7(read(v2.forks)))(function(forkMap) {\n                  return discard13(traverse_32(killFiber(error(\"Cancelled\")))(lookup12(v1.value0)(forkMap)))(function() {\n                    return pure14(v1.value1);\n                  });\n                });\n              });\n            }\n            ;\n            if (v1 instanceof GetRef) {\n              return bind18(liftEffect7(read(ref3)))(function(v2) {\n                return pure14(v1.value1(lookup22(v1.value0)(v2.refs)));\n              });\n            }\n            ;\n            throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 83, column 12 - line 139, column 33): \" + [v1.constructor.name]);\n          };\n        };\n        return foldFree2(go2(initRef))(v);\n      };\n    };\n  };\n  var evalF = function(render) {\n    return function(ref3) {\n      return function(v) {\n        if (v instanceof RefUpdate) {\n          return liftEffect7(flip(modify_)(ref3)(mapDriverState(function(st) {\n            return {\n              component: st.component,\n              state: st.state,\n              children: st.children,\n              childrenIn: st.childrenIn,\n              childrenOut: st.childrenOut,\n              selfRef: st.selfRef,\n              handlerRef: st.handlerRef,\n              pendingQueries: st.pendingQueries,\n              pendingOuts: st.pendingOuts,\n              pendingHandlers: st.pendingHandlers,\n              rendering: st.rendering,\n              fresh: st.fresh,\n              subscriptions: st.subscriptions,\n              forks: st.forks,\n              lifecycleHandlers: st.lifecycleHandlers,\n              refs: alter2($$const(v.value1))(v.value0)(st.refs)\n            };\n          })));\n        }\n        ;\n        if (v instanceof Action) {\n          return bind18(liftEffect7(read(ref3)))(function(v1) {\n            return evalM(render)(ref3)(v1[\"component\"][\"eval\"](new Action2(v.value0, unit)));\n          });\n        }\n        ;\n        throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 52, column 20 - line 58, column 62): \" + [v.constructor.name]);\n      };\n    };\n  };\n\n  // output/Halogen.Aff.Driver/index.js\n  var bind19 = /* @__PURE__ */ bind(bindEffect);\n  var discard10 = /* @__PURE__ */ discard(discardUnit);\n  var for_4 = /* @__PURE__ */ for_(applicativeEffect)(foldableMaybe);\n  var traverse_8 = /* @__PURE__ */ traverse_(applicativeAff)(foldableList);\n  var fork4 = /* @__PURE__ */ fork2(monadForkAff);\n  var bindFlipped10 = /* @__PURE__ */ bindFlipped(bindEffect);\n  var traverse_14 = /* @__PURE__ */ traverse_(applicativeEffect);\n  var traverse_23 = /* @__PURE__ */ traverse_14(foldableMaybe);\n  var traverse_33 = /* @__PURE__ */ traverse_14(foldableMap);\n  var discard24 = /* @__PURE__ */ discard10(bindAff);\n  var parSequence_3 = /* @__PURE__ */ parSequence_(parallelAff)(applicativeParAff)(foldableList);\n  var liftEffect8 = /* @__PURE__ */ liftEffect(monadEffectAff);\n  var pure15 = /* @__PURE__ */ pure(applicativeEffect);\n  var map31 = /* @__PURE__ */ map(functorEffect);\n  var pure16 = /* @__PURE__ */ pure(applicativeAff);\n  var when6 = /* @__PURE__ */ when(applicativeEffect);\n  var renderStateX2 = /* @__PURE__ */ renderStateX(functorEffect);\n  var $$void10 = /* @__PURE__ */ $$void(functorAff);\n  var foreachSlot2 = /* @__PURE__ */ foreachSlot(applicativeEffect);\n  var renderStateX_2 = /* @__PURE__ */ renderStateX_(applicativeEffect);\n  var tailRecM3 = /* @__PURE__ */ tailRecM(monadRecEffect);\n  var voidLeft3 = /* @__PURE__ */ voidLeft(functorEffect);\n  var bind110 = /* @__PURE__ */ bind(bindAff);\n  var liftEffect1 = /* @__PURE__ */ liftEffect(monadEffectEffect);\n  var newLifecycleHandlers = /* @__PURE__ */ function() {\n    return $$new({\n      initializers: Nil.value,\n      finalizers: Nil.value\n    });\n  }();\n  var handlePending = function(ref3) {\n    return function __do2() {\n      var queue = read(ref3)();\n      write(Nothing.value)(ref3)();\n      return for_4(queue)(function() {\n        var $59 = traverse_8(fork4);\n        return function($60) {\n          return handleAff($59(reverse2($60)));\n        };\n      }())();\n    };\n  };\n  var cleanupSubscriptionsAndForks = function(v) {\n    return function __do2() {\n      bindFlipped10(traverse_23(traverse_33(unsubscribe)))(read(v.subscriptions))();\n      write(Nothing.value)(v.subscriptions)();\n      bindFlipped10(traverse_33(function() {\n        var $61 = killFiber(error(\"finalized\"));\n        return function($62) {\n          return handleAff($61($62));\n        };\n      }()))(read(v.forks))();\n      return write(empty2)(v.forks)();\n    };\n  };\n  var runUI = function(renderSpec2) {\n    return function(component7) {\n      return function(i2) {\n        var squashChildInitializers = function(lchs) {\n          return function(preInits) {\n            return unDriverStateX(function(st) {\n              var parentInitializer = evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Initialize(unit)));\n              return modify_(function(handlers) {\n                return {\n                  initializers: new Cons(discard24(parSequence_3(reverse2(handlers.initializers)))(function() {\n                    return discard24(parentInitializer)(function() {\n                      return liftEffect8(function __do2() {\n                        handlePending(st.pendingQueries)();\n                        return handlePending(st.pendingOuts)();\n                      });\n                    });\n                  }), preInits),\n                  finalizers: handlers.finalizers\n                };\n              })(lchs);\n            });\n          };\n        };\n        var runComponent = function(lchs) {\n          return function(handler3) {\n            return function(j) {\n              return unComponent(function(c) {\n                return function __do2() {\n                  var lchs$prime = newLifecycleHandlers();\n                  var $$var2 = initDriverState(c)(j)(handler3)(lchs$prime)();\n                  var pre2 = read(lchs)();\n                  write({\n                    initializers: Nil.value,\n                    finalizers: pre2.finalizers\n                  })(lchs)();\n                  bindFlipped10(unDriverStateX(function() {\n                    var $63 = render(lchs);\n                    return function($64) {\n                      return $63(function(v) {\n                        return v.selfRef;\n                      }($64));\n                    };\n                  }()))(read($$var2))();\n                  bindFlipped10(squashChildInitializers(lchs)(pre2.initializers))(read($$var2))();\n                  return $$var2;\n                };\n              });\n            };\n          };\n        };\n        var renderChild = function(lchs) {\n          return function(handler3) {\n            return function(childrenInRef) {\n              return function(childrenOutRef) {\n                return unComponentSlot(function(slot5) {\n                  return function __do2() {\n                    var childrenIn = map31(slot5.pop)(read(childrenInRef))();\n                    var $$var2 = function() {\n                      if (childrenIn instanceof Just) {\n                        write(childrenIn.value0.value1)(childrenInRef)();\n                        var dsx = read(childrenIn.value0.value0)();\n                        unDriverStateX(function(st) {\n                          return function __do3() {\n                            flip(write)(st.handlerRef)(function() {\n                              var $65 = maybe(pure16(unit))(handler3);\n                              return function($66) {\n                                return $65(slot5.output($66));\n                              };\n                            }())();\n                            return handleAff(evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Receive(slot5.input, unit))))();\n                          };\n                        })(dsx)();\n                        return childrenIn.value0.value0;\n                      }\n                      ;\n                      if (childrenIn instanceof Nothing) {\n                        return runComponent(lchs)(function() {\n                          var $67 = maybe(pure16(unit))(handler3);\n                          return function($68) {\n                            return $67(slot5.output($68));\n                          };\n                        }())(slot5.input)(slot5.component)();\n                      }\n                      ;\n                      throw new Error(\"Failed pattern match at Halogen.Aff.Driver (line 213, column 14 - line 222, column 98): \" + [childrenIn.constructor.name]);\n                    }();\n                    var isDuplicate = map31(function($69) {\n                      return isJust(slot5.get($69));\n                    })(read(childrenOutRef))();\n                    when6(isDuplicate)(warn(\"Halogen: Duplicate slot address was detected during rendering, unexpected results may occur\"))();\n                    modify_(slot5.set($$var2))(childrenOutRef)();\n                    return bind19(read($$var2))(renderStateX2(function(v) {\n                      if (v instanceof Nothing) {\n                        return $$throw(\"Halogen internal error: child was not initialized in renderChild\");\n                      }\n                      ;\n                      if (v instanceof Just) {\n                        return pure15(renderSpec2.renderChild(v.value0));\n                      }\n                      ;\n                      throw new Error(\"Failed pattern match at Halogen.Aff.Driver (line 227, column 37 - line 229, column 50): \" + [v.constructor.name]);\n                    }))();\n                  };\n                });\n              };\n            };\n          };\n        };\n        var render = function(lchs) {\n          return function($$var2) {\n            return function __do2() {\n              var v = read($$var2)();\n              var shouldProcessHandlers = map31(isNothing)(read(v.pendingHandlers))();\n              when6(shouldProcessHandlers)(write(new Just(Nil.value))(v.pendingHandlers))();\n              write(empty3)(v.childrenOut)();\n              write(v.children)(v.childrenIn)();\n              var handler3 = function() {\n                var $70 = queueOrRun(v.pendingHandlers);\n                var $71 = evalF(render)(v.selfRef);\n                return function($72) {\n                  return $70($$void10($71($72)));\n                };\n              }();\n              var childHandler = function() {\n                var $73 = queueOrRun(v.pendingQueries);\n                return function($74) {\n                  return $73(handler3(Action.create($74)));\n                };\n              }();\n              var rendering = renderSpec2.render(function($75) {\n                return handleAff(handler3($75));\n              })(renderChild(lchs)(childHandler)(v.childrenIn)(v.childrenOut))(v.component.render(v.state))(v.rendering)();\n              var children2 = read(v.childrenOut)();\n              var childrenIn = read(v.childrenIn)();\n              foreachSlot2(childrenIn)(function(v1) {\n                return function __do3() {\n                  var childDS = read(v1)();\n                  renderStateX_2(renderSpec2.removeChild)(childDS)();\n                  return finalize(lchs)(childDS)();\n                };\n              })();\n              flip(modify_)(v.selfRef)(mapDriverState(function(ds$prime) {\n                return {\n                  component: ds$prime.component,\n                  state: ds$prime.state,\n                  refs: ds$prime.refs,\n                  childrenIn: ds$prime.childrenIn,\n                  childrenOut: ds$prime.childrenOut,\n                  selfRef: ds$prime.selfRef,\n                  handlerRef: ds$prime.handlerRef,\n                  pendingQueries: ds$prime.pendingQueries,\n                  pendingOuts: ds$prime.pendingOuts,\n                  pendingHandlers: ds$prime.pendingHandlers,\n                  fresh: ds$prime.fresh,\n                  subscriptions: ds$prime.subscriptions,\n                  forks: ds$prime.forks,\n                  lifecycleHandlers: ds$prime.lifecycleHandlers,\n                  rendering: new Just(rendering),\n                  children: children2\n                };\n              }))();\n              return when6(shouldProcessHandlers)(flip(tailRecM3)(unit)(function(v1) {\n                return function __do3() {\n                  var handlers = read(v.pendingHandlers)();\n                  write(new Just(Nil.value))(v.pendingHandlers)();\n                  traverse_23(function() {\n                    var $76 = traverse_8(fork4);\n                    return function($77) {\n                      return handleAff($76(reverse2($77)));\n                    };\n                  }())(handlers)();\n                  var mmore = read(v.pendingHandlers)();\n                  var $52 = maybe(false)($$null3)(mmore);\n                  if ($52) {\n                    return voidLeft3(write(Nothing.value)(v.pendingHandlers))(new Done(unit))();\n                  }\n                  ;\n                  return new Loop(unit);\n                };\n              }))();\n            };\n          };\n        };\n        var finalize = function(lchs) {\n          return unDriverStateX(function(st) {\n            return function __do2() {\n              cleanupSubscriptionsAndForks(st)();\n              var f2 = evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Finalize(unit)));\n              modify_(function(handlers) {\n                return {\n                  initializers: handlers.initializers,\n                  finalizers: new Cons(f2, handlers.finalizers)\n                };\n              })(lchs)();\n              return foreachSlot2(st.children)(function(v) {\n                return function __do3() {\n                  var dsx = read(v)();\n                  return finalize(lchs)(dsx)();\n                };\n              })();\n            };\n          });\n        };\n        var evalDriver = function(disposed) {\n          return function(ref3) {\n            return function(q2) {\n              return bind110(liftEffect8(read(disposed)))(function(v) {\n                if (v) {\n                  return pure16(Nothing.value);\n                }\n                ;\n                return evalQ(render)(ref3)(q2);\n              });\n            };\n          };\n        };\n        var dispose = function(disposed) {\n          return function(lchs) {\n            return function(dsx) {\n              return handleLifecycle(lchs)(function __do2() {\n                var v = read(disposed)();\n                if (v) {\n                  return unit;\n                }\n                ;\n                write(true)(disposed)();\n                finalize(lchs)(dsx)();\n                return unDriverStateX(function(v1) {\n                  return function __do3() {\n                    var v2 = liftEffect1(read(v1.selfRef))();\n                    return for_4(v2.rendering)(renderSpec2.dispose)();\n                  };\n                })(dsx)();\n              });\n            };\n          };\n        };\n        return bind110(liftEffect8(newLifecycleHandlers))(function(lchs) {\n          return bind110(liftEffect8($$new(false)))(function(disposed) {\n            return handleLifecycle(lchs)(function __do2() {\n              var sio = create();\n              var dsx = bindFlipped10(read)(runComponent(lchs)(function() {\n                var $78 = notify(sio.listener);\n                return function($79) {\n                  return liftEffect8($78($79));\n                };\n              }())(i2)(component7))();\n              return unDriverStateX(function(st) {\n                return pure15({\n                  query: evalDriver(disposed)(st.selfRef),\n                  messages: sio.emitter,\n                  dispose: dispose(disposed)(lchs)(dsx)\n                });\n              })(dsx)();\n            });\n          });\n        });\n      };\n    };\n  };\n\n  // output/Web.DOM.Node/foreign.js\n  var getEffProp2 = function(name15) {\n    return function(node) {\n      return function() {\n        return node[name15];\n      };\n    };\n  };\n  var baseURI = getEffProp2(\"baseURI\");\n  var _ownerDocument = getEffProp2(\"ownerDocument\");\n  var _parentNode = getEffProp2(\"parentNode\");\n  var _parentElement = getEffProp2(\"parentElement\");\n  var childNodes = getEffProp2(\"childNodes\");\n  var _firstChild = getEffProp2(\"firstChild\");\n  var _lastChild = getEffProp2(\"lastChild\");\n  var _previousSibling = getEffProp2(\"previousSibling\");\n  var _nextSibling = getEffProp2(\"nextSibling\");\n  var _nodeValue = getEffProp2(\"nodeValue\");\n  var textContent = getEffProp2(\"textContent\");\n  function insertBefore(node1) {\n    return function(node2) {\n      return function(parent2) {\n        return function() {\n          parent2.insertBefore(node1, node2);\n        };\n      };\n    };\n  }\n  function appendChild(node) {\n    return function(parent2) {\n      return function() {\n        parent2.appendChild(node);\n      };\n    };\n  }\n  function removeChild2(node) {\n    return function(parent2) {\n      return function() {\n        parent2.removeChild(node);\n      };\n    };\n  }\n\n  // output/Web.DOM.Node/index.js\n  var map33 = /* @__PURE__ */ map(functorEffect);\n  var parentNode2 = /* @__PURE__ */ function() {\n    var $6 = map33(toMaybe);\n    return function($7) {\n      return $6(_parentNode($7));\n    };\n  }();\n  var nextSibling = /* @__PURE__ */ function() {\n    var $15 = map33(toMaybe);\n    return function($16) {\n      return $15(_nextSibling($16));\n    };\n  }();\n\n  // output/Halogen.VDom.Driver/index.js\n  var $runtime_lazy9 = function(name15, moduleName, init3) {\n    var state3 = 0;\n    var val;\n    return function(lineNumber) {\n      if (state3 === 2)\n        return val;\n      if (state3 === 1)\n        throw new ReferenceError(name15 + \" was needed before it finished initializing (module \" + moduleName + \", line \" + lineNumber + \")\", moduleName, lineNumber);\n      state3 = 1;\n      val = init3();\n      state3 = 2;\n      return val;\n    };\n  };\n  var $$void11 = /* @__PURE__ */ $$void(functorEffect);\n  var pure17 = /* @__PURE__ */ pure(applicativeEffect);\n  var traverse_9 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableMaybe);\n  var unwrap5 = /* @__PURE__ */ unwrap();\n  var when7 = /* @__PURE__ */ when(applicativeEffect);\n  var not5 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean)));\n  var identity15 = /* @__PURE__ */ identity(categoryFn);\n  var bind111 = /* @__PURE__ */ bind(bindAff);\n  var liftEffect9 = /* @__PURE__ */ liftEffect(monadEffectAff);\n  var map34 = /* @__PURE__ */ map(functorEffect);\n  var bindFlipped11 = /* @__PURE__ */ bindFlipped(bindEffect);\n  var substInParent = function(v) {\n    return function(v1) {\n      return function(v2) {\n        if (v1 instanceof Just && v2 instanceof Just) {\n          return $$void11(insertBefore(v)(v1.value0)(v2.value0));\n        }\n        ;\n        if (v1 instanceof Nothing && v2 instanceof Just) {\n          return $$void11(appendChild(v)(v2.value0));\n        }\n        ;\n        return pure17(unit);\n      };\n    };\n  };\n  var removeChild3 = function(v) {\n    return function __do2() {\n      var npn = parentNode2(v.node)();\n      return traverse_9(function(pn) {\n        return removeChild2(v.node)(pn);\n      })(npn)();\n    };\n  };\n  var mkSpec = function(handler3) {\n    return function(renderChildRef) {\n      return function(document2) {\n        var getNode = unRenderStateX(function(v) {\n          return v.node;\n        });\n        var done = function(st) {\n          if (st instanceof Just) {\n            return halt(st.value0);\n          }\n          ;\n          return unit;\n        };\n        var buildWidget2 = function(spec) {\n          var buildThunk2 = buildThunk(unwrap5)(spec);\n          var $lazy_patch = $runtime_lazy9(\"patch\", \"Halogen.VDom.Driver\", function() {\n            return function(st, slot5) {\n              if (st instanceof Just) {\n                if (slot5 instanceof ComponentSlot) {\n                  halt(st.value0);\n                  return $lazy_renderComponentSlot(100)(slot5.value0);\n                }\n                ;\n                if (slot5 instanceof ThunkSlot) {\n                  var step$prime = step(st.value0, slot5.value0);\n                  return mkStep(new Step2(extract2(step$prime), new Just(step$prime), $lazy_patch(103), done));\n                }\n                ;\n                throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 97, column 22 - line 103, column 79): \" + [slot5.constructor.name]);\n              }\n              ;\n              return $lazy_render(104)(slot5);\n            };\n          });\n          var $lazy_render = $runtime_lazy9(\"render\", \"Halogen.VDom.Driver\", function() {\n            return function(slot5) {\n              if (slot5 instanceof ComponentSlot) {\n                return $lazy_renderComponentSlot(86)(slot5.value0);\n              }\n              ;\n              if (slot5 instanceof ThunkSlot) {\n                var step4 = buildThunk2(slot5.value0);\n                return mkStep(new Step2(extract2(step4), new Just(step4), $lazy_patch(89), done));\n              }\n              ;\n              throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 84, column 7 - line 89, column 75): \" + [slot5.constructor.name]);\n            };\n          });\n          var $lazy_renderComponentSlot = $runtime_lazy9(\"renderComponentSlot\", \"Halogen.VDom.Driver\", function() {\n            return function(cs) {\n              var renderChild = read(renderChildRef)();\n              var rsx = renderChild(cs)();\n              var node = getNode(rsx);\n              return mkStep(new Step2(node, Nothing.value, $lazy_patch(117), done));\n            };\n          });\n          var patch = $lazy_patch(91);\n          var render = $lazy_render(82);\n          var renderComponentSlot = $lazy_renderComponentSlot(109);\n          return render;\n        };\n        var buildAttributes = buildProp(handler3);\n        return {\n          buildWidget: buildWidget2,\n          buildAttributes,\n          document: document2\n        };\n      };\n    };\n  };\n  var renderSpec = function(document2) {\n    return function(container) {\n      var render = function(handler3) {\n        return function(child) {\n          return function(v) {\n            return function(v1) {\n              if (v1 instanceof Nothing) {\n                return function __do2() {\n                  var renderChildRef = $$new(child)();\n                  var spec = mkSpec(handler3)(renderChildRef)(document2);\n                  var machine = buildVDom(spec)(v);\n                  var node = extract2(machine);\n                  $$void11(appendChild(node)(toNode2(container)))();\n                  return {\n                    machine,\n                    node,\n                    renderChildRef\n                  };\n                };\n              }\n              ;\n              if (v1 instanceof Just) {\n                return function __do2() {\n                  write(child)(v1.value0.renderChildRef)();\n                  var parent2 = parentNode2(v1.value0.node)();\n                  var nextSib = nextSibling(v1.value0.node)();\n                  var machine$prime = step(v1.value0.machine, v);\n                  var newNode = extract2(machine$prime);\n                  when7(not5(unsafeRefEq)(v1.value0.node)(newNode))(substInParent(newNode)(nextSib)(parent2))();\n                  return {\n                    machine: machine$prime,\n                    node: newNode,\n                    renderChildRef: v1.value0.renderChildRef\n                  };\n                };\n              }\n              ;\n              throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 157, column 5 - line 173, column 80): \" + [v1.constructor.name]);\n            };\n          };\n        };\n      };\n      return {\n        render,\n        renderChild: identity15,\n        removeChild: removeChild3,\n        dispose: removeChild3\n      };\n    };\n  };\n  var runUI2 = function(component7) {\n    return function(i2) {\n      return function(element3) {\n        return bind111(liftEffect9(map34(toDocument)(bindFlipped11(document)(windowImpl))))(function(document2) {\n          return runUI(renderSpec(document2)(element3))(component7)(i2);\n        });\n      };\n    };\n  };\n\n  // output/Main/index.js\n  var main2 = /* @__PURE__ */ runHalogenAff(/* @__PURE__ */ bind(bindAff)(awaitBody)(function(body2) {\n    return runUI2(component6)(unit)(body2);\n  }));\n\n  // <stdin>\n  main2();\n})();\n//# sourceMappingURL=app.js.map\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < digits[i]) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define( function () {\r\n        return bigInt;\r\n    });\r\n}\r\n","export const arrayApply = function (fs) {\n  return function (xs) {\n    var l = fs.length;\n    var k = xs.length;\n    var result = new Array(l*k);\n    var n = 0;\n    for (var i = 0; i < l; i++) {\n      var f = fs[i];\n      for (var j = 0; j < k; j++) {\n        result[n++] = f(xs[j]);\n      }\n    }\n    return result;\n  };\n};\n","module Control.Semigroupoid where\n\n-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not\n-- | require an identity element `identity`, just composable morphisms.\n-- |\n-- | `Semigroupoid`s must satisfy the following law:\n-- |\n-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n-- |\n-- | One example of a `Semigroupoid` is the function type constructor `(->)`,\n-- | with `(<<<)` defined as function composition.\nclass Semigroupoid :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a where\n  compose :: forall b c d. a c d -> a b c -> a b d\n\ninstance semigroupoidFn :: Semigroupoid (->) where\n  compose f g x = f (g x)\n\ninfixr 9 compose as <<<\n\n-- | Forwards composition, or `compose` with its arguments reversed.\ncomposeFlipped :: forall a b c d. Semigroupoid a => a b c -> a c d -> a b d\ncomposeFlipped f g = compose g f\n\ninfixr 9 composeFlipped as >>>\n","module Control.Category\n  ( class Category\n  , identity\n  , module Control.Semigroupoid\n  ) where\n\nimport Control.Semigroupoid (class Semigroupoid, compose, (<<<), (>>>))\n\n-- | `Category`s consist of objects and composable morphisms between them, and\n-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\n-- | must have an identity element.\n-- |\n-- | Instances must satisfy the following law in addition to the\n-- | `Semigroupoid` law:\n-- |\n-- | - Identity: `identity <<< p = p <<< identity = p`\nclass Category :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a <= Category a where\n  identity :: forall t. a t t\n\ninstance categoryFn :: Category (->) where\n  identity x = x\n","module Data.Boolean where\n\n-- | An alias for `true`, which can be useful in guard clauses:\n-- |\n-- | ```purescript\n-- | max x y | x >= y    = x\n-- |         | otherwise = y\n-- | ```\notherwise :: Boolean\notherwise = true\n","module Data.Function\n  ( flip\n  , const\n  , apply\n  , ($)\n  , applyFlipped\n  , (#)\n  , applyN\n  , on\n  , module Control.Category\n  ) where\n\nimport Control.Category (identity, compose, (<<<), (>>>))\nimport Data.Boolean (otherwise)\nimport Data.Ord ((<=))\nimport Data.Ring ((-))\n\n-- | Given a function that takes two arguments, applies the arguments\n-- | to the function in a swapped order.\n-- |\n-- | ```purescript\n-- | flip append \"1\" \"2\" == append \"2\" \"1\" == \"21\"\n-- |\n-- | const 1 \"two\" == 1\n-- |\n-- | flip const 1 \"two\" == const \"two\" 1 == \"two\"\n-- | ```\nflip :: forall a b c. (a -> b -> c) -> b -> a -> c\nflip f b a = f a b\n\n-- | Returns its first argument and ignores its second.\n-- |\n-- | ```purescript\n-- | const 1 \"hello\" = 1\n-- | ```\n-- |\n-- | It can also be thought of as creating a function that ignores its argument:\n-- |\n-- | ```purescript\n-- | const 1 = \\_ -> 1\n-- | ```\nconst :: forall a b. a -> b -> a\nconst a _ = a\n\n-- | Applies a function to an argument. This is primarily used as the operator\n-- | `($)` which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a chain of composed functions to a value.\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n\n-- | Applies a function to an argument: the reverse of `(#)`.\n-- |\n-- | ```purescript\n-- | length $ groupBy productCategory $ filter isInStock $ products\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying chain of composed functions to\n-- | a value:\n-- |\n-- | ```purescript\n-- | length <<< groupBy productCategory <<< filter isInStock $ products\n-- | ```\ninfixr 0 apply as $\n\n-- | Applies an argument to a function. This is primarily used as the `(#)`\n-- | operator, which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a value to a chain of composed functions.\napplyFlipped :: forall a b. a -> (a -> b) -> b\napplyFlipped x f = f x\n\n-- | Applies an argument to a function: the reverse of `($)`.\n-- |\n-- | ```purescript\n-- | products # filter isInStock # groupBy productCategory # length\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying a value to a chain of composed\n-- | functions:\n-- |\n-- | ```purescript\n-- | products # filter isInStock >>> groupBy productCategory >>> length\n-- | ```\ninfixl 1 applyFlipped as #\n\n-- | `applyN f n` applies the function `f` to its argument `n` times.\n-- |\n-- | If n is less than or equal to 0, the function is not applied.\n-- |\n-- | ```purescript\n-- | applyN (_ + 1) 10 0 == 10\n-- | ```\napplyN :: forall a. (a -> a) -> Int -> a -> a\napplyN f = go\n  where\n  go n acc\n    | n <= 0 = acc\n    | otherwise = go (n - 1) (f acc)\n\n-- | The `on` function is used to change the domain of a binary operator.\n-- |\n-- | For example, we can create a function which compares two records based on the values of their `x` properties:\n-- |\n-- | ```purescript\n-- | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering\n-- | compareX = compare `on` _.x\n-- | ```\non :: forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c\non f g x y = g x `f` g y\n","export const arrayMap = function (f) {\n  return function (arr) {\n    var l = arr.length;\n    var result = new Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(arr[i]);\n    }\n    return result;\n  };\n};\n","export const unit = undefined;\n","-- | The `Proxy` type and values are for situations where type information is\n-- | required for an input to determine the type of an output, but where it is\n-- | not possible or convenient to provide a _value_ for the input.\n-- |\n-- | A hypothetical example: if you have a class that is used to handle the\n-- | result of an AJAX request, you may want to use this information to set the\n-- | expected content type of the request, so you might have a class something\n-- | like this:\n-- |\n-- | ``` purescript\n-- | class AjaxResponse a where\n-- |   responseType :: a -> ResponseType\n-- |   fromResponse :: Foreign -> a\n-- | ```\n-- |\n-- | The problem here is `responseType` requires a value of type `a`, but we\n-- | won't have a value of that type until the request has been completed. The\n-- | solution is to use a `Proxy` type instead:\n-- |\n-- | ``` purescript\n-- | class AjaxResponse a where\n-- |   responseType :: Proxy a -> ResponseType\n-- |   fromResponse :: Foreign -> a\n-- | ```\n-- |\n-- | We can now call `responseType (Proxy :: Proxy SomeContentType)` to produce\n-- | a `ResponseType` for `SomeContentType` without having to construct some\n-- | empty version of `SomeContentType` first. In situations like this where\n-- | the `Proxy` type can be statically determined, it is recommended to pull\n-- | out the definition to the top level and make a declaration like:\n-- |\n-- | ``` purescript\n-- | _SomeContentType :: Proxy SomeContentType\n-- | _SomeContentType = Proxy\n-- | ```\n-- |\n-- | That way the proxy value can be used as `responseType _SomeContentType`\n-- | for improved readability. However, this is not always possible, sometimes\n-- | the type required will be determined by a type variable. As PureScript has\n-- | scoped type variables, we can do things like this:\n-- |\n-- | ``` purescript\n-- | makeRequest :: URL -> ResponseType -> Aff _ Foreign\n-- | makeRequest = ...\n-- |\n-- | fetchData :: forall a. (AjaxResponse a) => URL -> Aff _ a\n-- | fetchData url = fromResponse <$> makeRequest url (responseType (Proxy :: Proxy a))\n-- | ```\nmodule Type.Proxy where\n\n-- | Proxy type for all `kind`s.\ndata Proxy :: forall k. k -> Type\ndata Proxy a = Proxy\n","module Data.Functor\n  ( class Functor\n  , map\n  , (<$>)\n  , mapFlipped\n  , (<#>)\n  , void\n  , voidRight\n  , (<$)\n  , voidLeft\n  , ($>)\n  , flap\n  , (<@>)\n  ) where\n\nimport Data.Function (const, compose)\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Functor` is a type constructor which supports a mapping operation\n-- | `map`.\n-- |\n-- | `map` can be used to turn functions `a -> b` into functions\n-- | `f a -> f b` whose argument and return types use the type constructor `f`\n-- | to represent some computational context.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Identity: `map identity = identity`\n-- | - Composition: `map (f <<< g) = map f <<< map g`\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n\ninfixl 4 map as <$>\n\n-- | `mapFlipped` is `map` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | [1, 2, 3] <#> \\n -> n * n\n-- | ```\nmapFlipped :: forall f a b. Functor f => f a -> (a -> b) -> f b\nmapFlipped fa f = f <$> fa\n\ninfixl 1 mapFlipped as <#>\n\ninstance functorFn :: Functor ((->) r) where\n  map = compose\n\ninstance functorArray :: Functor Array where\n  map = arrayMap\n\ninstance functorProxy :: Functor Proxy where\n  map _ _ = Proxy\n\nforeign import arrayMap :: forall a b. (a -> b) -> Array a -> Array b\n\n-- | The `void` function is used to ignore the type wrapped by a\n-- | [`Functor`](#functor), replacing it with `Unit` and keeping only the type\n-- | information provided by the type constructor itself.\n-- |\n-- | `void` is often useful when using `do` notation to change the return type\n-- | of a monadic computation:\n-- |\n-- | ```purescript\n-- | main = forE 1 10 \\n -> void do\n-- |   print n\n-- |   print (n * n)\n-- | ```\nvoid :: forall f a. Functor f => f a -> f Unit\nvoid = map (const unit)\n\n-- | Ignore the return value of a computation, using the specified return value\n-- | instead.\nvoidRight :: forall f a b. Functor f => a -> f b -> f a\nvoidRight x = map (const x)\n\ninfixl 4 voidRight as <$\n\n-- | A version of `voidRight` with its arguments flipped.\nvoidLeft :: forall f a b. Functor f => f a -> b -> f b\nvoidLeft f x = const x <$> f\n\ninfixl 4 voidLeft as $>\n\n-- | Apply a value in a computational context to a value in no context.\n-- |\n-- | Generalizes `flip`.\n-- |\n-- | ```purescript\n-- | longEnough :: String -> Bool\n-- | hasSymbol :: String -> Bool\n-- | hasDigit :: String -> Bool\n-- | password :: String\n-- |\n-- | validate :: String -> Array Bool\n-- | validate = flap [longEnough, hasSymbol, hasDigit]\n-- | ```\n-- |\n-- | ```purescript\n-- | flap (-) 3 4 == 1\n-- | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)\n-- | ```\nflap :: forall f a b. Functor f => f (a -> b) -> a -> f b\nflap ff x = map (\\f -> f x) ff\n\ninfixl 4 flap as <@>\n","module Control.Apply\n  ( class Apply\n  , apply\n  , (<*>)\n  , applyFirst\n  , (<*)\n  , applySecond\n  , (*>)\n  , lift2\n  , lift3\n  , lift4\n  , lift5\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Function (const)\nimport Control.Category (identity)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Apply` class provides the `(<*>)` which is used to apply a function\n-- | to an argument under a type constructor.\n-- |\n-- | `Apply` can be used to lift functions of two or more arguments to work on\n-- | values wrapped with the type constructor `f`. It might also be understood\n-- | in terms of the `lift2` function:\n-- |\n-- | ```purescript\n-- | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n-- | lift2 f a b = f <$> a <*> b\n-- | ```\n-- |\n-- | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\n-- | the function application operator `($)` to arguments wrapped with the\n-- | type constructor `f`.\n-- |\n-- | Put differently...\n-- | ```\n-- | foo =\n-- |   functionTakingNArguments <$> computationProducingArg1\n-- |                            <*> computationProducingArg2\n-- |                            <*> ...\n-- |                            <*> computationProducingArgN\n-- | ```\n-- |\n-- | Instances must satisfy the following law in addition to the `Functor`\n-- | laws:\n-- |\n-- | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n-- |\n-- | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\nclass Functor f <= Apply f where\n  apply :: forall a b. f (a -> b) -> f a -> f b\n\ninfixl 4 apply as <*>\n\ninstance applyFn :: Apply ((->) r) where\n  apply f g x = f x (g x)\n\ninstance applyArray :: Apply Array where\n  apply = arrayApply\n\nforeign import arrayApply :: forall a b. Array (a -> b) -> Array a -> Array b\n\ninstance applyProxy :: Apply Proxy where\n  apply _ _ = Proxy\n\n-- | Combine two effectful actions, keeping only the result of the first.\napplyFirst :: forall a b f. Apply f => f a -> f b -> f a\napplyFirst a b = const <$> a <*> b\n\ninfixl 4 applyFirst as <*\n\n-- | Combine two effectful actions, keeping only the result of the second.\napplySecond :: forall a b f. Apply f => f a -> f b -> f b\napplySecond a b = const identity <$> a <*> b\n\ninfixl 4 applySecond as *>\n\n-- | Lift a function of two arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\n-- |\n-- | ```purescript\n-- | lift2 add (Just 1) (Just 2) == Just 3\n-- | lift2 add Nothing (Just 2) == Nothing\n-- |```\n-- |\nlift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n\n-- | Lift a function of three arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift3 :: forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nlift3 f a b c = f <$> a <*> b <*> c\n\n-- | Lift a function of four arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift4 :: forall a b c d e f. Apply f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e\nlift4 f a b c d = f <$> a <*> b <*> c <*> d\n\n-- | Lift a function of five arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift5 :: forall a b c d e f g. Apply f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g\nlift5 f a b c d e = f <$> a <*> b <*> c <*> d <*> e\n","module Control.Applicative\n  ( class Applicative\n  , pure\n  , liftA1\n  , unless\n  , when\n  , module Control.Apply\n  , module Data.Functor\n  ) where\n\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Applicative` type class extends the [`Apply`](#apply) type class\n-- | with a `pure` function, which can be used to create values of type `f a`\n-- | from values of type `a`.\n-- |\n-- | Where [`Apply`](#apply) provides the ability to lift functions of two or\n-- | more arguments to functions whose arguments are wrapped using `f`, and\n-- | [`Functor`](#functor) provides the ability to lift functions of one\n-- | argument, `pure` can be seen as the function which lifts functions of\n-- | _zero_ arguments. That is, `Applicative` functors support a lifting\n-- | operation for any number of function arguments.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Identity: `(pure identity) <*> v = v`\n-- | - Composition: `pure (<<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n-- | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n-- | - Interchange: `u <*> (pure y) = (pure (_ $ y)) <*> u`\nclass Apply f <= Applicative f where\n  pure :: forall a. a -> f a\n\ninstance applicativeFn :: Applicative ((->) r) where\n  pure x _ = x\n\ninstance applicativeArray :: Applicative Array where\n  pure x = [ x ]\n\ninstance applicativeProxy :: Applicative Proxy where\n  pure _ = Proxy\n\n-- | `liftA1` provides a default implementation of `(<$>)` for any\n-- | [`Applicative`](#applicative) functor, without using `(<$>)` as provided\n-- | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\n-- | relationship.\n-- |\n-- | `liftA1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftA1\n-- | ```\nliftA1 :: forall f a b. Applicative f => (a -> b) -> f a -> f b\nliftA1 f a = pure f <*> a\n\n-- | Perform an applicative action when a condition is true.\nwhen :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nwhen true m = m\nwhen false _ = pure unit\n\n-- | Perform an applicative action unless a condition is true.\nunless :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nunless false m = m\nunless true _ = pure unit\n","export const arrayBind = function (arr) {\n  return function (f) {\n    var result = [];\n    for (var i = 0, l = arr.length; i < l; i++) {\n      Array.prototype.push.apply(result, f(arr[i]));\n    }\n    return result;\n  };\n};\n","module Control.Bind\n  ( class Bind\n  , bind\n  , (>>=)\n  , bindFlipped\n  , (=<<)\n  , class Discard\n  , discard\n  , join\n  , composeKleisli\n  , (>=>)\n  , composeKleisliFlipped\n  , (<=<)\n  , ifM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Category (identity)\n\nimport Data.Function (flip)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bind` type class extends the [`Apply`](#apply) type class with a\n-- | \"bind\" operation `(>>=)` which composes computations in sequence, using\n-- | the return value of one computation to determine the next computation.\n-- |\n-- | The `>>=` operator can also be expressed using `do` notation, as follows:\n-- |\n-- | ```purescript\n-- | x >>= f = do y <- x\n-- |              f y\n-- | ```\n-- |\n-- | where the function argument of `f` is given the name `y`.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Associativity: `(x >>= f) >>= g = x >>= (\\k -> f k >>= g)`\n-- | - Apply Superclass: `apply f x = f >>= \\f’ -> map f’ x`\n-- |\n-- | Associativity tells us that we can regroup operations which use `do`\n-- | notation so that we can unambiguously write, for example:\n-- |\n-- | ```purescript\n-- | do x <- m1\n-- |    y <- m2 x\n-- |    m3 x y\n-- | ```\nclass Apply m <= Bind m where\n  bind :: forall a b. m a -> (a -> m b) -> m b\n\ninfixl 1 bind as >>=\n\n-- | `bindFlipped` is `bind` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | print =<< random\n-- | ```\nbindFlipped :: forall m a b. Bind m => (a -> m b) -> m a -> m b\nbindFlipped = flip bind\n\ninfixr 1 bindFlipped as =<<\n\ninstance bindFn :: Bind ((->) r) where\n  bind m f x = f (m x) x\n\n-- | The `bind`/`>>=` function for `Array` works by applying a function to\n-- | each element in the array, and flattening the results into a single,\n-- | new array.\n-- |\n-- | Array's `bind`/`>>=` works like a nested for loop. Each `bind` adds\n-- | another level of nesting in the loop. For example:\n-- | ```\n-- | foo :: Array String\n-- | foo =\n-- |   [\"a\", \"b\"] >>= \\eachElementInArray1 ->\n-- |     [\"c\", \"d\"] >>= \\eachElementInArray2\n-- |       pure (eachElementInArray1 <> eachElementInArray2)\n-- |\n-- | -- In other words...\n-- | foo\n-- | -- ... is the same as...\n-- | [ (\"a\" <> \"c\"), (\"a\" <> \"d\"), (\"b\" <> \"c\"), (\"b\" <> \"d\") ]\n-- | -- which simplifies to...\n-- | [ \"ac\", \"ad\", \"bc\", \"bd\" ]\n-- | ```\ninstance bindArray :: Bind Array where\n  bind = arrayBind\n\nforeign import arrayBind :: forall a b. Array a -> (a -> Array b) -> Array b\n\ninstance bindProxy :: Bind Proxy where\n  bind _ _ = Proxy\n\n-- | A class for types whose values can safely be discarded\n-- | in a `do` notation block.\n-- |\n-- | An example is the `Unit` type, since there is only one\n-- | possible value which can be returned.\nclass Discard a where\n  discard :: forall f b. Bind f => f a -> (a -> f b) -> f b\n\ninstance discardUnit :: Discard Unit where\n  discard = bind\n\ninstance discardProxy :: Discard (Proxy a) where\n  discard = bind\n\n-- | Collapse two applications of a monadic type constructor into one.\njoin :: forall a m. Bind m => m (m a) -> m a\njoin m = m >>= identity\n\n-- | Forwards Kleisli composition.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Data.Array (head, tail)\n-- |\n-- | third = tail >=> tail >=> head\n-- | ```\ncomposeKleisli :: forall a b c m. Bind m => (a -> m b) -> (b -> m c) -> a -> m c\ncomposeKleisli f g a = f a >>= g\n\ninfixr 1 composeKleisli as >=>\n\n-- | Backwards Kleisli composition.\ncomposeKleisliFlipped :: forall a b c m. Bind m => (b -> m c) -> (a -> m b) -> a -> m c\ncomposeKleisliFlipped f g a = f =<< g a\n\ninfixr 1 composeKleisliFlipped as <=<\n\n-- | Execute a monadic action if a condition holds.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = ifM ((< 0.5) <$> random)\n-- |          (trace \"Heads\")\n-- |          (trace \"Tails\")\n-- | ```\nifM :: forall a m. Bind m => m Boolean -> m a -> m a -> m a\nifM cond t f = cond >>= \\cond' -> if cond' then t else f\n","module Control.Monad\n  ( class Monad\n  , liftM1\n  , whenM\n  , unlessM\n  , ap\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  , module Control.Bind\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy)\n\n-- | The `Monad` type class combines the operations of the `Bind` and\n-- | `Applicative` type classes. Therefore, `Monad` instances represent type\n-- | constructors which support sequential composition, and also lifting of\n-- | functions of arbitrary arity.\n-- |\n-- | Instances must satisfy the following laws in addition to the\n-- | `Applicative` and `Bind` laws:\n-- |\n-- | - Left Identity: `pure x >>= f = f x`\n-- | - Right Identity: `x >>= pure = x`\nclass (Applicative m, Bind m) <= Monad m\n\ninstance monadFn :: Monad ((->) r)\n\ninstance monadArray :: Monad Array\n\ninstance monadProxy :: Monad Proxy\n\n-- | `liftM1` provides a default implementation of `(<$>)` for any\n-- | [`Monad`](#monad), without using `(<$>)` as provided by the\n-- | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n-- |\n-- | `liftM1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftM1\n-- | ```\nliftM1 :: forall m a b. Monad m => (a -> b) -> m a -> m b\nliftM1 f a = do\n  a' <- a\n  pure (f a')\n\n-- | Perform a monadic action when a condition is true, where the conditional\n-- | value is also in a monadic context.\nwhenM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nwhenM mb m = do\n  b <- mb\n  when b m\n\n-- | Perform a monadic action unless a condition is true, where the conditional\n-- | value is also in a monadic context.\nunlessM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nunlessM mb m = do\n  b <- mb\n  unless b m\n\n-- | `ap` provides a default implementation of `(<*>)` for any `Monad`, without\n-- | using `(<*>)` as provided by the `Apply`-`Monad` superclass relationship.\n-- |\n-- | `ap` can therefore be used to write `Apply` instances as follows:\n-- |\n-- | ```purescript\n-- | instance applyF :: Apply F where\n-- |   apply = ap\n-- | ```\n-- Note: Only a `Bind` constraint is needed, but this can\n-- produce loops when used with other default implementations\n-- (i.e. `liftA1`).\n-- See https://github.com/purescript/purescript-prelude/issues/232\nap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\nap f a = do\n  f' <- f\n  a' <- a\n  pure (f' a')\n","export const concatString = function (s1) {\n  return function (s2) {\n    return s1 + s2;\n  };\n};\n\nexport const concatArray = function (xs) {\n  return function (ys) {\n    if (xs.length === 0) return ys;\n    if (ys.length === 0) return xs;\n    return xs.concat(ys);\n  };\n};\n","module Data.Symbol\n  ( class IsSymbol\n  , reflectSymbol\n  , reifySymbol\n  ) where\n\nimport Type.Proxy (Proxy(..))\n\n-- | A class for known symbols\nclass IsSymbol (sym :: Symbol) where\n  reflectSymbol :: Proxy sym -> String\n\n-- local definition for use in `reifySymbol`\nforeign import unsafeCoerce :: forall a b. a -> b\n\nreifySymbol :: forall r. String -> (forall sym. IsSymbol sym => Proxy sym -> r) -> r\nreifySymbol s f = coerce f { reflectSymbol: \\_ -> s } Proxy\n  where\n  coerce\n    :: (forall sym1. IsSymbol sym1 => Proxy sym1 -> r)\n    -> { reflectSymbol :: Proxy \"\" -> String }\n    -> Proxy \"\"\n    -> r\n  coerce = unsafeCoerce\n","export const unsafeHas = function (label) {\n  return function (rec) {\n    return {}.hasOwnProperty.call(rec, label);\n  };\n};\n\nexport const unsafeGet = function (label) {\n  return function (rec) {\n    return rec[label];\n  };\n};\n\nexport const unsafeSet = function (label) {\n  return function (value) {\n    return function (rec) {\n      var copy = {};\n      for (var key in rec) {\n        if ({}.hasOwnProperty.call(rec, key)) {\n          copy[key] = rec[key];\n        }\n      }\n      copy[label] = value;\n      return copy;\n    };\n  };\n};\n\nexport const unsafeDelete = function (label) {\n  return function (rec) {\n    var copy = {};\n    for (var key in rec) {\n      if (key !== label && {}.hasOwnProperty.call(rec, key)) {\n        copy[key] = rec[key];\n      }\n    }\n    return copy;\n  };\n};\n","module Data.Semigroup\n  ( class Semigroup\n  , append\n  , (<>)\n  , class SemigroupRecord\n  , appendRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semigroup` type class identifies an associative operation on a type.\n-- |\n-- | Instances are required to satisfy the following law:\n-- |\n-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`\n-- |\n-- | One example of a `Semigroup` is `String`, with `(<>)` defined as string\n-- | concatenation. Another example is `List a`, with `(<>)` defined as\n-- | list concatenation.\n-- |\n-- | ### Newtypes for Semigroup\n-- |\n-- | There are two other ways to implement an instance for this type class\n-- | regardless of which type is used. These instances can be used by\n-- | wrapping the values in one of the two newtypes below:\n-- | 1. `First` - Use the first argument every time: `append first _ = first`.\n-- | 2. `Last` - Use the last argument every time: `append _ last = last`.\nclass Semigroup a where\n  append :: a -> a -> a\n\ninfixr 5 append as <>\n\ninstance semigroupString :: Semigroup String where\n  append = concatString\n\ninstance semigroupUnit :: Semigroup Unit where\n  append _ _ = unit\n\ninstance semigroupVoid :: Semigroup Void where\n  append _ = absurd\n\ninstance semigroupFn :: Semigroup s' => Semigroup (s -> s') where\n  append f g x = f x <> g x\n\ninstance semigroupArray :: Semigroup (Array a) where\n  append = concatArray\n\ninstance semigroupProxy :: Semigroup (Proxy a) where\n  append _ _ = Proxy\n\ninstance semigroupRecord :: (RL.RowToList row list, SemigroupRecord list row row) => Semigroup (Record row) where\n  append = appendRecord (Proxy :: Proxy list)\n\nforeign import concatString :: String -> String -> String\nforeign import concatArray :: forall a. Array a -> Array a -> Array a\n\n-- | A class for records where all fields have `Semigroup` instances, used to\n-- | implement the `Semigroup` instance for records.\nclass SemigroupRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow | rowlist -> subrow where\n  appendRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance semigroupRecordNil :: SemigroupRecord RL.Nil row () where\n  appendRecord _ _ _ = {}\n\ninstance semigroupRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemigroupRecord rowlistTail row subrowTail\n  , Semigroup focus\n  ) =>\n  SemigroupRecord (RL.Cons key focus rowlistTail) row subrow where\n  appendRecord _ ra rb = insert (get ra <> get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = appendRecord (Proxy :: Proxy rowlistTail) ra rb\n","module Control.Alt\n  ( class Alt, alt, (<|>)\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (append)\n\n-- | The `Alt` type class identifies an associative operation on a type\n-- | constructor.  It is similar to `Semigroup`, except that it applies to\n-- | types of kind `* -> *`, like `Array` or `List`, rather than concrete types\n-- | `String` or `Number`.\n-- |\n-- | `Alt` instances are required to satisfy the following laws:\n-- |\n-- | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`\n-- | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`\n-- |\n-- | For example, the `Array` (`[]`) type is an instance of `Alt`, where\n-- | `(<|>)` is defined to be concatenation.\n-- |\n-- | A common use case is to select the first \"valid\" item, or, if all items\n-- | are \"invalid\", the last \"invalid\" item.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Control.Alt ((<|>))\n-- | import Data.Maybe (Maybe(..)\n-- | import Data.Either (Either(..))\n-- |\n-- | Nothing <|> Just 1 <|> Just 2 == Just 1\n-- | Left \"err\" <|> Right 1 <|> Right 2 == Right 1\n-- | Left \"err 1\" <|> Left \"err 2\" <|> Left \"err 3\" == Left \"err 3\"\n-- | ```\nclass Functor f <= Alt f where\n  alt :: forall a. f a -> f a -> f a\n\ninfixr 3 alt as <|>\n\ninstance altArray :: Alt Array where\n  alt = append\n","export const topInt = 2147483647;\nexport const bottomInt = -2147483648;\n\nexport const topChar = String.fromCharCode(65535);\nexport const bottomChar = String.fromCharCode(0);\n\nexport const topNumber = Number.POSITIVE_INFINITY;\nexport const bottomNumber = Number.NEGATIVE_INFINITY;\n","var unsafeCompareImpl = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (x) {\n        return function (y) {\n          return x < y ? lt : x === y ? eq : gt;\n        };\n      };\n    };\n  };\n};\n\nexport const ordBooleanImpl = unsafeCompareImpl;\nexport const ordIntImpl = unsafeCompareImpl;\nexport const ordNumberImpl = unsafeCompareImpl;\nexport const ordStringImpl = unsafeCompareImpl;\nexport const ordCharImpl = unsafeCompareImpl;\n\nexport const ordArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var i = 0;\n      var xlen = xs.length;\n      var ylen = ys.length;\n      while (i < xlen && i < ylen) {\n        var x = xs[i];\n        var y = ys[i];\n        var o = f(x)(y);\n        if (o !== 0) {\n          return o;\n        }\n        i++;\n      }\n      if (xlen === ylen) {\n        return 0;\n      } else if (xlen > ylen) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n  };\n};\n","var refEq = function (r1) {\n  return function (r2) {\n    return r1 === r2;\n  };\n};\n\nexport const eqBooleanImpl = refEq;\nexport const eqIntImpl = refEq;\nexport const eqNumberImpl = refEq;\nexport const eqCharImpl = refEq;\nexport const eqStringImpl = refEq;\n\nexport const eqArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      if (xs.length !== ys.length) return false;\n      for (var i = 0; i < xs.length; i++) {\n        if (!f(xs[i])(ys[i])) return false;\n      }\n      return true;\n    };\n  };\n};\n","module Data.Eq\n  ( class Eq\n  , eq\n  , (==)\n  , notEq\n  , (/=)\n  , class Eq1\n  , eq1\n  , notEq1\n  , class EqRecord\n  , eqRecord\n  ) where\n\nimport Data.HeytingAlgebra ((&&))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Eq` type class represents types which support decidable equality.\n-- |\n-- | `Eq` instances should satisfy the following laws:\n-- |\n-- | - Reflexivity: `x == x = true`\n-- | - Symmetry: `x == y = y == x`\n-- | - Transitivity: if `x == y` and `y == z` then `x == z`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,\n-- | computing with `Number` can result in a loss of precision, so sometimes\n-- | values that should be equivalent are not.\nclass Eq a where\n  eq :: a -> a -> Boolean\n\ninfix 4 eq as ==\n\n-- | `notEq` tests whether one value is _not equal_ to another. Shorthand for\n-- | `not (eq x y)`.\nnotEq :: forall a. Eq a => a -> a -> Boolean\nnotEq x y = (x == y) == false\n\ninfix 4 notEq as /=\n\ninstance eqBoolean :: Eq Boolean where\n  eq = eqBooleanImpl\n\ninstance eqInt :: Eq Int where\n  eq = eqIntImpl\n\ninstance eqNumber :: Eq Number where\n  eq = eqNumberImpl\n\ninstance eqChar :: Eq Char where\n  eq = eqCharImpl\n\ninstance eqString :: Eq String where\n  eq = eqStringImpl\n\ninstance eqUnit :: Eq Unit where\n  eq _ _ = true\n\ninstance eqVoid :: Eq Void where\n  eq _ _ = true\n\ninstance eqArray :: Eq a => Eq (Array a) where\n  eq = eqArrayImpl eq\n\ninstance eqRec :: (RL.RowToList row list, EqRecord list row) => Eq (Record row) where\n  eq = eqRecord (Proxy :: Proxy list)\n\ninstance eqProxy :: Eq (Proxy a) where\n  eq _ _ = true\n\nforeign import eqBooleanImpl :: Boolean -> Boolean -> Boolean\nforeign import eqIntImpl :: Int -> Int -> Boolean\nforeign import eqNumberImpl :: Number -> Number -> Boolean\nforeign import eqCharImpl :: Char -> Char -> Boolean\nforeign import eqStringImpl :: String -> String -> Boolean\n\nforeign import eqArrayImpl :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Boolean\n\n-- | The `Eq1` type class represents type constructors with decidable equality.\nclass Eq1 f where\n  eq1 :: forall a. Eq a => f a -> f a -> Boolean\n\ninstance eq1Array :: Eq1 Array where\n  eq1 = eq\n\nnotEq1 :: forall f a. Eq1 f => Eq a => f a -> f a -> Boolean\nnotEq1 x y = (x `eq1` y) == false\n\n-- | A class for records where all fields have `Eq` instances, used to implement\n-- | the `Eq` instance for records.\nclass EqRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row where\n  eqRecord :: Proxy rowlist -> Record row -> Record row -> Boolean\n\ninstance eqRowNil :: EqRecord RL.Nil row where\n  eqRecord _ _ _ = true\n\ninstance eqRowCons ::\n  ( EqRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Eq focus\n  ) =>\n  EqRecord (RL.Cons key focus rowlistTail) row where\n  eqRecord _ ra rb = (get ra == get rb) && tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = eqRecord (Proxy :: Proxy rowlistTail) ra rb\n","module Data.Ordering (Ordering(..), invert) where\n\nimport Data.Eq (class Eq)\nimport Data.Semigroup (class Semigroup)\nimport Data.Show (class Show)\n\n-- | The `Ordering` data type represents the three possible outcomes of\n-- | comparing two values:\n-- |\n-- | `LT` - The first value is _less than_ the second.\n-- | `GT` - The first value is _greater than_ the second.\n-- | `EQ` - The first value is _equal to_ the second.\ndata Ordering = LT | GT | EQ\n\ninstance eqOrdering :: Eq Ordering where\n  eq LT LT = true\n  eq GT GT = true\n  eq EQ EQ = true\n  eq _ _ = false\n\ninstance semigroupOrdering :: Semigroup Ordering where\n  append LT _ = LT\n  append GT _ = GT\n  append EQ y = y\n\ninstance showOrdering :: Show Ordering where\n  show LT = \"LT\"\n  show GT = \"GT\"\n  show EQ = \"EQ\"\n\n-- | Reverses an `Ordering` value, flipping greater than for less than while\n-- | preserving equality.\ninvert :: Ordering -> Ordering\ninvert GT = LT\ninvert EQ = EQ\ninvert LT = GT\n","export const intSub = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x - y | 0;\n  };\n};\n\nexport const numSub = function (n1) {\n  return function (n2) {\n    return n1 - n2;\n  };\n};\n","export const intAdd = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x + y | 0;\n  };\n};\n\nexport const intMul = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x * y | 0;\n  };\n};\n\nexport const numAdd = function (n1) {\n  return function (n2) {\n    return n1 + n2;\n  };\n};\n\nexport const numMul = function (n1) {\n  return function (n2) {\n    return n1 * n2;\n  };\n};\n","module Data.Semiring\n  ( class Semiring\n  , add\n  , (+)\n  , zero\n  , mul\n  , (*)\n  , one\n  , class SemiringRecord\n  , addRecord\n  , mulRecord\n  , oneRecord\n  , zeroRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semiring` class is for types that support an addition and\n-- | multiplication operation.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Commutative monoid under addition:\n-- |   - Associativity: `(a + b) + c = a + (b + c)`\n-- |   - Identity: `zero + a = a + zero = a`\n-- |   - Commutative: `a + b = b + a`\n-- | - Monoid under multiplication:\n-- |   - Associativity: `(a * b) * c = a * (b * c)`\n-- |   - Identity: `one * a = a * one = a`\n-- | - Multiplication distributes over addition:\n-- |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n-- |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n-- | - Annihilation: `zero * a = a * zero = zero`\n-- |\n-- | **Note:** The `Number` and `Int` types are not fully law abiding\n-- | members of this class hierarchy due to the potential for arithmetic\n-- | overflows, and in the case of `Number`, the presence of `NaN` and\n-- | `Infinity` values. The behaviour is unspecified in these cases.\nclass Semiring a where\n  add :: a -> a -> a\n  zero :: a\n  mul :: a -> a -> a\n  one :: a\n\ninfixl 6 add as +\ninfixl 7 mul as *\n\ninstance semiringInt :: Semiring Int where\n  add = intAdd\n  zero = 0\n  mul = intMul\n  one = 1\n\ninstance semiringNumber :: Semiring Number where\n  add = numAdd\n  zero = 0.0\n  mul = numMul\n  one = 1.0\n\ninstance semiringFn :: Semiring b => Semiring (a -> b) where\n  add f g x = f x + g x\n  zero = \\_ -> zero\n  mul f g x = f x * g x\n  one = \\_ -> one\n\ninstance semiringUnit :: Semiring Unit where\n  add _ _ = unit\n  zero = unit\n  mul _ _ = unit\n  one = unit\n\ninstance semiringProxy :: Semiring (Proxy a) where\n  add _ _ = Proxy\n  mul _ _ = Proxy\n  one = Proxy\n  zero = Proxy\n\ninstance semiringRecord :: (RL.RowToList row list, SemiringRecord list row row) => Semiring (Record row) where\n  add = addRecord (Proxy :: Proxy list)\n  mul = mulRecord (Proxy :: Proxy list)\n  one = oneRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  zero = zeroRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n\nforeign import intAdd :: Int -> Int -> Int\nforeign import intMul :: Int -> Int -> Int\nforeign import numAdd :: Number -> Number -> Number\nforeign import numMul :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Semiring` instances, used to\n-- | implement the `Semiring` instance for records.\nclass SemiringRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow | rowlist -> subrow where\n  addRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  mulRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  oneRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  zeroRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance semiringRecordNil :: SemiringRecord RL.Nil row () where\n  addRecord _ _ _ = {}\n  mulRecord _ _ _ = {}\n  oneRecord _ _ = {}\n  zeroRecord _ _ = {}\n\ninstance semiringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemiringRecord rowlistTail row subrowTail\n  , Semiring focus\n  ) =>\n  SemiringRecord (RL.Cons key focus rowlistTail) row subrow where\n  addRecord _ ra rb = insert (get ra + get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = addRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  mulRecord _ ra rb = insert (get ra * get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = mulRecord (Proxy :: Proxy rowlistTail) ra rb\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  oneRecord _ _ = insert one tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = oneRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  zeroRecord _ _ = insert zero tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    tail = zeroRecord (Proxy :: Proxy rowlistTail) (Proxy :: Proxy row)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n","module Data.Ring\n  ( class Ring\n  , sub\n  , negate\n  , (-)\n  , module Data.Semiring\n  , class RingRecord\n  , subRecord\n  ) where\n\nimport Data.Semiring (class Semiring, class SemiringRecord, add, mul, one, zero, (*), (+))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ring` class is for types that support addition, multiplication,\n-- | and subtraction operations.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Semiring`\n-- | laws:\n-- |\n-- | - Additive inverse: `a - a = zero`\n-- | - Compatibility of `sub` and `negate`: `a - b = a + (zero - b)`\nclass Semiring a <= Ring a where\n  sub :: a -> a -> a\n\ninfixl 6 sub as -\n\ninstance ringInt :: Ring Int where\n  sub = intSub\n\ninstance ringNumber :: Ring Number where\n  sub = numSub\n\ninstance ringUnit :: Ring Unit where\n  sub _ _ = unit\n\ninstance ringFn :: Ring b => Ring (a -> b) where\n  sub f g x = f x - g x\n\ninstance ringProxy :: Ring (Proxy a) where\n  sub _ _ = Proxy\n\ninstance ringRecord :: (RL.RowToList row list, RingRecord list row row) => Ring (Record row) where\n  sub = subRecord (Proxy :: Proxy list)\n\n-- | `negate x` can be used as a shorthand for `zero - x`.\nnegate :: forall a. Ring a => a -> a\nnegate a = zero - a\n\nforeign import intSub :: Int -> Int -> Int\nforeign import numSub :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Ring` instances, used to\n-- | implement the `Ring` instance for records.\nclass RingRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemiringRecord rowlist row subrow <= RingRecord rowlist row subrow | rowlist -> subrow where\n  subRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance ringRecordNil :: RingRecord RL.Nil row () where\n  subRecord _ _ _ = {}\n\ninstance ringRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , RingRecord rowlistTail row subrowTail\n  , Ring focus\n  ) =>\n  RingRecord (RL.Cons key focus rowlistTail) row subrow where\n  subRecord _ ra rb = insert (get ra - get rb) tail\n    where\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = subRecord (Proxy :: Proxy rowlistTail) ra rb\n","module Data.Ord\n  ( class Ord\n  , compare\n  , class Ord1\n  , compare1\n  , lessThan\n  , (<)\n  , lessThanOrEq\n  , (<=)\n  , greaterThan\n  , (>)\n  , greaterThanOrEq\n  , (>=)\n  , comparing\n  , min\n  , max\n  , clamp\n  , between\n  , abs\n  , signum\n  , module Data.Ordering\n  , class OrdRecord\n  , compareRecord\n  ) where\n\nimport Data.Eq (class Eq, class Eq1, class EqRecord, (/=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Ordering (Ordering(..))\nimport Data.Ring (class Ring, zero, one, negate)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ord` type class represents types which support comparisons with a\n-- | _total order_.\n-- |\n-- | `Ord` instances should satisfy the laws of total orderings:\n-- |\n-- | - Reflexivity: `a <= a`\n-- | - Antisymmetry: if `a <= b` and `b <= a` then `a == b`\n-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN <= NaN` evaluates to `false`\nclass Eq a <= Ord a where\n  compare :: a -> a -> Ordering\n\ninstance ordBoolean :: Ord Boolean where\n  compare = ordBooleanImpl LT EQ GT\n\ninstance ordInt :: Ord Int where\n  compare = ordIntImpl LT EQ GT\n\ninstance ordNumber :: Ord Number where\n  compare = ordNumberImpl LT EQ GT\n\ninstance ordString :: Ord String where\n  compare = ordStringImpl LT EQ GT\n\ninstance ordChar :: Ord Char where\n  compare = ordCharImpl LT EQ GT\n\ninstance ordUnit :: Ord Unit where\n  compare _ _ = EQ\n\ninstance ordVoid :: Ord Void where\n  compare _ _ = EQ\n\ninstance ordProxy :: Ord (Proxy a) where\n  compare _ _ = EQ\n\ninstance ordArray :: Ord a => Ord (Array a) where\n  compare = \\xs ys -> compare 0 (ordArrayImpl toDelta xs ys)\n    where\n    toDelta x y =\n      case compare x y of\n        EQ -> 0\n        LT -> 1\n        GT -> -1\n\nforeign import ordBooleanImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Boolean\n  -> Boolean\n  -> Ordering\n\nforeign import ordIntImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Int\n  -> Int\n  -> Ordering\n\nforeign import ordNumberImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Number\n  -> Number\n  -> Ordering\n\nforeign import ordStringImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\nforeign import ordCharImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Char\n  -> Char\n  -> Ordering\n\nforeign import ordArrayImpl :: forall a. (a -> a -> Int) -> Array a -> Array a -> Int\n\ninstance ordOrdering :: Ord Ordering where\n  compare LT LT = EQ\n  compare EQ EQ = EQ\n  compare GT GT = EQ\n  compare LT _ = LT\n  compare EQ LT = GT\n  compare EQ GT = LT\n  compare GT _ = GT\n\n-- | Test whether one value is _strictly less than_ another.\nlessThan :: forall a. Ord a => a -> a -> Boolean\nlessThan a1 a2 = case a1 `compare` a2 of\n  LT -> true\n  _ -> false\n\n-- | Test whether one value is _strictly greater than_ another.\ngreaterThan :: forall a. Ord a => a -> a -> Boolean\ngreaterThan a1 a2 = case a1 `compare` a2 of\n  GT -> true\n  _ -> false\n\n-- | Test whether one value is _non-strictly less than_ another.\nlessThanOrEq :: forall a. Ord a => a -> a -> Boolean\nlessThanOrEq a1 a2 = case a1 `compare` a2 of\n  GT -> false\n  _ -> true\n\n-- | Test whether one value is _non-strictly greater than_ another.\ngreaterThanOrEq :: forall a. Ord a => a -> a -> Boolean\ngreaterThanOrEq a1 a2 = case a1 `compare` a2 of\n  LT -> false\n  _ -> true\n\ninfixl 4 lessThan as <\ninfixl 4 lessThanOrEq as <=\ninfixl 4 greaterThan as >\ninfixl 4 greaterThanOrEq as >=\n\n-- | Compares two values by mapping them to a type with an `Ord` instance.\ncomparing :: forall a b. Ord b => (a -> b) -> (a -> a -> Ordering)\ncomparing f x y = compare (f x) (f y)\n\n-- | Take the minimum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmin :: forall a. Ord a => a -> a -> a\nmin x y =\n  case compare x y of\n    LT -> x\n    EQ -> x\n    GT -> y\n\n-- | Take the maximum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmax :: forall a. Ord a => a -> a -> a\nmax x y =\n  case compare x y of\n    LT -> y\n    EQ -> x\n    GT -> x\n\n-- | Clamp a value between a minimum and a maximum. For example:\n-- |\n-- | ``` purescript\n-- | let f = clamp 0 10\n-- | f (-5) == 0\n-- | f 5    == 5\n-- | f 15   == 10\n-- | ```\nclamp :: forall a. Ord a => a -> a -> a -> a\nclamp low hi x = min hi (max low x)\n\n-- | Test whether a value is between a minimum and a maximum (inclusive).\n-- | For example:\n-- |\n-- | ``` purescript\n-- | let f = between 0 10\n-- | f 0    == true\n-- | f (-5) == false\n-- | f 5    == true\n-- | f 10   == true\n-- | f 15   == false\n-- | ```\nbetween :: forall a. Ord a => a -> a -> a -> Boolean\nbetween low hi x\n  | x < low = false\n  | x > hi = false\n  | true = true\n\n-- | The absolute value function. `abs x` is defined as `if x >= zero then x\n-- | else negate x`.\nabs :: forall a. Ord a => Ring a => a -> a\nabs x = if x >= zero then x else negate x\n\n-- | The sign function; returns `one` if the argument is positive,\n-- | `negate one` if the argument is negative, or `zero` if the argument is `zero`.\n-- | For floating point numbers with signed zeroes, when called with a zero,\n-- | this function returns the argument in order to preserve the sign.\n-- | For any `x`, we should have `signum x * abs x == x`.\nsignum :: forall a. Ord a => Ring a => a -> a\nsignum x =\n  if x < zero then negate one\n  else if x > zero then one\n  else x\n\n-- | The `Ord1` type class represents totally ordered type constructors.\nclass Eq1 f <= Ord1 f where\n  compare1 :: forall a. Ord a => f a -> f a -> Ordering\n\ninstance ord1Array :: Ord1 Array where\n  compare1 = compare\n\nclass OrdRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row <= OrdRecord rowlist row where\n  compareRecord :: Proxy rowlist -> Record row -> Record row -> Ordering\n\ninstance ordRecordNil :: OrdRecord RL.Nil row where\n  compareRecord _ _ _ = EQ\n\ninstance ordRecordCons ::\n  ( OrdRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Ord focus\n  ) =>\n  OrdRecord (RL.Cons key focus rowlistTail) row where\n  compareRecord _ ra rb =\n    if left /= EQ then left\n    else compareRecord (Proxy :: Proxy rowlistTail) ra rb\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    unsafeGet' = unsafeGet :: String -> Record row -> focus\n    left = unsafeGet' key ra `compare` unsafeGet' key rb\n\ninstance ordRecord ::\n  ( RL.RowToList row list\n  , OrdRecord list row\n  ) =>\n  Ord (Record row) where\n  compare = compareRecord (Proxy :: Proxy list)\n","module Data.Bounded\n  ( class Bounded\n  , bottom\n  , top\n  , module Data.Ord\n  , class BoundedRecord\n  , bottomRecord\n  , topRecord\n  ) where\n\nimport Data.Ord (class Ord, class OrdRecord, Ordering(..), compare, (<), (<=), (>), (>=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bounded` type class represents totally ordered types that have an\n-- | upper and lower boundary.\n-- |\n-- | Instances should satisfy the following law in addition to the `Ord` laws:\n-- |\n-- | - Bounded: `bottom <= a <= top`\nclass Ord a <= Bounded a where\n  top :: a\n  bottom :: a\n\ninstance boundedBoolean :: Bounded Boolean where\n  top = true\n  bottom = false\n\n-- | The `Bounded` `Int` instance has `top :: Int` equal to 2^31 - 1,\n-- | and `bottom :: Int` equal to -2^31, since these are the largest and smallest\n-- | integers representable by twos-complement 32-bit integers, respectively.\ninstance boundedInt :: Bounded Int where\n  top = topInt\n  bottom = bottomInt\n\nforeign import topInt :: Int\nforeign import bottomInt :: Int\n\n-- | Characters fall within the Unicode range.\ninstance boundedChar :: Bounded Char where\n  top = topChar\n  bottom = bottomChar\n\nforeign import topChar :: Char\nforeign import bottomChar :: Char\n\ninstance boundedOrdering :: Bounded Ordering where\n  top = GT\n  bottom = LT\n\ninstance boundedUnit :: Bounded Unit where\n  top = unit\n  bottom = unit\n\nforeign import topNumber :: Number\nforeign import bottomNumber :: Number\n\ninstance boundedNumber :: Bounded Number where\n  top = topNumber\n  bottom = bottomNumber\n\ninstance boundedProxy :: Bounded (Proxy a) where\n  bottom = Proxy\n  top = Proxy\n\nclass BoundedRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass OrdRecord rowlist row <= BoundedRecord rowlist row subrow | rowlist -> subrow where\n  topRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  bottomRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance boundedRecordNil :: BoundedRecord RL.Nil row () where\n  topRecord _ _ = {}\n  bottomRecord _ _ = {}\n\ninstance boundedRecordCons ::\n  ( IsSymbol key\n  , Bounded focus\n  , Row.Cons key focus rowTail row\n  , Row.Cons key focus subrowTail subrow\n  , BoundedRecord rowlistTail row subrowTail\n  ) =>\n  BoundedRecord (RL.Cons key focus rowlistTail) row subrow where\n  topRecord _ rowProxy = insert top tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = topRecord (Proxy :: Proxy rowlistTail) rowProxy\n\n  bottomRecord _ rowProxy = insert bottom tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = bottomRecord (Proxy :: Proxy rowlistTail) rowProxy\n\ninstance boundedRecord ::\n  ( RL.RowToList row list\n  , BoundedRecord list row row\n  ) =>\n  Bounded (Record row) where\n  top = topRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  bottom = bottomRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n","export const showIntImpl = function (n) {\n  return n.toString();\n};\n\nexport const showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexport const showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexport const showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexport const showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n","module Data.Show\n  ( class Show\n  , show\n  , class ShowRecordFields\n  , showRecordFields\n  ) where\n\nimport Data.Semigroup ((<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row (class Nub)\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Show` type class represents those types which can be converted into\n-- | a human-readable `String` representation.\n-- |\n-- | While not required, it is recommended that for any expression `x`, the\n-- | string `show x` be executable PureScript code which evaluates to the same\n-- | value as the expression `x`.\nclass Show a where\n  show :: a -> String\n\ninstance showUnit :: Show Unit where\n  show _ = \"unit\"\n\ninstance showBoolean :: Show Boolean where\n  show true = \"true\"\n  show false = \"false\"\n\ninstance showInt :: Show Int where\n  show = showIntImpl\n\ninstance showNumber :: Show Number where\n  show = showNumberImpl\n\ninstance showChar :: Show Char where\n  show = showCharImpl\n\ninstance showString :: Show String where\n  show = showStringImpl\n\ninstance showArray :: Show a => Show (Array a) where\n  show = showArrayImpl show\n\ninstance showProxy :: Show (Proxy a) where\n  show _ = \"Proxy\"\n\ninstance showVoid :: Show Void where\n  show = absurd\n\ninstance showRecord ::\n  ( Nub rs rs\n  , RL.RowToList rs ls\n  , ShowRecordFields ls rs\n  ) =>\n  Show (Record rs) where\n  show record = \"{\" <> showRecordFields (Proxy :: Proxy ls) record <> \"}\"\n\n-- | A class for records where all fields have `Show` instances, used to\n-- | implement the `Show` instance for records.\nclass ShowRecordFields :: RL.RowList Type -> Row Type -> Constraint\nclass ShowRecordFields rowlist row where\n  showRecordFields :: Proxy rowlist -> Record row -> String\n\ninstance showRecordFieldsNil :: ShowRecordFields RL.Nil row where\n  showRecordFields _ _ = \"\"\nelse\ninstance showRecordFieldsConsNil ::\n  ( IsSymbol key\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus RL.Nil) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \" \"\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\nelse\ninstance showRecordFieldsCons ::\n  ( IsSymbol key\n  , ShowRecordFields rowlistTail row\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus rowlistTail) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \",\" <> tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\n    tail = showRecordFields (Proxy :: Proxy rowlistTail) record\n\nforeign import showIntImpl :: Int -> String\nforeign import showNumberImpl :: Number -> String\nforeign import showCharImpl :: Char -> String\nforeign import showStringImpl :: String -> String\nforeign import showArrayImpl :: forall a. (a -> String) -> Array a -> String\n","module Data.Generic.Rep\n  ( class Generic\n  , to\n  , from\n  , repOf\n  , NoConstructors\n  , NoArguments(..)\n  , Sum(..)\n  , Product(..)\n  , Constructor(..)\n  , Argument(..)\n  ) where\n\nimport Data.Semigroup ((<>))\nimport Data.Show (class Show, show)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Void (Void)\nimport Type.Proxy (Proxy(..))\n\n-- | A representation for types with no constructors.\nnewtype NoConstructors = NoConstructors Void\n\n-- | A representation for constructors with no arguments.\ndata NoArguments = NoArguments\n\ninstance showNoArguments :: Show NoArguments where\n  show _ = \"NoArguments\"\n\n-- | A representation for types with multiple constructors.\ndata Sum a b = Inl a | Inr b\n\ninstance showSum :: (Show a, Show b) => Show (Sum a b) where\n  show (Inl a) = \"(Inl \" <> show a <> \")\"\n  show (Inr b) = \"(Inr \" <> show b <> \")\"\n\n-- | A representation for constructors with multiple fields.\ndata Product a b = Product a b\n\ninstance showProduct :: (Show a, Show b) => Show (Product a b) where\n  show (Product a b) = \"(Product \" <> show a <> \" \" <> show b <> \")\"\n\n-- | A representation for constructors which includes the data constructor name\n-- | as a type-level string.\nnewtype Constructor (name :: Symbol) a = Constructor a\n\ninstance showConstructor :: (IsSymbol name, Show a) => Show (Constructor name a) where\n  show (Constructor a) = \"(Constructor @\" <> show (reflectSymbol (Proxy :: Proxy name)) <> \" \" <> show a <> \")\"\n\n-- | A representation for an argument in a data constructor.\nnewtype Argument a = Argument a\n\ninstance showArgument :: Show a => Show (Argument a) where\n  show (Argument a) = \"(Argument \" <> show a <> \")\"\n\n-- | The `Generic` class asserts the existence of a type function from types\n-- | to their representations using the type constructors defined in this module.\nclass Generic a rep | a -> rep where\n  to :: rep -> a\n  from :: a -> rep\n\nrepOf :: forall a rep. Generic a rep => Proxy a -> Proxy rep\nrepOf _ = Proxy\n","module Data.Maybe where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Ord (class Ord1)\n\n-- | The `Maybe` type is used to represent optional values and can be seen as\n-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`\n-- | is the non-null value `x`.\ndata Maybe a = Nothing | Just a\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Just` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing == Nothing\n-- | ```\ninstance functorMaybe :: Functor Maybe where\n  map fn (Just x) = Just (fn x)\n  map _  _        = Nothing\n\n-- | The `Apply` instance allows functions contained within a `Just` to\n-- | transform a value contained within a `Just` using the `apply` operator:\n-- |\n-- | ``` purescript\n-- | Just f <*> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Just f <*> Nothing == Nothing\n-- | Nothing <*> Just x == Nothing\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a\n-- | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Maybe a -> Maybe b -> Maybe c`:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> Just y == Just (f x y)\n-- | ```\n-- |\n-- | The `Nothing`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Nothing`\n-- | means the whole result becomes `Nothing` also:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing <*> Just y == Nothing\n-- | f <$> Just x <*> Nothing == Nothing\n-- | f <$> Nothing <*> Nothing == Nothing\n-- | ```\ninstance applyMaybe :: Apply Maybe where\n  apply (Just fn) x = fn <$> x\n  apply Nothing   _ = Nothing\n\n-- | The `Applicative` instance enables lifting of values into `Maybe` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Maybe _ == Just x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Maybe` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> pure y == Just (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Just` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Just` with a new constructor.\ninstance applicativeMaybe :: Applicative Maybe where\n  pure = Just\n\n-- | The `Alt` instance allows for a choice to be made between two `Maybe`\n-- | values with the `<|>` operator, where the first `Just` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Just x <|> Just y == Just x\n-- | Nothing <|> Just y == Just y\n-- | Nothing <|> Nothing == Nothing\n-- | ```\ninstance altMaybe :: Alt Maybe where\n  alt Nothing r = r\n  alt l       _ = l\n\n-- | The `Plus` instance provides a default `Maybe` value:\n-- |\n-- | ``` purescript\n-- | empty :: Maybe _ == Nothing\n-- | ```\ninstance plusMaybe :: Plus Maybe where\n  empty = Nothing\n\n-- | The `Alternative` instance guarantees that there are both `Applicative` and\n-- | `Plus` instances for `Maybe`.\ninstance alternativeMaybe :: Alternative Maybe\n\n-- | The `Bind` instance allows sequencing of `Maybe` values and functions that\n-- | return a `Maybe` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Just x >>= f = f x\n-- | Nothing >>= f = Nothing\n-- | ```\ninstance bindMaybe :: Bind Maybe where\n  bind (Just x) k = k x\n  bind Nothing  _ = Nothing\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | case x of\n-- |   Nothing -> Nothing\n-- |   Just x' -> case y of\n-- |     Nothing -> Nothing\n-- |     Just y' -> Just (f x' y')\n-- | ```\ninstance monadMaybe :: Monad Maybe\n\n-- | The `Extend` instance allows sequencing of `Maybe` values and functions\n-- | that accept a `Maybe a` and return a non-`Maybe` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Nothing = Nothing\n-- | f <<= x = Just (f x)\n-- | ```\ninstance extendMaybe :: Extend Maybe where\n  extend _ Nothing  = Nothing\n  extend f x        = Just (f x)\n\ninstance invariantMaybe :: Invariant Maybe where\n  imap = imapF\n\n-- | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values\n-- | whenever there is a `Semigroup` instance for the type the `Maybe` contains.\n-- | The exact behaviour of `<>` depends on the \"inner\" `Semigroup` instance,\n-- | but generally captures the notion of appending or combining things.\n-- |\n-- | ``` purescript\n-- | Just x <> Just y = Just (x <> y)\n-- | Just x <> Nothing = Just x\n-- | Nothing <> Just y = Just y\n-- | Nothing <> Nothing = Nothing\n-- | ```\ninstance semigroupMaybe :: Semigroup a => Semigroup (Maybe a) where\n  append Nothing y = y\n  append x Nothing = x\n  append (Just x) (Just y) = Just (x <> y)\n\ninstance monoidMaybe :: Semigroup a => Monoid (Maybe a) where\n  mempty = Nothing\n\ninstance semiringMaybe :: Semiring a => Semiring (Maybe a) where\n  zero = Nothing\n  one = Just one\n\n  add Nothing y = y\n  add x Nothing = x\n  add (Just x) (Just y) = Just (add x y)\n\n  mul x y = mul <$> x <*> y\n\n-- | The `Eq` instance allows `Maybe` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for the\n-- | type the `Maybe` contains.\nderive instance eqMaybe :: Eq a => Eq (Maybe a)\n\ninstance eq1Maybe :: Eq1 Maybe where eq1 = eq\n\n-- | The `Ord` instance allows `Maybe` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | the type the `Maybe` contains.\n-- |\n-- | `Nothing` is considered to be less than any `Just` value.\nderive instance ordMaybe :: Ord a => Ord (Maybe a)\n\ninstance ord1Maybe :: Ord1 Maybe where compare1 = compare\n\ninstance boundedMaybe :: Bounded a => Bounded (Maybe a) where\n  top = Just top\n  bottom = Nothing\n\n-- | The `Show` instance allows `Maybe` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for the type the `Maybe`\n-- | contains.\ninstance showMaybe :: Show a => Show (Maybe a) where\n  show (Just x) = \"(Just \" <> show x <> \")\"\n  show Nothing  = \"Nothing\"\n\nderive instance genericMaybe :: Generic (Maybe a) _\n\n-- | Takes a default value, a function, and a `Maybe` value. If the `Maybe`\n-- | value is `Nothing` the default value is returned, otherwise the function\n-- | is applied to the value inside the `Just` and the result is returned.\n-- |\n-- | ``` purescript\n-- | maybe x f Nothing == x\n-- | maybe x f (Just y) == f y\n-- | ```\nmaybe :: forall a b. b -> (a -> b) -> Maybe a -> b\nmaybe b _ Nothing = b\nmaybe _ f (Just a) = f a\n\n-- | Similar to `maybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `maybe` has\n-- | to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | maybe' (\\_ -> x) f Nothing == x\n-- | maybe' (\\_ -> x) f (Just y) == f y\n-- | ```\nmaybe' :: forall a b. (Unit -> b) -> (a -> b) -> Maybe a -> b\nmaybe' g _ Nothing = g unit\nmaybe' _ f (Just a) = f a\n\n-- | Takes a default value, and a `Maybe` value. If the `Maybe` value is\n-- | `Nothing` the default value is returned, otherwise the value inside the\n-- | `Just` is returned.\n-- |\n-- | ``` purescript\n-- | fromMaybe x Nothing == x\n-- | fromMaybe x (Just y) == y\n-- | ```\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe a = maybe a identity\n\n-- | Similar to `fromMaybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`\n-- | has to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | fromMaybe' (\\_ -> x) Nothing == x\n-- | fromMaybe' (\\_ -> x) (Just y) == y\n-- | ```\nfromMaybe' :: forall a. (Unit -> a) -> Maybe a -> a\nfromMaybe' a = maybe' a identity\n\n-- | Returns `true` when the `Maybe` value was constructed with `Just`.\nisJust :: forall a. Maybe a -> Boolean\nisJust = maybe false (const true)\n\n-- | Returns `true` when the `Maybe` value is `Nothing`.\nisNothing :: forall a. Maybe a -> Boolean\nisNothing = maybe true (const false)\n\n-- | A partial function that extracts the value from the `Just` data\n-- | constructor. Passing `Nothing` to `fromJust` will throw an error at\n-- | runtime.\nfromJust :: forall a. Partial => Maybe a -> a\nfromJust (Just x) = x\n\n-- | One or none.\n-- |\n-- | ```purescript\n-- | optional empty = pure Nothing\n-- | ```\n-- |\n-- | The behaviour of `optional (pure x)` depends on whether the `Alt` instance\n-- | satisfy the left catch law (`pure a <|> b = pure a`).\n-- |\n-- | `Either e` does:\n-- |\n-- | ```purescript\n-- | optional (Right x) = Right (Just x)\n-- | ```\n-- |\n-- | But `Array` does not:\n-- |\n-- | ```purescript\n-- | optional [x] = [Just x, Nothing]\n-- | ```\noptional :: forall f a. Alt f => Applicative f => f a -> f (Maybe a)\noptional a = map Just a <|> pure Nothing\n","module Data.Either where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Extend (class Extend)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..), maybe, maybe')\nimport Data.Ord (class Ord1)\n\n-- | The `Either` type is used to represent a choice between two types of value.\n-- |\n-- | A common use case for `Either` is error handling, where `Left` is used to\n-- | carry an error value and `Right` is used to carry a success value.\ndata Either a b = Left a | Right b\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Right` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Left y == Left y\n-- | ```\nderive instance functorEither :: Functor (Either a)\n\nderive instance genericEither :: Generic (Either a b) _\n\ninstance invariantEither :: Invariant (Either a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions contained within a `Right` to\n-- | transform a value contained within a `Right` using the `(<*>)` operator:\n-- |\n-- | ``` purescript\n-- | Right f <*> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Left f <*> Right x == Left f\n-- | Right f <*> Left y == Left y\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a\n-- | pure function to take `Either`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Either l a -> Either l b -> Either l c`:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> Right y == Right (f x y)\n-- | ```\n-- |\n-- | The `Left`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Left`\n-- | means the whole result becomes `Left` also, taking the first `Left` value\n-- | found:\n-- |\n-- | ``` purescript\n-- | f <$> Left x <*> Right y == Left x\n-- | f <$> Right x <*> Left y == Left y\n-- | f <$> Left x <*> Left y == Left x\n-- | ```\ninstance applyEither :: Apply (Either e) where\n  apply (Left e) _ = Left e\n  apply (Right f) r = f <$> r\n\n-- | The `Applicative` instance enables lifting of values into `Either` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Either _ _ == Right x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Either` and non-`Either` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Either` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> pure y == Right (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Right` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Right` with a new constructor.\ninstance applicativeEither :: Applicative (Either e) where\n  pure = Right\n\n-- | The `Alt` instance allows for a choice to be made between two `Either`\n-- | values with the `<|>` operator, where the first `Right` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Right x <|> Right y == Right x\n-- | Left x <|> Right y == Right y\n-- | Left x <|> Left y == Left y\n-- | ```\ninstance altEither :: Alt (Either e) where\n  alt (Left _) r = r\n  alt l        _ = l\n\n-- | The `Bind` instance allows sequencing of `Either` values and functions that\n-- | return an `Either` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Left x >>= f = Left x\n-- | Right x >>= f = f x\n-- | ```\n-- |\n-- | `Either`'s \"do notation\" can be understood to work like this:\n-- | ``` purescript\n-- | x :: forall e a. Either e a\n-- | x = --\n-- |\n-- | y :: forall e b. Either e b\n-- | y = --\n-- |\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | ...which is equivalent to...\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | ...and is the same as writing...\n-- |\n-- | ```\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = case x of\n-- |   Left e ->\n-- |     Left e\n-- |   Right x -> case y of\n-- |     Left e ->\n-- |       Left e\n-- |     Right y ->\n-- |       Right (f x y)\n-- | ```\ninstance bindEither :: Bind (Either e) where\n  bind = either (\\e _ -> Left e) (\\a f -> f a)\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Either`.\ninstance monadEither :: Monad (Either e)\n\n-- | The `Extend` instance allows sequencing of `Either` values and functions\n-- | that accept an `Either` and return a non-`Either` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Left x = Left x\n-- | f <<= Right x = Right (f (Right x))\n-- | ```\ninstance extendEither :: Extend (Either e) where\n  extend _ (Left y)  = Left y\n  extend f x         = Right (f x)\n\n-- | The `Show` instance allows `Either` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for both type the `Either` can\n-- | contain.\ninstance showEither :: (Show a, Show b) => Show (Either a b) where\n  show (Left x) = \"(Left \" <> show x <> \")\"\n  show (Right y) = \"(Right \" <> show y <> \")\"\n\n-- | The `Eq` instance allows `Either` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for both\n-- | types the `Either` can contain.\nderive instance eqEither :: (Eq a, Eq b) => Eq (Either a b)\n\nderive instance eq1Either :: Eq a => Eq1 (Either a)\n\n-- | The `Ord` instance allows `Either` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | both types the `Either` can contain.\n-- |\n-- | Any `Left` value is considered to be less than a `Right` value.\nderive instance ordEither :: (Ord a, Ord b) => Ord (Either a b)\n\nderive instance ord1Either :: Ord a => Ord1 (Either a)\n\ninstance boundedEither :: (Bounded a, Bounded b) => Bounded (Either a b) where\n  top = Right top\n  bottom = Left bottom\n\ninstance semigroupEither :: (Semigroup b) => Semigroup (Either a b) where\n  append x y = append <$> x <*> y\n\n-- | Takes two functions and an `Either` value, if the value is a `Left` the\n-- | inner value is applied to the first function, if the value is a `Right`\n-- | the inner value is applied to the second function.\n-- |\n-- | ``` purescript\n-- | either f g (Left x) == f x\n-- | either f g (Right y) == g y\n-- | ```\neither :: forall a b c. (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n-- | Combine two alternatives.\nchoose :: forall m a b. Alt m => m a -> m b -> m (Either a b)\nchoose a b = Left <$> a <|> Right <$> b\n\n-- | Returns `true` when the `Either` value was constructed with `Left`.\nisLeft :: forall a b. Either a b -> Boolean\nisLeft = either (const true) (const false)\n\n-- | Returns `true` when the `Either` value was constructed with `Right`.\nisRight :: forall a b. Either a b -> Boolean\nisRight = either (const false) (const true)\n\n-- | A function that extracts the value from the `Left` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Right` is passed to `fromLeft`.\nfromLeft :: forall a b. a -> Either a b -> a\nfromLeft _ (Left a) = a\nfromLeft default _ = default\n\n-- | Similar to `fromLeft` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromLeft`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Right`.\nfromLeft' :: forall a b. (Unit -> a) -> Either a b -> a\nfromLeft' _ (Left a) = a\nfromLeft' default _ = default unit\n\n-- | A function that extracts the value from the `Right` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Left` is passed to `fromRight`.\nfromRight :: forall a b. b -> Either a b -> b\nfromRight _ (Right b) = b\nfromRight default _ = default\n\n-- | Similar to `fromRight` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromRight`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Left`.\nfromRight' :: forall a b. (Unit -> b) -> Either a b -> b\nfromRight' _ (Right b) = b\nfromRight' default _ = default unit\n\n-- | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into\n-- | a `Right`, if the value is a `Nothing` use the provided default as a `Left`\n-- |\n-- | ```purescript\n-- | note \"default\" Nothing = Left \"default\"\n-- | note \"default\" (Just 1) = Right 1\n-- | ```\nnote :: forall a b. a -> Maybe b -> Either a b\nnote a = maybe (Left a) Right\n\n-- | Similar to `note`, but for use in cases where the default value may be\n-- | expensive to compute.\n-- |\n-- | ```purescript\n-- | note' (\\_ -> \"default\") Nothing = Left \"default\"\n-- | note' (\\_ -> \"default\") (Just 1) = Right 1\n-- | ```\nnote' :: forall a b. (Unit -> a) -> Maybe b -> Either a b\nnote' f = maybe' (Left <<< f) Right\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Left` values away and converting\n-- | them into `Nothing`. `Right` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | hush (Left \"ParseError\") = Nothing\n-- | hush (Right 42) = Just 42\n-- | ```\nhush :: forall a b. Either a b -> Maybe b\nhush = either (const Nothing) Just\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Right` values away and converting\n-- | them into `Nothing`. `Left` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | blush (Left \"ParseError\") = Just \"Parse Error\"\n-- | blush (Right 42) = Nothing\n-- | ```\nblush :: forall a b. Either a b -> Maybe a\nblush = either Just (const Nothing)\n","export const pureE = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bindE = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const untilE = function (f) {\n  return function () {\n    while (!f());\n  };\n};\n\nexport const whileE = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexport const forE = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexport const foreachE = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n","export const intDegree = function (x) {\n  return Math.min(Math.abs(x), 2147483647);\n};\n\n// See the Euclidean definition in\n// https://en.m.wikipedia.org/wiki/Modulo_operation.\nexport const intDiv = function (x) {\n  return function (y) {\n    if (y === 0) return 0;\n    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);\n  };\n};\n\nexport const intMod = function (x) {\n  return function (y) {\n    if (y === 0) return 0;\n    var yy = Math.abs(y);\n    return ((x % yy) + yy) % yy;\n  };\n};\n\nexport const numDiv = function (n1) {\n  return function (n2) {\n    return n1 / n2;\n  };\n};\n","module Data.CommutativeRing\n  ( class CommutativeRing\n  , module Data.Ring\n  , module Data.Semiring\n  , class CommutativeRingRecord\n  ) where\n\nimport Data.Ring (class Ring, class RingRecord)\nimport Data.Semiring (class Semiring, add, mul, one, zero, (*), (+))\nimport Data.Symbol (class IsSymbol)\nimport Data.Unit (Unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Type.Proxy (Proxy)\n\n-- | The `CommutativeRing` class is for rings where multiplication is\n-- | commutative.\n-- |\n-- | Instances must satisfy the following law in addition to the `Ring`\n-- | laws:\n-- |\n-- | - Commutative multiplication: `a * b = b * a`\nclass Ring a <= CommutativeRing a\n\ninstance commutativeRingInt :: CommutativeRing Int\ninstance commutativeRingNumber :: CommutativeRing Number\ninstance commutativeRingUnit :: CommutativeRing Unit\ninstance commutativeRingFn :: CommutativeRing b => CommutativeRing (a -> b)\ninstance commutativeRingRecord :: (RL.RowToList row list, CommutativeRingRecord list row row) => CommutativeRing (Record row)\ninstance commutativeRingProxy :: CommutativeRing (Proxy a)\n\n-- | A class for records where all fields have `CommutativeRing` instances, used\n-- | to implement the `CommutativeRing` instance for records.\nclass RingRecord rowlist row subrow <= CommutativeRingRecord rowlist row subrow | rowlist -> subrow\n\ninstance commutativeRingRecordNil :: CommutativeRingRecord RL.Nil row ()\n\ninstance commutativeRingRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , CommutativeRingRecord rowlistTail row subrowTail\n  , CommutativeRing focus\n  ) =>\n  CommutativeRingRecord (RL.Cons key focus rowlistTail) row subrow\n","module Data.EuclideanRing\n  ( class EuclideanRing\n  , degree\n  , div\n  , mod\n  , (/)\n  , gcd\n  , lcm\n  , module Data.CommutativeRing\n  , module Data.Ring\n  , module Data.Semiring\n  ) where\n\nimport Data.BooleanAlgebra ((||))\nimport Data.CommutativeRing (class CommutativeRing)\nimport Data.Eq (class Eq, (==))\nimport Data.Ring (class Ring, sub, (-))\nimport Data.Semiring (class Semiring, add, mul, one, zero, (*), (+))\n\n-- | The `EuclideanRing` class is for commutative rings that support division.\n-- | The mathematical structure this class is based on is sometimes also called\n-- | a *Euclidean domain*.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Ring`\n-- | laws:\n-- |\n-- | - Integral domain: `one /= zero`, and if `a` and `b` are both nonzero then\n-- |   so is their product `a * b`\n-- | - Euclidean function `degree`:\n-- |   - Nonnegativity: For all nonzero `a`, `degree a >= 0`\n-- |   - Quotient/remainder: For all `a` and `b`, where `b` is nonzero,\n-- |     let `q = a / b` and ``r = a `mod` b``; then `a = q*b + r`, and also\n-- |     either `r = zero` or `degree r < degree b`\n-- | - Submultiplicative euclidean function:\n-- |   - For all nonzero `a` and `b`, `degree a <= degree (a * b)`\n-- |\n-- | The behaviour of division by `zero` is unconstrained by these laws,\n-- | meaning that individual instances are free to choose how to behave in this\n-- | case. Similarly, there are no restrictions on what the result of\n-- | `degree zero` is; it doesn't make sense to ask for `degree zero` in the\n-- | same way that it doesn't make sense to divide by `zero`, so again,\n-- | individual instances may choose how to handle this case.\n-- |\n-- | For any `EuclideanRing` which is also a `Field`, one valid choice\n-- | for `degree` is simply `const 1`. In fact, unless there's a specific\n-- | reason not to, `Field` types should normally use this definition of\n-- | `degree`.\n-- |\n-- | The `EuclideanRing Int` instance is one of the most commonly used\n-- | `EuclideanRing` instances and deserves a little more discussion. In\n-- | particular, there are a few different sensible law-abiding implementations\n-- | to choose from, with slightly different behaviour in the presence of\n-- | negative dividends or divisors. The most common definitions are \"truncating\"\n-- | division, where the result of `a / b` is rounded towards 0, and \"Knuthian\"\n-- | or \"flooring\" division, where the result of `a / b` is rounded towards\n-- | negative infinity. A slightly less common, but arguably more useful, option\n-- | is \"Euclidean\" division, which is defined so as to ensure that ``a `mod` b``\n-- | is always nonnegative. With Euclidean division, `a / b` rounds towards\n-- | negative infinity if the divisor is positive, and towards positive infinity\n-- | if the divisor is negative. Note that all three definitions are identical if\n-- | we restrict our attention to nonnegative dividends and divisors.\n-- |\n-- | In versions 1.x, 2.x, and 3.x of the Prelude, the `EuclideanRing Int`\n-- | instance used truncating division. As of 4.x, the `EuclideanRing Int`\n-- | instance uses Euclidean division. Additional functions `quot` and `rem` are\n-- | supplied if truncating division is desired.\nclass CommutativeRing a <= EuclideanRing a where\n  degree :: a -> Int\n  div :: a -> a -> a\n  mod :: a -> a -> a\n\ninfixl 7 div as /\n\ninstance euclideanRingInt :: EuclideanRing Int where\n  degree = intDegree\n  div = intDiv\n  mod = intMod\n\ninstance euclideanRingNumber :: EuclideanRing Number where\n  degree _ = 1\n  div = numDiv\n  mod _ _ = 0.0\n\nforeign import intDegree :: Int -> Int\nforeign import intDiv :: Int -> Int -> Int\nforeign import intMod :: Int -> Int -> Int\n\nforeign import numDiv :: Number -> Number -> Number\n\n-- | The *greatest common divisor* of two values.\ngcd :: forall a. Eq a => EuclideanRing a => a -> a -> a\ngcd a b =\n  if b == zero then a\n  else gcd b (a `mod` b)\n\n-- | The *least common multiple* of two values.\nlcm :: forall a. Eq a => EuclideanRing a => a -> a -> a\nlcm a b =\n  if a == zero || b == zero then zero\n  else a * b / gcd a b\n","module Data.Monoid\n  ( class Monoid\n  , mempty\n  , power\n  , guard\n  , module Data.Semigroup\n  , class MonoidRecord\n  , memptyRecord\n  ) where\n\nimport Data.Boolean (otherwise)\nimport Data.Eq ((==))\nimport Data.EuclideanRing (mod, (/))\nimport Data.Ord ((<=))\nimport Data.Ordering (Ordering(..))\nimport Data.Semigroup (class Semigroup, class SemigroupRecord, (<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a\n-- | left and right unit for the associative operation `<>`:\n-- |\n-- | - Left unit: `(mempty <> x) = x`\n-- | - Right unit: `(x <> mempty) = x`\n-- |\n-- | `Monoid`s are commonly used as the result of fold operations, where\n-- | `<>` is used to combine individual results, and `mempty` gives the result\n-- | of folding an empty collection of elements.\n-- |\n-- | ### Newtypes for Monoid\n-- |\n-- | Some types (e.g. `Int`, `Boolean`) can implement multiple law-abiding\n-- | instances for `Monoid`. Let's use `Int` as an example\n-- | 1. `<>` could be `+` and `mempty` could be `0`\n-- | 2. `<>` could be `*` and `mempty` could be `1`.\n-- |\n-- | To clarify these ambiguous situations, one should use the newtypes\n-- | defined in `Data.Monoid.<NewtypeName>` modules.\n-- |\n-- | In the above ambiguous situation, we could use `Additive`\n-- | for the first situation or `Multiplicative` for the second one.\nclass Semigroup m <= Monoid m where\n  mempty :: m\n\ninstance monoidUnit :: Monoid Unit where\n  mempty = unit\n\ninstance monoidOrdering :: Monoid Ordering where\n  mempty = EQ\n\ninstance monoidFn :: Monoid b => Monoid (a -> b) where\n  mempty _ = mempty\n\ninstance monoidString :: Monoid String where\n  mempty = \"\"\n\ninstance monoidArray :: Monoid (Array a) where\n  mempty = []\n\ninstance monoidRecord :: (RL.RowToList row list, MonoidRecord list row row) => Monoid (Record row) where\n  mempty = memptyRecord (Proxy :: Proxy list)\n\n-- | Append a value to itself a certain number of times. For the\n-- | `Multiplicative` type, and for a non-negative power, this is the same as\n-- | normal number exponentiation.\n-- |\n-- | If the second argument is negative this function will return `mempty`\n-- | (*unlike* normal number exponentiation). The `Monoid` constraint alone\n-- | is not enough to write a `power` function with the property that `power x\n-- | n` cancels with `power x (-n)`, i.e. `power x n <> power x (-n) = mempty`.\n-- | For that, we would additionally need the ability to invert elements, i.e.\n-- | a Group.\n-- |\n-- | ```purescript\n-- | power [1,2] 3    == [1,2,1,2,1,2]\n-- | power [1,2] 1    == [1,2]\n-- | power [1,2] 0    == []\n-- | power [1,2] (-3) == []\n-- | ```\n-- |\npower :: forall m. Monoid m => m -> Int -> m\npower x = go\n  where\n  go :: Int -> m\n  go p\n    | p <= 0 = mempty\n    | p == 1 = x\n    | p `mod` 2 == 0 = let x' = go (p / 2) in x' <> x'\n    | otherwise = let x' = go (p / 2) in x' <> x' <> x\n\n-- | Allow or \"truncate\" a Monoid to its `mempty` value based on a condition.\nguard :: forall m. Monoid m => Boolean -> m -> m\nguard true a = a\nguard false _ = mempty\n\n-- | A class for records where all fields have `Monoid` instances, used to\n-- | implement the `Monoid` instance for records.\nclass MonoidRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow <= MonoidRecord rowlist row subrow | rowlist -> row subrow where\n  memptyRecord :: Proxy rowlist -> Record subrow\n\ninstance monoidRecordNil :: MonoidRecord RL.Nil row () where\n  memptyRecord _ = {}\n\ninstance monoidRecordCons ::\n  ( IsSymbol key\n  , Monoid focus\n  , Row.Cons key focus subrowTail subrow\n  , MonoidRecord rowlistTail row subrowTail\n  ) =>\n  MonoidRecord (RL.Cons key focus rowlistTail) row subrow where\n  memptyRecord _ = insert mempty tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = memptyRecord (Proxy :: Proxy rowlistTail)\n","-- | This module provides the `Effect` type, which is used to represent\n-- | _native_ effects. The `Effect` type provides a typed API for effectful\n-- | computations, while at the same time generating efficient JavaScript.\nmodule Effect\n  ( Effect\n  , untilE, whileE, forE, foreachE\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\n\n-- | A native effect. The type parameter denotes the return type of running the\n-- | effect, that is, an `Effect Int` is a possibly-effectful computation which\n-- | eventually produces a value of the type `Int` when it finishes.\nforeign import data Effect :: Type -> Type\n\ntype role Effect representational\n\ninstance functorEffect :: Functor Effect where\n  map = liftA1\n\ninstance applyEffect :: Apply Effect where\n  apply = ap\n\ninstance applicativeEffect :: Applicative Effect where\n  pure = pureE\n\nforeign import pureE :: forall a. a -> Effect a\n\ninstance bindEffect :: Bind Effect where\n  bind = bindE\n\nforeign import bindE :: forall a b. Effect a -> (a -> Effect b) -> Effect b\n\ninstance monadEffect :: Monad Effect\n\n-- | The `Semigroup` instance for effects allows you to run two effects, one\n-- | after the other, and then combine their results using the result type's\n-- | `Semigroup` instance.\ninstance semigroupEffect :: Semigroup a => Semigroup (Effect a) where\n  append = lift2 append\n\n-- | If you have a `Monoid a` instance, then `mempty :: Effect a` is defined as\n-- | `pure mempty`.\ninstance monoidEffect :: Monoid a => Monoid (Effect a) where\n  mempty = pureE mempty\n\n-- | Loop until a condition becomes `true`.\n-- |\n-- | `untilE b` is an effectful computation which repeatedly runs the effectful\n-- | computation `b`, until its return value is `true`.\nforeign import untilE :: Effect Boolean -> Effect Unit\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `whileE b m` is effectful computation which runs the effectful computation\n-- | `b`. If its result is `true`, it runs the effectful computation `m` and\n-- | loops. If not, the computation ends.\nforeign import whileE :: forall a. Effect Boolean -> Effect a -> Effect Unit\n\n-- | Loop over a consecutive collection of numbers.\n-- |\n-- | `forE lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import forE :: Int -> Int -> (Int -> Effect Unit) -> Effect Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `foreachE xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreachE :: forall a. Array a -> (a -> Effect Unit) -> Effect Unit\n","export function showErrorImpl(err) {\n  return err.stack || err.toString();\n}\n\nexport function error(msg) {\n  return new Error(msg);\n}\n\nexport function message(e) {\n  return e.message;\n}\n\nexport function name(e) {\n  return e.name || \"Error\";\n}\n\nexport function stackImpl(just) {\n  return function (nothing) {\n    return function (e) {\n      return e.stack ? just(e.stack) : nothing;\n    };\n  };\n}\n\nexport function throwException(e) {\n  return function () {\n    throw e;\n  };\n}\n\nexport function catchException(c) {\n  return function (t) {\n    return function () {\n      try {\n        return t();\n      } catch (e) {\n        if (e instanceof Error || Object.prototype.toString.call(e) === \"[object Error]\") {\n          return c(e)();\n        } else {\n          return c(new Error(e.toString()))();\n        }\n      }\n    };\n  };\n}\n","-- | This module defines an effect, actions and handlers for working\n-- | with JavaScript exceptions.\n\nmodule Effect.Exception\n  ( Error\n  , error\n  , message\n  , name\n  , stack\n  , throwException\n  , catchException\n  , throw\n  , try\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\n\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\n\n-- | The type of JavaScript errors\nforeign import data Error :: Type\n\ninstance showError :: Show Error where\n  show = showErrorImpl\n\nforeign import showErrorImpl :: Error -> String\n\n-- | Create a JavaScript error, specifying a message\nforeign import error :: String -> Error\n\n-- | Get the error message from a JavaScript error\nforeign import message :: Error -> String\n\n-- | Get the error name when defined, or fallback to 'Error'\nforeign import name :: Error -> String\n\n-- | Get the stack trace from a JavaScript error\nstack :: Error -> Maybe String\nstack = stackImpl Just Nothing\n\nforeign import stackImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Error\n  -> Maybe String\n\n-- | Throw an exception\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = do\n-- |   x <- readNumber\n-- |   when (x < 0) $ throwException $\n-- |     error \"Expected a non-negative number\"\n-- | ```\nforeign import throwException\n  :: forall a\n   . Error\n  -> Effect a\n\n-- | Catch an exception by providing an exception handler.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = catchException Console.logShow do\n-- |   Console.log \"Exceptions thrown in this block will be logged to the console\"\n-- | ```\nforeign import catchException\n  :: forall a\n   . (Error -> Effect a)\n  -> Effect a\n  -> Effect a\n\n-- | A shortcut allowing you to throw an error in one step. Defined as\n-- | `throwException <<< error`.\nthrow :: forall a. String -> Effect a\nthrow = throwException <<< error\n\n-- | Runs an Eff and returns eventual Exceptions as a `Left` value. If the\n-- | computation succeeds the result gets wrapped in a `Right`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main :: Effect Unit\n-- | main = do\n-- |   result <- try (readTextFile UTF8 \"README.md\")\n-- |   case result of\n-- |     Right lines ->\n-- |       Console.log (\"README: \\n\" <> lines )\n-- |     Left error ->\n-- |       Console.error (\"Couldn't open README.md. Error was: \" <> show error)\n-- | ```\n\ntry :: forall a. Effect a -> Effect (Either Error a)\ntry action = catchException (pure <<< Left) (Right <$> action)\n","-- | This module defines the `MonadError` type class and its instances.\n\nmodule Control.Monad.Error.Class where\n\nimport Prelude\n\nimport Data.Either (Either(..), either)\nimport Data.Maybe (Maybe(..), maybe)\nimport Effect (Effect)\nimport Effect.Exception as Ex\n\n\n-- | The `MonadThrow` type class represents those monads which support errors via\n-- | `throwError`, where `throwError e` halts, yielding the error `e`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Left zero: `throwError e >>= f = throwError e`\n-- |\nclass Monad m <= MonadThrow e m | m -> e where\n  throwError :: forall a. e -> m a\n\n-- | The `MonadError` type class represents those monads which support catching\n-- | errors.\n-- |\n-- | - `catchError x f` calls the error handler `f` if an error is thrown during the\n-- |   evaluation of `x`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Catch: `catchError (throwError e) f = f e`\n-- | - Pure: `catchError (pure a) f = pure a`\n-- |\nclass MonadThrow e m <= MonadError e m | m -> e where\n  catchError :: forall a. m a -> (e -> m a) -> m a\n\n-- | This function allows you to provide a predicate for selecting the\n-- | exceptions that you're interested in, and handle only those exceptons.\n-- | If the inner computation throws an exception, and the predicate returns\n-- | Nothing, then the whole computation will still fail with that exception.\ncatchJust\n  :: forall e m a b\n   . MonadError e m\n  => (e -> Maybe b) -- ^ Predicate to select exceptions\n  -> m a            -- ^ Computation to run\n  -> (b -> m a)     -- ^ Handler\n  -> m a\ncatchJust p act handler = catchError act handle\n  where\n  handle e =\n    case p e of\n      Nothing -> throwError e\n      Just b -> handler b\n\n-- | Return `Right` if the given action succeeds, `Left` if it throws.\ntry\n  :: forall e m a\n   . MonadError e m\n  => m a\n  -> m (Either e a)\ntry a = (Right <$> a) `catchError` (pure <<< Left)\n\ninstance monadThrowEither :: MonadThrow e (Either e) where\n  throwError = Left\n\ninstance monadErrorEither :: MonadError e (Either e) where\n  catchError (Left e) h = h e\n  catchError (Right x) _ = Right x\n\ninstance monadThrowMaybe :: MonadThrow Unit Maybe where\n  throwError = const Nothing\n\ninstance monadErrorMaybe :: MonadError Unit Maybe where\n  catchError Nothing f  = f unit\n  catchError (Just a) _ = Just a\n \ninstance monadThrowEffect :: MonadThrow Ex.Error Effect where\n  throwError = Ex.throwException\n\ninstance monadErrorEffect :: MonadError Ex.Error Effect where\n  catchError = flip Ex.catchException\n\n\n-- | Make sure that a resource is cleaned up in the event of an exception. The\n-- | release action is called regardless of whether the body action throws or\n-- | returns.\nwithResource\n  :: forall e m r a\n   . MonadError e m\n  => m r\n  -> (r -> m Unit)\n  -> (r -> m a)\n  -> m a\nwithResource acquire release kleisli = do\n  resource <- acquire\n  result <- try $ kleisli resource\n  release resource\n  either throwError pure result\n\n-- | Lift a `Maybe` value to a MonadThrow monad.\nliftMaybe :: forall m e a. MonadThrow e m => e -> Maybe a -> m a\nliftMaybe error = maybe (throwError error) pure\n\n-- | Lift an `Either` value to a MonadThrow monad.\nliftEither :: forall m e a. MonadThrow e m => Either e a -> m a\nliftEither = either throwError pure\n","module Data.Identity where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\nnewtype Identity a = Identity a\n\nderive instance newtypeIdentity :: Newtype (Identity a) _\n\nderive newtype instance eqIdentity :: Eq a => Eq (Identity a)\n\nderive newtype instance ordIdentity :: Ord a => Ord (Identity a)\n\nderive newtype instance boundedIdentity :: Bounded a => Bounded (Identity a)\n\nderive newtype instance heytingAlgebraIdentity :: HeytingAlgebra a => HeytingAlgebra (Identity a)\n\nderive newtype instance booleanAlgebraIdentity :: BooleanAlgebra a => BooleanAlgebra (Identity a)\n\nderive newtype instance semigroupIdentity :: Semigroup a => Semigroup (Identity a)\n\nderive newtype instance monoidIdentity :: Monoid a => Monoid (Identity a)\n\nderive newtype instance semiringIdentity :: Semiring a => Semiring (Identity a)\n\nderive newtype instance euclideanRingIdentity :: EuclideanRing a => EuclideanRing (Identity a)\n\nderive newtype instance ringIdentity :: Ring a => Ring (Identity a)\n\nderive newtype instance commutativeRingIdentity :: CommutativeRing a => CommutativeRing (Identity a)\n\nderive newtype instance lazyIdentity :: Lazy a => Lazy (Identity a)\n\ninstance showIdentity :: Show a => Show (Identity a) where\n  show (Identity x) = \"(Identity \" <> show x <> \")\"\n\nderive instance eq1Identity :: Eq1 Identity\n\nderive instance ord1Identity :: Ord1 Identity\n\nderive instance functorIdentity :: Functor Identity\n\ninstance invariantIdentity :: Invariant Identity where\n  imap = imapF\n\ninstance altIdentity :: Alt Identity where\n  alt x _ = x\n\ninstance applyIdentity :: Apply Identity where\n  apply (Identity f) (Identity x) = Identity (f x)\n\ninstance applicativeIdentity :: Applicative Identity where\n  pure = Identity\n\ninstance bindIdentity :: Bind Identity where\n  bind (Identity m) f = f m\n\ninstance monadIdentity :: Monad Identity\n\ninstance extendIdentity :: Extend Identity where\n  extend f m = Identity (f m)\n\ninstance comonadIdentity :: Comonad Identity where\n  extract (Identity x) = x\n","export const _new = function (val) {\n  return function () {\n    return { value: val };\n  };\n};\n\nexport const newWithSelf = function (f) {\n  return function () {\n    var ref = { value: null };\n    ref.value = f(ref);\n    return ref;\n  };\n};\n\nexport const read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexport const modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexport const write = function (val) {\n  return function (ref) {\n    return function () {\n      ref.value = val;\n    };\n  };\n};\n","-- | This module defines the `Ref` type for mutable value references, as well\n-- | as actions for working with them.\n-- |\n-- | You'll notice that all of the functions that operate on a `Ref` (e.g.\n-- | `new`, `read`, `write`) return their result wrapped in an `Effect`.\n-- | Working with mutable references is considered effectful in PureScript\n-- | because of the principle of purity: functions should not have side\n-- | effects, and should return the same result when called with the same\n-- | arguments. If a `Ref` could be written to without using `Effect`, that\n-- | would cause a side effect (the effect of changing the result of subsequent\n-- | reads for that `Ref`). If there were a function for reading the current\n-- | value of a `Ref` without the result being wrapped in `Effect`, the result\n-- | of calling that function would change each time a new value was written to\n-- | the `Ref`. Even creating a new `Ref` is effectful: if there were a\n-- | function for creating a new `Ref` with the type `forall s. s -> Ref s`,\n-- | then calling that function twice with the same argument would not give the\n-- | same result in each case, since you'd end up with two distinct references\n-- | which could be updated independently of each other.\n-- |\n-- | _Note_: `Control.Monad.ST` provides a pure alternative to `Ref` when\n-- | mutation is restricted to a local scope.\nmodule Effect.Ref\n  ( Ref\n  , new\n  , newWithSelf\n  , read\n  , modify'\n  , modify\n  , modify_\n  , write\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\n\n-- | A value of type `Ref a` represents a mutable reference\n-- | which holds a value of type `a`.\nforeign import data Ref :: Type -> Type\n\ntype role Ref representational\n\n-- | Create a new mutable reference containing the specified value.\nforeign import _new :: forall s. s -> Effect (Ref s)\n\nnew :: forall s. s -> Effect (Ref s)\nnew = _new\n\n-- | Create a new mutable reference containing a value that can refer to the\n-- | `Ref` being created.\nforeign import newWithSelf :: forall s. (Ref s -> s) -> Effect (Ref s)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall s. Ref s -> Effect s\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value.\nmodify' :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\nmodify' = modifyImpl\n\nforeign import modifyImpl :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value. The updated value is returned.\nmodify :: forall s. (s -> s) -> Ref s -> Effect s\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | A version of `modify` which does not return the updated value.\nmodify_ :: forall s. (s -> s) -> Ref s -> Effect Unit\nmodify_ f s = void $ modify f s\n\n-- | Update the value of a mutable reference to the specified value.\nforeign import write :: forall s. s -> Ref s -> Effect Unit\n","module Control.Monad.Rec.Class\n  ( Step(..)\n  , class MonadRec\n  , tailRec\n  , tailRec2\n  , tailRec3\n  , tailRecM\n  , tailRecM2\n  , tailRecM3\n  , forever\n  , whileJust\n  , untilJust\n  , loop2\n  , loop3\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Either (Either(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect, untilE)\nimport Effect.Ref as Ref\nimport Partial.Unsafe (unsafePartial)\n\n-- | The result of a computation: either `Loop` containing the updated\n-- | accumulator, or `Done` containing the final result of the computation.\ndata Step a b = Loop a | Done b\n\nderive instance functorStep :: Functor (Step a)\n\ninstance bifunctorStep :: Bifunctor Step where\n  bimap f _ (Loop a) = Loop (f a)\n  bimap _ g (Done b) = Done (g b)\n\n-- | This type class captures those monads which support tail recursion in\n-- | constant stack space.\n-- |\n-- | The `tailRecM` function takes a step function, and applies that step\n-- | function recursively until a pure value of type `b` is found.\n-- |\n-- | Instances are provided for standard monad transformers.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | loopWriter :: Int -> WriterT (Additive Int) Effect Unit\n-- | loopWriter n = tailRecM go n\n-- |   where\n-- |   go 0 = do\n-- |     traceM \"Done!\"\n-- |     pure (Done unit)\n-- |   go i = do\n-- |     tell $ Additive i\n-- |     pure (Loop (i - 1))\n-- | ```\nclass Monad m <= MonadRec m where\n  tailRecM :: forall a b. (a -> m (Step a b)) -> a -> m b\n\n-- | Create a tail-recursive function of two arguments which uses constant stack space.\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM2\n  :: forall m a b c\n   . MonadRec m\n  => (a -> b -> m (Step { a :: a, b :: b } c))\n  -> a\n  -> b\n  -> m c\ntailRecM2 f a b = tailRecM (\\o -> f o.a o.b) { a, b }\n\n-- | Create a tail-recursive function of three arguments which uses constant stack space.\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM3\n  :: forall m a b c d\n   . MonadRec m\n  => (a -> b -> c -> m (Step { a :: a, b :: b, c :: c } d))\n  -> a\n  -> b\n  -> c\n  -> m d\ntailRecM3 f a b c = tailRecM (\\o -> f o.a o.b o.c) { a, b, c }\n\n-- | Create a pure tail-recursive function of one argument\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | pow :: Int -> Int -> Int\n-- | pow n p = tailRec go { accum: 1, power: p }\n-- |   where\n-- |   go :: _ -> Step _ Int\n-- |   go { accum: acc, power: 0 } = Done acc\n-- |   go { accum: acc, power: p } = Loop { accum: acc * n, power: p - 1 }\n-- | ```\ntailRec :: forall a b. (a -> Step a b) -> a -> b\ntailRec f = go <<< f\n  where\n  go (Loop a) = go (f a)\n  go (Done b) = b\n\n-- | Create a pure tail-recursive function of two arguments\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec2 :: forall a b c. (a -> b -> Step { a :: a, b :: b } c) -> a -> b -> c\ntailRec2 f a b = tailRec (\\o -> f o.a o.b) { a, b }\n\n-- | Create a pure tail-recursive function of three arguments\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec3 :: forall a b c d. (a -> b -> c -> Step { a :: a, b :: b, c :: c } d) -> a -> b -> c -> d\ntailRec3 f a b c = tailRec (\\o -> f o.a o.b o.c) { a, b, c }\n\ninstance monadRecIdentity :: MonadRec Identity where\n  tailRecM f = Identity <<< tailRec (runIdentity <<< f)\n    where runIdentity (Identity x) = x\n\ninstance monadRecEffect :: MonadRec Effect where\n  tailRecM f a = do\n    r <- Ref.new =<< f a\n    untilE do\n      Ref.read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          _ <- Ref.write e r\n          pure false\n        Done _ -> pure true\n    fromDone <$> Ref.read r\n    where\n    fromDone :: forall a b. Step a b -> b\n    fromDone = unsafePartial \\(Done b) -> b\n\ninstance monadRecFunction :: MonadRec ((->) e) where\n  tailRecM f a0 e = tailRec (\\a -> f a e) a0\n\ninstance monadRecEither :: MonadRec (Either e) where\n  tailRecM f a0 =\n    let\n      g (Left e) = Done (Left e)\n      g (Right (Loop a)) = Loop (f a)\n      g (Right (Done b)) = Done (Right b)\n    in tailRec g (f a0)\n\ninstance monadRecMaybe :: MonadRec Maybe where\n  tailRecM f a0 =\n    let\n      g Nothing = Done Nothing\n      g (Just (Loop a)) = Loop (f a)\n      g (Just (Done b)) = Done (Just b)\n    in tailRec g (f a0)\n\n-- | `forever` runs an action indefinitely, using the `MonadRec` instance to\n-- | ensure constant stack usage.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = forever $ trace \"Hello, World!\"\n-- | ```\nforever :: forall m a b. MonadRec m => m a -> m b\nforever ma = tailRecM (\\u -> Loop u <$ ma) unit\n\n-- | While supplied computation evaluates to `Just _`, it will be\n-- | executed repeatedly and results will be combined using monoid instance.\nwhileJust :: forall a m. Monoid a => MonadRec m => m (Maybe a) -> m a\nwhileJust m = mempty # tailRecM \\v -> m <#> case _ of\n  Nothing -> Done v\n  Just x -> Loop $ v <> x\n\n-- | Supplied computation will be executed repeatedly until it evaluates\n-- | to `Just value` and then that `value` will be returned.\nuntilJust :: forall a m. MonadRec m => m (Maybe a) -> m a\nuntilJust m = unit # tailRecM \\_ -> m <#> case _ of\n  Nothing -> Loop unit\n  Just x -> Done x\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec2` and `tailRecM2`.\nloop2 :: forall a b c. a -> b -> Step { a :: a, b :: b } c\nloop2 a b = Loop { a, b }\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec3` and `tailRecM3`.\nloop3 :: forall a b c d. a -> b -> c -> Step { a :: a, b :: b, c :: c } d\nloop3 a b c = Loop { a, b, c }\n","export const boolConj = function (b1) {\n  return function (b2) {\n    return b1 && b2;\n  };\n};\n\nexport const boolDisj = function (b1) {\n  return function (b2) {\n    return b1 || b2;\n  };\n};\n\nexport const boolNot = function (b) {\n  return !b;\n};\n","module Data.HeytingAlgebra\n  ( class HeytingAlgebra\n  , tt\n  , ff\n  , implies\n  , conj\n  , disj\n  , not\n  , (&&)\n  , (||)\n  , class HeytingAlgebraRecord\n  , ffRecord\n  , ttRecord\n  , impliesRecord\n  , conjRecord\n  , disjRecord\n  , notRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `HeytingAlgebra` type class represents types that are bounded lattices with\n-- | an implication operator such that the following laws hold:\n-- |\n-- | - Associativity:\n-- |   - `a || (b || c) = (a || b) || c`\n-- |   - `a && (b && c) = (a && b) && c`\n-- | - Commutativity:\n-- |   - `a || b = b || a`\n-- |   - `a && b = b && a`\n-- | - Absorption:\n-- |   - `a || (a && b) = a`\n-- |   - `a && (a || b) = a`\n-- | - Idempotent:\n-- |   - `a || a = a`\n-- |   - `a && a = a`\n-- | - Identity:\n-- |   - `a || ff = a`\n-- |   - `a && tt = a`\n-- | - Implication:\n-- |   - ``a `implies` a = tt``\n-- |   - ``a && (a `implies` b) = a && b``\n-- |   - ``b && (a `implies` b) = b``\n-- |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``\n-- | - Complemented:\n-- |   - ``not a = a `implies` ff``\nclass HeytingAlgebra a where\n  ff :: a\n  tt :: a\n  implies :: a -> a -> a\n  conj :: a -> a -> a\n  disj :: a -> a -> a\n  not :: a -> a\n\ninfixr 3 conj as &&\ninfixr 2 disj as ||\n\ninstance heytingAlgebraBoolean :: HeytingAlgebra Boolean where\n  ff = false\n  tt = true\n  implies a b = not a || b\n  conj = boolConj\n  disj = boolDisj\n  not = boolNot\n\ninstance heytingAlgebraUnit :: HeytingAlgebra Unit where\n  ff = unit\n  tt = unit\n  implies _ _ = unit\n  conj _ _ = unit\n  disj _ _ = unit\n  not _ = unit\n\ninstance heytingAlgebraFunction :: HeytingAlgebra b => HeytingAlgebra (a -> b) where\n  ff _ = ff\n  tt _ = tt\n  implies f g a = f a `implies` g a\n  conj f g a = f a && g a\n  disj f g a = f a || g a\n  not f a = not (f a)\n\ninstance heytingAlgebraProxy :: HeytingAlgebra (Proxy a) where\n  conj _ _ = Proxy\n  disj _ _ = Proxy\n  implies _ _ = Proxy\n  ff = Proxy\n  not _ = Proxy\n  tt = Proxy\n\ninstance heytingAlgebraRecord :: (RL.RowToList row list, HeytingAlgebraRecord list row row) => HeytingAlgebra (Record row) where\n  ff = ffRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  tt = ttRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  conj = conjRecord (Proxy :: Proxy list)\n  disj = disjRecord (Proxy :: Proxy list)\n  implies = impliesRecord (Proxy :: Proxy list)\n  not = notRecord (Proxy :: Proxy list)\n\nforeign import boolConj :: Boolean -> Boolean -> Boolean\nforeign import boolDisj :: Boolean -> Boolean -> Boolean\nforeign import boolNot :: Boolean -> Boolean\n\n-- | A class for records where all fields have `HeytingAlgebra` instances, used\n-- | to implement the `HeytingAlgebra` instance for records.\nclass HeytingAlgebraRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass HeytingAlgebraRecord rowlist row subrow | rowlist -> subrow where\n  ffRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  ttRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  impliesRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  disjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  conjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  notRecord :: Proxy rowlist -> Record row -> Record subrow\n\ninstance heytingAlgebraRecordNil :: HeytingAlgebraRecord RL.Nil row () where\n  conjRecord _ _ _ = {}\n  disjRecord _ _ _ = {}\n  ffRecord _ _ = {}\n  impliesRecord _ _ _ = {}\n  notRecord _ _ = {}\n  ttRecord _ _ = {}\n\ninstance heytingAlgebraRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , HeytingAlgebraRecord rowlistTail row subrowTail\n  , HeytingAlgebra focus\n  ) =>\n  HeytingAlgebraRecord (RL.Cons key focus rowlistTail) row subrow where\n  conjRecord _ ra rb = insert (conj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = conjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  disjRecord _ ra rb = insert (disj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = disjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  impliesRecord _ ra rb = insert (implies (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = impliesRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  ffRecord _ row = insert ff tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ffRecord (Proxy :: Proxy rowlistTail) row\n\n  notRecord _ row = insert (not (get row)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = notRecord (Proxy :: Proxy rowlistTail) row\n\n  ttRecord _ row = insert tt tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ttRecord (Proxy :: Proxy rowlistTail) row\n","-- | A data type and functions for working with ordered pairs.\nmodule Data.Tuple where\n\nimport Prelude\n\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy, defer)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.HeytingAlgebra (implies, ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | A simple product type for wrapping a pair of component values.\ndata Tuple a b = Tuple a b\n\n-- | Allows `Tuple`s to be rendered as a string with `show` whenever there are\n-- | `Show` instances for both component types.\ninstance showTuple :: (Show a, Show b) => Show (Tuple a b) where\n  show (Tuple a b) = \"(Tuple \" <> show a <> \" \" <> show b <> \")\"\n\n-- | Allows `Tuple`s to be checked for equality with `==` and `/=` whenever\n-- | there are `Eq` instances for both component types.\nderive instance eqTuple :: (Eq a, Eq b) => Eq (Tuple a b)\n\nderive instance eq1Tuple :: Eq a => Eq1 (Tuple a)\n\n-- | Allows `Tuple`s to be compared with `compare`, `>`, `>=`, `<` and `<=`\n-- | whenever there are `Ord` instances for both component types. To obtain\n-- | the result, the `fst`s are `compare`d, and if they are `EQ`ual, the\n-- | `snd`s are `compare`d.\nderive instance ordTuple :: (Ord a, Ord b) => Ord (Tuple a b)\n\nderive instance ord1Tuple :: Ord a => Ord1 (Tuple a)\n\ninstance boundedTuple :: (Bounded a, Bounded b) => Bounded (Tuple a b) where\n  top = Tuple top top\n  bottom = Tuple bottom bottom\n\ninstance semigroupoidTuple :: Semigroupoid Tuple where\n  compose (Tuple _ c) (Tuple a _) = Tuple a c\n\n-- | The `Semigroup` instance enables use of the associative operator `<>` on\n-- | `Tuple`s whenever there are `Semigroup` instances for the component\n-- | types. The `<>` operator is applied pairwise, so:\n-- | ```purescript\n-- | (Tuple a1 b1) <> (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n-- | ```\ninstance semigroupTuple :: (Semigroup a, Semigroup b) => Semigroup (Tuple a b) where\n  append (Tuple a1 b1) (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n\ninstance monoidTuple :: (Monoid a, Monoid b) => Monoid (Tuple a b) where\n  mempty = Tuple mempty mempty\n\ninstance semiringTuple :: (Semiring a, Semiring b) => Semiring (Tuple a b) where\n  add (Tuple x1 y1) (Tuple x2 y2) = Tuple (add x1 x2) (add y1 y2)\n  one = Tuple one one\n  mul (Tuple x1 y1) (Tuple x2 y2) = Tuple (mul x1 x2) (mul y1 y2)\n  zero = Tuple zero zero\n\ninstance ringTuple :: (Ring a, Ring b) => Ring (Tuple a b) where\n  sub (Tuple x1 y1) (Tuple x2 y2) = Tuple (sub x1 x2) (sub y1 y2)\n\ninstance commutativeRingTuple :: (CommutativeRing a, CommutativeRing b) => CommutativeRing (Tuple a b)\n\ninstance heytingAlgebraTuple :: (HeytingAlgebra a, HeytingAlgebra b) => HeytingAlgebra (Tuple a b) where\n  tt = Tuple tt tt\n  ff = Tuple ff ff\n  implies (Tuple x1 y1) (Tuple x2 y2) = Tuple (x1 `implies` x2) (y1 `implies` y2)\n  conj (Tuple x1 y1) (Tuple x2 y2) = Tuple (conj x1 x2) (conj y1 y2)\n  disj (Tuple x1 y1) (Tuple x2 y2) = Tuple (disj x1 x2) (disj y1 y2)\n  not (Tuple x y) = Tuple (not x) (not y)\n\ninstance booleanAlgebraTuple :: (BooleanAlgebra a, BooleanAlgebra b) => BooleanAlgebra (Tuple a b)\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<$>` operator, applying the function to the second\n-- | component, so:\n-- | ```purescript\n-- | f <$> (Tuple x y) = Tuple x (f y)\n-- | ````\nderive instance functorTuple :: Functor (Tuple a)\n\nderive instance genericTuple :: Generic (Tuple a b) _\n\ninstance invariantTuple :: Invariant (Tuple a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<*>` operator whenever there is a `Semigroup` instance\n-- | for the `fst` component, so:\n-- | ```purescript\n-- | (Tuple a1 f) <*> (Tuple a2 x) == Tuple (a1 <> a2) (f x)\n-- | ```\ninstance applyTuple :: (Semigroup a) => Apply (Tuple a) where\n  apply (Tuple a1 f) (Tuple a2 x) = Tuple (a1 <> a2) (f x)\n\ninstance applicativeTuple :: (Monoid a) => Applicative (Tuple a) where\n  pure = Tuple mempty\n\ninstance bindTuple :: (Semigroup a) => Bind (Tuple a) where\n  bind (Tuple a1 b) f = case f b of\n    Tuple a2 c -> Tuple (a1 <> a2) c\n\ninstance monadTuple :: (Monoid a) => Monad (Tuple a)\n\ninstance extendTuple :: Extend (Tuple a) where\n  extend f t@(Tuple a _) = Tuple a (f t)\n\ninstance comonadTuple :: Comonad (Tuple a) where\n  extract = snd\n\ninstance lazyTuple :: (Lazy a, Lazy b) => Lazy (Tuple a b) where\n  defer f = Tuple (defer $ \\_ -> fst (f unit)) (defer $ \\_ -> snd (f unit))\n\n-- | Returns the first component of a tuple.\nfst :: forall a b. Tuple a b -> a\nfst (Tuple a _) = a\n\n-- | Returns the second component of a tuple.\nsnd :: forall a b. Tuple a b -> b\nsnd (Tuple _ b) = b\n\n-- | Turn a function that expects a tuple into a function of two arguments.\ncurry :: forall a b c. (Tuple a b -> c) -> a -> b -> c\ncurry f a b = f (Tuple a b)\n\n-- | Turn a function of two arguments into a function that expects a tuple.\nuncurry :: forall a b c. (a -> b -> c) -> Tuple a b -> c\nuncurry f (Tuple a b) = f a b\n\n-- | Exchange the first and second components of a tuple.\nswap :: forall a b. Tuple a b -> Tuple b a\nswap (Tuple a b) = Tuple b a\n","-- | This module defines the `MonadState` type class and its instances.\n\nmodule Control.Monad.State.Class where\n\nimport Prelude (class Monad, Unit, unit)\n\nimport Data.Tuple (Tuple(..))\n\n-- | The `MonadState s` type class represents those monads which support a single piece of mutable\n-- | state of type `s`.\n-- |\n-- | - `state f` updates the state using the function `f`.\n-- |\n-- | An implementation is provided for `StateT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - `do { get ; get } = get`\n-- | - `do { put x ; put y } = put y`\n-- | - `do { put x ; get } = put x $> x`\n-- | - `do { s <- get ; put s } = pure unit`\n-- |\nclass Monad m <= MonadState s m | m -> s where\n  state :: forall a. (s -> (Tuple a s)) -> m a\n\n-- | Get the current state.\nget :: forall m s. MonadState s m => m s\nget = state \\s -> Tuple s s\n\n-- | Get a value which depends on the current state.\ngets :: forall s m a. MonadState s m => (s -> a) -> m a\ngets f = state \\s -> Tuple (f s) s\n\n-- | Set the state.\nput :: forall m s. MonadState s m => s -> m Unit\nput s = state \\_ -> Tuple unit s\n\n-- | Modify the state by applying a function to the current state. The returned\n-- | value is the new state value.\nmodify :: forall s m. MonadState s m => (s -> s) -> m s\nmodify f = state \\s -> let s' = f s in Tuple s' s'\n\nmodify_ :: forall s m. MonadState s m => (s -> s) -> m Unit\nmodify_ f = state \\s -> Tuple unit (f s)\n","-- | This module defines the `MonadTrans` type class of _monad transformers_.\n\nmodule Control.Monad.Trans.Class where\n\nimport Prelude (class Monad)\n\n-- | The `MonadTrans` type class represents _monad transformers_.\n-- |\n-- | A monad transformer is a type constructor of kind `(* -> *) -> * -> *`, which\n-- | takes a `Monad` as its first argument, and returns another `Monad`.\n-- |\n-- | This allows us to add additional effects to an existing monad. By iterating this\n-- | process, we create monad transformer _stacks_, which contain all of the effects\n-- | required for a particular computation.\n-- |\n-- | The laws state that `lift` is a `Monad` morphism.\n-- |\n-- | Laws:\n-- |\n-- | - `lift (pure a) = pure a`\n-- | - `lift (do { x <- m ; y }) = do { x <- lift m ; lift y }`\nclass MonadTrans t where\n  lift :: forall m a. Monad m => m a -> t m a\n","module Effect.Class where\n\nimport Control.Category (identity)\nimport Control.Monad (class Monad)\nimport Effect (Effect)\n\n-- | The `MonadEffect` class captures those monads which support native effects.\n-- |\n-- | Instances are provided for `Effect` itself, and the standard monad\n-- | transformers.\n-- |\n-- | `liftEffect` can be used in any appropriate monad transformer stack to lift an\n-- | action of type `Effect a` into the monad.\n-- |\nclass Monad m <= MonadEffect m where\n  liftEffect :: forall a. Effect a -> m a\n\ninstance monadEffectEffect :: MonadEffect Effect where\n  liftEffect = identity\n","-- | This module defines the `MaybeT` monad transformer.\n\nmodule Control.Monad.Maybe.Trans\n  ( MaybeT(..), runMaybeT, mapMaybeT\n  , module Control.Monad.Trans.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Monad.Cont.Class (class MonadCont, callCC)\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError, catchError, throwError)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, ask, local)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.State.Class (class MonadState, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.Monad.Writer.Class (class MonadWriter, class MonadTell, pass, listen, tell)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..))\nimport Effect.Class (class MonadEffect, liftEffect)\n\n-- | The `MaybeT` monad transformer.\n-- |\n-- | This monad transformer extends the base monad, supporting failure and alternation via\n-- | the `MonadPlus` type class.\nnewtype MaybeT m a = MaybeT (m (Maybe a))\n\n-- | Run a computation in the `MaybeT` monad.\nrunMaybeT :: forall m a. MaybeT m a -> m (Maybe a)\nrunMaybeT (MaybeT x) = x\n\n-- | Change the result type of a `MaybeT` monad action.\nmapMaybeT :: forall m1 m2 a b. (m1 (Maybe a) -> m2 (Maybe b)) -> MaybeT m1 a -> MaybeT m2 b\nmapMaybeT f (MaybeT m) = MaybeT (f m)\n\nderive instance newtypeMaybeT :: Newtype (MaybeT m a) _\n\ninstance functorMaybeT :: Functor m => Functor (MaybeT m) where\n  map f (MaybeT ma) = MaybeT (map f <$> ma)\n\ninstance applyMaybeT :: Monad m => Apply (MaybeT m) where\n  apply = ap\n\ninstance applicativeMaybeT :: Monad m => Applicative (MaybeT m) where\n  pure = MaybeT <<< pure <<< Just\n\ninstance bindMaybeT :: Monad m => Bind (MaybeT m) where\n  bind (MaybeT x) f = MaybeT do\n    x >>= case _ of\n      Nothing -> pure Nothing\n      Just y -> case f y of MaybeT m -> m\n\ninstance monadMaybeT :: Monad m => Monad (MaybeT m)\n\ninstance monadTransMaybeT :: MonadTrans MaybeT where\n  lift = MaybeT <<< liftM1 Just\n\ninstance altMaybeT :: Monad m => Alt (MaybeT m) where\n  alt (MaybeT m1) (MaybeT m2) = MaybeT do\n    m <- m1\n    case m of\n      Nothing -> m2\n      ja -> pure ja\n\ninstance plusMaybeT :: Monad m => Plus (MaybeT m) where\n  empty = MaybeT (pure Nothing)\n\ninstance alternativeMaybeT :: Monad m => Alternative (MaybeT m)\n\ninstance monadPlusMaybeT :: Monad m => MonadPlus (MaybeT m)\n\ninstance monadRecMaybeT :: MonadRec m => MonadRec (MaybeT m) where\n  tailRecM f =\n    MaybeT <<< tailRecM \\a ->\n      case f a of\n        MaybeT m -> m >>= \\m' ->\n          pure case m' of\n            Nothing -> Done Nothing\n            Just (Loop a1) -> Loop a1\n            Just (Done b) -> Done (Just b)\n\ninstance monadEffectMaybe :: MonadEffect m => MonadEffect (MaybeT m) where\n  liftEffect = lift <<< liftEffect\n\ninstance monadContMaybeT :: MonadCont m => MonadCont (MaybeT m) where\n  callCC f =\n    MaybeT $ callCC \\c -> case f (\\a -> MaybeT $ c $ Just a) of MaybeT m -> m\n\ninstance monadThrowMaybeT :: MonadThrow e m => MonadThrow e (MaybeT m) where\n  throwError e = lift (throwError e)\n\ninstance monadErrorMaybeT :: MonadError e m => MonadError e (MaybeT m) where\n  catchError (MaybeT m) h =\n    MaybeT $ catchError m (\\a -> case h a of MaybeT b -> b)\n\ninstance monadAskMaybeT :: MonadAsk r m => MonadAsk r (MaybeT m) where\n  ask = lift ask\n\ninstance monadReaderMaybeT :: MonadReader r m => MonadReader r (MaybeT m) where\n  local f = mapMaybeT (local f)\n\ninstance monadStateMaybeT :: MonadState s m => MonadState s (MaybeT m) where\n  state f = lift (state f)\n\ninstance monadTellMaybeT :: MonadTell w m => MonadTell w (MaybeT m) where\n  tell = lift <<< tell\n\ninstance monadWriterMaybeT :: MonadWriter w m => MonadWriter w (MaybeT m) where\n  listen = mapMaybeT \\m -> do\n    Tuple a w <- listen m\n    pure $ (\\r -> Tuple r w) <$> a\n  pass = mapMaybeT \\m -> pass do\n    a <- m\n    pure case a of\n      Nothing -> Tuple Nothing identity\n      Just (Tuple v f) -> Tuple (Just v) f\n\ninstance semigroupMaybeT :: (Monad m, Semigroup a) => Semigroup (MaybeT m a) where\n  append = lift2 (<>)\n\ninstance monoidMaybeT :: (Monad m, Monoid a) => Monoid (MaybeT m a) where\n  mempty = pure mempty\n\n","//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const rangeImpl = function (start, end) {\n  var step = start > end ? -1 : 1;\n  var result = new Array(step * (end - start) + 1);\n  var i = start, n = 0;\n  while (i !== end) {\n    result[n++] = i;\n    i += step;\n  }\n  result[n] = i;\n  return result;\n};\n\nvar replicateFill = function (count, value) {\n  if (count < 1) {\n    return [];\n  }\n  var result = new Array(count);\n  return result.fill(value);\n};\n\nvar replicatePolyfill = function (count, value) {\n  var result = [];\n  var n = 0;\n  for (var i = 0; i < count; i++) {\n    result[n++] = value;\n  }\n  return result;\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexport const replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexport const fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr, xs) {\n    return listToArray(foldr(curryCons)(emptyList)(xs));\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unconsImpl = function (empty, next, xs) {\n  return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const indexImpl = function (just, nothing, xs, i) {\n  return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n};\n\nexport const findMapImpl = function (nothing, isJust, f, xs) {\n  for (var i = 0; i < xs.length; i++) {\n    var result = f(xs[i]);\n    if (isJust(result)) return result;\n  }\n  return nothing;\n};\n\nexport const findIndexImpl = function (just, nothing, f, xs) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const findLastIndexImpl = function (just, nothing, f, xs) {\n  for (var i = xs.length - 1; i >= 0; i--) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const _insertAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i > l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 0, a);\n  return just(l1);\n};\n\nexport const _deleteAt = function (just, nothing, i, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 1);\n  return just(l1);\n};\n\nexport const _updateAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1[i] = a;\n  return just(l1);\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexport const concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexport const filterImpl = function (f, xs) {\n  return xs.filter(f);\n};\n\nexport const partitionImpl = function (f, xs) {\n  var yes = [];\n  var no  = [];\n  for (var i = 0; i < xs.length; i++) {\n    var x = xs[i];\n    if (f(x))\n      yes.push(x);\n    else\n      no.push(x);\n  }\n  return { yes: yes, no: no };\n};\n\nexport const scanlImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    acc = f(acc)(xs[i]);\n    out[i] = acc;\n  }\n  return out;\n};\n\nexport const scanrImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = len - 1; i >= 0; i--) {\n    acc = f(xs[i])(acc);\n    out[i] = acc;\n  }\n  return out;\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    var out;\n\n    if (xs.length < 2) return xs;\n\n    out = xs.slice(0);\n    mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);\n\n    return out;\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sliceImpl = function (s, e, l) {\n  return l.slice(s, e);\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const zipWithImpl = function (f, xs, ys) {\n  var l = xs.length < ys.length ? xs.length : ys.length;\n  var result = new Array(l);\n  for (var i = 0; i < l; i++) {\n    result[i] = f(xs[i])(ys[i]);\n  }\n  return result;\n};\n\n//------------------------------------------------------------------------------\n// Folding ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const anyImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (p(xs[i])) return true;\n  }\n  return false;\n};\n\nexport const allImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (!p(xs[i])) return false;\n  }\n  return true;\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unsafeIndexImpl = function (xs, n) {\n  return xs[n];\n};\n","export const map_ = function (f) {\n  return function (a) {\n    return function () {\n      return f(a());\n    };\n  };\n};\n\nexport const pure_ = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bind_ = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const run = function (f) {\n  return f();\n};\n\nfunction whileST(f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n}\nexport { whileST as while };\n\nfunction forST(lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n}\nexport { forST as for };\n\nexport const foreach = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n\nfunction newSTRef(val) {\n  return function () {\n    return { value: val };\n  };\n}\nexport { newSTRef as new };\n\nexport const read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexport const modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexport const write = function (a) {\n  return function (ref) {\n    return function () {\n      return ref.value = a; // eslint-disable-line no-return-assign\n    };\n  };\n};\n","module Control.Monad.ST.Internal\n  ( Region\n  , ST\n  , run\n  , while\n  , for\n  , foreach\n  , STRef\n  , new\n  , read\n  , modify'\n  , modify\n  , write\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..))\nimport Partial.Unsafe (unsafePartial)\n\n-- | `ST` is concerned with _restricted_ mutation. Mutation is restricted to a\n-- | _region_ of mutable references. This kind is inhabited by phantom types\n-- | which represent regions in the type system.\nforeign import data Region :: Type\n\n-- | The `ST` type constructor allows _local mutation_, i.e. mutation which\n-- | does not \"escape\" into the surrounding computation.\n-- |\n-- | An `ST` computation is parameterized by a phantom type which is used to\n-- | restrict the set of reference cells it is allowed to access.\n-- |\n-- | The `run` function can be used to run a computation in the `ST` monad.\nforeign import data ST :: Region -> Type -> Type\n\ntype role ST nominal representational\n\nforeign import map_ :: forall r a b. (a -> b) -> ST r a -> ST r b\n\nforeign import pure_ :: forall r a. a -> ST r a\n\nforeign import bind_ :: forall r a b. ST r a -> (a -> ST r b) -> ST r b\n\ninstance functorST :: Functor (ST r) where\n  map = map_\n\ninstance applyST :: Apply (ST r) where\n  apply = ap\n\ninstance applicativeST :: Applicative (ST r) where\n  pure = pure_\n\ninstance bindST :: Bind (ST r) where\n  bind = bind_\n\ninstance monadST :: Monad (ST r)\n\ninstance monadRecST :: MonadRec (ST r) where\n  tailRecM f a = do\n    r <- new =<< f a\n    while (isLooping <$> read r) do\n      read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          void (write e r)\n        Done _ -> pure unit\n    fromDone <$> read r\n    where\n      fromDone :: forall a b. Step a b -> b\n      fromDone = unsafePartial \\(Done b) -> b\n\n      isLooping = case _ of\n        Loop _ -> true\n        _ -> false\n\ninstance semigroupST :: Semigroup a => Semigroup (ST r a) where\n  append = lift2 append\n\ninstance monoidST :: Monoid a => Monoid (ST r a) where\n  mempty = pure mempty\n\n-- | Run an `ST` computation.\n-- |\n-- | Note: the type of `run` uses a rank-2 type to constrain the phantom\n-- | type `r`, such that the computation must not leak any mutable references\n-- | to the surrounding computation. It may cause problems to apply this\n-- | function using the `$` operator. The recommended approach is to use\n-- | parentheses instead.\nforeign import run :: forall a. (forall r. ST r a) -> a\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `while b m` is ST computation which runs the ST computation `b`. If its\n-- | result is `true`, it runs the ST computation `m` and loops. If not, the\n-- | computation ends.\nforeign import while :: forall r a. ST r Boolean -> ST r a -> ST r Unit\n\n-- | Loop over a consecutive collection of numbers\n-- |\n-- | `ST.for lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import for :: forall r a. Int -> Int -> (Int -> ST r a) -> ST r Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `ST.foreach xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreach :: forall r a. Array a -> (a -> ST r Unit) -> ST r Unit\n\n-- | The type `STRef r a` represents a mutable reference holding a value of\n-- | type `a`, which can be used with the `ST r` effect.\nforeign import data STRef :: Region -> Type -> Type\n\ntype role STRef nominal representational\n\n-- | Create a new mutable reference.\nforeign import new :: forall a r. a -> ST r (STRef r a)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall a r. STRef r a -> ST r a\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value, computing a new state value for the reference and\n-- | a return value.\nmodify' :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\nmodify' = modifyImpl\n\nforeign import modifyImpl :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\n\n-- | Modify the value of a mutable reference by applying a function to the\n-- | current value. The modified value is returned.\nmodify :: forall r a. (a -> a) -> STRef r a -> ST r a\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | Set the value of a mutable reference.\nforeign import write :: forall a r. a -> STRef r a -> ST r a\n","function newSTArray() {\n  return [];\n}\nexport { newSTArray as new };\n\nexport const peekImpl = function (just, nothing, i, xs) {\n  return i >= 0 && i < xs.length ? just(xs[i]) : nothing;\n};\n\nexport const pokeImpl = function (i, a, xs) {\n  var ret = i >= 0 && i < xs.length;\n  if (ret) xs[i] = a;\n  return ret;\n};\n\nexport const lengthImpl = function (xs) {\n  return xs.length;\n};\n\nexport const popImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.pop()) : nothing;\n};\n\nexport const pushAllImpl = function (as, xs) {\n  return xs.push.apply(xs, as);\n};\n\nexport const shiftImpl = function (just, nothing, xs) {\n  return xs.length > 0 ? just(xs.shift()) : nothing;\n};\n\nexport const unshiftAllImpl = function (as, xs) {\n  return xs.unshift.apply(xs, as);\n};\n\nexport const spliceImpl = function (i, howMany, bs, xs) {\n  return xs.splice.apply(xs, [i, howMany].concat(bs));\n};\n\nfunction unsafeFreezeThawImpl(xs) {\n  return xs;\n}\n\nexport const unsafeFreezeImpl = unsafeFreezeThawImpl;\n\nexport const unsafeThawImpl = unsafeFreezeThawImpl;\n\nfunction copyImpl(xs) {\n  return xs.slice();\n}\n\nexport const freezeImpl = copyImpl;\n\nexport const thawImpl = copyImpl;\n\nexport const cloneImpl = copyImpl;\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      } else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    if (xs.length < 2) return xs;\n\n    mergeFromTo(compare, fromOrdering, xs, xs.slice(0), 0, xs.length);\n\n    return xs;\n  };\n})();\n\nexport const toAssocArrayImpl = function (xs) {\n  var n = xs.length;\n  var as = new Array(n);\n  for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };\n  return as;\n};\n\nexport const pushImpl = function (a, xs) {\n  return xs.push(a);\n};\n","export const mkSTFn1 = function mkSTFn1(fn) {\n  return function(x) {\n    return fn(x)();\n  };\n};\n  \nexport const mkSTFn2 = function mkSTFn2(fn) {\n  return function(a, b) {\n    return fn(a)(b)();\n  };\n};\n  \nexport const mkSTFn3 = function mkSTFn3(fn) {\n  return function(a, b, c) {\n    return fn(a)(b)(c)();\n  };\n};\n  \nexport const mkSTFn4 = function mkSTFn4(fn) {\n  return function(a, b, c, d) {\n    return fn(a)(b)(c)(d)();\n  };\n};\n  \nexport const mkSTFn5 = function mkSTFn5(fn) {\n  return function(a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e)();\n  };\n};\n  \nexport const mkSTFn6 = function mkSTFn6(fn) {\n  return function(a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f)();\n  };\n};\n  \nexport const mkSTFn7 = function mkSTFn7(fn) {\n  return function(a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g)();\n  };\n};\n  \nexport const mkSTFn8 = function mkSTFn8(fn) {\n  return function(a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)();\n  };\n};\n  \nexport const mkSTFn9 = function mkSTFn9(fn) {\n  return function(a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)();\n  };\n};\n  \nexport const mkSTFn10 = function mkSTFn10(fn) {\n  return function(a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)();\n  };\n};\n  \nexport const runSTFn1 = function runSTFn1(fn) {\n  return function(a) {\n    return function() {\n      return fn(a);\n    };\n  };\n};\n  \nexport const runSTFn2 = function runSTFn2(fn) {\n  return function(a) {\n    return function(b) {\n      return function() {\n        return fn(a, b);\n      };\n    };\n  };\n};\n  \nexport const runSTFn3 = function runSTFn3(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function() {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn4 = function runSTFn4(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function() {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn5 = function runSTFn5(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function() {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn6 = function runSTFn6(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function() {\n                return fn(a, b, c, d, e, f);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn7 = function runSTFn7(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function() {\n                  return fn(a, b, c, d, e, f, g);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn8 = function runSTFn8(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function() {\n                    return fn(a, b, c, d, e, f, g, h);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn9 = function runSTFn9(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function() {\n                      return fn(a, b, c, d, e, f, g, h, i);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n  \nexport const runSTFn10 = function runSTFn10(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function(j) {\n                      return function() {\n                        return fn(a, b, c, d, e, f, g, h, i, j);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};","-- | Helper functions for working with mutable arrays using the `ST` effect.\n-- |\n-- | This module can be used when performance is important and mutation is a local effect.\n\nmodule Data.Array.ST\n  ( STArray(..)\n  , Assoc\n  , run\n  , withArray\n  , new\n  , peek\n  , poke\n  , modify\n  , length\n  , pop\n  , push\n  , pushAll\n  , shift\n  , unshift\n  , unshiftAll\n  , splice\n  , sort\n  , sortBy\n  , sortWith\n  , freeze\n  , thaw\n  , clone\n  , unsafeFreeze\n  , unsafeThaw\n  , toAssocArray\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST, Region)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Uncurried (STFn1, STFn2, STFn3, STFn4, runSTFn1, runSTFn2, runSTFn3, runSTFn4)\nimport Data.Maybe (Maybe(..))\n\n-- | A reference to a mutable array.\n-- |\n-- | The first type parameter represents the memory region which the array belongs to.\n-- | The second type parameter defines the type of elements of the mutable array.\n-- |\n-- | The runtime representation of a value of type `STArray h a` is the same as that of `Array a`,\n-- | except that mutation is allowed.\nforeign import data STArray :: Region -> Type -> Type\n\ntype role STArray nominal representational\n\n-- | An element and its index.\ntype Assoc a = { value :: a, index :: Int }\n\n-- | A safe way to create and work with a mutable array before returning an\n-- | immutable array for later perusal. This function avoids copying the array\n-- | before returning it - it uses unsafeFreeze internally, but this wrapper is\n-- | a safe interface to that function.\nrun :: forall a. (forall h. ST h (STArray h a)) -> Array a\nrun st = ST.run (st >>= unsafeFreeze)\n\n-- | Perform an effect requiring a mutable array on a copy of an immutable array,\n-- | safely returning the result as an immutable array.\nwithArray\n  :: forall h a b\n   . (STArray h a -> ST h b)\n  -> Array a\n  -> ST h (Array a)\nwithArray f xs = do\n  result <- thaw xs\n  _ <- f result\n  unsafeFreeze result\n\n-- | O(1). Convert a mutable array to an immutable array, without copying. The mutable\n-- | array must not be mutated afterwards.\nunsafeFreeze :: forall h a. STArray h a -> ST h (Array a)\nunsafeFreeze = runSTFn1 unsafeFreezeImpl\n\nforeign import unsafeFreezeImpl :: forall h a. STFn1 (STArray h a) h (Array a)\n\n-- | O(1) Convert an immutable array to a mutable array, without copying. The input\n-- | array must not be used afterward.\nunsafeThaw :: forall h a. Array a -> ST h (STArray h a)\nunsafeThaw = runSTFn1 unsafeThawImpl\n\nforeign import unsafeThawImpl :: forall h a. STFn1 (Array a) h (STArray h a)\n\n-- | Create a new, empty mutable array.\nforeign import new :: forall h a. ST h (STArray h a)\n\nthaw\n  :: forall h a\n   . Array a\n  -> ST h (STArray h a)\nthaw = runSTFn1 thawImpl\n\n-- | Create a mutable copy of an immutable array.\nforeign import thawImpl :: forall h a. STFn1 (Array a) h (STArray h a)\n\n-- | Make a mutable copy of a mutable array.\nclone\n  :: forall h a\n   . STArray h a\n  -> ST h (STArray h a)\nclone = runSTFn1 cloneImpl\n\nforeign import cloneImpl :: forall h a. STFn1 (STArray h a) h (STArray h a)\n\n-- | Sort a mutable array in place. Sorting is stable: the order of equal\n-- | elements is preserved.\nsort :: forall a h. Ord a => STArray h a -> ST h (STArray h a)\nsort = sortBy compare\n\n-- | Remove the first element from an array and return that element.\nshift :: forall h a. STArray h a -> ST h (Maybe a)\nshift = runSTFn3 shiftImpl Just Nothing\n\nforeign import shiftImpl\n  :: forall h a\n   . STFn3 (forall b. b -> Maybe b) (forall b. Maybe b) (STArray h a) h (Maybe a)\n\n-- | Sort a mutable array in place using a comparison function. Sorting is\n-- | stable: the order of elements is preserved if they are equal according to\n-- | the comparison function.\nsortBy\n  :: forall a h\n   . (a -> a -> Ordering)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortBy comp = runSTFn3 sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\nforeign import sortByImpl\n  :: forall a h\n   . STFn3 (a -> a -> Ordering) (Ordering -> Int) (STArray h a) h (STArray h a)\n\n-- | Sort a mutable array in place based on a projection. Sorting is stable: the\n-- | order of elements is preserved if they are equal according to the projection.\nsortWith\n  :: forall a b h\n   . Ord b\n  => (a -> b)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortWith f = sortBy (comparing f)\n\n-- | Create an immutable copy of a mutable array.\nfreeze\n  :: forall h a\n   . STArray h a\n  -> ST h (Array a)\nfreeze = runSTFn1 freezeImpl\n\nforeign import freezeImpl :: forall h a. STFn1 (STArray h a) h (Array a)\n\n-- | Read the value at the specified index in a mutable array.\npeek\n  :: forall h a\n   . Int\n  -> STArray h a\n  -> ST h (Maybe a)\npeek = runSTFn4 peekImpl Just Nothing\n\nforeign import peekImpl :: forall h a r. STFn4 (a -> r) r Int (STArray h a) h r\n\npoke\n  :: forall h a\n   . Int\n  -> a\n  -> STArray h a\n  -> ST h Boolean\npoke = runSTFn3 pokeImpl\n\n-- | Change the value at the specified index in a mutable array.\nforeign import pokeImpl :: forall h a. STFn3 Int a (STArray h a) h Boolean\n\nforeign import lengthImpl :: forall h a. STFn1 (STArray h a) h Int\n\n-- | Get the number of elements in a mutable array.\nlength :: forall h a. STArray h a -> ST h Int\nlength = runSTFn1 lengthImpl\n\n-- | Remove the last element from an array and return that element.\npop :: forall h a. STArray h a -> ST h (Maybe a)\npop = runSTFn3 popImpl Just Nothing\n\nforeign import popImpl\n  :: forall h a\n   . STFn3 (forall b. b -> Maybe b) (forall b. Maybe b) (STArray h a) h (Maybe a)\n\n-- | Append an element to the end of a mutable array. Returns the new length of\n-- | the array.\npush :: forall h a. a -> (STArray h a) -> ST h Int\npush = runSTFn2 pushImpl\n\nforeign import pushImpl :: forall h a. STFn2 a (STArray h a) h Int\n\n-- | Append the values in an immutable array to the end of a mutable array.\n-- | Returns the new length of the mutable array.\npushAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\npushAll = runSTFn2 pushAllImpl\n\nforeign import pushAllImpl\n  :: forall h a\n   . STFn2 (Array a) (STArray h a) h Int\n\n-- | Append an element to the front of a mutable array. Returns the new length of\n-- | the array.\nunshift :: forall h a. a -> STArray h a -> ST h Int\nunshift a = runSTFn2 unshiftAllImpl [ a ]\n\n-- | Append the values in an immutable array to the front of a mutable array.\n-- | Returns the new length of the mutable array.\nunshiftAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\nunshiftAll = runSTFn2 unshiftAllImpl\n\nforeign import unshiftAllImpl\n  :: forall h a\n   . STFn2 (Array a) (STArray h a) h Int\n\n-- | Mutate the element at the specified index using the supplied function.\nmodify :: forall h a. Int -> (a -> a) -> STArray h a -> ST h Boolean\nmodify i f xs = do\n  entry <- peek i xs\n  case entry of\n    Just x -> poke i (f x) xs\n    Nothing -> pure false\n\n-- | Remove and/or insert elements from/into a mutable array at the specified index.\nsplice\n  :: forall h a\n   . Int\n  -> Int\n  -> Array a\n  -> STArray h a\n  -> ST h (Array a)\nsplice = runSTFn4 spliceImpl\n\nforeign import spliceImpl\n  :: forall h a\n   . STFn4 Int Int (Array a) (STArray h a) h (Array a)\n\n-- | Create an immutable copy of a mutable array, where each element\n-- | is labelled with its index in the original array.\ntoAssocArray\n  :: forall h a\n   . STArray h a\n  -> ST h (Array (Assoc a))\ntoAssocArray = runSTFn1 toAssocArrayImpl\n\nforeign import toAssocArrayImpl\n  :: forall h a\n   . STFn1 (STArray h a) h (Array (Assoc a))\n","export const foldrArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n      }\n      return acc;\n    };\n  };\n};\n\nexport const foldlArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n      }\n      return acc;\n    };\n  };\n};\n","module Control.Plus\n  ( class Plus, empty\n  , module Control.Alt\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Plus` type class extends the `Alt` type class with a value that\n-- | should be the left and right identity for `(<|>)`.\n-- |\n-- | It is similar to `Monoid`, except that it applies to types of\n-- | kind `* -> *`, like `Array` or `List`, rather than concrete types like\n-- | `String` or `Number`.\n-- |\n-- | `Plus` instances should satisfy the following laws:\n-- |\n-- | - Left identity: `empty <|> x == x`\n-- | - Right identity: `x <|> empty == x`\n-- | - Annihilation: `f <$> empty == empty`\nclass Alt f <= Plus f where\n  empty :: forall a. f a\n\ninstance plusArray :: Plus Array where\n  empty = []\n","module Data.Bifunctor where\n\nimport Control.Category (identity)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Tuple (Tuple(..))\n\n-- | A `Bifunctor` is a `Functor` from the pair category `(Type, Type)` to `Type`.\n-- |\n-- | A type constructor with two type arguments can be made into a `Bifunctor` if\n-- | both of its type arguments are covariant.\n-- |\n-- | The `bimap` function maps a pair of functions over the two type arguments\n-- | of the bifunctor.\n-- |\n-- | Laws:\n-- |\n-- | - Identity: `bimap identity identity == identity`\n-- | - Composition: `bimap f1 g1 <<< bimap f2 g2 == bimap (f1 <<< f2) (g1 <<< g2)`\n-- |\nclass Bifunctor f where\n  bimap :: forall a b c d. (a -> b) -> (c -> d) -> f a c -> f b d\n\n-- | Map a function over the first type argument of a `Bifunctor`.\nlmap :: forall f a b c. Bifunctor f => (a -> b) -> f a c -> f b c\nlmap f = bimap f identity\n\n-- | Map a function over the second type arguments of a `Bifunctor`.\nrmap :: forall f a b c. Bifunctor f => (b -> c) -> f a b -> f a c\nrmap = bimap identity\n\ninstance bifunctorEither :: Bifunctor Either where\n  bimap f _ (Left l) = Left (f l)\n  bimap _ g (Right r) = Right (g r)\n\ninstance bifunctorTuple :: Bifunctor Tuple where\n  bimap f g (Tuple x y) = Tuple (f x) (g y)\n\ninstance bifunctorConst :: Bifunctor Const where\n  bimap f _ (Const a) = Const (f a)\n","// module Unsafe.Coerce\n\nexport const unsafeCoerce = function (x) {\n  return x;\n};\n","module Safe.Coerce\n  ( module Prim.Coerce\n  , coerce\n  ) where\n\nimport Prim.Coerce (class Coercible)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Coerce a value of one type to a value of some other type, without changing\n-- | its runtime representation. This function behaves identically to\n-- | `unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n-- | `Coercible` constraint prevents any use of this function from compiling\n-- | unless the compiler can prove that the two types have the same runtime\n-- | representation.\n-- |\n-- | One application for this function is to avoid doing work that you know is a\n-- | no-op because of newtypes. For example, if you have an `Array (Conj a)` and you\n-- | want an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\n-- | this performs an unnecessary traversal of the array, with O(n) cost.\n-- | `coerce` accomplishes the same with only O(1) cost:\n-- |\n-- | ```purescript\n-- | mapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\n-- | mapConjToDisj = coerce\n-- | ```\ncoerce :: forall a b. Coercible a b => a -> b\ncoerce = unsafeCoerce\n","module Data.Newtype where\n\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Semigroup.First (First(..))\nimport Data.Semigroup.Last (Last(..))\nimport Safe.Coerce (class Coercible, coerce)\n\n-- | A type class for `newtype`s to enable convenient wrapping and unwrapping,\n-- | and the use of the other functions in this module.\n-- |\n-- | The compiler can derive instances of `Newtype` automatically:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- |\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- | ```\n-- |\n-- | Note that deriving for `Newtype` instances requires that the type be\n-- | defined as `newtype` rather than `data` declaration (even if the `data`\n-- | structurally fits the rules of a `newtype`), and the use of a wildcard for\n-- | the wrapped type.\nclass Newtype :: Type -> Type -> Constraint\nclass Coercible t a <= Newtype t a | t -> a\n\nwrap :: forall t a. Newtype t a => a -> t\nwrap = coerce\n\nunwrap :: forall t a. Newtype t a => t -> a\nunwrap = coerce\n\ninstance newtypeAdditive :: Newtype (Additive a) a\n\ninstance newtypeMultiplicative :: Newtype (Multiplicative a) a\n\ninstance newtypeConj :: Newtype (Conj a) a\n\ninstance newtypeDisj :: Newtype (Disj a) a\n\ninstance newtypeDual :: Newtype (Dual a) a\n\ninstance newtypeEndo :: Newtype (Endo c a) (c a a)\n\ninstance newtypeFirst :: Newtype (First a) a\n\ninstance newtypeLast :: Newtype (Last a) a\n\n-- | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`\n-- | function.\nun :: forall t a. Newtype t a => (a -> t) -> t -> a\nun _ = unwrap\n\n-- | This combinator unwraps the newtype, applies a monomorphic function to the \n-- | contained value and wraps the result back in the newtype\nmodify :: forall t a. Newtype t a => (a -> a) -> t -> t\nmodify fn t = wrap (fn (unwrap t))\n\n-- | This combinator is for when you have a higher order function that you want\n-- | to use in the context of some newtype - `foldMap` being a common example:\n-- |\n-- | ``` purescript\n-- | ala Additive foldMap [1,2,3,4] -- 10\n-- | ala Multiplicative foldMap [1,2,3,4] -- 24\n-- | ala Conj foldMap [true, false] -- false\n-- | ala Disj foldMap [true, false] -- true\n-- | ```\nala\n  :: forall f t a s b\n   . Coercible (f t) (f a)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> ((b -> s) -> f t)\n  -> f a\nala _ f = coerce (f wrap)\n\n-- | Similar to `ala` but useful for cases where you want to use an additional\n-- | projection with the higher order function:\n-- |\n-- | ``` purescript\n-- | alaF Additive foldMap String.length [\"hello\", \"world\"] -- 10\n-- | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0\n-- | ```\n-- |\n-- | The type admits other possibilities due to the polymorphic `Functor`\n-- | constraints, but the case described above works because ((->) a) is a\n-- | `Functor`.\nalaF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nalaF _ = coerce\n\n-- | Lifts a function operate over newtypes. This can be used to lift a\n-- | function to manipulate the contents of a single newtype, somewhat like\n-- | `map` does for a `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype Label = Label String\n-- | derive instance newtypeLabel :: Newtype Label _\n-- |\n-- | toUpperLabel :: Label -> Label\n-- | toUpperLabel = over Label String.toUpper\n-- | ```\n-- |\n-- | But the result newtype is polymorphic, meaning the result can be returned\n-- | as an alternative newtype:\n-- |\n-- | ``` purescript\n-- | newtype UppercaseLabel = UppercaseLabel String\n-- | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _\n-- |\n-- | toUpperLabel' :: Label -> UppercaseLabel\n-- | toUpperLabel' = over Label String.toUpper\n-- | ```\nover\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> b)\n  -> t\n  -> s\nover _ = coerce\n\n-- | Much like `over`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | findLabel :: String -> Array Label -> Maybe Label\n-- | findLabel s = overF Label (Foldable.find (_ == s))\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\noverF\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> g b)\n  -> f t\n  -> g s\noverF _ = coerce\n\n-- | The opposite of `over`: lowers a function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\n-- |\n-- | ``` purescript\n-- | newtype Degrees = Degrees Number\n-- | derive instance newtypeDegrees :: Newtype Degrees _\n-- |\n-- | newtype NormalDegrees = NormalDegrees Number\n-- | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _\n-- |\n-- | normaliseDegrees :: Degrees -> NormalDegrees\n-- | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)\n-- |\n-- | asNormalDegrees :: Number -> Number\n-- | asNormalDegrees = under Degrees normaliseDegrees\n-- | ```\n-- |\n-- | As with `over` the `Newtype` is polymorphic, as illustrated in the example\n-- | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,\n-- | so even though `normaliseDegrees` changes the result type we can still put\n-- | a `Number` in and get a `Number` out via `under`.\nunder\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> s)\n  -> a\n  -> b\nunder _ = coerce\n\n-- | Much like `under`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- |\n-- | isValid :: EmailAddress -> Boolean\n-- | isValid x = false -- imagine a slightly less strict predicate here\n-- |\n-- | findValidEmailString :: Array String -> Maybe String\n-- | findValidEmailString = underF EmailAddress (Foldable.find isValid)\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\nunderF\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nunderF _ = coerce\n\n-- | Lifts a binary function to operate over newtypes.\n-- |\n-- | ``` purescript\n-- | newtype Meter = Meter Int\n-- | derive newtype instance newtypeMeter :: Newtype Meter _\n-- | newtype SquareMeter = SquareMeter Int\n-- | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _\n-- |\n-- | area :: Meter -> Meter -> SquareMeter\n-- | area = over2 Meter (*)\n-- | ```\n-- |\n-- | The above example also demonstrates that the return type is polymorphic\n-- | here too.\nover2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> a -> b)\n  -> t\n  -> t\n  -> s\nover2 _ = coerce\n\n-- | Much like `over2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\noverF2\n  :: forall f g t a s b\n   . Coercible (f a) (f t)\n  => Coercible (g b) (g s)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> f a -> g b)\n  -> f t\n  -> f t\n  -> g s\noverF2 _ = coerce\n\n-- | The opposite of `over2`: lowers a binary function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\nunder2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> t -> s)\n  -> a\n  -> a\n  -> b\nunder2 _ = coerce\n\n-- | Much like `under2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\nunderF2\n  :: forall f g t a s b\n   . Coercible (f t) (f a)\n  => Coercible (g s) (g b)\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> f t -> g s)\n  -> f a\n  -> f a\n  -> g b\nunderF2 _ = coerce\n\n-- | Similar to the function from the `Traversable` class, but operating within\n-- | a newtype instead.\ntraverse\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (a -> f a)\n  -> t\n  -> f t\ntraverse _ = coerce\n\n-- | Similar to the function from the `Distributive` class, but operating within\n-- | a newtype instead.\ncollect\n  :: forall f t a\n   . Coercible (f a) (f t)\n  => Newtype t a\n  => (a -> t)\n  -> (f a -> a)\n  -> f t\n  -> t\ncollect _ = coerce\n","module Data.Foldable\n  ( class Foldable, foldr, foldl, foldMap\n  , foldrDefault, foldlDefault, foldMapDefaultL, foldMapDefaultR\n  , fold\n  , foldM\n  , traverse_\n  , for_\n  , sequence_\n  , oneOf\n  , oneOfMap\n  , intercalate\n  , surroundMap\n  , surround\n  , and\n  , or\n  , all\n  , any\n  , sum\n  , product\n  , elem\n  , notElem\n  , indexl\n  , indexr\n  , find\n  , findMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  , null\n  , length\n  , lookup\n  ) where\n\nimport Prelude\n\nimport Control.Plus (class Plus, alt, empty)\nimport Data.Const (Const)\nimport Data.Either (Either(..))\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct, coproduct)\nimport Data.Functor.Product (Product(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (alaF, unwrap)\nimport Data.Tuple (Tuple(..))\n\n-- | `Foldable` represents data structures which can be _folded_.\n-- |\n-- | - `foldr` folds a structure from the right\n-- | - `foldl` folds a structure from the left\n-- | - `foldMap` folds a structure by accumulating values in a `Monoid`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrDefault`\n-- | - `foldlDefault`\n-- | - `foldMapDefaultR`\n-- | - `foldMapDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f where\n  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n\n-- | A default implementation of `foldr` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultR`.\nfoldrDefault\n  :: forall f a b\n   . Foldable f\n  => (a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrDefault c u xs = unwrap (foldMap (Endo <<< c) xs) u\n\n-- | A default implementation of `foldl` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultL`.\nfoldlDefault\n  :: forall f a b\n   . Foldable f\n  => (b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlDefault c u xs = unwrap (unwrap (foldMap (Dual <<< Endo <<< flip c) xs)) u\n\n-- | A default implementation of `foldMap` using `foldr`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldrDefault`.\nfoldMapDefaultR\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultR f = foldr (\\x acc -> f x <> acc) mempty\n\n-- | A default implementation of `foldMap` using `foldl`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldlDefault`.\nfoldMapDefaultL\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultL f = foldl (\\acc x -> acc <> f x) mempty\n\ninstance foldableArray :: Foldable Array where\n  foldr = foldrArray\n  foldl = foldlArray\n  foldMap = foldMapDefaultR\n\nforeign import foldrArray :: forall a b. (a -> b -> b) -> b -> Array a -> b\nforeign import foldlArray :: forall a b. (b -> a -> b) -> b -> Array a -> b\n\ninstance foldableMaybe :: Foldable Maybe where\n  foldr _ z Nothing  = z\n  foldr f z (Just x) = x `f` z\n  foldl _ z Nothing  = z\n  foldl f z (Just x) = z `f` x\n  foldMap _ Nothing  = mempty\n  foldMap f (Just x) = f x\n\ninstance foldableFirst :: Foldable First where\n  foldr f z (First x) = foldr f z x\n  foldl f z (First x) = foldl f z x\n  foldMap f (First x) = foldMap f x\n\ninstance foldableLast :: Foldable Last where\n  foldr f z (Last x) = foldr f z x\n  foldl f z (Last x) = foldl f z x\n  foldMap f (Last x) = foldMap f x\n\ninstance foldableAdditive :: Foldable Additive where\n  foldr f z (Additive x) = x `f` z\n  foldl f z (Additive x) = z `f` x\n  foldMap f (Additive x) = f x\n\ninstance foldableDual :: Foldable Dual where\n  foldr f z (Dual x) = x `f` z\n  foldl f z (Dual x) = z `f` x\n  foldMap f (Dual x) = f x\n\ninstance foldableDisj :: Foldable Disj where\n  foldr f z (Disj x) = f x z\n  foldl f z (Disj x) = f z x\n  foldMap f (Disj x) = f x\n\ninstance foldableConj :: Foldable Conj where\n  foldr f z (Conj x) = f x z\n  foldl f z (Conj x) = f z x\n  foldMap f (Conj x) = f x\n\ninstance foldableMultiplicative :: Foldable Multiplicative where\n  foldr f z (Multiplicative x) = x `f` z\n  foldl f z (Multiplicative x) = z `f` x\n  foldMap f (Multiplicative x) = f x\n\ninstance foldableEither :: Foldable (Either a) where\n  foldr _ z (Left _)  = z\n  foldr f z (Right x) = f x z\n  foldl _ z (Left _)  = z\n  foldl f z (Right x) = f z x\n  foldMap _ (Left _)  = mempty\n  foldMap f (Right x) = f x\n\ninstance foldableTuple :: Foldable (Tuple a) where\n  foldr f z (Tuple _ x) = f x z\n  foldl f z (Tuple _ x) = f z x\n  foldMap f (Tuple _ x) = f x\n\ninstance foldableIdentity :: Foldable Identity where\n  foldr f z (Identity x) = f x z\n  foldl f z (Identity x) = f z x\n  foldMap f (Identity x) = f x\n\ninstance foldableConst :: Foldable (Const a) where\n  foldr _ z _ = z\n  foldl _ z _ = z\n  foldMap _ _ = mempty\n\ninstance foldableProduct :: (Foldable f, Foldable g) => Foldable (Product f g) where\n  foldr f z (Product (Tuple fa ga)) = foldr f (foldr f z ga) fa\n  foldl f z (Product (Tuple fa ga)) = foldl f (foldl f z fa) ga\n  foldMap f (Product (Tuple fa ga)) = foldMap f fa <> foldMap f ga\n\ninstance foldableCoproduct :: (Foldable f, Foldable g) => Foldable (Coproduct f g) where\n  foldr f z = coproduct (foldr f z) (foldr f z)\n  foldl f z = coproduct (foldl f z) (foldl f z)\n  foldMap f = coproduct (foldMap f) (foldMap f)\n\ninstance foldableCompose :: (Foldable f, Foldable g) => Foldable (Compose f g) where\n  foldr f i (Compose fga) = foldr (flip (foldr f)) i fga\n  foldl f i (Compose fga) = foldl (foldl f) i fga\n  foldMap f (Compose fga) = foldMap (foldMap f) fga\n\ninstance foldableApp :: Foldable f => Foldable (App f) where\n  foldr f i (App x) = foldr f i x\n  foldl f i (App x) = foldl f i x\n  foldMap f (App x) = foldMap f x\n\n-- | Fold a data structure, accumulating values in some `Monoid`.\nfold :: forall f m. Foldable f => Monoid m => f m -> m\nfold = foldMap identity\n\n-- | Similar to 'foldl', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldM :: forall f m a b. Foldable f => Monad m => (b -> a -> m b) -> b -> f a -> m b\nfoldM f b0 = foldl (\\b a -> b >>= flip f a) (pure b0)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Applicative` functor at each value, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | traverse_ print [1, 2, 3]\n-- | ```\ntraverse_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => (a -> m b)\n  -> f a\n  -> m Unit\ntraverse_ f = foldr ((*>) <<< f) (pure unit)\n\n-- | A version of `traverse_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for_ [1, 2, 3] \\n -> do\n-- |   print n\n-- |   trace \"squared is\"\n-- |   print (n * n)\n-- | ```\nfor_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => f a\n  -> (a -> m b)\n  -> m Unit\nfor_ = flip traverse_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable` instance, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | sequence_ [ trace \"Hello, \", trace \" world!\" ]\n-- | ```\nsequence_ :: forall a f m. Applicative m => Foldable f => f (m a) -> m Unit\nsequence_ = traverse_ identity\n\n-- | Combines a collection of elements using the `Alt` operation.\noneOf :: forall f g a. Foldable f => Plus g => f (g a) -> g a\noneOf = foldr alt empty\n\n-- | Folds a structure into some `Plus`.\noneOfMap :: forall f g a b. Foldable f => Plus g => (a -> g b) -> f a -> g b\noneOfMap f = foldr (alt <<< f) empty\n\n-- | Fold a data structure, accumulating values in some `Monoid`,\n-- | combining adjacent elements using the specified separator.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > intercalate \", \" [\"Lorem\", \"ipsum\", \"dolor\"]\n-- | = \"Lorem, ipsum, dolor\"\n-- |\n-- | > intercalate \"*\" [\"a\", \"b\", \"c\"]\n-- | = \"a*b*c\"\n-- |\n-- | > intercalate [1] [[2, 3], [4, 5], [6, 7]]\n-- | = [2, 3, 1, 4, 5, 1, 6, 7]\n-- | ```\nintercalate :: forall f m. Foldable f => Monoid m => m -> f m -> m\nintercalate sep xs = (foldl go { init: true, acc: mempty } xs).acc\n  where\n  go { init: true } x = { init: false, acc: x }\n  go { acc: acc }   x = { init: false, acc: acc <> sep <> x }\n\n-- | `foldMap` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMap \"*\" show []\n-- | = \"*\"\n-- |\n-- | > surroundMap \"*\" show [1]\n-- | = \"*1*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2]\n-- | = \"*1*2*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2, 3]\n-- | = \"*1*2*3*\"\n-- | ```\nsurroundMap :: forall f a m. Foldable f => Semigroup m => m -> (a -> m) -> f a -> m\nsurroundMap d t f = unwrap (foldMap joined f) d\n  where joined a = Endo \\m -> d <> t a <> m\n\n-- | `fold` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surround \"*\" []\n-- | = \"*\"\n-- |\n-- | > surround \"*\" [\"1\"]\n-- | = \"*1*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\"]\n-- | = \"*1*2*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\", \"3\"]\n-- | = \"*1*2*3*\"\n-- | ```\nsurround :: forall f m. Foldable f => Semigroup m => m -> f m -> m\nsurround d = surroundMap d identity\n\n-- | The conjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether all of the values in a data\n-- | structure are `true`.\nand :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nand = all identity\n\n-- | The disjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether any of the values in a data\n-- | structure is `true`.\nor :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nor = any identity\n\n-- | `all f` is the same as `and <<< map f`; map a function over the structure,\n-- | and then get the conjunction of the results.\nall :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nall  = alaF Conj foldMap\n\n-- | `any f` is the same as `or <<< map f`; map a function over the structure,\n-- | and then get the disjunction of the results.\nany :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nany = alaF Disj foldMap\n\n-- | Find the sum of the numeric values in a data structure.\nsum :: forall a f. Foldable f => Semiring a => f a -> a\nsum = foldl (+) zero\n\n-- | Find the product of the numeric values in a data structure.\nproduct :: forall a f. Foldable f => Semiring a => f a -> a\nproduct = foldl (*) one\n\n-- | Test whether a value is an element of a data structure.\nelem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nelem = any <<< (==)\n\n-- | Test whether a value is not an element of a data structure.\nnotElem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nnotElem x = not <<< elem x\n\n-- | Try to get nth element from the left in a data structure\nindexl :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexl idx = _.elem <<< foldl go { elem: Nothing, pos: 0 }\n  where\n  go cursor a =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to get nth element from the right in a data structure\nindexr :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexr idx = _.elem <<< foldr go { elem: Nothing, pos: 0 }\n  where\n  go a cursor =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to find an element in a data structure which satisfies a predicate.\nfind :: forall a f. Foldable f => (a -> Boolean) -> f a -> Maybe a\nfind p = foldl go Nothing\n  where\n  go Nothing x | p x = Just x\n  go r _ = r\n\n-- | Try to find an element in a data structure which satisfies a predicate mapping.\nfindMap :: forall a b f. Foldable f => (a -> Maybe b) -> f a -> Maybe b\nfindMap p = foldl go Nothing\n  where\n  go Nothing x = p x\n  go r _ = r\n\n-- | Find the largest element of a structure, according to its `Ord` instance.\nmaximum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nmaximum = maximumBy compare\n\n-- | Find the largest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nmaximumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nmaximumBy cmp = foldl max' Nothing\n  where\n  max' Nothing x  = Just x\n  max' (Just x) y = Just (if cmp x y == GT then x else y)\n\n-- | Find the smallest element of a structure, according to its `Ord` instance.\nminimum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nminimum = minimumBy compare\n\n-- | Find the smallest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nminimumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nminimumBy cmp = foldl min' Nothing\n  where\n  min' Nothing x  = Just x\n  min' (Just x) y = Just (if cmp x y == LT then x else y)\n\n-- | Test whether the structure is empty.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nnull :: forall a f. Foldable f => f a -> Boolean\nnull = foldr (\\_ _ -> false) true\n\n-- | Returns the size/length of a finite structure.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nlength :: forall a b f. Foldable f => Semiring b => f a -> b\nlength = foldl (\\c _ -> add one c) zero\n\n-- | Lookup a value in a data structure of `Tuple`s, generalizing association lists.\nlookup :: forall a b f. Foldable f => Eq a => a -> f (Tuple a b) -> Maybe b\nlookup a = unwrap <<< foldMap \\(Tuple a' b) -> First (if a == a' then Just b else Nothing)\n","// module Data.Function.Uncurried\n\nexport const mkFn0 = function (fn) {\n  return function () {\n    return fn();\n  };\n};\n\nexport const mkFn2 = function (fn) {\n  /* jshint maxparams: 2 */\n  return function (a, b) {\n    return fn(a)(b);\n  };\n};\n\nexport const mkFn3 = function (fn) {\n  /* jshint maxparams: 3 */\n  return function (a, b, c) {\n    return fn(a)(b)(c);\n  };\n};\n\nexport const mkFn4 = function (fn) {\n  /* jshint maxparams: 4 */\n  return function (a, b, c, d) {\n    return fn(a)(b)(c)(d);\n  };\n};\n\nexport const mkFn5 = function (fn) {\n  /* jshint maxparams: 5 */\n  return function (a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e);\n  };\n};\n\nexport const mkFn6 = function (fn) {\n  /* jshint maxparams: 6 */\n  return function (a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f);\n  };\n};\n\nexport const mkFn7 = function (fn) {\n  /* jshint maxparams: 7 */\n  return function (a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g);\n  };\n};\n\nexport const mkFn8 = function (fn) {\n  /* jshint maxparams: 8 */\n  return function (a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h);\n  };\n};\n\nexport const mkFn9 = function (fn) {\n  /* jshint maxparams: 9 */\n  return function (a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i);\n  };\n};\n\nexport const mkFn10 = function (fn) {\n  /* jshint maxparams: 10 */\n  return function (a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j);\n  };\n};\n\nexport const runFn0 = function (fn) {\n  return fn();\n};\n\nexport const runFn2 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return fn(a, b);\n    };\n  };\n};\n\nexport const runFn3 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return fn(a, b, c);\n      };\n    };\n  };\n};\n\nexport const runFn4 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return fn(a, b, c, d);\n        };\n      };\n    };\n  };\n};\n\nexport const runFn5 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return fn(a, b, c, d, e);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn6 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return fn(a, b, c, d, e, f);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn7 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return fn(a, b, c, d, e, f, g);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn8 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return fn(a, b, c, d, e, f, g, h);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn9 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return fn(a, b, c, d, e, f, g, h, i);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn10 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return function (j) {\n                      return fn(a, b, c, d, e, f, g, h, i, j);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n","export const mapWithIndexArray = function (f) {\n  return function (xs) {\n    var l = xs.length;\n    var result = Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(i)(xs[i]);\n    }\n    return result;\n  };\n};\n","module Data.Monoid.Additive where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup for semirings under addition.\n-- |\n-- | ``` purescript\n-- | Additive x <> Additive y == Additive (x + y)\n-- | (mempty :: Additive _) == Additive zero\n-- | ```\nnewtype Additive a = Additive a\n\nderive newtype instance eqAdditive :: Eq a => Eq (Additive a)\nderive instance eq1Additive :: Eq1 Additive\n\nderive newtype instance ordAdditive :: Ord a => Ord (Additive a)\nderive instance ord1Additive :: Ord1 Additive\n\nderive newtype instance boundedAdditive :: Bounded a => Bounded (Additive a)\n\ninstance showAdditive :: Show a => Show (Additive a) where\n  show (Additive a) = \"(Additive \" <> show a <> \")\"\n\nderive instance functorAdditive :: Functor Additive\n\ninstance applyAdditive :: Apply Additive where\n  apply (Additive f) (Additive x) = Additive (f x)\n\ninstance applicativeAdditive :: Applicative Additive where\n  pure = Additive\n\ninstance bindAdditive :: Bind Additive where\n  bind (Additive x) f = f x\n\ninstance monadAdditive :: Monad Additive\n\ninstance semigroupAdditive :: Semiring a => Semigroup (Additive a) where\n  append (Additive a) (Additive b) = Additive (a + b)\n\ninstance monoidAdditive :: Semiring a => Monoid (Additive a) where\n  mempty = Additive zero\n","module Data.FunctorWithIndex\n  ( class FunctorWithIndex, mapWithIndex, mapDefault\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (bimap)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..))\nimport Data.Functor.Product (Product(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe)\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj)\nimport Data.Monoid.Disj (Disj)\nimport Data.Monoid.Dual (Dual)\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Tuple (Tuple, curry)\n\n-- | A `Functor` with an additional index.\n-- | Instances must satisfy a modified form of the `Functor` laws\n-- | ```purescript\n-- | mapWithIndex (\\_ a -> a) = identity\n-- | mapWithIndex f . mapWithIndex g = mapWithIndex (\\i -> f i <<< g i)\n-- | ```\n-- | and be compatible with the `Functor` instance\n-- | ```purescript\n-- | map f = mapWithIndex (const f)\n-- | ```\nclass Functor f <= FunctorWithIndex i f | f -> i where\n  mapWithIndex :: forall a b. (i -> a -> b) -> f a -> f b\n\nforeign import mapWithIndexArray :: forall a b. (Int -> a -> b) -> Array a -> Array b\n\ninstance functorWithIndexArray :: FunctorWithIndex Int Array where\n  mapWithIndex = mapWithIndexArray\n\ninstance functorWithIndexMaybe :: FunctorWithIndex Unit Maybe where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexFirst :: FunctorWithIndex Unit First where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexLast :: FunctorWithIndex Unit Last where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexAdditive :: FunctorWithIndex Unit Additive where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexDual :: FunctorWithIndex Unit Dual where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexConj :: FunctorWithIndex Unit Conj where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexDisj :: FunctorWithIndex Unit Disj where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexMultiplicative :: FunctorWithIndex Unit Multiplicative where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexEither :: FunctorWithIndex Unit (Either a) where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexTuple :: FunctorWithIndex Unit (Tuple a) where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexIdentity :: FunctorWithIndex Unit Identity where\n  mapWithIndex f (Identity a) = Identity (f unit a)\n\ninstance functorWithIndexConst :: FunctorWithIndex Void (Const a) where\n  mapWithIndex _ (Const x) = Const x\n\ninstance functorWithIndexProduct :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Either a b) (Product f g) where\n  mapWithIndex f (Product fga) = Product (bimap (mapWithIndex (f <<< Left)) (mapWithIndex (f <<< Right)) fga)\n\ninstance functorWithIndexCoproduct :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Either a b) (Coproduct f g) where\n  mapWithIndex f (Coproduct e) = Coproduct (bimap (mapWithIndex (f <<< Left)) (mapWithIndex (f <<< Right)) e)\n\ninstance functorWithIndexCompose :: (FunctorWithIndex a f, FunctorWithIndex b g) => FunctorWithIndex (Tuple a b) (Compose f g) where\n  mapWithIndex f (Compose fga) = Compose $ mapWithIndex (mapWithIndex <<< curry f) fga\n\ninstance functorWithIndexApp :: FunctorWithIndex a f => FunctorWithIndex a (App f) where\n  mapWithIndex f (App x) = App $ mapWithIndex f x\n\n-- | A default implementation of Functor's `map` in terms of `mapWithIndex`\nmapDefault :: forall i f a b. FunctorWithIndex i f => (a -> b) -> f a -> f b\nmapDefault f = mapWithIndex (const f)\n","// jshint maxparams: 3\n\nexport const traverseArrayImpl = (function () {\n  function array1(a) {\n    return [a];\n  }\n\n  function array2(a) {\n    return function (b) {\n      return [a, b];\n    };\n  }\n\n  function array3(a) {\n    return function (b) {\n      return function (c) {\n        return [a, b, c];\n      };\n    };\n  }\n\n  function concat2(xs) {\n    return function (ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (pure) {\n        return function (f) {\n          return function (array) {\n            function go(bot, top) {\n              switch (top - bot) {\n              case 0: return pure([]);\n              case 1: return map(array1)(f(array[bot]));\n              case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));\n              case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));\n              default:\n                // This slightly tricky pivot selection aims to produce two\n                // even-length partitions where possible.\n                var pivot = bot + Math.floor((top - bot) / 4) * 2;\n                return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));\n              }\n            }\n            return go(0, array.length);\n          };\n        };\n      };\n    };\n  };\n})();\n","module Data.Traversable\n  ( class Traversable, traverse, sequence\n  , traverseDefault, sequenceDefault\n  , for\n  , scanl\n  , scanr\n  , mapAccumL\n  , mapAccumR\n  , module Data.Foldable\n  , module Data.Traversable.Accum\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Foldable (class Foldable, all, and, any, elem, find, fold, foldMap, foldMapDefaultL, foldMapDefaultR, foldl, foldlDefault, foldr, foldrDefault, for_, intercalate, maximum, maximumBy, minimum, minimumBy, notElem, oneOf, or, sequence_, sum, traverse_)\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..), coproduct)\nimport Data.Functor.Product (Product(..), product)\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Traversable.Accum (Accum)\nimport Data.Traversable.Accum.Internal (StateL(..), StateR(..), stateL, stateR)\nimport Data.Tuple (Tuple(..))\n\n-- | `Traversable` represents data structures which can be _traversed_,\n-- | accumulating results and effects in some `Applicative` functor.\n-- |\n-- | - `traverse` runs an action for every element in a data structure,\n-- |   and accumulates the results.\n-- | - `sequence` runs the actions _contained_ in a data structure,\n-- |   and accumulates the results.\n-- |\n-- | ```purescript\n-- | import Data.Traversable\n-- | import Data.Maybe\n-- | import Data.Int (fromNumber)\n-- |\n-- | sequence [Just 1, Just 2, Just 3] == Just [1,2,3]\n-- | sequence [Nothing, Just 2, Just 3] == Nothing\n-- |\n-- | traverse fromNumber [1.0, 2.0, 3.0] == Just [1,2,3]\n-- | traverse fromNumber [1.5, 2.0, 3.0] == Nothing\n-- |\n-- | traverse logShow [1,2,3]\n-- | -- prints:\n-- |    1\n-- |    2\n-- |    3\n-- |\n-- | traverse (\\x -> [x, 0]) [1,2,3] == [[1,2,3],[1,2,0],[1,0,3],[1,0,0],[0,2,3],[0,2,0],[0,0,3],[0,0,0]]\n-- | ```\n-- |\n-- | The `traverse` and `sequence` functions should be compatible in the\n-- | following sense:\n-- |\n-- | - `traverse f xs = sequence (f <$> xs)`\n-- | - `sequence = traverse identity`\n-- |\n-- | `Traversable` instances should also be compatible with the corresponding\n-- | `Foldable` instances, in the following sense:\n-- |\n-- | - `foldMap f = runConst <<< traverse (Const <<< f)`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `traverseDefault`\n-- | - `sequenceDefault`\nclass (Functor t, Foldable t) <= Traversable t where\n  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n\n-- | A default implementation of `traverse` using `sequence` and `map`.\ntraverseDefault\n  :: forall t a b m\n   . Traversable t\n  => Applicative m\n  => (a -> m b)\n  -> t a\n  -> m (t b)\ntraverseDefault f ta = sequence (f <$> ta)\n\n-- | A default implementation of `sequence` using `traverse`.\nsequenceDefault\n  :: forall t a m\n   . Traversable t\n  => Applicative m\n  => t (m a)\n  -> m (t a)\nsequenceDefault = traverse identity\n\ninstance traversableArray :: Traversable Array where\n  traverse = traverseArrayImpl apply map pure\n  sequence = sequenceDefault\n\nforeign import traverseArrayImpl\n  :: forall m a b\n   . (forall x y. m (x -> y) -> m x -> m y)\n  -> (forall x y. (x -> y) -> m x -> m y)\n  -> (forall x. x -> m x)\n  -> (a -> m b)\n  -> Array a\n  -> m (Array b)\n\ninstance traversableMaybe :: Traversable Maybe where\n  traverse _ Nothing  = pure Nothing\n  traverse f (Just x) = Just <$> f x\n  sequence Nothing  = pure Nothing\n  sequence (Just x) = Just <$> x\n\ninstance traversableFirst :: Traversable First where\n  traverse f (First x) = First <$> traverse f x\n  sequence (First x) = First <$> sequence x\n\ninstance traversableLast :: Traversable Last where\n  traverse f (Last x) = Last <$> traverse f x\n  sequence (Last x) = Last <$> sequence x\n\ninstance traversableAdditive :: Traversable Additive where\n  traverse f (Additive x) = Additive <$> f x\n  sequence (Additive x) = Additive <$> x\n\ninstance traversableDual :: Traversable Dual where\n  traverse f (Dual x) = Dual <$> f x\n  sequence (Dual x) = Dual <$> x\n\ninstance traversableConj :: Traversable Conj where\n  traverse f (Conj x) = Conj <$> f x\n  sequence (Conj x) = Conj <$> x\n\ninstance traversableDisj :: Traversable Disj where\n  traverse f (Disj x) = Disj <$> f x\n  sequence (Disj x) = Disj <$> x\n\ninstance traversableMultiplicative :: Traversable Multiplicative where\n  traverse f (Multiplicative x) = Multiplicative <$> f x\n  sequence (Multiplicative x) = Multiplicative <$> x\n\ninstance traversableEither :: Traversable (Either a) where\n  traverse _ (Left x)  = pure (Left x)\n  traverse f (Right x) = Right <$> f x\n  sequence (Left x) = pure (Left x)\n  sequence (Right x)  = Right <$> x\n\ninstance traversableTuple :: Traversable (Tuple a) where\n  traverse f (Tuple x y) = Tuple x <$> f y\n  sequence (Tuple x y) = Tuple x <$> y\n\ninstance traversableIdentity :: Traversable Identity where\n  traverse f (Identity x) = Identity <$> f x\n  sequence (Identity x) = Identity <$> x\n\ninstance traversableConst :: Traversable (Const a) where\n  traverse _ (Const x) = pure (Const x)\n  sequence (Const x) = pure (Const x)\n\ninstance traversableProduct :: (Traversable f, Traversable g) => Traversable (Product f g) where\n  traverse f (Product (Tuple fa ga)) = lift2 product (traverse f fa) (traverse f ga)\n  sequence (Product (Tuple fa ga)) = lift2 product (sequence fa) (sequence ga)\n\ninstance traversableCoproduct :: (Traversable f, Traversable g) => Traversable (Coproduct f g) where\n  traverse f = coproduct\n    (map (Coproduct <<< Left) <<< traverse f)\n    (map (Coproduct <<< Right) <<< traverse f)\n  sequence = coproduct\n    (map (Coproduct <<< Left) <<< sequence)\n    (map (Coproduct <<< Right) <<< sequence)\n\ninstance traversableCompose :: (Traversable f, Traversable g) => Traversable (Compose f g) where\n  traverse f (Compose fga) = map Compose $ traverse (traverse f) fga\n  sequence = traverse identity\n\ninstance traversableApp :: Traversable f => Traversable (App f) where\n  traverse f (App x) = App <$> traverse f x\n  sequence (App x) = App <$> sequence x\n\n-- | A version of `traverse` with its arguments flipped.\n-- |\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for [1, 2, 3] \\n -> do\n-- |   print n\n-- |   return (n * n)\n-- | ```\nfor\n  :: forall a b m t\n   . Applicative m\n  => Traversable t\n  => t a\n  -> (a -> m b)\n  -> m (t b)\nfor x f = traverse f x\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```purescript\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b f. Traversable f => (b -> a -> b) -> b -> f a -> f b\nscanl f b0 xs = (mapAccumL (\\b a -> let b' = f b a in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanl`, `mapAccumL` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumL\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumL f s0 xs = stateL (traverse (\\a -> StateL \\s -> f s a) xs) s0\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```purescript\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b f. Traversable f => (a -> b -> b) -> b -> f a -> f b\nscanr f b0 xs = (mapAccumR (\\b a -> let b' = f a b in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanr`, `mapAccumR` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumR\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumR f s0 xs = stateR (traverse (\\a -> StateR \\s -> f s a) xs) s0\n","export const unfoldr1ArrayImpl = function (isNothing) {\n  return function (fromJust) {\n    return function (fst) {\n      return function (snd) {\n        return function (f) {\n          return function (b) {\n            var result = [];\n            var value = b;\n            while (true) { // eslint-disable-line no-constant-condition\n              var tuple = f(value);\n              result.push(fst(tuple));\n              var maybe = snd(tuple);\n              if (isNothing(maybe)) return result;\n              value = fromJust(maybe);\n            }\n          };\n        };\n      };\n    };\n  };\n};\n","module Data.Semigroup.Foldable\n  ( class Foldable1\n  , foldMap1\n  , fold1\n  , foldr1\n  , foldl1\n  , traverse1_\n  , for1_\n  , sequence1_\n  , foldr1Default\n  , foldl1Default\n  , foldMap1DefaultR\n  , foldMap1DefaultL\n  , intercalate\n  , intercalateMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable)\nimport Data.Identity (Identity(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (ala, alaF)\nimport Data.Ord.Max (Max(..))\nimport Data.Ord.Min (Min(..))\nimport Data.Tuple (Tuple(..))\n\n-- | `Foldable1` represents data structures with a minimum of one element that can be _folded_.\n-- |\n-- | - `foldr1` folds a structure from the right\n-- | - `foldl1` folds a structure from the left\n-- | - `foldMap1` folds a structure by accumulating values in a `Semigroup`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldr1Default`\n-- | - `foldl1Default`\n-- | - `foldMap1DefaultR`\n-- | - `foldMap1DefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable t <= Foldable1 t where\n  foldr1 :: forall a. (a -> a -> a) -> t a -> a\n  foldl1 :: forall a. (a -> a -> a) -> t a -> a\n  foldMap1 :: forall a m. Semigroup m => (a -> m) -> t a -> m\n\n-- | A default implementation of `foldr1` using `foldMap1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldMap1DefaultR`.\nfoldr1Default :: forall t a. Foldable1 t => (a -> a -> a) -> t a -> a\nfoldr1Default = flip (runFoldRight1 <<< foldMap1 mkFoldRight1)\n\n-- | A default implementation of `foldl1` using `foldMap1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldMap1DefaultL`.\nfoldl1Default :: forall t a. Foldable1 t => (a -> a -> a) -> t a -> a\nfoldl1Default = flip (runFoldRight1 <<< alaF Dual foldMap1 mkFoldRight1) <<< flip\n\n-- | A default implementation of `foldMap1` using `foldr1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldr1Default`.\nfoldMap1DefaultR :: forall t m a. Foldable1 t => Functor t => Semigroup m => (a -> m) -> t a -> m\nfoldMap1DefaultR f = map f >>> foldr1 (<>)\n\n-- | A default implementation of `foldMap1` using `foldl1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldl1Default`.\nfoldMap1DefaultL :: forall t m a. Foldable1 t => Functor t => Semigroup m => (a -> m) -> t a -> m\nfoldMap1DefaultL f = map f >>> foldl1 (<>)\n\ninstance foldableDual :: Foldable1 Dual where\n  foldr1 _ (Dual x) = x\n  foldl1 _ (Dual x) = x\n  foldMap1 f (Dual x) = f x\n\ninstance foldableMultiplicative :: Foldable1 Multiplicative where\n  foldr1 _ (Multiplicative x) = x\n  foldl1 _ (Multiplicative x) = x\n  foldMap1 f (Multiplicative x) = f x\n\ninstance foldableTuple :: Foldable1 (Tuple a) where\n  foldMap1 f (Tuple _ x) = f x\n  foldr1 _ (Tuple _ x) = x\n  foldl1 _ (Tuple _ x) = x\n\ninstance foldableIdentity :: Foldable1 Identity where\n  foldMap1 f (Identity x) = f x\n  foldl1 _ (Identity x) = x\n  foldr1 _ (Identity x) = x\n\n-- | Fold a data structure, accumulating values in some `Semigroup`.\nfold1 :: forall t m. Foldable1 t => Semigroup m => t m -> m\nfold1 = foldMap1 identity\n\nnewtype Act :: forall k. (k -> Type) -> k -> Type\nnewtype Act f a = Act (f a)\n\ngetAct :: forall f a. Act f a -> f a\ngetAct (Act f) = f\n\ninstance semigroupAct :: Apply f => Semigroup (Act f a) where\n  append (Act a) (Act b) = Act (a *> b)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Apply` instance at each value, ignoring the final result.\ntraverse1_ :: forall t f a b. Foldable1 t => Apply f => (a -> f b) -> t a -> f Unit\ntraverse1_ f t = unit <$ getAct (foldMap1 (Act <<< f) t)\n\n-- | A version of `traverse1_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\nfor1_ :: forall t f a b. Foldable1 t => Apply f => t a -> (a -> f b) -> f Unit\nfor1_ = flip traverse1_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable1` instance, ignoring the final result.\nsequence1_ :: forall t f a. Foldable1 t => Apply f => t (f a) -> f Unit\nsequence1_ = traverse1_ identity\n\nmaximum :: forall f a. Ord a => Foldable1 f => f a -> a\nmaximum = ala Max foldMap1\n\nmaximumBy :: forall f a. Foldable1 f => (a -> a -> Ordering) -> f a -> a\nmaximumBy cmp = foldl1 \\x y -> if cmp x y == GT then x else y\n\nminimum :: forall f a. Ord a => Foldable1 f => f a -> a\nminimum = ala Min foldMap1\n\nminimumBy :: forall f a. Foldable1 f => (a -> a -> Ordering) -> f a -> a\nminimumBy cmp = foldl1 \\x y -> if cmp x y == LT then x else y\n\n-- | Internal. Used by intercalation functions.\nnewtype JoinWith a = JoinWith (a -> a)\n\njoinee :: forall a. JoinWith a -> a -> a\njoinee (JoinWith x) = x\n\ninstance semigroupJoinWith :: Semigroup a => Semigroup (JoinWith a) where\n  append (JoinWith a) (JoinWith b) = JoinWith $ \\j -> a j <> j <> b j\n\n-- | Fold a data structure using a `Semigroup` instance,\n-- | combining adjacent elements using the specified separator.\nintercalate :: forall f m. Foldable1 f => Semigroup m => m -> f m -> m\nintercalate = flip intercalateMap identity\n\n-- | Fold a data structure, accumulating values in some `Semigroup`,\n-- | combining adjacent elements using the specified separator.\nintercalateMap\n  :: forall f m a\n   . Foldable1 f\n  => Semigroup m\n  => m -> (a -> m) -> f a -> m\nintercalateMap j f foldable =\n  joinee (foldMap1 (JoinWith <<< const <<< f) foldable) j\n\n-- | Internal. Used by foldr1Default and foldl1Default.\ndata FoldRight1 a = FoldRight1 (a -> (a -> a -> a) -> a) a\n\ninstance foldRight1Semigroup :: Semigroup (FoldRight1 a) where\n  append (FoldRight1 lf lr) (FoldRight1 rf rr) = FoldRight1 (\\a f -> lf (f lr (rf a f)) f) rr\n\nmkFoldRight1 :: forall a. a -> FoldRight1 a\nmkFoldRight1 = FoldRight1 const\n\nrunFoldRight1 :: forall a. FoldRight1 a -> (a -> a -> a) -> a\nrunFoldRight1 (FoldRight1 f a) = f a\n","module Data.Unfoldable1\n  ( class Unfoldable1, unfoldr1\n  , replicate1\n  , replicate1A\n  , singleton\n  , range\n  , iterateN\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..), fromJust, isNothing)\nimport Data.Semigroup.Traversable (class Traversable1, sequence1)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Partial.Unsafe (unsafePartial)\n\n-- | This class identifies data structures which can be _unfolded_.\n-- |\n-- | The generating function `f` in `unfoldr1 f` corresponds to the `uncons`\n-- | operation of a non-empty list or array; it always returns a value, and\n-- | then optionally a value to continue unfolding from.\n-- |\n-- | Note that, in order to provide an `Unfoldable1 t` instance, `t` need not\n-- | be a type which is guaranteed to be non-empty. For example, the fact that\n-- | lists can be empty does not prevent us from providing an\n-- | `Unfoldable1 List` instance. However, the result of `unfoldr1` should\n-- | always be non-empty.\n-- |\n-- | Every type which has an `Unfoldable` instance can be given an\n-- | `Unfoldable1` instance (and, in fact, is required to, because\n-- | `Unfoldable1` is a superclass of `Unfoldable`). However, there are types\n-- | which have `Unfoldable1` instances but cannot have `Unfoldable` instances.\n-- | In particular, types which are guaranteed to be non-empty, such as\n-- | `NonEmptyList`, cannot be given `Unfoldable` instances.\n-- |\n-- | The utility of this class, then, is that it provides an `Unfoldable`-like\n-- | interface while still permitting instances for guaranteed-non-empty types\n-- | like `NonEmptyList`.\nclass Unfoldable1 t where\n  unfoldr1 :: forall a b. (b -> Tuple a (Maybe b)) -> b -> t a\n\ninstance unfoldable1Array :: Unfoldable1 Array where\n  unfoldr1 = unfoldr1ArrayImpl isNothing (unsafePartial fromJust) fst snd\n\ninstance unfoldable1Maybe :: Unfoldable1 Maybe where\n  unfoldr1 f b = Just (fst (f b))\n\nforeign import unfoldr1ArrayImpl\n  :: forall a b\n   . (forall x. Maybe x -> Boolean)\n  -> (forall x. Maybe x -> x)\n  -> (forall x y. Tuple x y -> x)\n  -> (forall x y. Tuple x y -> y)\n  -> (b -> Tuple a (Maybe b))\n  -> b\n  -> Array a\n\n-- | Replicate a value `n` times. At least one value will be produced, so values\n-- | `n` less than 1 will be treated as 1.\n-- |\n-- | ``` purescript\n-- | replicate1 2 \"foo\" == (NEL.cons \"foo\" (NEL.singleton \"foo\") :: NEL.NonEmptyList String)\n-- | replicate1 0 \"foo\" == (NEL.singleton \"foo\" :: NEL.NonEmptyList String)\n-- | ```\nreplicate1 :: forall f a. Unfoldable1 f => Int -> a -> f a\nreplicate1 n v = unfoldr1 step (n - 1)\n  where\n    step :: Int -> Tuple a (Maybe Int)\n    step i\n      | i <= 0 = Tuple v Nothing\n      | otherwise = Tuple v (Just (i - 1))\n\n-- | Perform an `Apply` action `n` times (at least once, so values `n` less\n-- | than 1 will be treated as 1), and accumulate the results.\n-- |\n-- | ``` purescript\n-- | > replicate1A 2 (randomInt 1 10) :: Effect (NEL.NonEmptyList Int)\n-- | (NonEmptyList (NonEmpty 8 (2 : Nil)))\n-- | > replicate1A 0 (randomInt 1 10) :: Effect (NEL.NonEmptyList Int)\n-- | (NonEmptyList (NonEmpty 4 Nil))\n-- | ```\nreplicate1A\n  :: forall m f a\n   . Apply m\n  => Unfoldable1 f\n  => Traversable1 f\n  => Int\n  -> m a\n  -> m (f a)\nreplicate1A n m = sequence1 (replicate1 n m)\n\n-- | Contain a single value. For example:\n-- |\n-- | ``` purescript\n-- | singleton \"foo\" == (NEL.singleton \"foo\" :: NEL.NonEmptyList String)\n-- | ```\nsingleton :: forall f a. Unfoldable1 f => a -> f a\nsingleton = replicate1 1\n\n-- | Create an `Unfoldable1` containing a range of values, including both\n-- | endpoints.\n-- |\n-- | ``` purescript\n-- | range 0 0 == (NEL.singleton 0 :: NEL.NonEmptyList Int)\n-- | range 1 2 == (NEL.cons 1 (NEL.singleton 2) :: NEL.NonEmptyList Int)\n-- | range 2 0 == (NEL.cons 2 (NEL.cons 1 (NEL.singleton 0)) :: NEL.NonEmptyList Int)\n-- | ```\nrange :: forall f. Unfoldable1 f => Int -> Int -> f Int\nrange start end =\n  let delta = if end >= start then 1 else -1 in unfoldr1 (go delta) start\n  where\n    go delta i =\n      let i' = i + delta\n      in Tuple i (if i == end then Nothing else Just i')\n\n-- | Create an `Unfoldable1` by repeated application of a function to a seed value.\n-- | For example:\n-- |\n-- | ``` purescript\n-- | (iterateN 5 (_ + 1) 0 :: Array Int) == [0, 1, 2, 3, 4]\n-- | (iterateN 5 (_ + 1) 0 :: NonEmptyArray Int) == NonEmptyArray [0, 1, 2, 3, 4]\n-- |\n-- | (iterateN 0 (_ + 1) 0 :: Array Int) == [0]\n-- | (iterateN 0 (_ + 1) 0 :: NonEmptyArray Int) == NonEmptyArray [0]\n-- | ```\niterateN :: forall f a. Unfoldable1 f => Int -> (a -> a) -> a -> f a\niterateN n f s = unfoldr1 go $ Tuple s (n - 1)\n  where\n  go (Tuple x n') = Tuple x\n    if n' > 0 then Just $ Tuple (f x) $ n' - 1\n    else Nothing\n","-- | Helper functions for working with immutable Javascript arrays.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use `Data.List` or\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is useful when integrating with JavaScript libraries\n-- | which use arrays, but immutable arrays are not a practical data structure\n-- | for many use cases due to their poor asymptotics.\n-- |\n-- | In addition to the functions in this module, Arrays have a number of\n-- | useful instances:\n-- |\n-- | * `Functor`, which provides `map :: forall a b. (a -> b) -> Array a ->\n-- |   Array b`\n-- | * `Apply`, which provides `(<*>) :: forall a b. Array (a -> b) -> Array a\n-- |   -> Array b`. This function works a bit like a Cartesian product; the\n-- |   result array is constructed by applying each function in the first\n-- |   array to each value in the second, so that the result array ends up with\n-- |   a length equal to the product of the two arguments' lengths.\n-- | * `Bind`, which provides `(>>=) :: forall a b. (a -> Array b) -> Array a\n-- |   -> Array b` (this is the same as `concatMap`).\n-- | * `Semigroup`, which provides `(<>) :: forall a. Array a -> Array a ->\n-- |   Array a`, for concatenating arrays.\n-- | * `Foldable`, which provides a slew of functions for *folding* (also known\n-- |   as *reducing*) arrays down to one value. For example,\n-- |   `Data.Foldable.or` tests whether an array of `Boolean` values contains\n-- |   at least one `true` value.\n-- | * `Traversable`, which provides the PureScript version of a for-loop,\n-- |   allowing you to STAI.iterate over an array and accumulate effects.\n-- |\nmodule Data.Array\n  ( fromFoldable\n  , toUnfoldable\n  , singleton\n  , (..)\n  , range\n  , replicate\n  , some\n  , many\n\n  , null\n  , length\n\n  , (:)\n  , cons\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!)\n  , index\n  , elem\n  , notElem\n  , elemIndex\n  , elemLastIndex\n  , find\n  , findMap\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , intersperse\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , splitAt\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n  , foldl\n  , foldr\n  , foldMap\n  , fold\n  , intercalate\n  , transpose\n  , scanl\n  , scanr\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n\n  , nub\n  , nubEq\n  , nubBy\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n\n  , (\\\\)\n  , difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , any\n  , all\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM2)\nimport Control.Monad.ST as ST\nimport Data.Array.NonEmpty.Internal (NonEmptyArray(..))\nimport Data.Array.ST as STA\nimport Data.Array.ST.Iterator as STAI\nimport Data.Foldable (class Foldable, traverse_)\nimport Data.Foldable as F\nimport Data.Function.Uncurried (Fn2, Fn3, Fn4, Fn5, runFn2, runFn3, runFn4, runFn5)\nimport Data.FunctorWithIndex as FWI\nimport Data.Maybe (Maybe(..), maybe, isJust, fromJust, isNothing)\nimport Data.Traversable (sequence, traverse)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafePartial)\n\n-- | Convert an `Array` into an `Unfoldable` structure.\ntoUnfoldable :: forall f. Unfoldable f => Array ~> f\ntoUnfoldable xs = unfoldr f 0\n  where\n  len = length xs\n  f i\n    | i < len = Just (Tuple (unsafePartial (unsafeIndex xs i)) (i + 1))\n    | otherwise = Nothing\n\n-- | Convert a `Foldable` structure into an `Array`.\n-- |\n-- | ```purescript\n-- | fromFoldable (Just 1) = [1]\n-- | fromFoldable (Nothing) = []\n-- | ```\n-- |\nfromFoldable :: forall f. Foldable f => f ~> Array\nfromFoldable = runFn2 fromFoldableImpl F.foldr\n\nforeign import fromFoldableImpl\n  :: forall f a\n   . Fn2 (forall b. (a -> b -> b) -> b -> f a -> b) (f a) (Array a)\n\n-- | Create an array of one element\n-- | ```purescript\n-- | singleton 2 = [2]\n-- | ```\nsingleton :: forall a. a -> Array a\nsingleton a = [ a ]\n\n-- | Create an array containing a range of integers, including both endpoints.\n-- | ```purescript\n-- | range 2 5 = [2, 3, 4, 5]\n-- | ```\nrange :: Int -> Int -> Array Int\nrange = runFn2 rangeImpl\n\nforeign import rangeImpl :: Fn2 Int Int (Array Int)\n\n-- | Create an array containing a value repeated the specified number of times.\n-- | ```purescript\n-- | replicate 2 \"Hi\" = [\"Hi\", \"Hi\"]\n-- | ```\nreplicate :: forall a. Int -> a -> Array a\nreplicate = runFn2 replicateImpl\n\nforeign import replicateImpl :: forall a. Fn2 Int a (Array a)\n\n-- | An infix synonym for `range`.\n-- | ```purescript\n-- | 2 .. 5 = [2, 3, 4, 5]\n-- | ```\ninfix 8 range as ..\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nsome v = (:) <$> v <*> defer (\\_ -> many v)\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nmany v = some v <|> pure []\n\n--------------------------------------------------------------------------------\n-- Array size ------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether an array is empty.\n-- | ```purescript\n-- | null [] = true\n-- | null [1, 2] = false\n-- | ```\nnull :: forall a. Array a -> Boolean\nnull xs = length xs == 0\n\n-- | Get the number of elements in an array.\n-- | ```purescript\n-- | length [\"Hello\", \"World\"] = 2\n-- | ```\nforeign import length :: forall a. Array a -> Int\n\n--------------------------------------------------------------------------------\n-- Extending arrays ------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Attaches an element to the front of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | cons 1 [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ncons :: forall a. a -> Array a -> Array a\ncons x xs = [ x ] <> xs\n\n-- | An infix alias for `cons`.\n-- |\n-- | ```purescript\n-- | 1 : [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ninfixr 6 cons as :\n\n-- | Append an element to the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | snoc [1, 2, 3] 4 = [1, 2, 3, 4]\n-- | ```\n-- |\nsnoc :: forall a. Array a -> a -> Array a\nsnoc xs x = ST.run (STA.withArray (STA.push x) xs)\n\n-- | Insert an element into a sorted array.\n-- |\n-- | ```purescript\n-- | insert 10 [1, 2, 20, 21] = [1, 2, 10, 20, 21]\n-- | ```\n-- |\ninsert :: forall a. Ord a => a -> Array a -> Array a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted array, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | ```purescript\n-- | invertCompare a b = invert $ compare a b\n-- |\n-- | insertBy invertCompare 10 [21, 20, 2, 1] = [21, 20, 10, 2, 1]\n-- | ```\n-- |\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> Array a -> Array a\ninsertBy cmp x ys =\n  let\n    i = maybe 0 (_ + 1) (findLastIndex (\\y -> cmp x y == GT) ys)\n  in\n    unsafePartial (fromJust (insertAt i x ys))\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | head [1, 2] = Just 1\n-- | head [] = Nothing\n-- | ```\n-- |\nhead :: forall a. Array a -> Maybe a\nhead xs = xs !! 0\n\n-- | Get the last element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | last [1, 2] = Just 2\n-- | last [] = Nothing\n-- | ```\n-- |\nlast :: forall a. Array a -> Maybe a\nlast xs = xs !! (length xs - 1)\n\n-- | Get all but the first element of an array, creating a new array, or\n-- | `Nothing` if the array is empty\n-- |\n-- | ```purescript\n-- | tail [1, 2, 3, 4] = Just [2, 3, 4]\n-- | tail [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ntail :: forall a. Array a -> Maybe (Array a)\ntail = runFn3 unconsImpl (const Nothing) (\\_ xs -> Just xs)\n\n-- | Get all but the last element of an array, creating a new array, or\n-- | `Nothing` if the array is empty.\n-- |\n-- | ```purescript\n-- | init [1, 2, 3, 4] = Just [1, 2, 3]\n-- | init [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ninit :: forall a. Array a -> Maybe (Array a)\ninit xs\n  | null xs = Nothing\n  | otherwise = Just (slice zero (length xs - one) xs)\n\n-- | Break an array into its first element and remaining elements.\n-- |\n-- | Using `uncons` provides a way of writing code that would use cons patterns\n-- | in Haskell or pre-PureScript 0.7:\n-- | ``` purescript\n-- | f (x : xs) = something\n-- | f [] = somethingElse\n-- | ```\n-- | Becomes:\n-- | ``` purescript\n-- | f arr = case uncons arr of\n-- |   Just { head: x, tail: xs } -> something\n-- |   Nothing -> somethingElse\n-- | ```\nuncons :: forall a. Array a -> Maybe { head :: a, tail :: Array a }\nuncons = runFn3 unconsImpl (const Nothing) \\x xs -> Just { head: x, tail: xs }\n\nforeign import unconsImpl\n  :: forall a b\n   . Fn3 (Unit -> b) (a -> Array a -> b) (Array a) b\n\n-- | Break an array into its last element and all preceding elements.\n-- |\n-- | ```purescript\n-- | unsnoc [1, 2, 3] = Just {init: [1, 2], last: 3}\n-- | unsnoc [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\nunsnoc :: forall a. Array a -> Maybe { init :: Array a, last :: a }\nunsnoc xs = { init: _, last: _ } <$> init xs <*> last xs\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | This function provides a safe way to read a value at a particular index\n-- | from an array.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | index sentence 0 = Just \"Hello\"\n-- | index sentence 7 = Nothing\n-- | ```\n-- |\nindex :: forall a. Array a -> Int -> Maybe a\nindex = runFn4 indexImpl Just Nothing\n\nforeign import indexImpl\n  :: forall a\n   . Fn4 (forall r. r -> Maybe r) (forall r. Maybe r) (Array a) Int (Maybe a)\n\n-- | An infix version of `index`.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | sentence !! 0 = Just \"Hello\"\n-- | sentence !! 7 = Nothing\n-- | ```\n-- |\ninfixl 8 index as !!\n\n-- | Returns true if the array has the given element.\nelem :: forall a. Eq a => a -> Array a -> Boolean\nelem a arr = isJust $ elemIndex a arr\n\n-- | Returns true if the array does not have the given element.\nnotElem :: forall a. Eq a => a -> Array a -> Boolean\nnotElem a arr = isNothing $ elemIndex a arr\n\n-- | Find the index of the first element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 0\n-- | elemIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemLastIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 2\n-- | elemLastIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemLastIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first element for which a predicate holds.\n-- |\n-- | ```purescript\n-- | find (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just \"bb\"\n-- | find (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\nfind :: forall a. (a -> Boolean) -> Array a -> Maybe a\nfind f xs = unsafePartial (unsafeIndex xs) <$> findIndex f xs\n\n-- | Find the first element in a data structure which satisfies\n-- | a predicate mapping.\nfindMap :: forall a b. (a -> Maybe b) -> Array a -> Maybe b\nfindMap = runFn4 findMapImpl Nothing isJust\n\nforeign import findMapImpl\n  :: forall a b\n   . Fn4\n       (forall c. Maybe c)\n       (forall c. Maybe c -> Boolean)\n       (a -> Maybe b)\n       (Array a)\n       (Maybe b)\n\n-- | Find the first index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 1\n-- | findIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindIndex = runFn4 findIndexImpl Just Nothing\n\nforeign import findIndexImpl\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       (a -> Boolean)\n       (Array a)\n       (Maybe Int)\n\n-- | Find the last index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findLastIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 2\n-- | findLastIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindLastIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindLastIndex = runFn4 findLastIndexImpl Just Nothing\n\nforeign import findLastIndexImpl\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       (a -> Boolean)\n       (Array a)\n       (Maybe Int)\n\n-- | Insert an element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | insertAt 2 \"!\" [\"Hello\", \"World\"] = Just [\"Hello\", \"World\", \"!\"]\n-- | insertAt 10 \"!\" [\"Hello\"] = Nothing\n-- | ```\n-- |\ninsertAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\ninsertAt = runFn5 _insertAt Just Nothing\n\nforeign import _insertAt\n  :: forall a\n   . Fn5\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       a\n       (Array a)\n       (Maybe (Array a))\n\n-- | Delete the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | deleteAt 0 [\"Hello\", \"World\"] = Just [\"World\"]\n-- | deleteAt 10 [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\ndeleteAt :: forall a. Int -> Array a -> Maybe (Array a)\ndeleteAt = runFn4 _deleteAt Just Nothing\n\nforeign import _deleteAt\n  :: forall a\n   . Fn4\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       (Array a)\n       (Maybe (Array a))\n\n-- | Change the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | updateAt 1 \"World\" [\"Hello\", \"Earth\"] = Just [\"Hello\", \"World\"]\n-- | updateAt 10 \"World\" [\"Hello\", \"Earth\"] = Nothing\n-- | ```\n-- |\nupdateAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\nupdateAt = runFn5 _updateAt Just Nothing\n\nforeign import _updateAt\n  :: forall a\n   . Fn5\n       (forall b. b -> Maybe b)\n       (forall b. Maybe b)\n       Int\n       a\n       (Array a)\n       (Maybe (Array a))\n\n-- | Apply a function to the element at the specified index, creating a new\n-- | array, or returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | modifyAt 1 toUpper [\"Hello\", \"World\"] = Just [\"Hello\", \"WORLD\"]\n-- | modifyAt 10 toUpper [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\nmodifyAt :: forall a. Int -> (a -> a) -> Array a -> Maybe (Array a)\nmodifyAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = updateAt i (f x) xs\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new array or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | ```purescript\n-- | alterAt 1 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\", \"World\"]\n-- |\n-- | alterAt 1 (stripSuffix $ Pattern \"!!!!!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\"]\n-- |\n-- | alterAt 10 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"] = Nothing\n-- | ```\n-- |\nalterAt :: forall a. Int -> (a -> Maybe a) -> Array a -> Maybe (Array a)\nalterAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = case f x of\n    Nothing -> deleteAt i xs\n    Just x' -> updateAt i x' xs\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Inserts the given element in between each element in the array. The array\n-- | must have two or more elements for this operation to take effect.\n-- |\n-- | ```purescript\n-- | intersperse \" \" [ \"a\", \"b\" ] == [ \"a\", \" \", \"b\" ]\n-- | intersperse 0 [ 1, 2, 3, 4, 5 ] == [ 1, 0, 2, 0, 3, 0, 4, 0, 5 ]\n-- | ```\n-- |\n-- | If the array has less than two elements, the input array is returned.\n-- | ```purescript\n-- | intersperse \" \" [] == []\n-- | intersperse \" \" [\"a\"] == [\"a\"]\n-- | ```\nintersperse :: forall a. a -> Array a -> Array a\nintersperse a arr = case length arr of\n  len\n    | len < 2 -> arr\n    | otherwise -> STA.run do\n        let unsafeGetElem idx = unsafePartial (unsafeIndex arr idx)\n        out <- STA.new\n        _ <- STA.push (unsafeGetElem 0) out\n        ST.for 1 len \\idx -> do\n          _ <- STA.push a out\n          void (STA.push (unsafeGetElem idx) out)\n        pure out\n\n-- | Reverse an array, creating a new array.\n-- |\n-- | ```purescript\n-- | reverse [] = []\n-- | reverse [1, 2, 3] = [3, 2, 1]\n-- | ```\n-- |\nforeign import reverse :: forall a. Array a -> Array a\n\n-- | Flatten an array of arrays, creating a new array.\n-- |\n-- | ```purescript\n-- | concat [[1, 2, 3], [], [4, 5, 6]] = [1, 2, 3, 4, 5, 6]\n-- | ```\n-- |\nforeign import concat :: forall a. Array (Array a) -> Array a\n\n-- | Apply a function to each element in an array, and flatten the results\n-- | into a single, new array.\n-- |\n-- | ```purescript\n-- | concatMap (split $ Pattern \" \") [\"Hello World\", \"other thing\"]\n-- |    = [\"Hello\", \"World\", \"other\", \"thing\"]\n-- | ```\n-- |\nconcatMap :: forall a b. (a -> Array b) -> Array a -> Array b\nconcatMap = flip bind\n\n-- | Filter an array, keeping the elements which satisfy a predicate function,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | filter (_ > 0) [-1, 4, -5, 7] = [4, 7]\n-- | ```\n-- |\nfilter :: forall a. (a -> Boolean) -> Array a -> Array a\nfilter = runFn2 filterImpl\n\nforeign import filterImpl\n  :: forall a\n   . Fn2 (a -> Boolean) (Array a) (Array a)\n\n-- | Partition an array using a predicate function, creating a set of\n-- | new arrays. One for the values satisfying the predicate function\n-- | and one for values that don't.\n-- |\n-- | ```purescript\n-- | partition (_ > 0) [-1, 4, -5, 7] = { yes: [4, 7], no: [-1, -5] }\n-- | ```\n-- |\npartition\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { yes :: Array a, no :: Array a }\npartition = runFn2 partitionImpl\n\nforeign import partitionImpl\n  :: forall a\n   . Fn2 (a -> Boolean) (Array a) { yes :: Array a, no :: Array a }\n\n-- | Splits an array into two subarrays, where `before` contains the elements\n-- | up to (but not including) the given index, and `after` contains the rest\n-- | of the elements, from that index on.\n-- |\n-- | ```purescript\n-- | >>> splitAt 3 [1, 2, 3, 4, 5]\n-- | { before: [1, 2, 3], after: [4, 5] }\n-- | ```\n-- |\n-- | Thus, the length of `(splitAt i arr).before` will equal either `i` or\n-- | `length arr`, if that is shorter. (Or if `i` is negative the length will\n-- | be 0.)\n-- |\n-- | ```purescript\n-- | splitAt 2 ([] :: Array Int) == { before: [], after: [] }\n-- | splitAt 3 [1, 2, 3, 4, 5] == { before: [1, 2, 3], after: [4, 5] }\n-- | ```\nsplitAt :: forall a. Int -> Array a -> { before :: Array a, after :: Array a }\nsplitAt i xs | i <= 0 = { before: [], after: xs }\nsplitAt i xs = { before: slice 0 i xs, after: slice i (length xs) xs }\n\n-- | Filter where the predicate returns a `Boolean` in some `Applicative`.\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. Array a -> Array (Array a)\n-- | powerSet = filterA (const [true, false])\n-- | ```\nfilterA :: forall a f. Applicative f => (a -> f Boolean) -> Array a -> f (Array a)\nfilterA p =\n  traverse (\\x -> Tuple x <$> p x)\n    >>> map (mapMaybe (\\(Tuple x b) -> if b then Just x else Nothing))\n\n-- | Apply a function to each element in an array, keeping only the results\n-- | which contain a value, creating a new array.\n-- |\n-- | ```purescript\n-- | parseEmail :: String -> Maybe Email\n-- | parseEmail = ...\n-- |\n-- | mapMaybe parseEmail [\"a.com\", \"hello@example.com\", \"--\"]\n-- |    = [Email {user: \"hello\", domain: \"example.com\"}]\n-- | ```\n-- |\nmapMaybe :: forall a b. (a -> Maybe b) -> Array a -> Array b\nmapMaybe f = concatMap (maybe [] singleton <<< f)\n\n-- | Filter an array of optional values, keeping only the elements which contain\n-- | a value, creating a new array.\n-- |\n-- | ```purescript\n-- | catMaybes [Nothing, Just 2, Nothing, Just 4] = [2, 4]\n-- | ```\n-- |\ncatMaybes :: forall a. Array (Maybe a) -> Array a\ncatMaybes = mapMaybe identity\n\n-- | Apply a function to each element in an array, supplying a generated\n-- | zero-based index integer along with the element, creating an array\n-- | with the new elements.\n-- |\n-- | ```purescript\n-- | prefixIndex index element = show index <> element\n-- |\n-- | mapWithIndex prefixIndex [\"Hello\", \"World\"] = [\"0Hello\", \"1World\"]\n-- | ```\n-- |\nmapWithIndex :: forall a b. (Int -> a -> b) -> Array a -> Array b\nmapWithIndex = FWI.mapWithIndex\n\n-- | Change the elements at the specified indices in index/value pairs.\n-- | Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | updates = [Tuple 0 \"Hi\", Tuple 2 \".\" , Tuple 10 \"foobar\"]\n-- |\n-- | updateAtIndices updates [\"Hello\", \"World\", \"!\"] = [\"Hi\", \"World\", \".\"]\n-- | ```\n-- |\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> Array a -> Array a\nupdateAtIndices us xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\(Tuple i a) -> STA.poke i a res) us) xs)\n\n-- | Apply a function to the element at the specified indices,\n-- | creating a new array. Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | indices = [1, 3]\n-- | modifyAtIndices indices toUpper [\"Hello\", \"World\", \"and\", \"others\"]\n-- |    = [\"Hello\", \"WORLD\", \"and\", \"OTHERS\"]\n-- | ```\n-- |\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> Array a -> Array a\nmodifyAtIndices is f xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\i -> STA.modify i f res) is) xs)\n\nfoldl :: forall a b. (b -> a -> b) -> b -> Array a -> b\nfoldl = F.foldl\n\nfoldr :: forall a b. (a -> b -> b) -> b -> Array a -> b\nfoldr = F.foldr\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> Array a -> m\nfoldMap = F.foldMap\n\nfold :: forall m. Monoid m => Array m -> m\nfold = F.fold\n\nintercalate :: forall a. Monoid a => a -> Array a -> a\nintercalate = F.intercalate\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [1, 2, 3]\n-- |   , [4, 5, 6]\n-- |   ] == \n-- |   [ [1, 4]\n-- |   , [2, 5]\n-- |   , [3, 6]\n-- |   ]\n-- | ```\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- | ```purescript\n-- | transpose \n-- |   [ [10, 11]\n-- |   , [20]\n-- |   , [30, 31, 32]\n-- |   ] == \n-- |   [ [10, 20, 30]\n-- |   , [11, 31]\n-- |   , [32]\n-- |   ]\n-- | ```\ntranspose :: forall a. Array (Array a) -> Array (Array a)\ntranspose xs = go 0 []\n  where\n  go :: Int -> Array (Array a) -> Array (Array a)\n  go idx allArrays = case buildNext idx of\n    Nothing -> allArrays\n    Just next -> go (idx + 1) (snoc allArrays next)\n\n  buildNext :: Int -> Maybe (Array a)\n  buildNext idx = do\n    xs # flip foldl Nothing \\acc nextArr -> do\n      maybe acc (\\el -> Just $ maybe [ el ] (flip snoc el) acc) $ index nextArr idx\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b. (b -> a -> b) -> b -> Array a -> Array b\nscanl = runFn3 scanlImpl\n\nforeign import scanlImpl :: forall a b. Fn3 (b -> a -> b) b (Array a) (Array b)\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b. (a -> b -> b) -> b -> Array a -> Array b\nscanr = runFn3 scanrImpl\n\nforeign import scanrImpl :: forall a b. Fn3 (a -> b -> b) b (Array a) (Array b)\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an array in increasing order, creating a new array.\n-- | Sorting is stable: the order of equal elements is preserved.\n-- |\n-- | ```purescript\n-- | sort [2, -3, 1] = [-3, 1, 2]\n-- | ```\n-- |\nsort :: forall a. Ord a => Array a -> Array a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | compared using the specified partial ordering, creating a new array.\n-- | Sorting is stable: the order of elements is preserved if they are equal\n-- | according to the specified partial ordering.\n-- |\n-- | ```purescript\n-- | compareLength a b = compare (length a) (length b)\n-- | sortBy compareLength [[1, 2, 3], [7, 9], [-2]] = [[-2],[7,9],[1,2,3]]\n-- | ```\n-- |\nsortBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nsortBy comp = runFn3 sortByImpl comp case _ of\n  GT -> 1\n  EQ -> 0\n  LT -> -1\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | sorted based on a projection. Sorting is stable: the order of elements is\n-- | preserved if they are equal according to the projection.\n-- |\n-- | ```purescript\n-- | sortWith (_.age) [{name: \"Alice\", age: 42}, {name: \"Bob\", age: 21}]\n-- |    = [{name: \"Bob\", age: 21}, {name: \"Alice\", age: 42}]\n-- | ```\n-- |\nsortWith :: forall a b. Ord b => (a -> b) -> Array a -> Array a\nsortWith f = sortBy (comparing f)\n\nforeign import sortByImpl :: forall a. Fn3 (a -> a -> Ordering) (Ordering -> Int) (Array a) (Array a)\n\n--------------------------------------------------------------------------------\n-- Subarrays -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Extract a subarray by a start and end index.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- | slice 1 3 letters = [\"b\", \"c\"]\n-- | slice 5 7 letters = []\n-- | slice 4 1 letters = []\n-- | ```\n-- |\nslice :: forall a. Int -> Int -> Array a -> Array a\nslice = runFn3 sliceImpl\n\nforeign import sliceImpl :: forall a. Fn3 Int Int (Array a) (Array a)\n\n-- | Keep only a number of elements from the start of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | take 2 letters = [\"a\", \"b\"]\n-- | take 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntake :: forall a. Int -> Array a -> Array a\ntake n xs = if n < 1 then [] else slice 0 n xs\n\n-- | Keep only a number of elements from the end of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | takeEnd 2 letters = [\"b\", \"c\"]\n-- | takeEnd 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntakeEnd :: forall a. Int -> Array a -> Array a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Calculate the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | takeWhile (_ > 0) [4, 1, 0, -4, 5] = [4, 1]\n-- | takeWhile (_ > 0) [-1, 4] = []\n-- | ```\n-- |\ntakeWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ntakeWhile p xs = (span p xs).init\n\n-- | Drop a number of elements from the start of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | drop 2 letters = [\"c\", \"d\"]\n-- | drop 10 letters = []\n-- | ```\n-- |\ndrop :: forall a. Int -> Array a -> Array a\ndrop n xs = if n < 1 then xs else slice n (length xs) xs\n\n-- | Drop a number of elements from the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | dropEnd 2 letters = [\"a\", \"b\"]\n-- | dropEnd 10 letters = []\n-- | ```\n-- |\ndropEnd :: forall a. Int -> Array a -> Array a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Remove the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | dropWhile (_ < 0) [-3, -1, 0, 4, -6] = [0, 4, -6]\n-- | ```\n-- |\ndropWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ndropWhile p xs = (span p xs).rest\n\n-- | Split an array into two parts:\n-- |\n-- | 1. the longest initial subarray for which all elements satisfy the\n-- |    specified predicate\n-- | 2. the remaining elements\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) [1,3,2,4,5] == { init: [1,3], rest: [2,4,5] }\n-- | ```\n-- |\n-- | Running time: `O(n)`.\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { init :: Array a, rest :: Array a }\nspan p arr =\n  case breakIndex of\n    Just 0 ->\n      { init: [], rest: arr }\n    Just i ->\n      { init: slice 0 i arr, rest: slice i (length arr) arr }\n    Nothing ->\n      { init: arr, rest: [] }\n  where\n  breakIndex = go 0\n  go i =\n    -- This looks like a good opportunity to use the Monad Maybe instance,\n    -- but it's important to write out an explicit case expression here in\n    -- order to ensure that TCO is triggered.\n    case index arr i of\n      Just x -> if p x then go (i + 1) else Just i\n      Nothing -> Nothing\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1], NonEmptyArray [2, 2], NonEmptyArray [1]]\n-- | ```\ngroup :: forall a. Eq a => Array a -> Array (NonEmptyArray a)\ngroup xs = groupBy eq xs\n\n-- | Group equal elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | groupAll [1, 1, 2, 2, 1] == [NonEmptyArray [1, 1, 1], NonEmptyArray [2, 2]]\n-- | ```\ngroupAll :: forall a. Ord a => Array a -> Array (NonEmptyArray a)\ngroupAll = groupAllBy compare\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to determine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [1, 3], NonEmptyArray [2], NonEmptyArray [4], NonEmptyArray [3, 3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> Array a -> Array (NonEmptyArray a)\ngroupBy op xs =\n  ST.run do\n    result <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\x -> void do\n      sub <- STA.new\n      _ <- STA.push x sub\n      STAI.pushWhile (op x) iter sub\n      grp <- STA.unsafeFreeze sub\n      STA.push (NonEmptyArray grp) result\n    STA.unsafeFreeze result\n\n-- | Group equal elements of an array into arrays, using the specified\n-- | comparison function to determine equality.\n-- |\n-- | ```purescript\n-- | groupAllBy (comparing Down) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmptyArray [4], NonEmptyArray [3, 3, 3], NonEmptyArray [2], NonEmptyArray [1]]\n-- | ```\n-- |\ngroupAllBy :: forall a. (a -> a -> Ordering) -> Array a -> Array (NonEmptyArray a)\ngroupAllBy cmp = groupBy (\\x y -> cmp x y == EQ) <<< sortBy cmp\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | ```purescript\n-- | nub [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnub :: forall a. Ord a => Array a -> Array a\nnub = nubBy compare\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnubEq :: forall a. Eq a => Array a -> Array a\nnubEq = nubByEq eq\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified ordering, creating a new array.\n-- |\n-- | ```purescript\n-- | nubBy compare [1, 3, 4, 2, 2, 1] == [1, 3, 4, 2]\n-- | ```\n-- |\nnubBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nnubBy comp xs = case head indexedAndSorted of\n  Nothing -> []\n  Just x -> map snd $ sortWith fst $ ST.run do\n    -- TODO: use NonEmptyArrays here to avoid partial functions\n    result <- STA.unsafeThaw $ singleton x\n    ST.foreach indexedAndSorted \\pair@(Tuple _ x') -> do\n      lst <- snd <<< unsafePartial (fromJust <<< last) <$> STA.unsafeFreeze result\n      when (comp lst x' /= EQ) $ void $ STA.push pair result\n    STA.unsafeFreeze result\n  where\n  indexedAndSorted :: Array (Tuple Int a)\n  indexedAndSorted = sortBy (\\x y -> comp (snd x) (snd y))\n    (mapWithIndex Tuple xs)\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified equivalence relation, creating a new array.\n-- |\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | relation.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | nubByEq mod3eq [1, 3, 4, 5, 6] = [1, 3, 5]\n-- | ```\n-- |\nnubByEq :: forall a. (a -> a -> Boolean) -> Array a -> Array a\nnubByEq eq xs = ST.run do\n  arr <- STA.new\n  ST.foreach xs \\x -> do\n    e <- not <<< any (_ `eq` x) <$> (STA.unsafeFreeze arr)\n    when e $ void $ STA.push x arr\n  STA.unsafeFreeze arr\n\n-- | Calculate the union of two arrays. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | Running time: `O(n^2)`\n-- |\n-- | ```purescript\n-- | union [1, 2, 1, 1] [3, 3, 3, 4] = [1, 2, 1, 1, 3, 4]\n-- | ```\n-- |\nunion :: forall a. Eq a => Array a -> Array a -> Array a\nunion = unionBy (==)\n\n-- | Calculate the union of two arrays, using the specified function to\n-- | determine equality of elements. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | unionBy mod3eq [1, 5, 1, 2] [3, 4, 3, 3] = [1, 5, 1, 2, 3]\n-- | ```\n-- |\nunionBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first element of an array which is equal to the specified value,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | delete 7 [1, 7, 3, 7] = [1, 3, 7]\n-- | delete 7 [1, 2, 3] = [1, 2, 3]\n-- | ```\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> Array a -> Array a\ndelete = deleteBy eq\n\n-- | Delete the first element of an array which matches the specified value,\n-- | under the equivalence relation provided in the first argument, creating a\n-- | new array.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | deleteBy mod3eq 6 [1, 3, 4, 3] = [1, 4, 3]\n-- | ```\n-- |\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> Array a -> Array a\ndeleteBy _ _ [] = []\ndeleteBy eq x ys = maybe ys (\\i -> unsafePartial $ fromJust (deleteAt i ys)) (findIndex (eq x) ys)\n\n-- | Delete the first occurrence of each element in the second array from the\n-- | first array, creating a new array.\n-- |\n-- | ```purescript\n-- | difference [2, 1] [2, 3] = [1]\n-- | ```\n-- |\n-- | Running time: `O(n*m)`, where n is the length of the first array, and m is\n-- | the length of the second.\ndifference :: forall a. Eq a => Array a -> Array a -> Array a\ndifference = foldr delete\n\ninfix 5 difference as \\\\\n\n-- | Calculate the intersection of two arrays, creating a new array. Note that\n-- | duplicates in the first array are preserved while duplicates in the second\n-- | array are removed.\n-- |\n-- | ```purescript\n-- | intersect [1, 1, 2] [2, 2, 1] = [1, 1, 2]\n-- | ```\n-- |\nintersect :: forall a. Eq a => Array a -> Array a -> Array a\nintersect = intersectBy eq\n\n-- | Calculate the intersection of two arrays, using the specified equivalence\n-- | relation to compare elements, creating a new array. Note that duplicates\n-- | in the first array are preserved while duplicates in the second array are\n-- | removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | intersectBy mod3eq [1, 2, 3] [4, 6, 7] = [1, 3]\n-- | ```\n-- |\nintersectBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nintersectBy eq xs ys = filter (\\x -> isJust (findIndex (eq x) ys)) xs\n\n-- | Apply a function to pairs of elements at the same index in two arrays,\n-- | collecting the results in a new array.\n-- |\n-- | If one array is longer, elements will be discarded from the longer array.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) [1, 2, 3] [4, 5, 6, 7] == [4, 10, 18]\n-- | ```\nzipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> Array a\n  -> Array b\n  -> Array c\nzipWith = runFn3 zipWithImpl\n\nforeign import zipWithImpl\n  :: forall a b c\n   . Fn3\n       (a -> b -> c)\n       (Array a)\n       (Array b)\n       (Array c)\n\n-- | A generalization of `zipWith` which accumulates results in some\n-- | `Applicative` functor.\n-- |\n-- | ```purescript\n-- | sndChars = zipWithA (\\a b -> charAt 2 (a <> b))\n-- | sndChars [\"a\", \"b\"] [\"A\", \"B\"] = Nothing -- since \"aA\" has no 3rd char\n-- | sndChars [\"aa\", \"b\"] [\"AA\", \"BBB\"] = Just ['A', 'B']\n-- | ```\n-- |\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> Array a\n  -> Array b\n  -> m (Array c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Takes two arrays and returns an array of corresponding pairs.\n-- | If one input array is short, excess elements of the longer array are\n-- | discarded.\n-- |\n-- | ```purescript\n-- | zip [1, 2, 3] [\"a\", \"b\"] = [Tuple 1 \"a\", Tuple 2 \"b\"]\n-- | ```\n-- |\nzip :: forall a b. Array a -> Array b -> Array (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms an array of pairs into an array of first components and an\n-- | array of second components.\n-- |\n-- | ```purescript\n-- | unzip [Tuple 1 \"a\", Tuple 2 \"b\"] = Tuple [1, 2] [\"a\", \"b\"]\n-- | ```\n-- |\nunzip :: forall a b. Array (Tuple a b) -> Tuple (Array a) (Array b)\nunzip xs =\n  ST.run do\n    fsts <- STA.new\n    snds <- STA.new\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\(Tuple fst snd) -> do\n      void $ STA.push fst fsts\n      void $ STA.push snd snds\n    fsts' <- STA.unsafeFreeze fsts\n    snds' <- STA.unsafeFreeze snds\n    pure $ Tuple fsts' snds'\n\n-- | Returns true if at least one array element satisfies the given predicate,\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields true.\n-- |\n-- | ```purescript\n-- | any (_ > 0) [] = False\n-- | any (_ > 0) [-1, 0, 1] = True\n-- | any (_ > 0) [-1, -2, -3] = False\n-- | ```\nany :: forall a. (a -> Boolean) -> Array a -> Boolean\nany = runFn2 anyImpl\n\nforeign import anyImpl :: forall a. Fn2 (a -> Boolean) (Array a) Boolean\n\n-- | Returns true if all the array elements satisfy the given predicate.\n-- | iterating the array only as necessary and stopping as soon as the predicate\n-- | yields false.\n-- |\n-- | ```purescript\n-- | all (_ > 0) [] = True\n-- | all (_ > 0) [1, 2, 3] = True\n-- | all (_ > 0) [-1, -2, -3] = False\n-- | ```\nall :: forall a. (a -> Boolean) -> Array a -> Boolean\nall = runFn2 allImpl\n\nforeign import allImpl :: forall a. Fn2 (a -> Boolean) (Array a) Boolean\n\n-- | Perform a fold using a monadic step function.\n-- |\n-- | ```purescript\n-- | foldM (\\x y -> Just (x + y)) 0 [1, 4] = Just 5\n-- | ```\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> Array a -> m b\nfoldM f b = runFn3 unconsImpl (\\_ -> pure b) (\\a as -> f b a >>= \\b' -> foldM f b' as)\n\nfoldRecM :: forall m a b. MonadRec m => (b -> a -> m b) -> b -> Array a -> m b\nfoldRecM f b array = tailRecM2 go b 0\n  where\n  go res i\n    | i >= length array = pure (Done res)\n    | otherwise = do\n        res' <- f res (unsafePartial (unsafeIndex array i))\n        pure (Loop { a: res', b: i + 1 })\n\n-- | Find the element of an array at the specified index.\n-- |\n-- | ```purescript\n-- | unsafePartial $ unsafeIndex [\"a\", \"b\", \"c\"] 1 = \"b\"\n-- | ```\n-- |\n-- | Using `unsafeIndex` with an out-of-range index will not immediately raise a runtime error.\n-- | Instead, the result will be undefined. Most attempts to subsequently use the result will\n-- | cause a runtime error, of course, but this is not guaranteed, and is dependent on the backend;\n-- | some programs will continue to run as if nothing is wrong. For example, in the JavaScript backend,\n-- | the expression `unsafePartial (unsafeIndex [true] 1)` has type `Boolean`;\n-- | since this expression evaluates to `undefined`, attempting to use it in an `if` statement will cause\n-- | the else branch to be taken.\nunsafeIndex :: forall a. Partial => Array a -> Int -> a\nunsafeIndex = runFn2 unsafeIndexImpl\n\nforeign import unsafeIndexImpl :: forall a. Fn2 (Array a) Int a\n","module Data.Exists where\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | This type constructor can be used to existentially quantify over a type.\n-- |\n-- | Specifically, the type `Exists f` is isomorphic to the existential type `exists a. f a`.\n-- |\n-- | Existential types can be encoded using universal types (`forall`) for endofunctors in more general\n-- | categories. The benefit of this library is that, by using the FFI, we can create an efficient\n-- | representation of the existential by simply hiding type information.\n-- |\n-- | For example, consider the type `exists s. Tuple s (s -> Tuple s a)` which represents infinite streams\n-- | of elements of type `a`.\n-- |\n-- | This type can be constructed by creating a type constructor `StreamF` as follows:\n-- |\n-- | ```purescript\n-- | data StreamF a s = StreamF s (s -> Tuple s a)\n-- | ```\n-- |\n-- | We can then define the type of streams using `Exists`:\n-- |\n-- | ```purescript\n-- | type Stream a = Exists (StreamF a)\n-- | ```\nforeign import data Exists :: forall k. (k -> Type) -> Type\n\ntype role Exists representational\n\n-- | The `mkExists` function is used to introduce a value of type `Exists f`, by providing a value of\n-- | type `f a`, for some type `a` which will be hidden in the existentially-quantified type.\n-- |\n-- | For example, to create a value of type `Stream Number`, we might use `mkExists` as follows:\n-- |\n-- | ```purescript\n-- | nats :: Stream Number\n-- | nats = mkExists $ StreamF 0 (\\n -> Tuple (n + 1) n)\n-- | ```\nmkExists :: forall f a. f a -> Exists f\nmkExists = unsafeCoerce\n\n-- | The `runExists` function is used to eliminate a value of type `Exists f`. The rank 2 type ensures\n-- | that the existentially-quantified type does not escape its scope. Since the function is required\n-- | to work for _any_ type `a`, it will work for the existentially-quantified type.\n-- |\n-- | For example, we can write a function to obtain the head of a stream by using `runExists` as follows:\n-- |\n-- | ```purescript\n-- | head :: forall a. Stream a -> a\n-- | head = runExists head'\n-- |   where\n-- |   head' :: forall s. StreamF a s -> a\n-- |   head' (StreamF s f) = snd (f s)\n-- | ```\nrunExists :: forall f r. (forall a. f a -> r) -> Exists f -> r\nrunExists = unsafeCoerce\n","module Data.Coyoneda\n  ( Coyoneda(..)\n  , CoyonedaF\n  , coyoneda\n  , unCoyoneda\n  , liftCoyoneda\n  , lowerCoyoneda\n  , hoistCoyoneda\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, alt)\nimport Control.Alternative (class Alternative, class Plus, empty)\nimport Control.Comonad (class Comonad, extract)\nimport Control.Extend (class Extend, (<<=))\nimport Control.Monad.Trans.Class (class MonadTrans)\nimport Control.MonadPlus (class MonadPlus)\nimport Data.Distributive (class Distributive, collect)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Exists (Exists, runExists, mkExists)\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1, foldMap1, foldr1Default, foldl1Default)\nimport Data.Semigroup.Traversable (class Traversable1, sequence1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\n\n-- | `Coyoneda` is encoded as an existential type using `Data.Exists`.\n-- |\n-- | This type constructor encodes the contents of the existential package.\ndata CoyonedaF f a i = CoyonedaF (i -> a) (f i)\n\n-- | The `Coyoneda` `Functor`.\n-- |\n-- | `Coyoneda f` is a `Functor` for any type constructor `f`. In fact,\n-- | it is the _free_ `Functor` for `f`, i.e. any natural transformation\n-- | `nat :: f ~> g`, can be factor through `liftCoyoneda`.  The natural\n-- | transformation from `Coyoneda f ~> g` is given by `lowerCoyoneda <<<\n-- | hoistCoyoneda nat`:\n-- | ```purescript\n-- | lowerCoyoneda <<< hoistCoyoneda nat <<< liftCoyoneda $ fi\n-- | = lowerCoyoneda (hoistCoyoneda nat (Coyoneda $ mkExists $ CoyonedaF identity fi))    (by definition of liftCoyoneda)\n-- | = lowerCoyoneda (coyoneda identity (nat fi))                                         (by definition of hoistCoyoneda)\n-- | = unCoyoneda map (coyoneda identity (nat fi))                                        (by definition of lowerCoyoneda)\n-- | = unCoyoneda map (Coyoneda $ mkExists $ CoyonedaF  identity (nat fi))                (by definition of coyoneda)\n-- | = map identity (nat fi)                                                              (by definition of unCoyoneda)\n-- | = nat fi                                                                       (since g is a Functor)\n-- | ```\nnewtype Coyoneda f a = Coyoneda (Exists (CoyonedaF f a))\n\ninstance eqCoyoneda :: (Functor f, Eq1 f, Eq a) => Eq (Coyoneda f a) where\n  eq x y = lowerCoyoneda x `eq1` lowerCoyoneda y\n\ninstance eq1Coyoneda :: (Functor f, Eq1 f) => Eq1 (Coyoneda f) where\n  eq1 = eq\n\ninstance ordCoyoneda :: (Functor f, Ord1 f, Ord a) => Ord (Coyoneda f a) where\n  compare x y = lowerCoyoneda x `compare1` lowerCoyoneda y\n\ninstance ord1Coyoneda :: (Functor f, Ord1 f) => Ord1 (Coyoneda f) where\n  compare1 = compare\n\ninstance functorCoyoneda :: Functor (Coyoneda f) where\n  map f (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> coyoneda (f <<< k) fi) e\n\ninstance invatiantCoyoneda :: Invariant (Coyoneda f) where\n  imap = imapF\n\ninstance applyCoyoneda :: Apply f => Apply (Coyoneda f) where\n  apply f g = liftCoyoneda $ lowerCoyoneda f <*> lowerCoyoneda g\n\ninstance applicativeCoyoneda :: Applicative f => Applicative (Coyoneda f) where\n  pure = liftCoyoneda <<< pure\n\ninstance altCoyoneda :: Alt f => Alt (Coyoneda f) where\n  alt x y = liftCoyoneda $ alt (lowerCoyoneda x) (lowerCoyoneda y)\n\ninstance plusCoyoneda :: Plus f => Plus (Coyoneda f) where\n  empty = liftCoyoneda empty\n\ninstance alternativeCoyoneda :: Alternative f => Alternative (Coyoneda f)\n\ninstance bindCoyoneda :: Bind f => Bind (Coyoneda f) where\n  bind (Coyoneda e) f =\n    liftCoyoneda $\n      runExists (\\(CoyonedaF k fi) -> lowerCoyoneda <<< f <<< k =<< fi) e\n\n-- | When `f` is a Monad then it is a functor as well.  In this case\n-- | `liftCoyoneda` is not only a functor isomorphism but also a monad\n-- | isomorphism, i.e. the following law holds\n-- | ```purescript\n-- | liftCoyoneda fa >>= liftCoyoneda <<< g = liftCoyoneda $ fa >>= g\n-- | ```\ninstance monadCoyoneda :: Monad f => Monad (Coyoneda f)\n\ninstance monadTransCoyoneda :: MonadTrans Coyoneda where\n  lift = liftCoyoneda\n\ninstance monadPlusCoyoneda :: MonadPlus f => MonadPlus (Coyoneda f)\n\ninstance extendCoyoneda :: Extend w => Extend (Coyoneda w) where\n  extend f (Coyoneda e) =\n    runExists (\\(CoyonedaF k fi) -> liftCoyoneda $ f <<< coyoneda k <<= fi) e\n\n-- | As in the monad case: if `w` is a comonad, then it is a functor, thus\n-- | `liftCoyoneda` is an iso of functors, but moreover it is an iso of\n-- | comonads, i.e. the following law holds:\n-- | ```purescript\n-- | g <<= liftCoyoneda w = liftCoyoneda $ g <<< liftCoyoneda <<= w\n-- | ```\ninstance comonadCoyoneda :: Comonad w => Comonad (Coyoneda w) where\n  extract (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> k $ extract fi) e\n\ninstance foldableCoyoneda :: Foldable f => Foldable (Coyoneda f) where\n  foldr f z = unCoyoneda \\k -> foldr (f <<< k) z\n  foldl f z = unCoyoneda \\k -> foldl (\\x -> f x <<< k) z\n  foldMap f = unCoyoneda \\k -> foldMap (f <<< k)\n\ninstance traversableCoyoneda :: Traversable f => Traversable (Coyoneda f) where\n  traverse f = unCoyoneda \\k -> map liftCoyoneda <<< traverse (f <<< k)\n  sequence = unCoyoneda \\k -> map liftCoyoneda <<< traverse k\n\ninstance foldable1Coyoneda :: Foldable1 f => Foldable1 (Coyoneda f) where\n  foldMap1 f = unCoyoneda \\k -> foldMap1 (f <<< k)\n  foldr1 = foldr1Default\n  foldl1 = foldl1Default\n\ninstance traversable1Coyoneda :: Traversable1 f => Traversable1 (Coyoneda f) where\n  traverse1 f = unCoyoneda \\k -> map liftCoyoneda <<< traverse1 (f <<< k)\n  sequence1 = unCoyoneda \\k -> map liftCoyoneda <<< sequence1 <<< map k\n\ninstance distributiveCoyoneda :: Distributive f => Distributive (Coyoneda f) where\n  collect f = liftCoyoneda <<< collect (lowerCoyoneda <<< f)\n  distribute = liftCoyoneda <<< collect lowerCoyoneda\n\n-- | Construct a value of type `Coyoneda f b` from a mapping function and a\n-- | value of type `f a`.\ncoyoneda :: forall f a b. (a -> b) -> f a -> Coyoneda f b\ncoyoneda k fi = Coyoneda $ mkExists $ CoyonedaF k fi\n\n-- | Deconstruct a value of `Coyoneda a` to retrieve the mapping function and\n-- | original value.\nunCoyoneda :: forall f a r. (forall b. (b -> a) -> f b -> r) -> Coyoneda f a -> r\nunCoyoneda f (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> f k fi) e\n\n-- | Lift a value described by the type constructor `f` to `Coyoneda f`.\n-- |\n-- | Note that for any functor `f` `liftCoyoneda` has a right inverse\n-- | `lowerCoyoneda`:\n-- | ```purescript\n-- | liftCoyoneda <<< lowerCoyoneda $ (Coyoneda e)\n-- | = liftCoyoneda <<< unCoyoneda map $ (Coyoneda e)\n-- | = liftCoyonead (runExists (\\(CoyonedaF k fi) -> map k fi) e)\n-- | = liftCoyonead (Coyoneda e)\n-- | = coyoneda identity (Coyoneda e)\n-- | = Coyoneda e\n-- | ```\n-- | Moreover if `f` is a `Functor` then `liftCoyoneda` is an isomorphism of\n-- | functors with inverse `lowerCoyoneda`:  we already showed that\n-- | `lowerCoyoneda <<< hoistCoyoneda identity = lowerCoyoneda` is its left inverse\n-- | whenever `f` is a functor.\nliftCoyoneda :: forall f. f ~> Coyoneda f\nliftCoyoneda = coyoneda identity\n\n-- | Lower a value of type `Coyoneda f a` to the `Functor` `f`.\nlowerCoyoneda :: forall f. Functor f => Coyoneda f ~> f\nlowerCoyoneda = unCoyoneda map\n\n-- | Use a natural transformation to change the generating type constructor of a\n-- | `Coyoneda`.\nhoistCoyoneda :: forall f g. (f ~> g) -> Coyoneda f ~> Coyoneda g\nhoistCoyoneda nat (Coyoneda e) =\n  runExists (\\(CoyonedaF k fi) -> coyoneda k (nat fi)) e\n","module Data.FoldableWithIndex\n  ( class FoldableWithIndex, foldrWithIndex, foldlWithIndex, foldMapWithIndex\n  , foldrWithIndexDefault\n  , foldlWithIndexDefault\n  , foldMapWithIndexDefaultR\n  , foldMapWithIndexDefaultL\n  , foldWithIndexM\n  , traverseWithIndex_\n  , forWithIndex_\n  , surroundMapWithIndex\n  , allWithIndex\n  , anyWithIndex\n  , findWithIndex\n  , findMapWithIndex\n  , foldrDefault\n  , foldlDefault\n  , foldMapDefault\n  ) where\n\nimport Prelude\n\nimport Data.Const (Const)\nimport Data.Either (Either(..))\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct, coproduct)\nimport Data.Functor.Product (Product(..))\nimport Data.FunctorWithIndex (mapWithIndex)\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Newtype (unwrap)\nimport Data.Tuple (Tuple(..), curry)\n\n-- | A `Foldable` with an additional index.\n-- | A `FoldableWithIndex` instance must be compatible with its `Foldable`\n-- | instance\n-- | ```purescript\n-- | foldr f = foldrWithIndex (const f)\n-- | foldl f = foldlWithIndex (const f)\n-- | foldMap f = foldMapWithIndex (const f)\n-- | ```\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrWithIndexDefault`\n-- | - `foldlWithIndexDefault`\n-- | - `foldMapWithIndexDefaultR`\n-- | - `foldMapWithIndexDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f <= FoldableWithIndex i f | f -> i where\n  foldrWithIndex :: forall a b. (i -> a -> b -> b) -> b -> f a -> b\n  foldlWithIndex :: forall a b. (i -> b -> a -> b) -> b -> f a -> b\n  foldMapWithIndex :: forall a m. Monoid m => (i -> a -> m) -> f a -> m\n\n-- | A default implementation of `foldrWithIndex` using `foldMapWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldMapWithIndexDefaultR`.\nfoldrWithIndexDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (i -> a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrWithIndexDefault c u xs = unwrap (foldMapWithIndex (\\i -> Endo <<< c i) xs) u\n\n-- | A default implementation of `foldlWithIndex` using `foldMapWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldMapWithIndexDefaultL`.\nfoldlWithIndexDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (i -> b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlWithIndexDefault c u xs = unwrap (unwrap (foldMapWithIndex (\\i -> Dual <<< Endo <<< flip (c i)) xs)) u\n\n-- | A default implementation of `foldMapWithIndex` using `foldrWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldrWithIndexDefault`.\nfoldMapWithIndexDefaultR\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (i -> a -> m)\n  -> f a\n  -> m\nfoldMapWithIndexDefaultR f = foldrWithIndex (\\i x acc -> f i x <> acc) mempty\n\n-- | A default implementation of `foldMapWithIndex` using `foldlWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldlWithIndexDefault`.\nfoldMapWithIndexDefaultL\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (i -> a -> m)\n  -> f a\n  -> m\nfoldMapWithIndexDefaultL f = foldlWithIndex (\\i acc x -> acc <> f i x) mempty\n\ninstance foldableWithIndexArray :: FoldableWithIndex Int Array where\n  foldrWithIndex f z = foldr (\\(Tuple i x) y -> f i x y) z <<< mapWithIndex Tuple\n  foldlWithIndex f z = foldl (\\y (Tuple i x) -> f i y x) z <<< mapWithIndex Tuple\n  foldMapWithIndex = foldMapWithIndexDefaultR\n\ninstance foldableWithIndexMaybe :: FoldableWithIndex Unit Maybe where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexFirst :: FoldableWithIndex Unit First where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexLast :: FoldableWithIndex Unit Last where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexAdditive :: FoldableWithIndex Unit Additive where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexDual :: FoldableWithIndex Unit Dual where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexDisj :: FoldableWithIndex Unit Disj where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexConj :: FoldableWithIndex Unit Conj where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexMultiplicative :: FoldableWithIndex Unit Multiplicative where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexEither :: FoldableWithIndex Unit (Either a) where\n  foldrWithIndex _ z (Left _)  = z\n  foldrWithIndex f z (Right x) = f unit x z\n  foldlWithIndex _ z (Left _)  = z\n  foldlWithIndex f z (Right x) = f unit z x\n  foldMapWithIndex _ (Left _)  = mempty\n  foldMapWithIndex f (Right x) = f unit x\n\ninstance foldableWithIndexTuple :: FoldableWithIndex Unit (Tuple a) where\n  foldrWithIndex f z (Tuple _ x) = f unit x z\n  foldlWithIndex f z (Tuple _ x) = f unit z x\n  foldMapWithIndex f (Tuple _ x) = f unit x\n\ninstance foldableWithIndexIdentity :: FoldableWithIndex Unit Identity where\n  foldrWithIndex f z (Identity x) = f unit x z\n  foldlWithIndex f z (Identity x) = f unit z x\n  foldMapWithIndex f (Identity x) = f unit x\n\ninstance foldableWithIndexConst :: FoldableWithIndex Void (Const a) where\n  foldrWithIndex _ z _ = z\n  foldlWithIndex _ z _ = z\n  foldMapWithIndex _ _ = mempty\n\ninstance foldableWithIndexProduct :: (FoldableWithIndex a f, FoldableWithIndex b g) => FoldableWithIndex (Either a b) (Product f g) where\n  foldrWithIndex f z (Product (Tuple fa ga)) = foldrWithIndex (f <<< Left) (foldrWithIndex (f <<< Right) z ga) fa\n  foldlWithIndex f z (Product (Tuple fa ga)) = foldlWithIndex (f <<< Right) (foldlWithIndex (f <<< Left) z fa) ga\n  foldMapWithIndex f (Product (Tuple fa ga)) = foldMapWithIndex (f <<< Left) fa <> foldMapWithIndex (f <<< Right) ga\n\ninstance foldableWithIndexCoproduct :: (FoldableWithIndex a f, FoldableWithIndex b g) => FoldableWithIndex (Either a b) (Coproduct f g) where\n  foldrWithIndex f z = coproduct (foldrWithIndex (f <<< Left) z) (foldrWithIndex (f <<< Right) z)\n  foldlWithIndex f z = coproduct (foldlWithIndex (f <<< Left) z) (foldlWithIndex (f <<< Right) z)\n  foldMapWithIndex f = coproduct (foldMapWithIndex (f <<< Left)) (foldMapWithIndex (f <<< Right))\n\ninstance foldableWithIndexCompose :: (FoldableWithIndex a f, FoldableWithIndex b g) => FoldableWithIndex (Tuple a b) (Compose f g) where\n  foldrWithIndex f i (Compose fga) = foldrWithIndex (\\a -> flip (foldrWithIndex (curry f a))) i fga\n  foldlWithIndex f i (Compose fga) = foldlWithIndex (foldlWithIndex <<< curry f) i fga\n  foldMapWithIndex f (Compose fga) = foldMapWithIndex (foldMapWithIndex <<< curry f) fga\n\ninstance foldableWithIndexApp :: FoldableWithIndex a f => FoldableWithIndex a (App f) where\n  foldrWithIndex f z (App x) = foldrWithIndex f z x\n  foldlWithIndex f z (App x) = foldlWithIndex f z x\n  foldMapWithIndex f (App x) = foldMapWithIndex f x\n\n\n-- | Similar to 'foldlWithIndex', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldWithIndexM\n  :: forall i f m a b\n   . FoldableWithIndex i f\n  => Monad m\n  => (i -> a -> b -> m a)\n  -> a\n  -> f b\n  -> m a\nfoldWithIndexM f a0 = foldlWithIndex (\\i ma b -> ma >>= flip (f i) b) (pure a0)\n\n-- | Traverse a data structure with access to the index, performing some\n-- | effects encoded by an `Applicative` functor at each value, ignoring the\n-- | final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > traverseWithIndex_ (curry logShow) [\"a\", \"b\", \"c\"]\n-- | (Tuple 0 \"a\")\n-- | (Tuple 1 \"b\")\n-- | (Tuple 2 \"c\")\n-- | ```\ntraverseWithIndex_\n  :: forall i a b f m\n   . Applicative m\n  => FoldableWithIndex i f\n  => (i -> a -> m b)\n  -> f a\n  -> m Unit\ntraverseWithIndex_ f = foldrWithIndex (\\i -> (*>) <<< f i) (pure unit)\n\n-- | A version of `traverseWithIndex_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | forWithIndex_ [\"a\", \"b\", \"c\"] \\i x -> do\n-- |   logShow i\n-- |   log x\n-- | ```\nforWithIndex_\n  :: forall i a b f m\n   . Applicative m\n  => FoldableWithIndex i f\n  => f a\n  -> (i -> a -> m b)\n  -> m Unit\nforWithIndex_ = flip traverseWithIndex_\n\n-- | `foldMapWithIndex` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) []\n-- | = \"*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\"]\n-- | = \"*0a*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\", \"b\"]\n-- | = \"*0a*1b*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\", \"b\", \"c\"]\n-- | = \"*0a*1b*2c*\"\n-- | ```\nsurroundMapWithIndex\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Semigroup m\n  => m\n  -> (i -> a -> m)\n  -> f a\n  -> m\nsurroundMapWithIndex d t f = unwrap (foldMapWithIndex joined f) d\n  where joined i a = Endo \\m -> d <> t i a <> m\n\n-- | `allWithIndex f` is the same as `and <<< mapWithIndex f`; map a function over the\n-- | structure, and then get the conjunction of the results.\nallWithIndex\n  :: forall i a b f\n   . FoldableWithIndex i f\n  => HeytingAlgebra b\n  => (i -> a -> b)\n  -> f a\n  -> b\nallWithIndex t = unwrap <<< foldMapWithIndex (\\i -> Conj <<< t i)\n\n-- | `anyWithIndex f` is the same as `or <<< mapWithIndex f`; map a function over the\n-- | structure, and then get the disjunction of the results.\nanyWithIndex\n  :: forall i a b f\n   . FoldableWithIndex i f\n  => HeytingAlgebra b\n  => (i -> a -> b)\n  -> f a\n  -> b\nanyWithIndex t = unwrap <<< foldMapWithIndex (\\i -> Disj <<< t i)\n\n-- | Try to find an element in a data structure which satisfies a predicate\n-- | with access to the index.\nfindWithIndex\n  :: forall i a f\n   . FoldableWithIndex i f\n  => (i -> a -> Boolean)\n  -> f a\n  -> Maybe { index :: i, value :: a }\nfindWithIndex p = foldlWithIndex go Nothing\n  where\n    go\n      :: i\n      -> Maybe { index :: i, value :: a }\n      -> a\n      -> Maybe { index :: i, value :: a }\n    go i Nothing x | p i x = Just { index: i, value: x }\n    go _ r _ = r\n\n-- | Try to find an element in a data structure which satisfies a predicate mapping\n-- | with access to the index.\nfindMapWithIndex\n  :: forall i a b f\n   . FoldableWithIndex i f\n  => (i -> a -> Maybe b)\n  -> f a\n  -> Maybe b\nfindMapWithIndex f = foldlWithIndex go Nothing\n  where\n    go\n      :: i\n      -> Maybe b\n      -> a\n      -> Maybe b\n    go i Nothing x = f i x\n    go _ r _ = r\n\n-- | A default implementation of `foldr` using `foldrWithIndex`\nfoldrDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (a -> b -> b) -> b -> f a -> b\nfoldrDefault f = foldrWithIndex (const f)\n\n-- | A default implementation of `foldl` using `foldlWithIndex`\nfoldlDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (b -> a -> b) -> b -> f a -> b\nfoldlDefault f = foldlWithIndex (const f)\n\n-- | A default implementation of `foldMap` using `foldMapWithIndex`\nfoldMapDefault\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (a -> m) -> f a -> m\nfoldMapDefault f = foldMapWithIndex (const f)\n","module Data.TraversableWithIndex \n  ( class TraversableWithIndex, traverseWithIndex\n  , traverseWithIndexDefault\n  , forWithIndex\n  , scanlWithIndex\n  , mapAccumLWithIndex\n  , scanrWithIndex\n  , mapAccumRWithIndex\n  , traverseDefault\n  , module Data.Traversable.Accum\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.FoldableWithIndex (class FoldableWithIndex)\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..), coproduct)\nimport Data.Functor.Product (Product(..), product)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe)\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj)\nimport Data.Monoid.Disj (Disj)\nimport Data.Monoid.Dual (Dual)\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Traversable (class Traversable, sequence, traverse)\nimport Data.Traversable.Accum (Accum)\nimport Data.Traversable.Accum.Internal (StateL(..), StateR(..), stateL, stateR)\nimport Data.Tuple (Tuple(..), curry)\n\n\n-- | A `Traversable` with an additional index.  \n-- | A `TraversableWithIndex` instance must be compatible with its\n-- | `Traversable` instance\n-- | ```purescript\n-- | traverse f = traverseWithIndex (const f)\n-- | ```\n-- | with its `FoldableWithIndex` instance\n-- | ```\n-- | foldMapWithIndex f = unwrap <<< traverseWithIndex (\\i -> Const <<< f i)\n-- | ```\n-- | and with its `FunctorWithIndex` instance\n-- | ```\n-- | mapWithIndex f = unwrap <<< traverseWithIndex (\\i -> Identity <<< f i)\n-- | ```\n-- |\n-- | A default implementation is provided by `traverseWithIndexDefault`.\nclass (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) <= TraversableWithIndex i t | t -> i where\n  traverseWithIndex :: forall a b m. Applicative m => (i -> a -> m b) -> t a -> m (t b)\n\n-- | A default implementation of `traverseWithIndex` using `sequence` and `mapWithIndex`.\ntraverseWithIndexDefault\n  :: forall i t a b m\n   . TraversableWithIndex i t\n  => Applicative m\n  => (i -> a -> m b)\n  -> t a\n  -> m (t b)\ntraverseWithIndexDefault f = sequence <<< mapWithIndex f\n\ninstance traversableWithIndexArray :: TraversableWithIndex Int Array where\n  traverseWithIndex = traverseWithIndexDefault\n\ninstance traversableWithIndexMaybe :: TraversableWithIndex Unit Maybe where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexFirst :: TraversableWithIndex Unit First where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexLast :: TraversableWithIndex Unit Last where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexAdditive :: TraversableWithIndex Unit Additive where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexDual :: TraversableWithIndex Unit Dual where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexConj :: TraversableWithIndex Unit Conj where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexDisj :: TraversableWithIndex Unit Disj where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexMultiplicative :: TraversableWithIndex Unit Multiplicative where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexEither :: TraversableWithIndex Unit (Either a) where\n  traverseWithIndex _ (Left x)  = pure (Left x)\n  traverseWithIndex f (Right x) = Right <$> f unit x\n\ninstance traversableWithIndexTuple :: TraversableWithIndex Unit (Tuple a) where\n  traverseWithIndex f (Tuple x y) = Tuple x <$> f unit y\n\ninstance traversableWithIndexIdentity :: TraversableWithIndex Unit Identity where\n  traverseWithIndex f (Identity x) = Identity <$> f unit x\n\ninstance traversableWithIndexConst :: TraversableWithIndex Void (Const a) where\n  traverseWithIndex _ (Const x) = pure (Const x)\n\ninstance traversableWithIndexProduct :: (TraversableWithIndex a f, TraversableWithIndex b g) => TraversableWithIndex (Either a b) (Product f g) where\n  traverseWithIndex f (Product (Tuple fa ga)) = lift2 product (traverseWithIndex (f <<< Left) fa) (traverseWithIndex (f <<< Right) ga)\n\ninstance traversableWithIndexCoproduct :: (TraversableWithIndex a f, TraversableWithIndex b g) => TraversableWithIndex (Either a b) (Coproduct f g) where\n  traverseWithIndex f = coproduct\n    (map (Coproduct <<< Left) <<< traverseWithIndex (f <<< Left))\n    (map (Coproduct <<< Right) <<< traverseWithIndex (f <<< Right))\n\ninstance traversableWithIndexCompose :: (TraversableWithIndex a f, TraversableWithIndex b g) => TraversableWithIndex (Tuple a b) (Compose f g) where\n  traverseWithIndex f (Compose fga) = map Compose $ traverseWithIndex (traverseWithIndex <<< curry f) fga\n\ninstance traversableWithIndexApp :: TraversableWithIndex a f => TraversableWithIndex a (App f) where\n  traverseWithIndex f (App x) = App <$> traverseWithIndex f x\n\n-- | A version of `traverseWithIndex` with its arguments flipped.\n-- |\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for [1, 2, 3] \\i x -> do\n-- |   logShow i\n-- |   pure (x * x)\n-- | ```\nforWithIndex\n  :: forall i a b m t\n   . Applicative m\n  => TraversableWithIndex i t\n  => t a\n  -> (i -> a -> m b)\n  -> m (t b)\nforWithIndex = flip traverseWithIndex\n\n-- | Fold a data structure from the left with access to the indices, keeping\n-- | all intermediate results instead of only the final result. Note that the\n-- | initial value does not appear in the result (unlike Haskell's\n-- | `Prelude.scanl`).\n-- |\n-- | ```purescript\n-- | scanlWithIndex (\\i y x -> i + y + x) 0 [1, 2, 3] = [1, 4, 9]\n-- | ```\nscanlWithIndex\n  :: forall i a b f\n   . TraversableWithIndex i f\n  => (i -> b -> a -> b)\n  -> b\n  -> f a\n  -> f b\nscanlWithIndex f b0 xs =\n  (mapAccumLWithIndex (\\i b a -> let b' = f i b a in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the left with access to the indices, keeping\n-- | all intermediate results instead of only the final result.\n-- |\n-- | Unlike `scanlWithIndex`, `mapAccumLWithIndex` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumLWithIndex\n  :: forall i a b s f\n   . TraversableWithIndex i f\n  => (i -> s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumLWithIndex f s0 xs = stateL (traverseWithIndex (\\i a -> StateL \\s -> f i s a) xs) s0\n\n-- | Fold a data structure from the right with access to the indices, keeping\n-- | all intermediate results instead of only the final result. Note that the\n-- | initial value does not appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```purescript\n-- | scanrWithIndex (\\i x y -> i + x + y) 0 [1, 2, 3] = [9, 8, 5]\n-- | ```\nscanrWithIndex\n  :: forall i a b f\n   . TraversableWithIndex i f\n  => (i -> a -> b -> b)\n  -> b\n  -> f a\n  -> f b\nscanrWithIndex f b0 xs =\n  (mapAccumRWithIndex (\\i b a -> let b' = f i a b in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the right with access to the indices, keeping\n-- | all intermediate results instead of only the final result.\n-- |\n-- | Unlike `scanrWithIndex`, `imapAccumRWithIndex` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumRWithIndex\n  :: forall i a b s f\n   . TraversableWithIndex i f\n  => (i -> s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumRWithIndex f s0 xs = stateR (traverseWithIndex (\\i a -> StateR \\s -> f i s a) xs) s0\n\n-- | A default implementation of `traverse` in terms of `traverseWithIndex`\ntraverseDefault\n  :: forall i t a b m\n   . TraversableWithIndex i t\n  => Applicative m\n  => (a -> m b) -> t a -> m (t b)\ntraverseDefault f = traverseWithIndex (const f)\n","-- | This module defines a generic non-empty data structure, which adds an\n-- | additional element to any container type.\nmodule Data.NonEmpty\n  ( NonEmpty(..)\n  , singleton\n  , (:|)\n  , foldl1\n  , fromNonEmpty\n  , oneOf\n  , head\n  , tail\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Plus (class Plus, empty)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, foldMap)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldMapWithIndex, foldlWithIndex, foldrWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Ord (class Ord1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Foldable (foldl1) as Foldable1\nimport Data.Traversable (class Traversable, traverse, sequence)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (uncurry)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | A non-empty container of elements of type a.\n-- |\n-- | ```purescript\n-- | import Data.NonEmpty\n-- |\n-- | nonEmptyArray :: NonEmpty Array Int\n-- | nonEmptyArray = NonEmpty 1 [2,3]\n-- |\n-- | import Data.List(List(..), (:))\n-- |\n-- | nonEmptyList :: NonEmpty List Int\n-- | nonEmptyList = NonEmpty 1 (2 : 3 : Nil)\n-- | ```\ndata NonEmpty f a = NonEmpty a (f a)\n\n-- | An infix synonym for `NonEmpty`.\n-- |\n-- | ```purescript\n-- | nonEmptyArray :: NonEmpty Array Int\n-- | nonEmptyArray = 1 :| [2,3]\n-- |\n-- | nonEmptyList :: NonEmpty List Int\n-- | nonEmptyList = 1 :| 2 : 3 : Nil\n-- | ```\ninfixr 5 NonEmpty as :|\n\n-- | Create a non-empty structure with a single value.\n-- |\n-- | ```purescript\n-- | import Prelude\n-- |\n-- | singleton 1 == 1 :| []\n-- | singleton 1 == 1 :| Nil\n-- | ```\nsingleton :: forall f a. Plus f => a -> NonEmpty f a\nsingleton a = a :| empty\n\n-- | Fold a non-empty structure, collecting results using a binary operation.\n-- |\n-- | ```purescript\n-- | foldl1 (+) (1 :| [2, 3]) == 6\n-- | ```\nfoldl1 :: forall f a. Foldable f => (a -> a -> a) -> NonEmpty f a -> a\nfoldl1 = Foldable1.foldl1\n\n-- | Apply a function that takes the `first` element and remaining elements\n-- | as arguments to a non-empty container.\n-- |\n-- | For example, return the remaining elements multiplied by the first element:\n-- |\n-- | ```purescript\n-- | fromNonEmpty (\\x xs -> map (_ * x) xs) (3 :| [2, 1]) == [6, 3]\n-- | ```\nfromNonEmpty :: forall f a r. (a -> f a -> r) -> NonEmpty f a -> r\nfromNonEmpty f (a :| fa) = a `f` fa\n\n-- | Returns the `alt` (`<|>`) result of:\n-- | - The first element lifted to the container of the remaining elements.\n-- | - The remaining elements.\n-- |\n-- | ```purescript\n-- | import Data.Maybe(Maybe(..))\n-- |\n-- | oneOf (1 :| Nothing) == Just 1\n-- | oneOf (1 :| Just 2) == Just 1\n-- |\n-- | oneOf (1 :| [2, 3]) == [1,2,3]\n-- | ```\noneOf :: forall f a. Alternative f => NonEmpty f a -> f a\noneOf (a :| fa) = pure a <|> fa\n\n-- | Get the 'first' element of a non-empty container.\n-- |\n-- | ```purescript\n-- | head (1 :| [2, 3]) == 1\n-- | ```\nhead :: forall f a. NonEmpty f a -> a\nhead (x :| _) = x\n\n-- | Get everything but the 'first' element of a non-empty container.\n-- |\n-- | ```purescript\n-- | tail (1 :| [2, 3]) == [2, 3]\n-- | ```\ntail :: forall f a. NonEmpty f a -> f a\ntail (_ :| xs) = xs\n\ninstance showNonEmpty :: (Show a, Show (f a)) => Show (NonEmpty f a) where\n  show (a :| fa) = \"(NonEmpty \" <> show a <> \" \" <> show fa <> \")\"\n\nderive instance eqNonEmpty :: (Eq1 f, Eq a) => Eq (NonEmpty f a)\n\nderive instance eq1NonEmpty :: Eq1 f => Eq1 (NonEmpty f)\n\nderive instance ordNonEmpty :: (Ord1 f, Ord a) => Ord (NonEmpty f a)\n\nderive instance ord1NonEmpty :: Ord1 f => Ord1 (NonEmpty f)\n\nderive instance functorNonEmpty :: Functor f => Functor (NonEmpty f)\n\ninstance functorWithIndex\n  :: FunctorWithIndex i f\n  => FunctorWithIndex (Maybe i) (NonEmpty f) where\n  mapWithIndex f (a :| fa) = f Nothing a :| mapWithIndex (f <<< Just) fa\n\ninstance foldableNonEmpty :: Foldable f => Foldable (NonEmpty f) where\n  foldMap f (a :| fa) = f a <> foldMap f fa\n  foldl f b (a :| fa) = foldl f (f b a) fa\n  foldr f b (a :| fa) = f a (foldr f b fa)\n\ninstance foldableWithIndexNonEmpty\n  :: (FoldableWithIndex i f)\n  => FoldableWithIndex (Maybe i) (NonEmpty f) where\n  foldMapWithIndex f (a :| fa) = f Nothing a <> foldMapWithIndex (f <<< Just) fa\n  foldlWithIndex f b (a :| fa) = foldlWithIndex (f <<< Just) (f Nothing b a) fa\n  foldrWithIndex f b (a :| fa) = f Nothing a (foldrWithIndex (f <<< Just) b fa)\n\ninstance traversableNonEmpty :: Traversable f => Traversable (NonEmpty f) where\n  sequence (a :| fa) = NonEmpty <$> a <*> sequence fa\n  traverse f (a :| fa) = NonEmpty <$> f a <*> traverse f fa\n\ninstance traversableWithIndexNonEmpty\n  :: (TraversableWithIndex i f)\n  => TraversableWithIndex (Maybe i) (NonEmpty f) where\n  traverseWithIndex f (a :| fa) =\n    NonEmpty <$> f Nothing a <*> traverseWithIndex (f <<< Just) fa\n\ninstance foldable1NonEmpty :: Foldable f => Foldable1 (NonEmpty f) where\n  foldMap1 f (a :| fa) = foldl (\\s a1 -> s <> f a1) (f a) fa\n  foldr1 f (a :| fa) = maybe a (f a) $ foldr (\\a1 -> Just <<< maybe a1 (f a1)) Nothing fa\n  foldl1 f (a :| fa) = foldl f a fa\n\ninstance unfoldable1NonEmpty :: Unfoldable f => Unfoldable1 (NonEmpty f) where\n  unfoldr1 f b = uncurry (:|) $ unfoldr (map f) <$> f b\n\n-- | This is a lawful `Semigroup` instance that will behave sensibly for common nonempty\n-- | containers like lists and arrays. However, it's not guaranteed that `pure` will behave\n-- | sensibly alongside `<>` for all types, as we don't have any laws which govern their behavior.\ninstance semigroupNonEmpty\n  :: (Applicative f, Semigroup (f a))\n  => Semigroup (NonEmpty f a) where\n  append (a1 :| f1) (a2 :| f2) = a1 :| (f1 <> pure a2 <> f2)\n","module Data.List.Types\n  ( List(..)\n  , (:)\n  , NonEmptyList(..)\n  , toList\n  , nelCons\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, intercalate)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex, foldMapWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.NonEmpty as NE\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Traversable (class Traversable1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), snd)\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\ndata List a = Nil | Cons a (List a)\n\ninfixr 6 Cons as :\n\ninstance showList :: Show a => Show (List a) where\n  show Nil = \"Nil\"\n  show xs = \"(\" <> intercalate \" : \" (show <$> xs) <> \" : Nil)\"\n\ninstance eqList :: Eq a => Eq (List a) where\n  eq = eq1\n\ninstance eq1List :: Eq1 List where\n  eq1 xs ys = go xs ys true\n    where\n      go _ _ false = false\n      go Nil Nil acc = acc\n      go (x : xs') (y : ys') acc = go xs' ys' $ acc && (y == x)\n      go _ _ _ = false\n\ninstance ordList :: Ord a => Ord (List a) where\n  compare = compare1\n\ninstance ord1List :: Ord1 List where\n  compare1 xs ys = go xs ys\n    where\n    go Nil Nil = EQ\n    go Nil _ = LT\n    go _ Nil = GT\n    go (x : xs') (y : ys') =\n      case compare x y of\n        EQ -> go xs' ys'\n        other -> other\n\ninstance semigroupList :: Semigroup (List a) where\n  append xs ys = foldr (:) ys xs\n\ninstance monoidList :: Monoid (List a) where\n  mempty = Nil\n\ninstance functorList :: Functor List where\n  map = listMap\n\n-- chunked list Functor inspired by OCaml\n-- https://discuss.ocaml.org/t/a-new-list-map-that-is-both-stack-safe-and-fast/865\n-- chunk sizes determined through experimentation\nlistMap :: forall a b. (a -> b) -> List a -> List b\nlistMap f = chunkedRevMap Nil\n  where\n  chunkedRevMap :: List (List a) -> List a -> List b\n  chunkedRevMap chunksAcc chunk@(_ : _ : _ : xs) =\n    chunkedRevMap (chunk : chunksAcc) xs\n  chunkedRevMap chunksAcc xs =\n    reverseUnrolledMap chunksAcc $ unrolledMap xs\n    where\n    unrolledMap :: List a -> List b\n    unrolledMap (x1 : x2 : Nil) = f x1 : f x2 : Nil\n    unrolledMap (x1 : Nil) = f x1 : Nil\n    unrolledMap _ = Nil\n\n    reverseUnrolledMap :: List (List a) -> List b -> List b\n    reverseUnrolledMap ((x1 : x2 : x3 : _) : cs) acc =\n      reverseUnrolledMap cs (f x1 : f x2 : f x3 : acc)\n    reverseUnrolledMap _ acc = acc\n\ninstance functorWithIndexList :: FunctorWithIndex Int List where\n  mapWithIndex f = foldrWithIndex (\\i x acc -> f i x : acc) Nil\n\ninstance foldableList :: Foldable List where\n  foldr f b = foldl (flip f) b <<< rev\n    where\n    rev = go Nil\n      where\n      go acc Nil = acc\n      go acc (x : xs) = go (x : acc) xs\n  foldl f = go\n    where\n    go b = case _ of\n      Nil -> b\n      a : as -> go (f b a) as\n  foldMap f = foldl (\\acc -> append acc <<< f) mempty\n\ninstance foldableWithIndexList :: FoldableWithIndex Int List where\n  foldrWithIndex f b xs =\n    -- as we climb the reversed list, we decrement the index\n    snd $ foldl\n            (\\(Tuple i b') a -> Tuple (i - 1) (f (i - 1) a b'))\n            (Tuple len b)\n            revList\n    where\n    Tuple len revList = rev (Tuple 0 Nil) xs\n      where\n      -- As we create our reversed list, we count elements.\n      rev = foldl (\\(Tuple i acc) a -> Tuple (i + 1) (a : acc))\n  foldlWithIndex f acc =\n    snd <<< foldl (\\(Tuple i b) a -> Tuple (i + 1) (f i b a)) (Tuple 0 acc)\n  foldMapWithIndex f = foldlWithIndex (\\i acc -> append acc <<< f i) mempty\n\ninstance unfoldable1List :: Unfoldable1 List where\n  unfoldr1 f b = go b Nil\n    where\n    go source memo = case f source of\n      Tuple one (Just rest) -> go rest (one : memo)\n      Tuple one Nothing -> foldl (flip (:)) Nil (one : memo)\n\ninstance unfoldableList :: Unfoldable List where\n  unfoldr f b = go b Nil\n    where\n    go source memo = case f source of\n      Nothing -> (foldl (flip (:)) Nil memo)\n      Just (Tuple one rest) -> go rest (one : memo)\n\ninstance traversableList :: Traversable List where\n  traverse f = map (foldl (flip (:)) Nil) <<< foldl (\\acc -> lift2 (flip (:)) acc <<< f) (pure Nil)\n  sequence = traverse identity\n\ninstance traversableWithIndexList :: TraversableWithIndex Int List where\n  traverseWithIndex f =\n    map rev\n    <<< foldlWithIndex (\\i acc -> lift2 (flip (:)) acc <<< f i) (pure Nil)\n    where\n    rev = foldl (flip Cons) Nil\n\ninstance applyList :: Apply List where\n  apply Nil _ = Nil\n  apply (f : fs) xs = (f <$> xs) <> (fs <*> xs)\n\ninstance applicativeList :: Applicative List where\n  pure a = a : Nil\n\ninstance bindList :: Bind List where\n  bind Nil _ = Nil\n  bind (x : xs) f = f x <> bind xs f\n\ninstance monadList :: Monad List\n\ninstance altList :: Alt List where\n  alt = append\n\ninstance plusList :: Plus List where\n  empty = Nil\n\ninstance alternativeList :: Alternative List\n\ninstance monadPlusList :: MonadPlus List\n\ninstance extendList :: Extend List where\n  extend _ Nil = Nil\n  extend f l@(_ : as) =\n    f l : (foldr go { val: Nil, acc: Nil } as).val\n    where\n    go a' { val, acc } =\n      let acc' = a' : acc\n      in { val: f acc' : val, acc: acc' }\n\nnewtype NonEmptyList a = NonEmptyList (NonEmpty List a)\n\ntoList :: NonEmptyList ~> List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nnelCons :: forall a. a -> NonEmptyList a -> NonEmptyList a\nnelCons a (NonEmptyList (b :| bs)) = NonEmptyList (a :| b : bs)\n\nderive instance newtypeNonEmptyList :: Newtype (NonEmptyList a) _\n\nderive newtype instance eqNonEmptyList :: Eq a => Eq (NonEmptyList a)\nderive newtype instance ordNonEmptyList :: Ord a => Ord (NonEmptyList a)\n\nderive newtype instance eq1NonEmptyList :: Eq1 NonEmptyList\nderive newtype instance ord1NonEmptyList :: Ord1 NonEmptyList\n\ninstance showNonEmptyList :: Show a => Show (NonEmptyList a) where\n  show (NonEmptyList nel) = \"(NonEmptyList \" <> show nel <> \")\"\n\nderive newtype instance functorNonEmptyList :: Functor NonEmptyList\n\ninstance applyNonEmptyList :: Apply NonEmptyList where\n  apply (NonEmptyList (f :| fs)) (NonEmptyList (a :| as)) =\n    NonEmptyList (f a :| (fs <*> a : Nil) <> ((f : fs) <*> as))\n\ninstance applicativeNonEmptyList :: Applicative NonEmptyList where\n  pure = NonEmptyList <<< NE.singleton\n\ninstance bindNonEmptyList :: Bind NonEmptyList where\n  bind (NonEmptyList (a :| as)) f =\n    case f a of\n      NonEmptyList (b :| bs) ->\n        NonEmptyList (b :| bs <> bind as (toList <<< f))\n\ninstance monadNonEmptyList :: Monad NonEmptyList\n\ninstance altNonEmptyList :: Alt NonEmptyList where\n  alt = append\n\ninstance extendNonEmptyList :: Extend NonEmptyList where\n  extend f w@(NonEmptyList (_ :| as)) =\n    NonEmptyList (f w :| (foldr go { val: Nil, acc: Nil } as).val)\n    where\n    go a { val, acc } = { val: f (NonEmptyList (a :| acc)) : val, acc: a : acc }\n\ninstance comonadNonEmptyList :: Comonad NonEmptyList where\n  extract (NonEmptyList (a :| _)) = a\n\ninstance semigroupNonEmptyList :: Semigroup (NonEmptyList a) where\n  append (NonEmptyList (a :| as)) as' =\n    NonEmptyList (a :| as <> toList as')\n\nderive newtype instance foldableNonEmptyList :: Foldable NonEmptyList\n\nderive newtype instance traversableNonEmptyList :: Traversable NonEmptyList\n\nderive newtype instance foldable1NonEmptyList :: Foldable1 NonEmptyList\n\nderive newtype instance unfoldable1NonEmptyList :: Unfoldable1 NonEmptyList\n\ninstance functorWithIndexNonEmptyList :: FunctorWithIndex Int NonEmptyList where\n  mapWithIndex fn (NonEmptyList ne) = NonEmptyList $ mapWithIndex (fn <<< maybe 0 (add 1)) ne\n\ninstance foldableWithIndexNonEmptyList :: FoldableWithIndex Int NonEmptyList where\n  foldMapWithIndex f (NonEmptyList ne) = foldMapWithIndex (f <<< maybe 0 (add 1)) ne\n  foldlWithIndex f b (NonEmptyList ne) = foldlWithIndex (f <<< maybe 0 (add 1)) b ne\n  foldrWithIndex f b (NonEmptyList ne) = foldrWithIndex (f <<< maybe 0 (add 1)) b ne\n\ninstance traversableWithIndexNonEmptyList :: TraversableWithIndex Int NonEmptyList where\n  traverseWithIndex f (NonEmptyList ne) = NonEmptyList <$> traverseWithIndex (f <<< maybe 0 (add 1)) ne\n\ninstance traversable1NonEmptyList :: Traversable1 NonEmptyList where\n  traverse1 f (NonEmptyList (a :| as)) =\n    foldl (\\acc -> lift2 (flip nelCons) acc <<< f) (pure <$> f a) as\n      <#> case _ of NonEmptyList (x :| xs) → foldl (flip nelCons) (pure x) xs\n  sequence1 = traverse1 identity\n","-- | This module defines a type of maps as height-balanced (AVL) binary trees.\n-- | Efficient set operations are implemented in terms of\n-- | <https://www.cs.cmu.edu/~guyb/papers/BFS16.pdf>\n\nmodule Data.Map.Internal\n  ( Map(..)\n  , showTree\n  , empty\n  , isEmpty\n  , singleton\n  , checkValid\n  , insert\n  , insertWith\n  , lookup\n  , lookupLE\n  , lookupLT\n  , lookupGE\n  , lookupGT\n  , findMin\n  , findMax\n  , foldSubmap\n  , submap\n  , fromFoldable\n  , fromFoldableWith\n  , fromFoldableWithIndex\n  , toUnfoldable\n  , toUnfoldableUnordered\n  , delete\n  , pop\n  , member\n  , alter\n  , update\n  , keys\n  , values\n  , union\n  , unionWith\n  , unions\n  , intersection\n  , intersectionWith\n  , difference\n  , isSubmap\n  , size\n  , filterWithKey\n  , filterKeys\n  , filter\n  , mapMaybeWithKey\n  , mapMaybe\n  , catMaybes\n  , MapIter\n  , MapIterStep(..)\n  , toMapIter\n  , stepAsc\n  , stepAscCps\n  , stepDesc\n  , stepDescCps\n  , stepUnordered\n  , stepUnorderedCps\n  , unsafeNode\n  , unsafeBalancedNode\n  , unsafeJoinNodes\n  , unsafeSplit\n  , Split(..)\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex)\nimport Data.Function.Uncurried (Fn2, Fn3, Fn4, Fn7, mkFn2, mkFn3, mkFn4, mkFn7, runFn2, runFn3, runFn4, runFn7)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.List (List(..), (:))\nimport Data.Maybe (Maybe(..))\nimport Data.Ord (class Ord1, abs)\nimport Data.Traversable (traverse, class Traversable)\nimport Data.TraversableWithIndex (class TraversableWithIndex)\nimport Data.Tuple (Tuple(Tuple))\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Prim.TypeError (class Warn, Text)\n\n-- | `Map k v` represents maps from keys of type `k` to values of type `v`.\ndata Map k v = Leaf | Node Int Int k v (Map k v) (Map k v)\n\ntype role Map nominal representational\n\ninstance eq1Map :: Eq k => Eq1 (Map k) where\n  eq1 = eq\n\ninstance eqMap :: (Eq k, Eq v) => Eq (Map k v) where\n  eq xs ys = case xs of\n    Leaf ->\n      case ys of\n        Leaf -> true\n        _ -> false\n    Node _ s1 _ _ _ _ ->\n      case ys of\n        Node _ s2 _ _ _ _\n          | s1 == s2 ->\n              toMapIter xs == toMapIter ys\n        _ ->\n          false\n\ninstance ord1Map :: Ord k => Ord1 (Map k) where\n  compare1 = compare\n\ninstance ordMap :: (Ord k, Ord v) => Ord (Map k v) where\n  compare xs ys = case xs of\n    Leaf ->\n      case ys of\n        Leaf -> EQ\n        _ -> LT\n    _ ->\n      case ys of\n        Leaf -> GT\n        _ -> compare (toMapIter xs) (toMapIter ys)\n\ninstance showMap :: (Show k, Show v) => Show (Map k v) where\n  show as = \"(fromFoldable \" <> show (toUnfoldable as :: Array _) <> \")\"\n\ninstance semigroupMap ::\n  ( Warn (Text \"Data.Map's `Semigroup` instance is now unbiased and differs from the left-biased instance defined in PureScript releases <= 0.13.x.\")\n  , Ord k\n  , Semigroup v\n  ) => Semigroup (Map k v) where\n  append = unionWith append\n\ninstance monoidSemigroupMap ::\n  ( Warn (Text \"Data.Map's `Semigroup` instance is now unbiased and differs from the left-biased instance defined in PureScript releases <= 0.13.x.\")\n  , Ord k\n  , Semigroup v\n  ) => Monoid (Map k v) where\n  mempty = empty\n\ninstance altMap :: Ord k => Alt (Map k) where\n  alt = union\n\ninstance plusMap :: Ord k => Plus (Map k) where\n  empty = empty\n\ninstance functorMap :: Functor (Map k) where\n  map f = go\n    where\n    go = case _ of\n      Leaf -> Leaf\n      Node h s k v l r ->\n        Node h s k (f v) (go l) (go r)\n\ninstance functorWithIndexMap :: FunctorWithIndex k (Map k) where\n  mapWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> Leaf\n      Node h s k v l r ->\n        Node h s k (f k v) (go l) (go r)\n\ninstance applyMap :: Ord k => Apply (Map k) where\n  apply = intersectionWith identity\n\ninstance bindMap :: Ord k => Bind (Map k) where\n  bind m f = mapMaybeWithKey (\\k -> lookup k <<< f) m\n\ninstance foldableMap :: Foldable (Map k) where\n  foldr f z = \\m -> runFn2 go m z\n    where\n    go = mkFn2 \\m' z' -> case m' of\n      Leaf -> z'\n      Node _ _ _ v l r ->\n        runFn2 go l (f v (runFn2 go r z'))\n  foldl f z = \\m -> runFn2 go z m\n    where\n    go = mkFn2 \\z' m' -> case m' of\n      Leaf -> z'\n      Node _ _ _ v l r ->\n        runFn2 go (f (runFn2 go z' l) v) r\n  foldMap f = go\n    where\n    go = case _ of\n      Leaf -> mempty\n      Node _ _ _ v l r ->\n        go l <> f v <> go r\n\ninstance foldableWithIndexMap :: FoldableWithIndex k (Map k) where\n  foldrWithIndex f z = \\m -> runFn2 go m z\n    where\n    go = mkFn2 \\m' z' -> case m' of\n      Leaf -> z'\n      Node _ _ k v l r ->\n        runFn2 go l (f k v (runFn2 go r z'))\n  foldlWithIndex f z = \\m -> runFn2 go z m\n    where\n    go = mkFn2 \\z' m' -> case m' of\n      Leaf -> z'\n      Node _ _ k v l r ->\n        runFn2 go (f k (runFn2 go z' l) v) r\n  foldMapWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> mempty\n      Node _ _ k v l r ->\n        go l <> f k v <> go r\n\ninstance traversableMap :: Traversable (Map k) where\n  traverse f = go\n    where\n    go = case _ of\n      Leaf -> pure Leaf\n      Node h s k v l r ->\n        (\\l' v' r' -> Node h s k v' l' r')\n          <$> go l\n          <*> f v\n          <*> go r\n  sequence = traverse identity\n\ninstance traversableWithIndexMap :: TraversableWithIndex k (Map k) where\n  traverseWithIndex f = go\n    where\n    go = case _ of\n      Leaf -> pure Leaf\n      Node h s k v l r ->\n        (\\l' v' r' -> Node h s k v' l' r')\n          <$> go l\n          <*> f k v\n          <*> go r\n\n-- | Render a `Map` as a `String`\nshowTree :: forall k v. Show k => Show v => Map k v -> String\nshowTree = go \"\"\n  where\n  go ind = case _ of\n    Leaf -> ind <> \"Leaf\"\n    Node h _ k v l r ->\n      (ind <> \"[\" <> show h  <> \"] \" <> show k <> \" => \" <> show v <> \"\\n\")\n        <> (go (ind <> \"    \") l <> \"\\n\")\n        <> (go (ind <> \"    \") r)\n\n-- | An empty map\nempty :: forall k v. Map k v\nempty = Leaf\n\n-- | Test if a map is empty\nisEmpty :: forall k v. Map k v -> Boolean\nisEmpty Leaf = true\nisEmpty _ = false\n\n-- | Create a map with one key/value pair\nsingleton :: forall k v. k -> v -> Map k v\nsingleton k v = Node 1 1 k v Leaf Leaf\n\n-- | Check whether the underlying tree satisfies the height, size, and ordering invariants.\n-- |\n-- | This function is provided for internal use.\ncheckValid :: forall k v. Ord k => Map k v -> Boolean\ncheckValid = go\n  where\n  go = case _ of\n    Leaf -> true\n    Node h s k _ l r ->\n      case l of\n        Leaf ->\n          case r of\n            Leaf ->\n              true\n            Node rh rs rk _ _ _ ->\n              h == 2 && rh == 1 && s > rs && rk > k && go r\n        Node lh ls lk _ _ _ ->\n          case r of\n            Leaf ->\n              h == 2 && lh == 1 && s > ls && lk < k && go l\n            Node rh rs rk _ _ _ ->\n              h > rh && rk > k && h > lh && lk < k && abs (rh - lh) < 2 && rs + ls + 1 == s && go l && go r\n\n-- | Look up a value for the specified key\nlookup :: forall k v. Ord k => k -> Map k v -> Maybe v\nlookup k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT -> go mr\n        EQ -> Just mv\n\n-- | Look up a value for the specified key, or the greatest one less than it\nlookupLE :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupLE k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT ->\n          case go mr of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        EQ ->\n          Just { key: mk, value: mv }\n\n-- | Look up a value for the greatest key less than the specified key\nlookupLT :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupLT k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT ->\n          case go mr of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        EQ ->\n          findMax ml\n\n-- | Look up a value for the specified key, or the least one greater than it\nlookupGE :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupGE k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT ->\n          case go ml of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        GT -> go mr\n        EQ -> Just { key: mk, value: mv }\n\n-- | Look up a value for the least key greater than the specified key\nlookupGT :: forall k v. Ord k => k -> Map k v -> Maybe { key :: k, value :: v }\nlookupGT k = go\n  where\n  go = case _ of\n    Leaf -> Nothing\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT ->\n          case go ml of\n            Nothing -> Just { key: mk, value: mv }\n            other -> other\n        GT -> go mr\n        EQ -> findMin mr\n\n-- | Returns the pair with the greatest key\nfindMax :: forall k v. Map k v -> Maybe { key :: k, value :: v }\nfindMax = case _ of\n  Leaf -> Nothing\n  Node _ _ k v  _ r ->\n    case r of\n      Leaf -> Just { key: k, value: v }\n      _ -> findMax r\n\n-- | Returns the pair with the least key\nfindMin :: forall k v. Map k v -> Maybe { key :: k, value :: v }\nfindMin = case _ of\n  Leaf -> Nothing\n  Node _ _ k v l _ ->\n    case l of\n      Leaf -> Just { key: k, value: v }\n      _ -> findMin l\n\n-- | Fold over the entries of a given map where the key is between a lower and\n-- | an upper bound. Passing `Nothing` as either the lower or upper bound\n-- | argument means that the fold has no lower or upper bound, i.e. the fold\n-- | starts from (or ends with) the smallest (or largest) key in the map.\n-- |\n-- | ```purescript\n-- | foldSubmap (Just 1) (Just 2) (\\_ v -> [v])\n-- |  (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |  == [\"one\", \"two\"]\n-- |\n-- | foldSubmap Nothing (Just 2) (\\_ v -> [v])\n-- |  (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |  == [\"zero\", \"one\", \"two\"]\n-- | ```\nfoldSubmap :: forall k v m. Ord k => Monoid m => Maybe k -> Maybe k -> (k -> v -> m) -> Map k v -> m\nfoldSubmap = foldSubmapBy (<>) mempty\n\nfoldSubmapBy :: forall k v m. Ord k => (m -> m -> m) -> m -> Maybe k -> Maybe k -> (k -> v -> m) -> Map k v -> m\nfoldSubmapBy appendFn memptyValue kmin kmax f =\n  let\n    tooSmall =\n      case kmin of\n        Just kmin' ->\n          \\k -> k < kmin'\n        Nothing ->\n          const false\n\n    tooLarge =\n      case kmax of\n        Just kmax' ->\n          \\k -> k > kmax'\n        Nothing ->\n          const false\n\n    inBounds =\n      case kmin, kmax of\n        Just kmin', Just kmax' ->\n          \\k -> kmin' <= k && k <= kmax'\n        Just kmin', Nothing ->\n          \\k -> kmin' <= k\n        Nothing, Just kmax' ->\n          \\k -> k <= kmax'\n        Nothing, Nothing ->\n          const true\n\n    go = case _ of\n      Leaf ->\n        memptyValue\n      Node _ _ k v left right ->\n                    (if tooSmall k then memptyValue else go left)\n        `appendFn` (if inBounds k then f k v else memptyValue)\n        `appendFn` (if tooLarge k then memptyValue else go right)\n  in\n    go\n\n-- | Returns a new map containing all entries of the given map which lie\n-- | between a given lower and upper bound, treating `Nothing` as no bound i.e.\n-- | including the smallest (or largest) key in the map, no matter how small\n-- | (or large) it is. For example:\n-- |\n-- | ```purescript\n-- | submap (Just 1) (Just 2)\n-- |   (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |   == fromFoldable [Tuple 1 \"one\", Tuple 2 \"two\"]\n-- |\n-- | submap Nothing (Just 2)\n-- |   (fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\", Tuple 3 \"three\"])\n-- |   == fromFoldable [Tuple 0 \"zero\", Tuple 1 \"one\", Tuple 2 \"two\"]\n-- | ```\n-- |\n-- | The function is entirely specified by the following\n-- | property:\n-- |\n-- | ```purescript\n-- | Given any m :: Map k v, mmin :: Maybe k, mmax :: Maybe k, key :: k,\n-- |   let m' = submap mmin mmax m in\n-- |     if (maybe true (\\min -> min <= key) mmin &&\n-- |         maybe true (\\max -> max >= key) mmax)\n-- |       then lookup key m == lookup key m'\n-- |       else not (member key m')\n-- | ```\nsubmap :: forall k v. Ord k => Maybe k -> Maybe k -> Map k v -> Map k v\nsubmap kmin kmax = foldSubmapBy union empty kmin kmax singleton\n\n-- | Test if a key is a member of a map\nmember :: forall k v. Ord k => k -> Map k v -> Boolean\nmember k = go\n  where\n  go = case _ of\n    Leaf -> false\n    Node _ _ mk _ ml mr ->\n      case compare k mk of\n        LT -> go ml\n        GT -> go mr\n        EQ -> true\n\n-- | Insert or replace a key/value pair in a map\ninsert :: forall k v. Ord k => k -> v -> Map k v -> Map k v\ninsert k v = go\n  where\n  go = case _ of\n    Leaf -> singleton k v\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> Node mh ms k v ml mr\n\n-- | Inserts or updates a value with the given function.\n-- |\n-- | The combining function is called with the existing value as the first\n-- | argument and the new value as the second argument.\ninsertWith :: forall k v. Ord k => (v -> v -> v) -> k -> v -> Map k v -> Map k v\ninsertWith app k v = go\n  where\n  go = case _ of\n    Leaf -> singleton k v\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> Node mh ms k (app mv v) ml mr\n\n-- | Delete a key and its corresponding value from a map.\ndelete :: forall k v. Ord k => k -> Map k v -> Map k v\ndelete k = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ -> runFn2 unsafeJoinNodes ml mr\n\n-- | Delete a key and its corresponding value from a map, returning the value\n-- | as well as the subsequent map.\npop :: forall k v. Ord k => k -> Map k v -> Maybe (Tuple v (Map k v))\npop k m = do\n  let (Split x l r) = runFn3 unsafeSplit compare k m\n  map (\\a -> Tuple a (runFn2 unsafeJoinNodes l r)) x\n\n-- | Insert the value, delete a value, or update a value for a key in a map\nalter :: forall k v. Ord k => (Maybe v -> Maybe v) -> k -> Map k v -> Map k v\nalter f k m = do\n  let Split v l r = runFn3 unsafeSplit compare k m\n  case f v of\n    Nothing ->\n      runFn2 unsafeJoinNodes l r\n    Just v' ->\n      runFn4 unsafeBalancedNode k v' l r\n\n-- | Update or delete the value for a key in a map\nupdate :: forall k v. Ord k => (v -> Maybe v) -> k -> Map k v -> Map k v\nupdate f k = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node mh ms mk mv ml mr ->\n      case compare k mk of\n        LT -> runFn4 unsafeBalancedNode mk mv (go ml) mr\n        GT -> runFn4 unsafeBalancedNode mk mv ml (go mr)\n        EQ ->\n          case f mv of\n            Nothing ->\n              runFn2 unsafeJoinNodes ml mr\n            Just mv' ->\n              Node mh ms mk mv' ml mr\n\n-- | Convert any foldable collection of key/value pairs to a map.\n-- | On key collision, later values take precedence over earlier ones.\nfromFoldable :: forall f k v. Ord k => Foldable f => f (Tuple k v) -> Map k v\nfromFoldable = foldl (\\m (Tuple k v) -> insert k v m) empty\n\n-- | Convert any foldable collection of key/value pairs to a map.\n-- | On key collision, the values are configurably combined.\nfromFoldableWith :: forall f k v. Ord k => Foldable f => (v -> v -> v) -> f (Tuple k v) -> Map k v\nfromFoldableWith f = foldl (\\m (Tuple k v) -> f' k v m) empty\n  where\n  f' = insertWith (flip f)\n\n-- | Convert any indexed foldable collection into a map.\nfromFoldableWithIndex :: forall f k v. Ord k => FoldableWithIndex k f => f v -> Map k v\nfromFoldableWithIndex = foldlWithIndex (\\k m v -> insert k v m) empty\n\n-- | Convert a map to an unfoldable structure of key/value pairs where the keys are in ascending order\ntoUnfoldable :: forall f k v. Unfoldable f => Map k v -> f (Tuple k v)\ntoUnfoldable = unfoldr stepUnfoldr <<< toMapIter\n\n-- | Convert a map to an unfoldable structure of key/value pairs\n-- |\n-- | While this traversal is up to 10% faster in benchmarks than `toUnfoldable`,\n-- | it leaks the underlying map stucture, making it only suitable for applications\n-- | where order is irrelevant.\n-- |\n-- | If you are unsure, use `toUnfoldable`\ntoUnfoldableUnordered :: forall f k v. Unfoldable f => Map k v -> f (Tuple k v)\ntoUnfoldableUnordered = unfoldr stepUnfoldrUnordered <<< toMapIter\n\n-- | Get a list of the keys contained in a map\nkeys :: forall k v. Map k v -> List k\nkeys = foldrWithIndex (\\k _ acc -> k : acc) Nil\n\n-- | Get a list of the values contained in a map\nvalues :: forall k v. Map k v -> List v\nvalues = foldr Cons Nil\n\n-- | Compute the union of two maps, using the specified function\n-- | to combine values for duplicate keys.\nunionWith :: forall k v. Ord k => (v -> v -> v) -> Map k v -> Map k v -> Map k v\nunionWith app m1 m2 = runFn4 unsafeUnionWith compare app m1 m2\n\n-- | Compute the union of two maps, preferring values from the first map in the case\n-- | of duplicate keys\nunion :: forall k v. Ord k => Map k v -> Map k v -> Map k v\nunion = unionWith const\n\n-- | Compute the union of a collection of maps\nunions :: forall k v f. Ord k => Foldable f => f (Map k v) -> Map k v\nunions = foldl union empty\n\n-- | Compute the intersection of two maps, using the specified function\n-- | to combine values for duplicate keys.\nintersectionWith :: forall k a b c. Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c\nintersectionWith app m1 m2 = runFn4 unsafeIntersectionWith compare app m1 m2\n\n-- | Compute the intersection of two maps, preferring values from the first map in the case\n-- | of duplicate keys.\nintersection :: forall k a b. Ord k => Map k a -> Map k b -> Map k a\nintersection = intersectionWith const\n\n-- | Difference of two maps. Return elements of the first map where\n-- | the keys do not exist in the second map.\ndifference :: forall k v w. Ord k => Map k v -> Map k w -> Map k v\ndifference m1 m2 = runFn3 unsafeDifference compare m1 m2\n\n-- | Test whether one map contains all of the keys and values contained in another map\nisSubmap :: forall k v. Ord k => Eq v => Map k v -> Map k v -> Boolean\nisSubmap = go\n  where\n  go m1 m2 = case m1 of\n    Leaf -> true\n    Node _ _ k v l r ->\n      case lookup k m2 of\n        Nothing -> false\n        Just v' ->\n          v == v' && go l m2 && go r m2\n\n-- | Calculate the number of key/value pairs in a map\nsize :: forall k v. Map k v -> Int\nsize = case _ of\n  Leaf -> 0\n  Node _ s _ _ _ _ -> s\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | fails to hold.\nfilterWithKey :: forall k v. Ord k => (k -> v -> Boolean) -> Map k v -> Map k v\nfilterWithKey f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r\n      | f k v ->\n          runFn4 unsafeBalancedNode k v (go l) (go r)\n      | otherwise ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the key fails to hold.\nfilterKeys :: forall k. Ord k => (k -> Boolean) -> Map k ~> Map k\nfilterKeys f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r\n      | f k ->\n          runFn4 unsafeBalancedNode k v (go l) (go r)\n      | otherwise ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the value fails to hold.\nfilter :: forall k v. Ord k => (v -> Boolean) -> Map k v -> Map k v\nfilter = filterWithKey <<< const\n\n-- | Applies a function to each key/value pair in a map, discarding entries\n-- | where the function returns `Nothing`.\nmapMaybeWithKey :: forall k a b. Ord k => (k -> a -> Maybe b) -> Map k a -> Map k b\nmapMaybeWithKey f = go\n  where\n  go = case _ of\n    Leaf -> Leaf\n    Node _ _ k v l r ->\n      case f k v of\n        Just v' ->\n          runFn4 unsafeBalancedNode k v' (go l) (go r)\n        Nothing ->\n          runFn2 unsafeJoinNodes (go l) (go r)\n\n-- | Applies a function to each value in a map, discarding entries where the\n-- | function returns `Nothing`.\nmapMaybe :: forall k a b. Ord k => (a -> Maybe b) -> Map k a -> Map k b\nmapMaybe = mapMaybeWithKey <<< const\n\n-- | Filter a map of optional values, keeping only the key/value pairs which\n-- | contain a value, creating a new map.\ncatMaybes :: forall k v. Ord k => Map k (Maybe v) -> Map k v\ncatMaybes = mapMaybe identity\n\n-- | Low-level Node constructor which maintains the height and size invariants\n-- | This is unsafe because it assumes the child Maps are ordered and balanced.\nunsafeNode :: forall k v. Fn4 k v (Map k v) (Map k v) (Map k v)\nunsafeNode = mkFn4 \\k v l r -> case l of\n  Leaf ->\n    case r of\n      Leaf ->\n        Node 1 1 k v l r\n      Node h2 s2 _ _ _ _ ->\n        Node (1 + h2) (1 + s2) k v l r\n  Node h1 s1 _ _ _ _ ->\n    case r of\n      Leaf ->\n        Node (1 + h1) (1 + s1) k v l r\n      Node h2 s2 _ _ _ _ ->\n        Node (1 + if h1 > h2 then h1 else h2) (1 + s1 + s2) k v l r\n\n-- | Low-level Node constructor which maintains the balance invariants.\n-- | This is unsafe because it assumes the child Maps are ordered.\nunsafeBalancedNode :: forall k v. Fn4 k v (Map k v) (Map k v) (Map k v)\nunsafeBalancedNode = mkFn4 \\k v l r -> case l of\n  Leaf ->\n    case r of\n      Leaf ->\n        singleton k v\n      Node rh _ rk rv rl rr\n        | rh > 1 ->\n            runFn7 rotateLeft k v l rk rv rl rr\n      _ ->\n        runFn4 unsafeNode k v l r\n  Node lh _ lk lv ll lr ->\n    case r of\n      Node rh _ rk rv rl rr\n        | rh > lh + 1 ->\n            runFn7 rotateLeft k v l rk rv rl rr\n        | lh > rh + 1 ->\n            runFn7 rotateRight k v lk lv ll lr r\n      Leaf\n        | lh > 1 ->\n            runFn7 rotateRight k v lk lv ll lr r\n      _ ->\n        runFn4 unsafeNode k v l r\n  where\n  rotateLeft :: Fn7 k v (Map k v) k v (Map k v) (Map k v) (Map k v)\n  rotateLeft = mkFn7 \\k v l rk rv rl rr -> case rl of\n    Node lh _ lk lv ll lr\n      | lh > height rr ->\n          runFn4 unsafeNode lk lv (runFn4 unsafeNode k v l ll) (runFn4 unsafeNode rk rv lr rr)\n    _ ->\n      runFn4 unsafeNode rk rv (runFn4 unsafeNode k v l rl) rr\n\n  rotateRight :: Fn7 k v k v (Map k v) (Map k v) (Map k v) (Map k v)\n  rotateRight = mkFn7 \\k v lk lv ll lr r -> case lr of\n    Node rh _ rk rv rl rr\n      | height ll <= rh ->\n          runFn4 unsafeNode rk rv (runFn4 unsafeNode lk lv ll rl) (runFn4 unsafeNode k v rr r)\n    _ ->\n      runFn4 unsafeNode lk lv ll (runFn4 unsafeNode k v lr r)\n\n  height :: Map k v -> Int\n  height = case _ of\n    Leaf -> 0\n    Node h _ _ _ _ _ -> h\n\n-- | Low-level Node constructor from two Maps.\n-- | This is unsafe because it assumes the child Maps are ordered.\nunsafeJoinNodes :: forall k v. Fn2 (Map k v) (Map k v) (Map k v)\nunsafeJoinNodes = mkFn2 case _, _ of\n  Leaf, b -> b\n  Node _ _ lk lv ll lr, r -> do\n    let (SplitLast k v l) = runFn4 unsafeSplitLast lk lv ll lr\n    runFn4 unsafeBalancedNode k v l r\n\ndata SplitLast k v = SplitLast k v (Map k v)\n\n-- | Reassociates a node by moving the last node to the top.\n-- | This is unsafe because it assumes the key and child Maps are from\n-- | a balanced node.\nunsafeSplitLast :: forall k v. Fn4 k v (Map k v) (Map k v) (SplitLast k v)\nunsafeSplitLast = mkFn4 \\k v l r -> case r of\n  Leaf -> SplitLast k v l\n  Node _ _ rk rv rl rr -> do\n    let (SplitLast k' v' t') = runFn4 unsafeSplitLast rk rv rl rr\n    SplitLast k' v' (runFn4 unsafeBalancedNode k v l t')\n\ndata Split k v = Split (Maybe v) (Map k v) (Map k v)\n\n-- | Reassocates a Map so the given key is at the top.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeSplit :: forall k v. Fn3 (k -> k -> Ordering) k (Map k v) (Split k v)\nunsafeSplit = mkFn3 \\comp k m -> case m of\n  Leaf ->\n    Split Nothing Leaf Leaf\n  Node _ _ mk mv ml mr ->\n    case comp k mk of\n      LT -> do\n        let (Split b ll lr) = runFn3 unsafeSplit comp k ml\n        Split b ll (runFn4 unsafeBalancedNode mk mv lr mr)\n      GT -> do\n        let (Split b rl rr) = runFn3 unsafeSplit comp k mr\n        Split b (runFn4 unsafeBalancedNode mk mv ml rl) rr\n      EQ ->\n        Split (Just mv) ml mr\n\n-- | Low-level unionWith implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeUnionWith :: forall k v. Fn4 (k -> k -> Ordering) (v -> v -> v) (Map k v) (Map k v) (Map k v)\nunsafeUnionWith = mkFn4 \\comp app l r -> case l, r of\n  Leaf, _ -> r\n  _, Leaf -> l\n  _, Node _ _ rk rv rl rr -> do\n    let (Split lv ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn4 unsafeUnionWith comp app ll rl\n    let r' = runFn4 unsafeUnionWith comp app lr rr\n    case lv of\n      Just lv' ->\n        runFn4 unsafeBalancedNode rk (app lv' rv) l' r'\n      Nothing ->\n        runFn4 unsafeBalancedNode rk rv l' r'\n\n-- | Low-level intersectionWith implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeIntersectionWith :: forall k a b c. Fn4 (k -> k -> Ordering) (a -> b -> c) (Map k a) (Map k b) (Map k c)\nunsafeIntersectionWith = mkFn4 \\comp app l r -> case l, r of\n  Leaf, _ -> Leaf\n  _, Leaf -> Leaf\n  _, Node _ _ rk rv rl rr -> do\n    let (Split lv ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn4 unsafeIntersectionWith comp app ll rl\n    let r' = runFn4 unsafeIntersectionWith comp app lr rr\n    case lv of\n      Just lv' ->\n        runFn4 unsafeBalancedNode rk (app lv' rv) l' r'\n      Nothing ->\n        runFn2 unsafeJoinNodes l' r'\n\n-- | Low-level difference implementation.\n-- | This is unsafe because it assumes the ordering function is appropriate.\nunsafeDifference :: forall k v w. Fn3 (k -> k -> Ordering) (Map k v) (Map k w) (Map k v)\nunsafeDifference = mkFn3 \\comp l r -> case l, r of\n  Leaf, _ -> Leaf\n  _, Leaf -> l\n  _, Node _ _ rk _ rl rr -> do\n    let (Split _ ll lr) = runFn3 unsafeSplit comp rk l\n    let l' = runFn3 unsafeDifference comp ll rl\n    let r' = runFn3 unsafeDifference comp lr rr\n    runFn2 unsafeJoinNodes l' r'\n\ndata MapIterStep k v\n  = IterDone\n  | IterNext k v (MapIter k v)\n\n-- | Low-level iteration state for a `Map`. Must be consumed using\n-- | an appropriate stepper.\ndata MapIter k v\n  = IterLeaf\n  | IterEmit k v (MapIter k v)\n  | IterNode (Map k v) (MapIter k v)\n\ninstance (Eq k, Eq v) => Eq (MapIter k v) where\n  eq = go\n    where\n    go a b = case stepAsc a of\n      IterNext k1 v1 a' ->\n        case stepAsc b of\n          IterNext k2 v2 b'\n            | k1 == k2 && v1 == v2 ->\n                go a' b'\n          _ ->\n            false\n      IterDone ->\n        true\n\ninstance (Ord k, Ord v) => Ord (MapIter k v) where\n  compare = go\n    where\n    go a b = case stepAsc a, stepAsc b of\n      IterNext k1 v1 a', IterNext k2 v2 b' ->\n        case compare k1 k2 of\n          EQ ->\n            case compare v1 v2 of\n              EQ ->\n                go a' b'\n              other ->\n                other\n          other ->\n            other\n      IterDone, b'->\n        case b' of\n          IterDone ->\n            EQ\n          _ ->\n            LT\n      _, IterDone ->\n        GT\n\n-- | Converts a Map to a MapIter for iteration using a MapStepper.\ntoMapIter :: forall k v. Map k v -> MapIter k v\ntoMapIter = flip IterNode IterLeaf\n\ntype MapStepper k v = MapIter k v -> MapIterStep k v\n\ntype MapStepperCps k v = forall r. (Fn3 k v (MapIter k v) r) -> (Unit -> r) -> MapIter k v -> r\n\n-- | Steps a `MapIter` in ascending order.\nstepAsc :: forall k v. MapStepper k v\nstepAsc = stepAscCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in descending order.\nstepDesc :: forall k v. MapStepper k v\nstepDesc = stepDescCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in arbitrary order.\nstepUnordered :: forall k v. MapStepper k v\nstepUnordered = stepUnorderedCps (mkFn3 \\k v next -> IterNext k v next) (const IterDone)\n\n-- | Steps a `MapIter` in ascending order with a CPS encoding.\nstepAscCps :: forall k v. MapStepperCps k v\nstepAscCps = stepWith iterMapL\n\n-- | Steps a `MapIter` in descending order with a CPS encoding.\nstepDescCps :: forall k v. MapStepperCps k v\nstepDescCps = stepWith iterMapR\n\n-- | Steps a `MapIter` in arbitrary order with a CPS encoding.\nstepUnorderedCps :: forall k v. MapStepperCps k v\nstepUnorderedCps = stepWith iterMapU\n\nstepUnfoldr :: forall k v. MapIter k v -> Maybe (Tuple (Tuple k v) (MapIter k v))\nstepUnfoldr = stepAscCps step (\\_ -> Nothing)\n  where\n  step = mkFn3 \\k v next ->\n    Just (Tuple (Tuple k v) next)\n\nstepUnfoldrUnordered :: forall k v. MapIter k v -> Maybe (Tuple (Tuple k v) (MapIter k v))\nstepUnfoldrUnordered = stepUnorderedCps step (\\_ -> Nothing)\n  where\n  step = mkFn3 \\k v next ->\n    Just (Tuple (Tuple k v) next)\n\nstepWith :: forall k v r. (MapIter k v -> Map k v -> MapIter k v) -> (Fn3 k v (MapIter k v) r) -> (Unit -> r) -> MapIter k v -> r\nstepWith f next done = go\n  where\n  go = case _ of\n    IterLeaf ->\n      done unit\n    IterEmit k v iter ->\n      runFn3 next k v iter\n    IterNode m iter ->\n      go (f iter m)\n\niterMapL :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapL = go\n  where\n  go iter = case _ of\n    Leaf -> iter\n    Node _ _ k v l r ->\n      case r of\n        Leaf ->\n          go (IterEmit k v iter) l\n        _ ->\n          go (IterEmit k v (IterNode r iter)) l\n\niterMapR :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapR = go\n  where\n  go iter = case _ of\n    Leaf -> iter\n    Node _ _ k v l r ->\n      case r of\n        Leaf ->\n          go (IterEmit k v iter) l\n        _ ->\n          go (IterEmit k v (IterNode l iter)) r\n\niterMapU :: forall k v. MapIter k v -> Map k v -> MapIter k v\niterMapU iter = case _ of\n  Leaf -> iter\n  Node _ _ k v l r ->\n    case l of\n      Leaf ->\n        case r of\n          Leaf ->\n            IterEmit k v iter\n          _ ->\n            IterEmit k v (IterNode r iter)\n      _ ->\n        case r of\n          Leaf ->\n            IterEmit k v (IterNode l iter)\n          _ ->\n            IterEmit k v (IterNode l (IterNode r iter))\n","module Data.Monoid.Alternate where\n\nimport Prelude\n\nimport Control.Alternative (class Alt, class Plus, class Alternative, empty, (<|>))\nimport Control.Comonad (class Comonad, class Extend)\nimport Data.Eq (class Eq1)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup instances corresponding to `Plus` and `Alt` instances\n-- | for `f`\n-- |\n-- | ``` purescript\n-- | Alternate fx <> Alternate fy == Alternate (fx <|> fy)\n-- | mempty :: Alternate _ == Alternate empty\n-- | ```\nnewtype Alternate :: forall k. (k -> Type) -> k -> Type\nnewtype Alternate f a = Alternate (f a)\n\nderive instance newtypeAlternate :: Newtype (Alternate f a) _\n\nderive newtype instance eqAlternate :: Eq (f a) => Eq (Alternate f a)\n\nderive newtype instance eq1Alternate :: Eq1 f => Eq1 (Alternate f)\n\nderive newtype instance ordAlternate :: Ord (f a) => Ord (Alternate f a)\n\nderive newtype instance ord1Alternate :: Ord1 f => Ord1 (Alternate f)\n\nderive newtype instance boundedAlternate :: Bounded (f a) => Bounded (Alternate f a)\n\nderive newtype instance functorAlternate :: Functor f => Functor (Alternate f)\n\nderive newtype instance applyAlternate :: Apply f => Apply (Alternate f)\n\nderive newtype instance applicativeAlternate :: Applicative f => Applicative (Alternate f)\n\nderive newtype instance altAlternate :: Alt f => Alt (Alternate f)\n\nderive newtype instance plusAlternate :: Plus f => Plus (Alternate f)\n\nderive newtype instance alternativeAlternate :: Alternative f => Alternative (Alternate f)\n\nderive newtype instance bindAlternate :: Bind f => Bind (Alternate f)\n\nderive newtype instance monadAlternate :: Monad f => Monad (Alternate f)\n\nderive newtype instance extendAlternate :: Extend f => Extend (Alternate f)\n\nderive newtype instance comonadAlternate :: Comonad f => Comonad (Alternate f)\n\ninstance showAlternate :: Show (f a) => Show (Alternate f a) where\n  show (Alternate a) = \"(Alternate \" <> show a <> \")\"\n\ninstance semigroupAlternate :: Alt f => Semigroup (Alternate f a) where\n  append (Alternate a) (Alternate b) = Alternate (a <|> b)\n\ninstance monoidAlternate :: Plus f => Monoid (Alternate f a) where\n  mempty = Alternate empty\n","module Halogen.Data.OrdBox\n  ( OrdBox\n  , mkOrdBox\n  , unOrdBox\n  ) where\n\nimport Prelude\n\n-- | A value carrying its `Ord` instance so it can be used at a later date\n-- | without the need for evidence of the instance.\ndata OrdBox a = OrdBox (a -> a -> Boolean) (a -> a -> Ordering) a\n\ninstance eqOrdBox :: Eq (OrdBox a) where\n  eq (OrdBox e _ x) (OrdBox _ _ y) = e x y\n\ninstance ordOrdBox :: Ord (OrdBox a) where\n  compare (OrdBox _ c x) (OrdBox _ _ y) = c x y\n\nmkOrdBox :: forall a. Ord a => a -> OrdBox a\nmkOrdBox = OrdBox eq compare\n\nunOrdBox :: forall a. OrdBox a -> a\nunOrdBox (OrdBox _ _ a) = a\n","module Halogen.Data.Slot\n  ( Slot\n  , SlotStorage\n  , empty\n  , lookup\n  , insert\n  , pop\n  , slots\n  , foreachSlot\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (traverse_)\nimport Data.Map (Map)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Data.Monoid.Alternate (Alternate(..))\nimport Data.Newtype (un)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Tuple (Tuple(..))\nimport Halogen.Data.OrdBox (OrdBox, mkOrdBox, unOrdBox)\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Unsafe.Coerce (unsafeCoerce)\n\nforeign import data Any :: Type\n\n-- | A type which records the queries, output messages, and slot identifier for\n-- | a particular slot (ie. a location in HTML where a component is rendered).\n-- | For example:\n-- |\n-- | ```purescript\n-- | type ButtonSlot slot = Slot Button.Query Button.Output slot\n-- |\n-- | -- A component using this slot type can have one type of child component,\n-- | -- which supports `Button.Query` queries, `Button.Output` outputs, and\n-- | -- which can be uniquely identified by an integer.\n-- | type Slots = ( button :: ButtonSlot Int )\n-- | ```\n-- |\n-- | - `query` represents the requests that can be made of this component\n-- | - `output` represents the output messages that can be raised by this component\n-- | - `slot` represents the unique identifier for this component\ndata Slot :: (Type -> Type) -> Type -> Type -> Type\ndata Slot (query :: Type -> Type) output slot\n\nnewtype SlotStorage (slots :: Row Type) (slot :: (Type -> Type) -> Type -> Type) =\n  SlotStorage (Map (Tuple String (OrdBox Any)) Any)\n\nempty :: forall slots slot. SlotStorage slots slot\nempty = SlotStorage Map.empty\n\nlookup\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> SlotStorage slots slot\n  -> Maybe (slot query output)\nlookup sym key (SlotStorage m) =\n  coerceSlot (Map.lookup (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) m)\n  where\n  coerceSlot :: Maybe Any -> Maybe (slot query output)\n  coerceSlot = unsafeCoerce\n\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\npop\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> SlotStorage slots slot\n  -> Maybe (Tuple (slot query output) (SlotStorage slots slot))\npop sym key (SlotStorage m) =\n  coercePop (Map.pop (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) m)\n  where\n  coercePop :: Maybe (Tuple Any (Map (Tuple String (OrdBox Any)) Any)) -> Maybe (Tuple (slot query output) (SlotStorage slots slot))\n  coercePop = unsafeCoerce\n\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\ninsert\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> slot query output\n  -> SlotStorage slots slot\n  -> SlotStorage slots slot\ninsert sym key val (SlotStorage m) =\n  SlotStorage (Map.insert (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) (coerceVal val) m)\n  where\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\n  coerceVal :: slot query output -> Any\n  coerceVal = unsafeCoerce\n\nslots\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> SlotStorage slots slot\n  -> Map s (slot query output)\nslots sym (SlotStorage m) = un Alternate $ Map.foldSubmap Nothing Nothing go m\n  where\n  key = reflectSymbol sym\n\n  go (Tuple key' ob) val\n    | key == key' = Alternate $ Map.singleton (unOrdBox (coerceBox ob)) (coerceVal val)\n    | otherwise = Alternate Map.empty\n\n  coerceBox :: OrdBox Any -> OrdBox s\n  coerceBox = unsafeCoerce\n\n  coerceVal :: Any -> slot query output\n  coerceVal = unsafeCoerce\n\nforeachSlot\n  :: forall m slots slot\n   . Applicative m\n  => SlotStorage slots slot\n  -> (forall query output. slot query output -> m Unit)\n  -> m Unit\nforeachSlot (SlotStorage m) k = traverse_ (k <<< coerceVal) m\n  where\n  coerceVal :: forall query output. Any -> slot query output\n  coerceVal = unsafeCoerce\n","export const _localeCompare = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (s1) {\n        return function (s2) {\n          var result = s1.localeCompare(s2);\n          return result < 0 ? lt : result > 0 ? gt : eq;\n        };\n      };\n    };\n  };\n};\n\nexport const replace = function (s1) {\n  return function (s2) {\n    return function (s3) {\n      return s3.replace(s1, s2);\n    };\n  };\n};\n\nexport const replaceAll = function (s1) {\n  return function (s2) {\n    return function (s3) {\n      return s3.replace(new RegExp(s1.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"g\"), s2); // eslint-disable-line no-useless-escape\n    };\n  };\n};\n\nexport const split = function (sep) {\n  return function (s) {\n    return s.split(sep);\n  };\n};\n\nexport const toLower = function (s) {\n  return s.toLowerCase();\n};\n\nexport const toUpper = function (s) {\n  return s.toUpperCase();\n};\n\nexport const trim = function (s) {\n  return s.trim();\n};\n\nexport const joinWith = function (s) {\n  return function (xs) {\n    return xs.join(s);\n  };\n};\n","module Data.String.Common\n  ( null\n  , localeCompare\n  , replace\n  , replaceAll\n  , split\n  , toLower\n  , toUpper\n  , trim\n  , joinWith\n  ) where\n\nimport Prelude\n\nimport Data.String.Pattern (Pattern, Replacement)\n\n-- | Returns `true` if the given string is empty.\n-- |\n-- | ```purescript\n-- | null \"\" == true\n-- | null \"Hi\" == false\n-- | ```\nnull :: String -> Boolean\nnull s = s == \"\"\n\n-- | Compare two strings in a locale-aware fashion. This is in contrast to\n-- | the `Ord` instance on `String` which treats strings as arrays of code\n-- | units:\n-- |\n-- | ```purescript\n-- | \"ä\" `localeCompare` \"b\" == LT\n-- | \"ä\" `compare` \"b\" == GT\n-- | ```\nlocaleCompare :: String -> String -> Ordering\nlocaleCompare = _localeCompare LT EQ GT\n\nforeign import _localeCompare\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\n-- | Replaces the first occurence of the pattern with the replacement string.\n-- |\n-- | ```purescript\n-- | replace (Pattern \"<=\") (Replacement \"≤\") \"a <= b <= c\" == \"a ≤ b <= c\"\n-- | ```\nforeign import replace :: Pattern -> Replacement -> String -> String\n\n-- | Replaces all occurences of the pattern with the replacement string.\n-- |\n-- | ```purescript\n-- | replaceAll (Pattern \"<=\") (Replacement \"≤\") \"a <= b <= c\" == \"a ≤ b ≤ c\"\n-- | ```\nforeign import replaceAll :: Pattern -> Replacement -> String -> String\n\n-- | Returns the substrings of the second string separated along occurences\n-- | of the first string.\n-- |\n-- | ```purescript\n-- | split (Pattern \" \") \"hello world\" == [\"hello\", \"world\"]\n-- | ```\nforeign import split :: Pattern -> String -> Array String\n\n-- | Returns the argument converted to lowercase.\n-- |\n-- | ```purescript\n-- | toLower \"hElLo\" == \"hello\"\n-- | ```\nforeign import toLower :: String -> String\n\n-- | Returns the argument converted to uppercase.\n-- |\n-- | ```purescript\n-- | toUpper \"Hello\" == \"HELLO\"\n-- | ```\nforeign import toUpper :: String -> String\n\n-- | Removes whitespace from the beginning and end of a string, including\n-- | [whitespace characters](http://www.ecma-international.org/ecma-262/5.1/#sec-7.2)\n-- | and [line terminators](http://www.ecma-international.org/ecma-262/5.1/#sec-7.3).\n-- |\n-- | ```purescript\n-- | trim \"   Hello  \\n World\\n\\t    \" == \"Hello  \\n World\"\n-- | ```\nforeign import trim :: String -> String\n\n-- | Joins the strings in the array together, inserting the first argument\n-- | as separator between them.\n-- |\n-- | ```purescript\n-- | joinWith \", \" [\"apple\", \"banana\", \"orange\"] == \"apple, banana, orange\"\n-- | ```\nforeign import joinWith :: String -> Array String -> String\n","module DOM.HTML.Indexed.InputType where\n\nimport Prelude\n\ndata InputType\n  = InputButton\n  | InputCheckbox\n  | InputColor\n  | InputDate\n  | InputDatetimeLocal\n  | InputEmail\n  | InputFile\n  | InputHidden\n  | InputImage\n  | InputMonth\n  | InputNumber\n  | InputPassword\n  | InputRadio\n  | InputRange\n  | InputReset\n  | InputSearch\n  | InputSubmit\n  | InputTel\n  | InputText\n  | InputTime\n  | InputUrl\n  | InputWeek\n\nderive instance eqInputType :: Eq InputType\nderive instance ordInputType :: Ord InputType\n\nrenderInputType :: InputType -> String\nrenderInputType = case _ of\n  InputButton -> \"button\"\n  InputCheckbox -> \"checkbox\"\n  InputColor -> \"color\"\n  InputDate -> \"date\"\n  InputDatetimeLocal -> \"datetime-local\"\n  InputEmail -> \"email\"\n  InputFile -> \"file\"\n  InputHidden -> \"hidden\"\n  InputImage -> \"image\"\n  InputMonth -> \"month\"\n  InputNumber -> \"number\"\n  InputPassword -> \"password\"\n  InputRadio -> \"radio\"\n  InputRange -> \"range\"\n  InputReset -> \"reset\"\n  InputSearch -> \"search\"\n  InputSubmit -> \"submit\"\n  InputTel -> \"tel\"\n  InputText -> \"text\"\n  InputTime -> \"time\"\n  InputUrl -> \"url\"\n  InputWeek -> \"week\"\n","module DOM.HTML.Indexed.StepValue where\n\nimport Prelude\n\ndata StepValue\n  = Any\n  | Step Number\n\nderive instance eqStepValue :: Eq StepValue\nderive instance ordStepValue :: Ord StepValue\n\nrenderStepValue :: StepValue -> String\nrenderStepValue = case _ of\n  Any -> \"any\"\n  Step n -> show n\n","module Halogen.Query.Input where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Newtype (class Newtype)\nimport Web.DOM (Element)\n\nnewtype RefLabel = RefLabel String\n\nderive instance newtypeRefLabel :: Newtype RefLabel _\nderive newtype instance eqRefLabel :: Eq RefLabel\nderive newtype instance ordRefLabel :: Ord RefLabel\n\ndata Input action\n  = RefUpdate RefLabel (Maybe Element)\n  | Action action\n\nderive instance functorInput :: Functor Input\n","/* eslint-disable no-eq-null, eqeqeq */\n\nconst nullImpl = null;\nexport { nullImpl as null };\n\nexport function nullable(a, r, f) {\n  return a == null ? r : f(a);\n}\n\nexport function notNull(x) {\n  return x;\n}\n","-- | This module defines types and functions for working with nullable types\n-- | using the FFI.\n\nmodule Data.Nullable\n  ( Nullable\n  , null\n  , notNull\n  , toMaybe\n  , toNullable\n  ) where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Function (on)\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Ord (class Ord1)\n\n-- | A nullable type. This type constructor is intended to be used for\n-- | interoperating with JavaScript functions which accept or return null\n-- | values.\n-- |\n-- | The runtime representation of `Nullable T` is the same as that of `T`,\n-- | except that it may also be `null`. For example, the JavaScript values\n-- | `null`, `[]`, and `[1,2,3]` may all be given the type\n-- | `Nullable (Array Int)`. Similarly, the JavaScript values `[]`, `[null]`,\n-- | and `[1,2,null,3]` may all be given the type `Array (Nullable Int)`.\n-- |\n-- | There is one pitfall with `Nullable`, which is that values of the type\n-- | `Nullable T` will not function as you might expect if the type `T` happens\n-- | to itself permit `null` as a valid runtime representation.\n-- |\n-- | In particular, values of the type `Nullable (Nullable T)` will ‘collapse’,\n-- | in the sense that the PureScript expressions `notNull null` and `null`\n-- | will both leave you with a value whose runtime representation is just\n-- | `null`. Therefore it is important to avoid using `Nullable T` in\n-- | situations where `T` itself can take `null` as a runtime representation.\n-- | If in doubt, use `Maybe` instead.\n-- |\n-- | `Nullable` does not permit lawful `Functor`, `Applicative`, or `Monad`\n-- | instances as a result of this pitfall, which is why these instances are\n-- | not provided.\nforeign import data Nullable :: Type -> Type\n\ntype role Nullable representational\n\n-- | The null value.\nforeign import null :: forall a. Nullable a\n\nforeign import nullable :: forall a r. Fn3 (Nullable a) r (a -> r) r\n\n-- | Wrap a non-null value.\nforeign import notNull :: forall a. a -> Nullable a\n\n-- | Takes `Nothing` to `null`, and `Just a` to `a`.\ntoNullable :: forall a. Maybe a -> Nullable a\ntoNullable = maybe null notNull\n\n-- | Represent `null` using `Maybe a` as `Nothing`. Note that this function\n-- | can violate parametricity, as it inspects the runtime representation of\n-- | its argument (see the warning about the pitfall of `Nullable` above).\ntoMaybe :: forall a. Nullable a -> Maybe a\ntoMaybe n = runFn3 nullable n Nothing Just\n\ninstance showNullable :: Show a => Show (Nullable a) where\n  show = maybe \"null\" show <<< toMaybe\n\ninstance eqNullable :: Eq a => Eq (Nullable a) where\n  eq = eq `on` toMaybe\n\ninstance eq1Nullable :: Eq1 Nullable where\n  eq1 = eq\n\ninstance ordNullable :: Ord a => Ord (Nullable a) where\n  compare = compare `on` toMaybe\n\ninstance ord1Nullable :: Ord1 Nullable where\n  compare1 = compare\n","module Halogen.VDom.Machine\n  ( Machine\n  , Step'(..)\n  , Step\n  , mkStep\n  , unStep\n  , extract\n  , step\n  , halt\n  ) where\n\nimport Prelude\n\nimport Effect.Uncurried (EffectFn1, EffectFn2, mkEffectFn1, mkEffectFn2, runEffectFn1, runEffectFn2)\nimport Unsafe.Coerce (unsafeCoerce)\n\ntype Machine a b = EffectFn1 a (Step a b)\n\ndata Step' a b s = Step b s (EffectFn2 s a (Step a b)) (EffectFn1 s Unit)\n\nforeign import data Step ∷ Type → Type → Type\n\nmkStep ∷ ∀ a b s. Step' a b s → Step a b\nmkStep = unsafeCoerce\n\nunStep :: ∀ a b r. (∀ s. Step' a b s → r) → Step a b → r\nunStep = unsafeCoerce\n\n-- | Returns the output value of a `Step`.\nextract ∷ ∀ a b. Step a b → b\nextract = unStep \\(Step x _ _ _) → x\n\n-- | Runs the next step.\nstep ∷ ∀ a b. EffectFn2 (Step a b) a (Step a b)\nstep = coerce $ mkEffectFn2 \\(Step _ s k _) a → runEffectFn2 k s a\n  where\n  coerce ∷ ∀ s. EffectFn2 (Step' a b s) a (Step a b) → EffectFn2 (Step a b) a (Step a b)\n  coerce = unsafeCoerce\n\n-- | Runs the finalizer associated with a `Step`\nhalt ∷ ∀ a b. EffectFn1 (Step a b) Unit\nhalt = coerce $ mkEffectFn1 \\(Step _ s _ k) → runEffectFn1 k s\n  where\n  coerce ∷ ∀ s. EffectFn1 (Step' a b s) Unit → EffectFn1 (Step a b) Unit\n  coerce = unsafeCoerce\n","module Halogen.VDom.Types\n  ( VDom(..)\n  , renderWidget\n  , Graft\n  , GraftX(..)\n  , graft\n  , unGraft\n  , runGraft\n  , ElemName(..)\n  , Namespace(..)\n  ) where\n\nimport Prelude\nimport Data.Bifunctor (class Bifunctor, bimap)\nimport Data.Maybe (Maybe)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The core virtual-dom tree type, where `a` is the type of attributes,\n-- | and `w` is the type of \"widgets\". Widgets are machines that have complete\n-- | control over the lifecycle of some `DOM.Node`.\n-- |\n-- | The `Grafted` constructor and associated machinery enables `bimap`\n-- | fusion using a Coyoneda-like encoding.\ndata VDom a w\n  = Text String\n  | Elem (Maybe Namespace) ElemName a (Array (VDom a w))\n  | Keyed (Maybe Namespace) ElemName a (Array (Tuple String (VDom a w)))\n  | Widget w\n  | Grafted (Graft a w)\n\ninstance functorVDom ∷ Functor (VDom a) where\n  map _ (Text a) = Text a\n  map g (Grafted a) = Grafted (map g a)\n  map g a = Grafted (graft (Graft identity g a))\n\ninstance bifunctorVDom ∷ Bifunctor VDom where\n  bimap _ _ (Text a) = Text a\n  bimap f g (Grafted a) = Grafted (bimap f g a)\n  bimap f g a = Grafted (graft (Graft f g a))\n\n-- | Replaces \"widgets\" in the `VDom` with the ability to turn them into other\n-- | `VDom` nodes.\n-- |\n-- | Using this function will fuse any `Graft`s present in the `VDom`.\nrenderWidget ∷ ∀ a b w x. (a → b) → (w → VDom b x) → VDom a w → VDom b x\nrenderWidget f g = case _ of\n  Text a → Text a\n  Elem ns n a ch → Elem ns n (f a) (map (renderWidget f g) ch)\n  Keyed ns n a ch → Keyed ns n (f a) (map (map (renderWidget f g)) ch)\n  Widget w → g w\n  Grafted gaw → renderWidget f g (runGraft gaw)\n\nforeign import data Graft ∷ Type → Type → Type\n\ninstance functorGraft ∷ Functor (Graft a) where\n  map g = unGraft \\(Graft f' g' a) → graft (Graft f' (g <<< g') a)\n\ninstance bifunctorGraft ∷ Bifunctor Graft where\n  bimap f g = unGraft \\(Graft f' g' a) → graft (Graft (f <<< f') (g <<< g') a)\n\ndata GraftX a a' w w' =\n  Graft (a → a') (w → w') (VDom a w)\n\ngraft\n  ∷ ∀ a a' w w'\n  . GraftX a a' w w'\n  → Graft a' w'\ngraft = unsafeCoerce\n\nunGraft\n  ∷ ∀ a' w' r\n  . (∀ a w. GraftX a a' w w' → r)\n  → Graft a' w'\n  → r\nunGraft f = f <<< unsafeCoerce\n\nrunGraft\n  ∷ ∀ a' w'\n  . Graft a' w'\n  → VDom a' w'\nrunGraft =\n  unGraft \\(Graft fa fw v) →\n    let\n      go (Text s) = Text s\n      go (Elem ns n a ch) = Elem ns n (fa a) (map go ch)\n      go (Keyed ns n a ch) = Keyed ns n (fa a) (map (map go) ch)\n      go (Widget w) = Widget (fw w)\n      go (Grafted g) = Grafted (bimap fa fw g)\n    in\n      go v\n\nnewtype ElemName = ElemName String\n\nderive instance newtypeElemName ∷ Newtype ElemName _\nderive newtype instance eqElemName ∷ Eq ElemName\nderive newtype instance ordElemName ∷ Ord ElemName\n\nnewtype Namespace = Namespace String\n\nderive instance newtypeNamespace ∷ Newtype Namespace _\nderive newtype instance eqNamespace ∷ Eq Namespace\nderive newtype instance ordNamespace ∷ Ord Namespace\n","\"use strict\";\n\nexport function unsafeGetAny(key, obj) {\n  return obj[key];\n}\n\nexport function unsafeHasAny(key, obj) {\n  return obj.hasOwnProperty(key);\n}\n\nexport function unsafeSetAny(key, val, obj) {\n    obj[key] = val;\n}\n\nexport function unsafeDeleteAny(key, obj) {\n  delete obj[key];\n}\n\nexport function forE(a, f) {\n  var b = [];\n  for (var i = 0; i < a.length; i++) {\n    b.push(f(i, a[i]));\n  }\n  return b;\n}\n\nexport function forEachE(a, f) {\n  for (var i = 0; i < a.length; i++) {\n    f(a[i]);\n  }\n}\n\nexport function forInE(o, f) {\n  var ks = Object.keys(o);\n  for (var i = 0; i < ks.length; i++) {\n    var k = ks[i];\n    f(k, o[k]);\n  }\n}\n\nexport function replicateE(n, f) {\n  for (var i = 0; i < n; i++) {\n    f();\n  }\n}\n\nexport function diffWithIxE(a1, a2, f1, f2, f3) {\n  var a3 = [];\n  var l1 = a1.length;\n  var l2 = a2.length;\n  var i  = 0;\n  while (1) {\n    if (i < l1) {\n      if (i < l2) {\n        a3.push(f1(i, a1[i], a2[i]));\n      } else {\n        f2(i, a1[i]);\n      }\n    } else if (i < l2) {\n      a3.push(f3(i, a2[i]));\n    } else {\n      break;\n    }\n    i++;\n  }\n  return a3;\n}\n\nexport function strMapWithIxE(as, fk, f) {\n  var o = {};\n  for (var i = 0; i < as.length; i++) {\n    var a = as[i];\n    var k = fk(a);\n    o[k] = f(k, i, a);\n  }\n  return o;\n}\n\nexport function diffWithKeyAndIxE(o1, as, fk, f1, f2, f3) {\n  var o2 = {};\n  for (var i = 0; i < as.length; i++) {\n    var a = as[i];\n    var k = fk(a);\n    if (o1.hasOwnProperty(k)) {\n      o2[k] = f1(k, i, o1[k], a);\n    } else {\n      o2[k] = f3(k, i, a);\n    }\n  }\n  for (var k in o1) {\n    if (k in o2) {\n      continue;\n    }\n    f2(k, o1[k]);\n  }\n  return o2;\n}\n\nexport function refEq(a, b) {\n  return a === b;\n}\n\nexport function createTextNode(s, doc) {\n  return doc.createTextNode(s);\n}\n\nexport function setTextContent(s, n) {\n  n.textContent = s;\n}\n\nexport function createElement(ns, name, doc) {\n  if (ns != null) {\n    return doc.createElementNS(ns, name);\n  } else {\n    return doc.createElement(name)\n  }\n}\n\nexport function insertChildIx(i, a, b) {\n  var n = b.childNodes.item(i) || null;\n  if (n !== a) {\n    b.insertBefore(a, n);\n  }\n}\n\nexport function removeChild(a, b) {\n  if (b && a.parentNode === b) {\n    b.removeChild(a);\n  }\n}\n\nexport function parentNode(a) {\n  return a.parentNode;\n}\n\nexport function setAttribute(ns, attr, val, el) {\n  if (ns != null) {\n    el.setAttributeNS(ns, attr, val);\n  } else {\n    el.setAttribute(attr, val);\n  }\n}\n\nexport function removeAttribute(ns, attr, el) {\n  if (ns != null) {\n    el.removeAttributeNS(ns, attr);\n  } else {\n    el.removeAttribute(attr);\n  }\n}\n\nexport function hasAttribute(ns, attr, el) {\n  if (ns != null) {\n    return el.hasAttributeNS(ns, attr);\n  } else {\n    return el.hasAttribute(attr);\n  }\n}\n\nexport function addEventListener(ev, listener, el) {\n  el.addEventListener(ev, listener, false);\n}\n\nexport function removeEventListener(ev, listener, el) {\n  el.removeEventListener(ev, listener, false);\n}\n\nexport var jsUndefined = void 0;\n","const newImpl = function () {\n  return {};\n};\nexport { newImpl as new };\n\nexport function peekImpl(just) {\n  return function (nothing) {\n    return function (k) {\n      return function (m) {\n        return function () {\n          return {}.hasOwnProperty.call(m, k) ? just(m[k]) : nothing;\n        };\n      };\n    };\n  };\n}\n\nexport function poke(k) {\n  return function (v) {\n    return function (m) {\n      return function () {\n        m[k] = v;\n        return m;\n      };\n    };\n  };\n}\n\nconst deleteImpl = function (k) {\n  return function (m) {\n    return function () {\n      delete m[k];\n      return m;\n    };\n  };\n};\nexport { deleteImpl as delete };\n","module Halogen.VDom.Util\n  ( newMutMap\n  , pokeMutMap\n  , deleteMutMap\n  , unsafeFreeze\n  , unsafeLookup\n  , unsafeGetAny\n  , unsafeHasAny\n  , unsafeSetAny\n  , unsafeDeleteAny\n  , forE\n  , forEachE\n  , forInE\n  , replicateE\n  , diffWithIxE\n  , diffWithKeyAndIxE\n  , strMapWithIxE\n  , refEq\n  , createTextNode\n  , setTextContent\n  , createElement\n  , insertChildIx\n  , removeChild\n  , parentNode\n  , setAttribute\n  , removeAttribute\n  , hasAttribute\n  , addEventListener\n  , removeEventListener\n  , JsUndefined\n  , jsUndefined\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried as Fn\nimport Data.Nullable (Nullable)\nimport Effect (Effect)\nimport Effect.Uncurried as EFn\nimport Foreign.Object (Object)\nimport Foreign.Object as Object\nimport Foreign.Object.ST (STObject)\nimport Foreign.Object.ST as STObject\nimport Halogen.VDom.Types (Namespace, ElemName)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Document (Document) as DOM\nimport Web.DOM.Element (Element) as DOM\nimport Web.DOM.Node (Node) as DOM\nimport Web.Event.EventTarget (EventListener) as DOM\n\nnewMutMap ∷ ∀ r a. Effect (STObject r a)\nnewMutMap = unsafeCoerce STObject.new\n\npokeMutMap ∷ ∀ r a. EFn.EffectFn3 String a (STObject r a) Unit\npokeMutMap = unsafeSetAny\n\ndeleteMutMap ∷ ∀ r a. EFn.EffectFn2 String (STObject r a) Unit\ndeleteMutMap = unsafeDeleteAny\n\nunsafeFreeze ∷ ∀ r a. STObject r a → Object a\nunsafeFreeze = unsafeCoerce\n\nunsafeLookup ∷ ∀ a. Fn.Fn2 String (Object a) a\nunsafeLookup = unsafeGetAny\n\nforeign import unsafeGetAny\n  ∷ ∀ a b. Fn.Fn2 String a b\n\nforeign import unsafeHasAny\n  ∷ ∀ a. Fn.Fn2 String a Boolean\n\nforeign import unsafeSetAny ∷ ∀ a b. EFn.EffectFn3 String a b Unit\n\nforeign import unsafeDeleteAny\n  ∷ ∀ a. EFn.EffectFn2 String a Unit\n\nforeign import forE\n  ∷ ∀ a b\n  . EFn.EffectFn2\n      (Array a)\n      (EFn.EffectFn2 Int a b)\n      (Array b)\n\nforeign import forEachE\n  ∷ ∀ a\n  . EFn.EffectFn2\n      (Array a)\n      (EFn.EffectFn1 a Unit)\n      Unit\n\nforeign import forInE\n  ∷ ∀ a\n  . EFn.EffectFn2\n      (Object.Object a)\n      (EFn.EffectFn2 String a Unit)\n      Unit\n\nforeign import replicateE\n  ∷ ∀ a\n  . EFn.EffectFn2\n      Int\n      (Effect a)\n      Unit\n\nforeign import diffWithIxE\n  ∷ ∀ b c d\n  . EFn.EffectFn5\n      (Array b)\n      (Array c)\n      (EFn.EffectFn3 Int b c d)\n      (EFn.EffectFn2 Int b Unit)\n      (EFn.EffectFn2 Int c d)\n      (Array d)\n\nforeign import diffWithKeyAndIxE\n  ∷ ∀ a b c d\n  . EFn.EffectFn6\n      (Object.Object a)\n      (Array b)\n      (b → String)\n      (EFn.EffectFn4 String Int a b c)\n      (EFn.EffectFn2 String a d)\n      (EFn.EffectFn3 String Int b c)\n      (Object.Object c)\n\nforeign import strMapWithIxE\n  ∷ ∀ a b\n  . EFn.EffectFn3\n      (Array a)\n      (a → String)\n      (EFn.EffectFn3 String Int a b)\n      (Object.Object b)\n\nforeign import refEq\n  ∷ ∀ a b. Fn.Fn2 a b Boolean\n\nforeign import createTextNode\n  ∷ EFn.EffectFn2 String DOM.Document DOM.Node\n\nforeign import setTextContent\n  ∷ EFn.EffectFn2 String DOM.Node Unit\n\nforeign import createElement\n  ∷ EFn.EffectFn3 (Nullable Namespace) ElemName DOM.Document DOM.Element\n\nforeign import insertChildIx\n  ∷ EFn.EffectFn3 Int DOM.Node DOM.Node Unit\n\nforeign import removeChild\n  ∷ EFn.EffectFn2 DOM.Node DOM.Node Unit\n\nforeign import parentNode\n  ∷ EFn.EffectFn1 DOM.Node DOM.Node\n\nforeign import setAttribute\n  ∷ EFn.EffectFn4 (Nullable Namespace) String String DOM.Element Unit\n\nforeign import removeAttribute\n  ∷ EFn.EffectFn3 (Nullable Namespace) String DOM.Element Unit\n\nforeign import hasAttribute\n  ∷ EFn.EffectFn3 (Nullable Namespace) String DOM.Element Boolean\n\nforeign import addEventListener\n  ∷ EFn.EffectFn3 String DOM.EventListener DOM.Element Unit\n\nforeign import removeEventListener\n  ∷ EFn.EffectFn3 String DOM.EventListener DOM.Element Unit\n\nforeign import data JsUndefined ∷ Type\n\nforeign import jsUndefined ∷ JsUndefined\n","var getProp = function (name) {\n  return function (doctype) {\n    return doctype[name];\n  };\n};\n\nexport const _namespaceURI = getProp(\"namespaceURI\");\nexport const _prefix = getProp(\"prefix\");\nexport const localName = getProp(\"localName\");\nexport const tagName = getProp(\"tagName\");\n\nexport function id(node) {\n  return function () {\n    return node.id;\n  };\n}\n\nexport function setId(id) {\n  return function (node) {\n    return function () {\n      node.id = id;\n    };\n  };\n}\n\nexport function className(node) {\n  return function () {\n    return node.className;\n  };\n}\n\nexport function classList(element) {\n  return function () {\n    return element.classList;\n  };\n}\n\nexport function setClassName(className) {\n  return function (node) {\n    return function () {\n      node.className = className;\n    };\n  };\n}\n\nexport function getElementsByTagName(localName) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByTagName(localName);\n    };\n  };\n}\n\nexport function _getElementsByTagNameNS(ns) {\n  return function (localName) {\n    return function (doc) {\n      return function () {\n        return doc.getElementsByTagNameNS(ns, localName);\n      };\n    };\n  };\n}\n\nexport function getElementsByClassName(classNames) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByClassName(classNames);\n    };\n  };\n}\n\nexport function setAttribute(name) {\n  return function (value) {\n    return function (element) {\n      return function () {\n        element.setAttribute(name, value);\n      };\n    };\n  };\n}\n\nexport function _getAttribute(name) {\n  return function (element) {\n    return function () {\n      return element.getAttribute(name);\n    };\n  };\n}\n\nexport function hasAttribute(name) {\n  return function (element) {\n    return function () {\n      return element.hasAttribute(name);\n    };\n  };\n}\n\nexport function removeAttribute(name) {\n  return function (element) {\n    return function () {\n      element.removeAttribute(name);\n    };\n  };\n}\n\nexport function matches(selector) {\n  return function(element) {\n    return function () {\n      return element.matches(selector);\n    };\n  };\n}\n\nexport function _closest(selector) {\n  return function(element) {\n    return function () {\n      return element.closest(selector);\n    };\n  };\n}\n\n// - CSSOM ---------------------------------------------------------------------\n\nexport function scrollTop(node) {\n  return function () {\n    return node.scrollTop;\n  };\n}\n\nexport function setScrollTop(scrollTop) {\n  return function (node) {\n    return function () {\n      node.scrollTop = scrollTop;\n    };\n  };\n}\n\nexport function scrollLeft(node) {\n  return function () {\n    return node.scrollLeft;\n  };\n}\n\nexport function setScrollLeft(scrollLeft) {\n  return function (node) {\n    return function () {\n      node.scrollLeft = scrollLeft;\n    };\n  };\n}\n\nexport function scrollWidth(el) {\n  return function () {\n    return el.scrollWidth;\n  };\n}\n\nexport function scrollHeight(el) {\n  return function () {\n    return el.scrollHeight;\n  };\n}\n\nexport function clientTop(el) {\n  return function () {\n    return el.clientTop;\n  };\n}\n\nexport function clientLeft(el) {\n  return function () {\n    return el.clientLeft;\n  };\n}\n\nexport function clientWidth(el) {\n  return function () {\n    return el.clientWidth;\n  };\n}\n\nexport function clientHeight(el) {\n  return function () {\n    return el.clientHeight;\n  };\n}\n\nexport function getBoundingClientRect(el) {\n  return function () {\n    var rect = el.getBoundingClientRect();\n    return {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height,\n      x: rect.x,\n      y: rect.y\n    };\n  };\n}\n\nexport function _attachShadow(props) {\n  return function (el) {\n    return function() {\n      return el.attachShadow(props);\n    };\n  };\n}\n","var getEffProp = function (name) {\n  return function (node) {\n    return function () {\n      return node[name];\n    };\n  };\n};\n\nexport const children = getEffProp(\"children\");\nexport const _firstElementChild = getEffProp(\"firstElementChild\");\nexport const _lastElementChild = getEffProp(\"lastElementChild\");\nexport const childElementCount = getEffProp(\"childElementCount\");\n\nexport function _querySelector(selector) {\n  return function (node) {\n    return function () {\n      return node.querySelector(selector);\n    };\n  };\n}\n\nexport function querySelectorAll(selector) {\n  return function (node) {\n    return function () {\n      return node.querySelectorAll(selector);\n    };\n  };\n}\n","module Web.DOM.ParentNode\n  ( ParentNode\n  , children\n  , firstElementChild\n  , lastElementChild\n  , childElementCount\n  , QuerySelector(..)\n  , querySelector\n  , querySelectorAll\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Newtype (class Newtype)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Web.DOM.Internal.Types (Element)\nimport Web.DOM.HTMLCollection (HTMLCollection)\nimport Web.DOM.NodeList (NodeList)\n\nforeign import data ParentNode :: Type\n\n-- | The child elements for the node.\nforeign import children :: ParentNode -> Effect HTMLCollection\n\n-- | The first child that is an element, or Nothing if no such element exists.\nfirstElementChild :: ParentNode -> Effect (Maybe Element)\nfirstElementChild = map toMaybe <<< _firstElementChild\n\nforeign import _firstElementChild :: ParentNode -> Effect (Nullable Element)\n\n-- | The last child that is an element, or Nothing if no such element exists.\nlastElementChild :: ParentNode -> Effect (Maybe Element)\nlastElementChild = map toMaybe <<< _lastElementChild\n\nforeign import _lastElementChild :: ParentNode -> Effect (Nullable Element)\n\n-- | The number of child elements.\nforeign import childElementCount :: ParentNode -> Effect Int\n\nnewtype QuerySelector = QuerySelector String\n\nderive newtype instance eqQuerySelector :: Eq QuerySelector\nderive newtype instance ordQuerySelector :: Ord QuerySelector\nderive instance newtypeQuerySelector :: Newtype QuerySelector _\n\n-- | Finds the first child that is an element that matches the selector(s), or\n-- | Nothing if no such element exists.\nquerySelector :: QuerySelector -> ParentNode -> Effect (Maybe Element)\nquerySelector qs = map toMaybe <<< _querySelector qs\n\nforeign import _querySelector :: QuerySelector -> ParentNode -> Effect (Nullable Element)\n\n-- | Finds all the child elements that matches the selector(s).\nforeign import querySelectorAll :: QuerySelector -> ParentNode -> Effect NodeList\n","export function _unsafeReadProtoTagged(nothing, just, name, value) {\n  if (typeof window !== \"undefined\") {\n    var ty = window[name];\n    if (ty != null && value instanceof ty) {\n      return just(value);\n    }\n  }\n  var obj = value;\n  while (obj != null) {\n    var proto = Object.getPrototypeOf(obj);\n    var constructorName = proto.constructor.name;\n    if (constructorName === name) {\n      return just(value);\n    } else if (constructorName === \"Object\") {\n      return nothing;\n    }\n    obj = proto;\n  }\n  return nothing;\n}\n","module Web.Internal.FFI (unsafeReadProtoTagged) where\n\nimport Data.Function.Uncurried (Fn4, runFn4)\nimport Data.Maybe (Maybe(..))\n\nunsafeReadProtoTagged :: forall a b. String -> a -> Maybe b\nunsafeReadProtoTagged name value =\n  runFn4 _unsafeReadProtoTagged Nothing Just name value\n\nforeign import _unsafeReadProtoTagged\n  :: forall a b\n   . Fn4\n      (forall x. Maybe x)\n      (forall x. x -> Maybe x)\n      String\n      a\n      (Maybe b)\n","module Web.DOM.Element\n  ( module Exports\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , namespaceURI\n  , prefix\n  , localName\n  , tagName\n  , id\n  , setId\n  , className\n  , classList\n  , setClassName\n  , getElementsByTagName\n  , getElementsByTagNameNS\n  , getElementsByClassName\n  , setAttribute\n  , getAttribute\n  , hasAttribute\n  , removeAttribute\n  , matches\n  , closest\n  , scrollTop\n  , setScrollTop\n  , scrollLeft\n  , setScrollLeft\n  , scrollWidth\n  , scrollHeight\n  , clientTop\n  , clientLeft\n  , clientWidth\n  , clientHeight\n  , getBoundingClientRect\n  , DOMRect\n  , ShadowRootInit\n  , attachShadow\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe, toNullable)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.ChildNode (ChildNode)\nimport Web.DOM.DOMTokenList (DOMTokenList)\nimport Web.DOM.Internal.Types (Element) as Exports\nimport Web.DOM.Internal.Types (Element, HTMLCollection, Node)\nimport Web.DOM.NonDocumentTypeChildNode (NonDocumentTypeChildNode)\nimport Web.DOM.ParentNode (QuerySelector) as Exports\nimport Web.DOM.ParentNode (ParentNode, QuerySelector)\nimport Web.DOM.ShadowRoot (ShadowRoot, ShadowRootMode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nfromNode :: Node -> Maybe Element\nfromNode = unsafeReadProtoTagged \"Element\"\n\nfromChildNode :: ChildNode -> Maybe Element\nfromChildNode = unsafeReadProtoTagged \"Element\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe Element\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"Element\"\n\nfromParentNode :: ParentNode -> Maybe Element\nfromParentNode = unsafeReadProtoTagged \"Element\"\n\nfromEventTarget :: EventTarget -> Maybe Element\nfromEventTarget = unsafeReadProtoTagged \"Element\"\n\ntoNode :: Element -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: Element -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: Element -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: Element -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: Element -> EventTarget\ntoEventTarget = unsafeCoerce\n\nnamespaceURI :: Element -> Maybe String\nnamespaceURI = toMaybe <<< _namespaceURI\n\nprefix :: Element -> Maybe String\nprefix = toMaybe <<< _prefix\n\nforeign import _namespaceURI :: Element -> Nullable String\nforeign import _prefix :: Element -> Nullable String\nforeign import localName :: Element -> String\nforeign import tagName :: Element -> String\n\nforeign import id :: Element -> Effect String\nforeign import setId :: String -> Element -> Effect Unit\nforeign import className :: Element -> Effect String\nforeign import classList :: Element -> Effect DOMTokenList\nforeign import setClassName :: String -> Element -> Effect Unit\n\nforeign import getElementsByTagName :: String -> Element -> Effect HTMLCollection\n\ngetElementsByTagNameNS :: Maybe String -> String -> Element -> Effect HTMLCollection\ngetElementsByTagNameNS = _getElementsByTagNameNS <<< toNullable\n\nforeign import _getElementsByTagNameNS :: Nullable String -> String -> Element -> Effect HTMLCollection\n\nforeign import getElementsByClassName :: String -> Element -> Effect HTMLCollection\n\nforeign import setAttribute :: String -> String -> Element -> Effect Unit\n\ngetAttribute :: String -> Element -> Effect (Maybe String)\ngetAttribute attr = map toMaybe <<< _getAttribute attr\n\nforeign import _getAttribute :: String -> Element -> Effect (Nullable String)\nforeign import hasAttribute :: String -> Element -> Effect Boolean\nforeign import removeAttribute :: String -> Element -> Effect Unit\n\nforeign import matches :: QuerySelector -> Element -> Effect Boolean\n\nclosest :: QuerySelector -> Element -> Effect (Maybe Element)\nclosest qs = map toMaybe <<< _closest qs\n\nforeign import _closest :: QuerySelector -> Element -> Effect (Nullable Element)\n\nforeign import scrollTop :: Element -> Effect Number\nforeign import setScrollTop :: Number -> Element -> Effect Unit\n\nforeign import scrollLeft :: Element -> Effect Number\nforeign import setScrollLeft :: Number -> Element -> Effect Unit\n\nforeign import scrollWidth :: Element -> Effect Number\nforeign import scrollHeight :: Element -> Effect Number\nforeign import clientTop :: Element -> Effect Number\nforeign import clientLeft :: Element -> Effect Number\nforeign import clientWidth :: Element -> Effect Number\nforeign import clientHeight :: Element -> Effect Number\n\ntype DOMRect =\n  { top :: Number\n  , right :: Number\n  , bottom :: Number\n  , left :: Number\n  , width :: Number\n  , height :: Number\n  , x :: Number\n  , y :: Number\n  }\n\nforeign import getBoundingClientRect :: Element -> Effect DOMRect\n\ntype ShadowRootInit = {\n  mode :: ShadowRootMode,\n  delegatesFocus :: Boolean\n}\n\nattachShadow :: ShadowRootInit -> Element -> Effect ShadowRoot\nattachShadow = _attachShadow <<< initToProps\n\ntype ShadowRootProps = {\n  mode :: String,\n  delegatesFocus :: Boolean\n}\n\ninitToProps :: ShadowRootInit -> ShadowRootProps\ninitToProps init = {\n  mode: show init.mode,\n  delegatesFocus: init.delegatesFocus\n}\n\nforeign import _attachShadow :: ShadowRootProps -> Element -> Effect ShadowRoot\n","module Halogen.VDom.DOM\n  ( VDomSpec(..)\n  , buildVDom\n  , buildText\n  , buildElem\n  , buildKeyed\n  , buildWidget\n  ) where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Function.Uncurried as Fn\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (toNullable)\nimport Data.Tuple (Tuple(..), fst)\nimport Effect.Uncurried as EFn\nimport Foreign.Object as Object\nimport Halogen.VDom.Machine (Machine, Step, Step'(..), extract, halt, mkStep, step, unStep)\nimport Halogen.VDom.Machine as Machine\nimport Halogen.VDom.Types (ElemName(..), Namespace(..), VDom(..), runGraft)\nimport Halogen.VDom.Util as Util\nimport Web.DOM.Document (Document) as DOM\nimport Web.DOM.Element (Element) as DOM\nimport Web.DOM.Element as DOMElement\nimport Web.DOM.Node (Node) as DOM\n\ntype VDomMachine a w = Machine (VDom a w) DOM.Node\n\ntype VDomStep a w = Step (VDom a w) DOM.Node\n\ntype VDomInit i a w = EFn.EffectFn1 i (VDomStep a w)\n\ntype VDomBuilder i a w = EFn.EffectFn3 (VDomSpec a w) (VDomMachine a w) i (VDomStep a w)\n\ntype VDomBuilder4 i j k l a w = EFn.EffectFn6 (VDomSpec a w) (VDomMachine a w) i j k l (VDomStep a w)\n\n-- | Widget machines recursively reference the configured spec to potentially\n-- | enable recursive trees of Widgets.\nnewtype VDomSpec a w = VDomSpec\n  { buildWidget ∷ VDomSpec a w → Machine w DOM.Node\n  , buildAttributes ∷ DOM.Element → Machine a Unit\n  , document ∷ DOM.Document\n  }\n\n-- | Starts an initial `VDom` machine by providing a `VDomSpec`.\n-- |\n-- | ```purescript\n-- | main = do\n-- |   machine1 ← buildVDom spec vdomTree1\n-- |   machine2 ← Machine.step machine1 vdomTree2\n-- |   machine3 ← Machine.step machine2 vdomTree3\n-- |   ...\n-- | ````\nbuildVDom ∷ ∀ a w. VDomSpec a w → VDomMachine a w\nbuildVDom spec = build\n  where\n  build = EFn.mkEffectFn1 case _ of\n    Text s → EFn.runEffectFn3 buildText spec build s\n    Elem ns n a ch → EFn.runEffectFn6 buildElem spec build ns n a ch\n    Keyed ns n a ch → EFn.runEffectFn6 buildKeyed spec build ns n a ch\n    Widget w → EFn.runEffectFn3 buildWidget spec build w\n    Grafted g → EFn.runEffectFn1 build (runGraft g)\n\ntype TextState a w =\n  { build ∷ VDomMachine a w\n  , node ∷ DOM.Node\n  , value ∷ String\n  }\n\nbuildText ∷ ∀ a w. VDomBuilder String a w\nbuildText = EFn.mkEffectFn3 \\(VDomSpec spec) build s → do\n  node ← EFn.runEffectFn2 Util.createTextNode s spec.document\n  let state = { build, node, value: s }\n  pure $ mkStep $ Step node state patchText haltText\n\npatchText ∷ ∀ a w. EFn.EffectFn2 (TextState a w) (VDom a w) (VDomStep a w)\npatchText = EFn.mkEffectFn2 \\state vdom → do\n  let { build, node, value: value1 } = state\n  case vdom of\n    Grafted g →\n      EFn.runEffectFn2 patchText state (runGraft g)\n    Text value2\n      | value1 == value2 →\n          pure $ mkStep $ Step node state patchText haltText\n      | otherwise → do\n          let nextState = { build, node, value: value2 }\n          EFn.runEffectFn2 Util.setTextContent value2 node\n          pure $ mkStep $ Step node nextState patchText haltText\n    _ → do\n      EFn.runEffectFn1 haltText state\n      EFn.runEffectFn1 build vdom\n\nhaltText ∷ ∀ a w. EFn.EffectFn1 (TextState a w) Unit\nhaltText = EFn.mkEffectFn1 \\{ node } → do\n  parent ← EFn.runEffectFn1 Util.parentNode node\n  EFn.runEffectFn2 Util.removeChild node parent\n\ntype ElemState a w =\n  { build ∷ VDomMachine a w\n  , node ∷ DOM.Node\n  , attrs ∷ Step a Unit\n  , ns ∷ Maybe Namespace\n  , name ∷ ElemName\n  , children ∷ Array (VDomStep a w)\n  }\n\nbuildElem ∷ ∀ a w. VDomBuilder4 (Maybe Namespace) ElemName a (Array (VDom a w)) a w\nbuildElem = EFn.mkEffectFn6 \\(VDomSpec spec) build ns1 name1 as1 ch1 → do\n  el ← EFn.runEffectFn3 Util.createElement (toNullable ns1) name1 spec.document\n  let\n    node = DOMElement.toNode el\n    onChild = EFn.mkEffectFn2 \\ix child → do\n      res ← EFn.runEffectFn1 build child\n      EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n      pure res\n  children ← EFn.runEffectFn2 Util.forE ch1 onChild\n  attrs ← EFn.runEffectFn1 (spec.buildAttributes el) as1\n  let\n    state =\n      { build\n      , node\n      , attrs\n      , ns: ns1\n      , name: name1\n      , children\n      }\n  pure $ mkStep $ Step node state patchElem haltElem\n\npatchElem ∷ ∀ a w. EFn.EffectFn2 (ElemState a w) (VDom a w) (VDomStep a w)\npatchElem = EFn.mkEffectFn2 \\state vdom → do\n  let { build, node, attrs, ns: ns1, name: name1, children: ch1 } = state\n  case vdom of\n    Grafted g →\n      EFn.runEffectFn2 patchElem state (runGraft g)\n    Elem ns2 name2 as2 ch2 | Fn.runFn4 eqElemSpec ns1 name1 ns2 name2 → do\n      case Array.length ch1, Array.length ch2 of\n        0, 0 → do\n          attrs2 ← EFn.runEffectFn2 step attrs as2\n          let\n            nextState =\n              { build\n              , node\n              , attrs: attrs2\n              , ns: ns2\n              , name: name2\n              , children: ch1\n              }\n          pure $ mkStep $ Step node nextState patchElem haltElem\n        _, _ → do\n          let\n            onThese = EFn.mkEffectFn3 \\ix s v → do\n              res ← EFn.runEffectFn2 step s v\n              EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n              pure res\n            onThis = EFn.mkEffectFn2 \\_ s → EFn.runEffectFn1 halt s\n            onThat = EFn.mkEffectFn2 \\ix v → do\n              res ← EFn.runEffectFn1 build v\n              EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n              pure res\n          children2 ← EFn.runEffectFn5 Util.diffWithIxE ch1 ch2 onThese onThis onThat\n          attrs2 ← EFn.runEffectFn2 step attrs as2\n          let\n            nextState =\n              { build\n              , node\n              , attrs: attrs2\n              , ns: ns2\n              , name: name2\n              , children: children2\n              }\n          pure $ mkStep $ Step node nextState patchElem haltElem\n    _ → do\n      EFn.runEffectFn1 haltElem state\n      EFn.runEffectFn1 build vdom\n\nhaltElem ∷ ∀ a w. EFn.EffectFn1 (ElemState a w) Unit\nhaltElem = EFn.mkEffectFn1 \\{ node, attrs, children } → do\n  parent ← EFn.runEffectFn1 Util.parentNode node\n  EFn.runEffectFn2 Util.removeChild node parent\n  EFn.runEffectFn2 Util.forEachE children halt\n  EFn.runEffectFn1 halt attrs\n\ntype KeyedState a w =\n  { build ∷ VDomMachine a w\n  , node ∷ DOM.Node\n  , attrs ∷ Step a Unit\n  , ns ∷ Maybe Namespace\n  , name ∷ ElemName\n  , children ∷ Object.Object (VDomStep a w)\n  , length ∷ Int\n  }\n\nbuildKeyed ∷ ∀ a w. VDomBuilder4 (Maybe Namespace) ElemName a (Array (Tuple String (VDom a w))) a w\nbuildKeyed = EFn.mkEffectFn6 \\(VDomSpec spec) build ns1 name1 as1 ch1 → do\n  el ← EFn.runEffectFn3 Util.createElement (toNullable ns1) name1 spec.document\n  let\n    node = DOMElement.toNode el\n    onChild = EFn.mkEffectFn3 \\_ ix (Tuple _ vdom) → do\n      res ← EFn.runEffectFn1 build vdom\n      EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n      pure res\n  children ← EFn.runEffectFn3 Util.strMapWithIxE ch1 fst onChild\n  attrs ← EFn.runEffectFn1 (spec.buildAttributes el) as1\n  let\n    state =\n      { build\n      , node\n      , attrs\n      , ns: ns1\n      , name: name1\n      , children\n      , length: Array.length ch1\n      }\n  pure $ mkStep $ Step node state patchKeyed haltKeyed\n\npatchKeyed ∷ ∀ a w. EFn.EffectFn2 (KeyedState a w) (VDom a w) (VDomStep a w)\npatchKeyed = EFn.mkEffectFn2 \\state vdom → do\n  let { build, node, attrs, ns: ns1, name: name1, children: ch1, length: len1 } = state\n  case vdom of\n    Grafted g →\n      EFn.runEffectFn2 patchKeyed state (runGraft g)\n    Keyed ns2 name2 as2 ch2 | Fn.runFn4 eqElemSpec ns1 name1 ns2 name2 →\n      case len1, Array.length ch2 of\n        0, 0 → do\n          attrs2 ← EFn.runEffectFn2 Machine.step attrs as2\n          let\n            nextState =\n              { build\n              , node\n              , attrs: attrs2\n              , ns: ns2\n              , name: name2\n              , children: ch1\n              , length: 0\n              }\n          pure $ mkStep $ Step node nextState patchKeyed haltKeyed\n        _, len2 → do\n          let\n            onThese = EFn.mkEffectFn4 \\_ ix' s (Tuple _ v) → do\n              res ← EFn.runEffectFn2 step s v\n              EFn.runEffectFn3 Util.insertChildIx ix' (extract res) node\n              pure res\n            onThis = EFn.mkEffectFn2 \\_ s → EFn.runEffectFn1 halt s\n            onThat = EFn.mkEffectFn3 \\_ ix (Tuple _ v) → do\n              res ← EFn.runEffectFn1 build v\n              EFn.runEffectFn3 Util.insertChildIx ix (extract res) node\n              pure res\n          children2 ← EFn.runEffectFn6 Util.diffWithKeyAndIxE ch1 ch2 fst onThese onThis onThat\n          attrs2 ← EFn.runEffectFn2 step attrs as2\n          let\n            nextState =\n              { build\n              , node\n              , attrs: attrs2\n              , ns: ns2\n              , name: name2\n              , children: children2\n              , length: len2\n              }\n          pure $ mkStep $ Step node nextState patchKeyed haltKeyed\n    _ → do\n      EFn.runEffectFn1 haltKeyed state\n      EFn.runEffectFn1 build vdom\n\nhaltKeyed ∷ ∀ a w. EFn.EffectFn1 (KeyedState a w) Unit\nhaltKeyed = EFn.mkEffectFn1 \\{ node, attrs, children } → do\n  parent ← EFn.runEffectFn1 Util.parentNode node\n  EFn.runEffectFn2 Util.removeChild node parent\n  EFn.runEffectFn2 Util.forInE children (EFn.mkEffectFn2 \\_ s → EFn.runEffectFn1 halt s)\n  EFn.runEffectFn1 halt attrs\n\ntype WidgetState a w =\n  { build ∷ VDomMachine a w\n  , widget ∷ Step w DOM.Node\n  }\n\nbuildWidget ∷ ∀ a w. VDomBuilder w a w\nbuildWidget = EFn.mkEffectFn3 \\(VDomSpec spec) build w → do\n  res ← EFn.runEffectFn1 (spec.buildWidget (VDomSpec spec)) w\n  let\n    res' = res # unStep \\(Step n _ _ _) →\n      mkStep $ Step n { build, widget: res } patchWidget haltWidget\n  pure res'\n\npatchWidget ∷ ∀ a w. EFn.EffectFn2 (WidgetState a w) (VDom a w) (VDomStep a w)\npatchWidget = EFn.mkEffectFn2 \\state vdom → do\n  let { build, widget } = state\n  case vdom of\n    Grafted g →\n      EFn.runEffectFn2 patchWidget state (runGraft g)\n    Widget w → do\n      res ← EFn.runEffectFn2 step widget w\n      let\n        res' = res # unStep \\(Step n _ _ _) →\n          mkStep $ Step n { build, widget: res } patchWidget haltWidget\n      pure res'\n    _ → do\n      EFn.runEffectFn1 haltWidget state\n      EFn.runEffectFn1 build vdom\n\nhaltWidget ∷ forall a w. EFn.EffectFn1 (WidgetState a w) Unit\nhaltWidget = EFn.mkEffectFn1 \\{ widget } → do\n  EFn.runEffectFn1 halt widget\n\neqElemSpec ∷ Fn.Fn4 (Maybe Namespace) ElemName (Maybe Namespace) ElemName Boolean\neqElemSpec = Fn.mkFn4 \\ns1 (ElemName name1) ns2 (ElemName name2) →\n  if name1 == name2\n    then case ns1, ns2 of\n      Just (Namespace ns1'), Just (Namespace ns2') | ns1' == ns2' → true\n      Nothing, Nothing → true\n      _, _ → false\n    else false\n","export function typeOf(value) {\n  return typeof value;\n}\n\nexport function tagOf(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isUndefined(value) {\n  return value === undefined;\n}\n\nexport const isArray = Array.isArray || function (value) {\n  return Object.prototype.toString.call(value) === \"[object Array]\";\n};\n","-- | This module defines the _exception monad transformer_ `ExceptT`.\n\nmodule Control.Monad.Except.Trans\n  ( ExceptT(..), runExceptT, withExceptT, mapExceptT, except\n  , module Control.Monad.Trans.Class\n  , module Control.Monad.Error.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Monad.Cont.Class (class MonadCont, callCC)\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError, throwError, catchError)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, ask, local)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.State.Class (class MonadState, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.Monad.Writer.Class (class MonadWriter, class MonadTell, pass, listen, tell)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Either (Either(..), either)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..))\nimport Effect.Class (class MonadEffect, liftEffect)\n\n-- | A monad transformer which adds exceptions to other monads, in the same way\n-- | as `Except`. As before, `e` is the type of exceptions, and `a` is the type\n-- | of successful results. The new type parameter `m` is the inner monad that\n-- | computations run in.\nnewtype ExceptT e m a = ExceptT (m (Either e a))\n\n-- | The inverse of `ExceptT`. Run a computation in the `ExceptT` monad.\nrunExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\nrunExceptT (ExceptT x) = x\n\n-- | Transform any exceptions thrown by an `ExceptT` computation using the given function.\nwithExceptT :: forall e e' m a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a\nwithExceptT f (ExceptT t) = ExceptT $ map (mapLeft f) t\n  where\n  mapLeft _ (Right x) = Right x\n  mapLeft f' (Left x) = Left (f' x)\n\n-- | Transform the unwrapped computation using the given function.\nmapExceptT :: forall e e' m n a b. (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b\nmapExceptT f (ExceptT m) = ExceptT (f m)\n\n-- | Construct a computation in the `ExceptT` transformer from an `Either` value.\nexcept :: forall e m a. Applicative m => Either e a -> ExceptT e m a\nexcept = ExceptT <<< pure\n\nderive instance newtypeExceptT :: Newtype (ExceptT e m a) _\n\ninstance functorExceptT :: Functor m => Functor (ExceptT e m) where\n  map f = mapExceptT (map (map f))\n\ninstance applyExceptT :: Monad m => Apply (ExceptT e m) where\n  apply = ap\n\ninstance applicativeExceptT :: Monad m => Applicative (ExceptT e m) where\n  pure = ExceptT <<< pure <<< Right\n\ninstance bindExceptT :: Monad m => Bind (ExceptT e m) where\n  bind (ExceptT m) k =\n    ExceptT (m >>= either (pure <<< Left) (\\a -> case k a of ExceptT b -> b))\n\ninstance monadExceptT :: Monad m => Monad (ExceptT e m)\n\ninstance monadRecExceptT :: MonadRec m => MonadRec (ExceptT e m) where\n  tailRecM f = ExceptT <<< tailRecM \\a ->\n    case f a of\n      ExceptT m -> m >>= \\m' ->\n        pure case m' of\n          Left e -> Done (Left e)\n          Right (Loop a1) -> Loop a1\n          Right (Done b) -> Done (Right b)\n\ninstance altExceptT :: (Semigroup e, Monad m) => Alt (ExceptT e m) where\n  alt (ExceptT m) (ExceptT n) = ExceptT do\n    rm <- m\n    case rm of\n      Right x -> pure (Right x)\n      Left err -> do\n        rn <- n\n        case rn of\n          Right x -> pure (Right x)\n          Left err' -> pure (Left (err <> err'))\n\ninstance plusExceptT :: (Monoid e, Monad m) => Plus (ExceptT e m) where\n  empty = throwError (mempty :: e)\n\ninstance alternativeExceptT :: (Monoid e, Monad m) => Alternative (ExceptT e m)\n\ninstance monadPlusExceptT :: (Monoid e, Monad m) => MonadPlus (ExceptT e m)\n\ninstance monadTransExceptT :: MonadTrans (ExceptT e) where\n  lift m = ExceptT do\n    a <- m\n    pure $ Right a\n\ninstance monadEffectExceptT :: MonadEffect m => MonadEffect (ExceptT e m) where\n  liftEffect = lift <<< liftEffect\n\ninstance monadContExceptT :: MonadCont m => MonadCont (ExceptT e m) where\n  callCC f = ExceptT $ callCC \\c ->\n    case f (\\a -> ExceptT $ c (Right a)) of ExceptT b -> b\n\ninstance monadThrowExceptT :: Monad m => MonadThrow e (ExceptT e m) where\n  throwError = ExceptT <<< pure <<< Left\n\ninstance monadErrorExceptT :: Monad m => MonadError e (ExceptT e m) where\n  catchError (ExceptT m) k =\n    ExceptT (m >>= either (\\a -> case k a of ExceptT b -> b) (pure <<< Right))\n\ninstance monadAskExceptT :: MonadAsk r m => MonadAsk r (ExceptT e m) where\n  ask = lift ask\n\ninstance monadReaderExceptT :: MonadReader r m => MonadReader r (ExceptT e m) where\n  local f = mapExceptT (local f)\n\ninstance monadStateExceptT :: MonadState s m => MonadState s (ExceptT e m) where\n  state f = lift (state f)\n\ninstance monadTellExceptT :: MonadTell w m => MonadTell w (ExceptT e m) where\n  tell = lift <<< tell\n\ninstance monadWriterExceptT :: MonadWriter w m => MonadWriter w (ExceptT e m) where\n  listen = mapExceptT \\m -> do\n    Tuple a w <- listen m\n    pure $ (\\r -> Tuple r w) <$> a\n  pass = mapExceptT \\m -> pass do\n    a <- m\n    pure case a of\n      Left e -> Tuple (Left e) identity\n      Right (Tuple r f) -> Tuple (Right r) f\n\ninstance semigroupExceptT :: (Monad m, Semigroup a) => Semigroup (ExceptT e m a) where\n  append = lift2 (<>)\n\ninstance monoidExceptT :: (Monad m, Monoid a) => Monoid (ExceptT e m a) where\n  mempty = pure mempty\n\n","export const fromNumberImpl = function (just) {\n  return function (nothing) {\n    return function (n) {\n      /* jshint bitwise: false */\n      return (n | 0) === n ? just(n) : nothing;\n    };\n  };\n};\n\nexport const toNumber = function (n) {\n  return n;\n};\n\nexport const fromStringAsImpl = function (just) {\n  return function (nothing) {\n    return function (radix) {\n      var digits;\n      if (radix < 11) {\n        digits = \"[0-\" + (radix - 1).toString() + \"]\";\n      } else if (radix === 11) {\n        digits = \"[0-9a]\";\n      } else {\n        digits = \"[0-9a-\" + String.fromCharCode(86 + radix) + \"]\";\n      }\n      var pattern = new RegExp(\"^[\\\\+\\\\-]?\" + digits + \"+$\", \"i\");\n\n      return function (s) {\n        /* jshint bitwise: false */\n        if (pattern.test(s)) {\n          var i = parseInt(s, radix);\n          return (i | 0) === i ? just(i) : nothing;\n        } else {\n          return nothing;\n        }\n      };\n    };\n  };\n};\n\nexport const toStringAs = function (radix) {\n  return function (i) {\n    return i.toString(radix);\n  };\n};\n\n\nexport const quot = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x / y | 0;\n  };\n};\n\nexport const rem = function (x) {\n  return function (y) {\n    return x % y;\n  };\n};\n\nexport const pow = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return Math.pow(x,y) | 0;\n  };\n};\n","/* globals exports */\nexport const nan = NaN;\nconst isNaNImpl = isNaN;\nexport { isNaNImpl as isNaN };\nexport const infinity = Infinity;\nconst isFiniteImpl = isFinite;\nexport { isFiniteImpl as isFinite };\n\nexport function fromStringImpl(str, isFinite, just, nothing) {\n  var num = parseFloat(str);\n  if (isFinite(num)) {\n    return just(num);\n  } else {\n    return nothing;\n  }\n}\n\nexport const abs = Math.abs;\n\nexport const acos = Math.acos;\n\nexport const asin = Math.asin;\n\nexport const atan = Math.atan;\n\nexport const atan2 = function (y) {\n  return function (x) {\n    return Math.atan2(y, x);\n  };\n};\n\nexport const ceil = Math.ceil;\n\nexport const cos = Math.cos;\n\nexport const exp = Math.exp;\n\nexport const floor = Math.floor;\n\nexport const log = Math.log;\n\nexport const max = function (n1) {\n  return function (n2) {\n    return Math.max(n1, n2);\n  };\n};\n\nexport const min = function (n1) {\n  return function (n2) {\n    return Math.min(n1, n2);\n  };\n};\n\nexport const pow = function (n) {\n  return function (p) {\n    return Math.pow(n, p);\n  };\n};\n\nexport const remainder = function (n) {\n  return function (m) {\n    return n % m;\n  };\n};\n\nexport const round = Math.round;\n\nexport const sign = Math.sign ? Math.sign : function(x) {\n  return x === 0 || x !== x ? x : (x < 0 ? -1 : 1);\n};\n\nexport const sin = Math.sin;\n\nexport const sqrt = Math.sqrt;\n\nexport const tan = Math.tan;\n\nexport const trunc = Math.trunc ? Math.trunc : function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n","module Data.Int\n  ( fromNumber\n  , ceil\n  , floor\n  , trunc\n  , round\n  , toNumber\n  , fromString\n  , Radix\n  , radix\n  , binary\n  , octal\n  , decimal\n  , hexadecimal\n  , base36\n  , fromStringAs\n  , toStringAs\n  , Parity(..)\n  , parity\n  , even\n  , odd\n  , quot\n  , rem\n  , pow\n  ) where\n\nimport Prelude\n\nimport Data.Int.Bits ((.&.))\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Number (isFinite)\nimport Data.Number as Number\n\n-- | Creates an `Int` from a `Number` value. The number must already be an\n-- | integer and fall within the valid range of values for the `Int` type\n-- | otherwise `Nothing` is returned.\nfromNumber :: Number -> Maybe Int\nfromNumber = fromNumberImpl Just Nothing\n\nforeign import fromNumberImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Number\n  -> Maybe Int\n\n-- | Convert a `Number` to an `Int`, by taking the closest integer equal to or\n-- | less than the argument. Values outside the `Int` range are clamped, `NaN`\n-- | and `Infinity` values return 0.\nfloor :: Number -> Int\nfloor = unsafeClamp <<< Number.floor\n\n-- | Convert a `Number` to an `Int`, by taking the closest integer equal to or\n-- | greater than the argument. Values outside the `Int` range are clamped,\n-- | `NaN` and `Infinity` values return 0.\nceil :: Number -> Int\nceil = unsafeClamp <<< Number.ceil\n\n-- | Convert a `Number` to an `Int`, by dropping the decimal.\n-- | Values outside the `Int` range are clamped, `NaN` and `Infinity`\n-- | values return 0.\ntrunc :: Number -> Int\ntrunc = unsafeClamp <<< Number.trunc\n\n-- | Convert a `Number` to an `Int`, by taking the nearest integer to the\n-- | argument. Values outside the `Int` range are clamped, `NaN` and `Infinity`\n-- | values return 0.\nround :: Number -> Int\nround = unsafeClamp <<< Number.round\n\n-- | Convert an integral `Number` to an `Int`, by clamping to the `Int` range.\n-- | This function will return 0 if the input is `NaN` or an `Infinity`.\nunsafeClamp :: Number -> Int\nunsafeClamp x\n  | not (isFinite x) = 0\n  | x >= toNumber top = top\n  | x <= toNumber bottom = bottom\n  | otherwise = fromMaybe 0 (fromNumber x)\n\n-- | Converts an `Int` value back into a `Number`. Any `Int` is a valid `Number`\n-- | so there is no loss of precision with this function.\nforeign import toNumber :: Int -> Number\n\n-- | Reads an `Int` from a `String` value. The number must parse as an integer\n-- | and fall within the valid range of values for the `Int` type, otherwise\n-- | `Nothing` is returned.\nfromString :: String -> Maybe Int\nfromString = fromStringAs (Radix 10)\n\n-- | A type for describing whether an integer is even or odd.\n-- |\n-- | The `Ord` instance considers `Even` to be less than `Odd`.\n-- |\n-- | The `Semiring` instance allows you to ask about the parity of the results\n-- | of arithmetical operations, given only the parities of the inputs. For\n-- | example, the sum of an odd number and an even number is odd, so\n-- | `Odd + Even == Odd`. This also works for multiplication, eg. the product\n-- | of two odd numbers is odd, and therefore `Odd * Odd == Odd`.\n-- |\n-- | More generally, we have that\n-- |\n-- | ```purescript\n-- | parity x + parity y == parity (x + y)\n-- | parity x * parity y == parity (x * y)\n-- | ```\n-- |\n-- | for any integers `x`, `y`. (A mathematician would say that `parity` is a\n-- | *ring homomorphism*.)\n-- |\n-- | After defining addition and multiplication on `Parity` in this way, the\n-- | `Semiring` laws now force us to choose `zero = Even` and `one = Odd`.\n-- | This `Semiring` instance actually turns out to be a `Field`.\ndata Parity = Even | Odd\n\nderive instance eqParity :: Eq Parity\nderive instance ordParity :: Ord Parity\n\ninstance showParity :: Show Parity where\n  show Even = \"Even\"\n  show Odd = \"Odd\"\n\ninstance boundedParity :: Bounded Parity where\n  bottom = Even\n  top = Odd\n\ninstance semiringParity :: Semiring Parity where\n  zero = Even\n  add x y = if x == y then Even else Odd\n  one = Odd\n  mul Odd Odd = Odd\n  mul _ _ = Even\n\ninstance ringParity :: Ring Parity where\n  sub = add\n\ninstance commutativeRingParity :: CommutativeRing Parity\n\ninstance euclideanRingParity :: EuclideanRing Parity where\n  degree Even = 0\n  degree Odd = 1\n  div x _ = x\n  mod _ _ = Even\n\ninstance divisionRingParity :: DivisionRing Parity where\n  recip = identity\n\n-- | Returns whether an `Int` is `Even` or `Odd`.\n-- |\n-- | ``` purescript\n-- | parity 0 == Even\n-- | parity 1 == Odd\n-- | ```\nparity :: Int -> Parity\nparity n = if even n then Even else Odd\n\n-- | Returns whether an `Int` is an even number.\n-- |\n-- | ``` purescript\n-- | even 0 == true\n-- | even 1 == false\n-- | ```\neven :: Int -> Boolean\neven x = x .&. 1 == 0\n\n-- | The negation of `even`.\n-- |\n-- | ``` purescript\n-- | odd 0 == false\n-- | odd 1 == true\n-- | ```\nodd :: Int -> Boolean\nodd x = x .&. 1 /= 0\n\n-- | The number of unique digits (including zero) used to represent integers in\n-- | a specific base.\nnewtype Radix = Radix Int\n\n-- | The base-2 system.\nbinary :: Radix\nbinary = Radix 2\n\n-- | The base-8 system.\noctal :: Radix\noctal = Radix 8\n\n-- | The base-10 system.\ndecimal :: Radix\ndecimal = Radix 10\n\n-- | The base-16 system.\nhexadecimal :: Radix\nhexadecimal = Radix 16\n\n-- | The base-36 system.\nbase36 :: Radix\nbase36 = Radix 36\n\n-- | Create a `Radix` from a number between 2 and 36.\nradix :: Int -> Maybe Radix\nradix n | n >= 2 && n <= 36 = Just (Radix n)\n        | otherwise         = Nothing\n\n-- | Like `fromString`, but the integer can be specified in a different base.\n-- |\n-- | Example:\n-- | ``` purs\n-- | fromStringAs binary      \"100\" == Just 4\n-- | fromStringAs hexadecimal \"ff\"  == Just 255\n-- | ```\nfromStringAs :: Radix -> String -> Maybe Int\nfromStringAs = fromStringAsImpl Just Nothing\n\n-- | The `quot` function provides _truncating_ integer division (see the\n-- | documentation for the `EuclideanRing` class). It is identical to `div` in\n-- | the `EuclideanRing Int` instance if the dividend is positive, but will be\n-- | slightly different if the dividend is negative. For example:\n-- |\n-- | ```purescript\n-- | div 2 3 == 0\n-- | quot 2 3 == 0\n-- |\n-- | div (-2) 3 == (-1)\n-- | quot (-2) 3 == 0\n-- |\n-- | div 2 (-3) == 0\n-- | quot 2 (-3) == 0\n-- | ```\nforeign import quot :: Int -> Int -> Int\n\n-- | The `rem` function provides the remainder after _truncating_ integer\n-- | division (see the documentation for the `EuclideanRing` class). It is\n-- | identical to `mod` in the `EuclideanRing Int` instance if the dividend is\n-- | positive, but will be slightly different if the dividend is negative. For\n-- | example:\n-- |\n-- | ```purescript\n-- | mod 2 3 == 2\n-- | rem 2 3 == 2\n-- |\n-- | mod (-2) 3 == 1\n-- | rem (-2) 3 == (-2)\n-- |\n-- | mod 2 (-3) == 2\n-- | rem 2 (-3) == 2\n-- | ```\nforeign import rem :: Int -> Int -> Int\n\n-- | Raise an Int to the power of another Int.\nforeign import pow :: Int -> Int -> Int\n\nforeign import fromStringAsImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Radix\n  -> String\n  -> Maybe Int\n\nforeign import toStringAs :: Radix -> Int -> String\n","-- | This module defines a type of _strict_ linked lists, and associated helper\n-- | functions and type class instances.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is an improvement over `Data.Array` when working with\n-- | immutable lists of data in a purely-functional setting, but does not have\n-- | good random-access performance.\n\nmodule Data.List\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n\n  , singleton\n  , (..), range\n  , some\n  , someRec\n  , many\n  , manyRec\n\n  , null\n  , length\n\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , modifyAt\n  , alterAt\n\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n\n  , sort\n  , sortBy\n\n  , Pattern(..)\n  , stripPrefix\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n  , (\\\\), difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , transpose\n\n  , foldM\n\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM, tailRecM2)\nimport Data.Bifunctor (bimap)\nimport Data.Foldable (class Foldable, foldr, any, foldl)\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.List.Internal (emptySet, insertAndLookupBy)\nimport Data.List.Types (List(..), (:))\nimport Data.List.Types (NonEmptyList(..)) as NEL\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty ((:|))\nimport Data.Traversable (scanl, scanr) as Exports\nimport Data.Traversable (sequence)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, unfoldr)\n\n-- | Convert a list into any unfoldable structure.\n-- |\n-- | Running time: `O(n)`\ntoUnfoldable :: forall f. Unfoldable f => List ~> f\ntoUnfoldable = unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> uncons xs)\n\n-- | Construct a list from a foldable structure.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> List\nfromFoldable = foldr Cons Nil\n\n--------------------------------------------------------------------------------\n-- List creation ---------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Create a list with a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> List a\nsingleton a = a : Nil\n\n-- | An infix synonym for `range`.\ninfix 8 range as ..\n\n-- | Create a list containing a range of integers, including both endpoints.\nrange :: Int -> Int -> List Int\nrange start end | start == end = singleton start\n                | otherwise = go end start (if start > end then 1 else -1) Nil\n  where\n  go s e step rest | s == e = s : rest\n                   | otherwise = go (s + step) e step (s : rest)\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nsome v = Cons <$> v <*> defer (\\_ -> many v)\n\n-- | A stack-safe version of `some`, at the cost of a `MonadRec` constraint.\nsomeRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nsomeRec v = Cons <$> v <*> manyRec v\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nmany v = some v <|> pure Nil\n\n-- | A stack-safe version of `many`, at the cost of a `MonadRec` constraint.\nmanyRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nmanyRec p = tailRecM go Nil\n  where\n  go :: List a -> f (Step (List a) (List a))\n  go acc = do\n    aa <- (Loop <$> p) <|> pure (Done unit)\n    pure $ bimap (_ : acc) (\\_ -> reverse acc) aa\n\n--------------------------------------------------------------------------------\n-- List size -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether a list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. List a -> Boolean\nnull Nil = true\nnull _ = false\n\n-- | Get the length of a list\n-- |\n-- | Running time: `O(n)`\nlength :: forall a. List a -> Int\nlength = foldl (\\acc _ -> acc + 1) 0\n\n--------------------------------------------------------------------------------\n-- Extending lists -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Append an element to the end of a list, creating a new list.\n-- |\n-- | Running time: `O(n)`\nsnoc :: forall a. List a -> a -> List a\nsnoc xs x = foldr (:) (x : Nil) xs\n\n-- | Insert an element into a sorted list.\n-- |\n-- | Running time: `O(n)`\ninsert :: forall a. Ord a => a -> List a -> List a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted list, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | Running time: `O(n)`\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> List a -> List a\ninsertBy _ x Nil = singleton x\ninsertBy cmp x ys@(y : ys') =\n  case cmp x y of\n    GT -> y : (insertBy cmp x ys')\n    _  -> x : ys\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`.\nhead :: List ~> Maybe\nhead Nil = Nothing\nhead (x : _) = Just x\n\n-- | Get the last element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`.\nlast :: List ~> Maybe\nlast (x : Nil) = Just x\nlast (_ : xs)  = last xs\nlast _         = Nothing\n\n-- | Get all but the first element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\ntail :: forall a. List a -> Maybe (List a)\ntail Nil = Nothing\ntail (_ : xs) = Just xs\n\n-- | Get all but the last element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\ninit :: forall a. List a -> Maybe (List a)\ninit lst = _.init <$> unsnoc lst\n\n-- | Break a list into its first element, and the remaining elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\nuncons :: forall a. List a -> Maybe { head :: a, tail :: List a }\nuncons Nil = Nothing\nuncons (x : xs) = Just { head: x, tail: xs }\n\n-- | Break a list into its last element, and the preceding elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\nunsnoc :: forall a. List a -> Maybe { init :: List a, last :: a }\nunsnoc lst = (\\h -> { init: reverse h.revInit, last: h.last }) <$> go lst Nil\n  where\n  go Nil _ = Nothing\n  go (x : Nil) acc = Just { revInit: acc, last: x }\n  go (x : xs) acc = go xs (x : acc)\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the element at the specified index, or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)` where `n` is the required index.\nindex :: forall a. List a -> Int -> Maybe a\nindex Nil _ = Nothing\nindex (a : _) 0 = Just a\nindex (_ : as) i = index as (i - 1)\n\n-- | An infix synonym for `index`.\ninfixl 8 index as !!\n\n-- | Find the index of the first element equal to the specified element.\nelemIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\nelemLastIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first index for which a predicate holds.\nfindIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindIndex fn = go 0\n  where\n  go :: Int -> List a -> Maybe Int\n  go n (x : xs) | fn x = Just n\n                | otherwise = go (n + 1) xs\n  go _ Nil = Nothing\n\n-- | Find the last index for which a predicate holds.\nfindLastIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindLastIndex fn xs = ((length xs - 1) - _) <$> findIndex fn (reverse xs)\n\n-- | Insert an element into a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ninsertAt :: forall a. Int -> a -> List a -> Maybe (List a)\ninsertAt 0 x xs = Just (x : xs)\ninsertAt n x (y : ys) = (y : _) <$> insertAt (n - 1) x ys\ninsertAt _ _ _  = Nothing\n\n-- | Delete an element from a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ndeleteAt :: forall a. Int -> List a -> Maybe (List a)\ndeleteAt 0 (_ : ys) = Just ys\ndeleteAt n (y : ys) = (y : _) <$> deleteAt (n - 1) ys\ndeleteAt _ _  = Nothing\n\n-- | Update the element at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nupdateAt :: forall a. Int -> a -> List a -> Maybe (List a)\nupdateAt 0 x ( _ : xs) = Just (x : xs)\nupdateAt n x (x1 : xs) = (x1 : _) <$> updateAt (n - 1) x xs\nupdateAt _ _ _ = Nothing\n\n-- | Update the element at the specified index by applying a function to\n-- | the current value, returning a new list or `Nothing` if the index is\n-- | out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nmodifyAt :: forall a. Int -> (a -> a) -> List a -> Maybe (List a)\nmodifyAt n f = alterAt n (Just <<< f)\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new list or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nalterAt :: forall a. Int -> (a -> Maybe a) -> List a -> Maybe (List a)\nalterAt 0 f (y : ys) = Just $\n  case f y of\n    Nothing -> ys\n    Just y' -> y' : ys\nalterAt n f (y : ys) = (y : _) <$> alterAt (n - 1) f ys\nalterAt _ _ _  = Nothing\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Reverse a list.\n-- |\n-- | Running time: `O(n)`\nreverse :: List ~> List\nreverse = go Nil\n  where\n  go acc Nil = acc\n  go acc (x : xs) = go (x : acc) xs\n\n-- | Flatten a list of lists.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcat :: forall a. List (List a) -> List a\nconcat = (_ >>= identity)\n\n-- | Apply a function to each element in a list, and flatten the results\n-- | into a single, new list.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcatMap :: forall a b. (a -> List b) -> List a -> List b\nconcatMap = flip bind\n\n-- | Filter a list, keeping the elements which satisfy a predicate function.\n-- |\n-- | Running time: `O(n)`\nfilter :: forall a. (a -> Boolean) -> List a -> List a\nfilter p = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs)\n    | p x = go (x : acc) xs\n    | otherwise = go acc xs\n\n-- | Filter where the predicate returns a monadic `Boolean`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. [a] -> [[a]]\n-- | powerSet = filterM (const [true, false])\n-- | ```\nfilterM :: forall a m. Monad m => (a -> m Boolean) -> List a -> m (List a)\nfilterM _ Nil = pure Nil\nfilterM p (x : xs) = do\n  b <- p x\n  xs' <- filterM p xs\n  pure if b then x : xs' else xs'\n\n-- | Apply a function to each element in a list, keeping only the results which\n-- | contain a value.\n-- |\n-- | Running time: `O(n)`\nmapMaybe :: forall a b. (a -> Maybe b) -> List a -> List b\nmapMaybe f = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs) =\n    case f x of\n      Nothing -> go acc xs\n      Just y -> go (y : acc) xs\n\n-- | Filter a list of optional values, keeping only the elements which contain\n-- | a value.\ncatMaybes :: forall a. List (Maybe a) -> List a\ncatMaybes = mapMaybe identity\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an list in increasing order.\nsort :: forall a. Ord a => List a -> List a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of a list in increasing order, where elements are\n-- | compared using the specified ordering.\nsortBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nsortBy cmp = mergeAll <<< sequences\n  -- implementation lifted from http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#sort\n  where\n  sequences :: List a -> List (List a)\n  sequences (a : b : xs)\n    | a `cmp` b == GT = descending b (singleton a) xs\n    | otherwise = ascending b (a : _) xs\n  sequences xs = singleton xs\n\n  descending :: a -> List a -> List a -> List (List a)\n  descending a as (b : bs)\n    | a `cmp` b == GT = descending b (a : as) bs\n  descending a as bs = (a : as) : sequences bs\n\n  ascending :: a -> (List a -> List a) -> List a -> List (List a)\n  ascending a as (b : bs)\n    | a `cmp` b /= GT = ascending b (\\ys -> as (a : ys)) bs\n  ascending a as bs = ((as $ singleton a) : sequences bs)\n\n  mergeAll :: List (List a) -> List a\n  mergeAll (x : Nil) = x\n  mergeAll xs = mergeAll (mergePairs xs)\n\n  mergePairs :: List (List a) -> List (List a)\n  mergePairs (a : b : xs) = merge a b : mergePairs xs\n  mergePairs xs = xs\n\n  merge :: List a -> List a -> List a\n  merge as@(a : as') bs@(b : bs')\n    | a `cmp` b == GT = b : merge as bs'\n    | otherwise       = a : merge as' bs\n  merge Nil bs = bs\n  merge as Nil = as\n\n--------------------------------------------------------------------------------\n-- Sublists --------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | A newtype used in cases where there is a list to be matched.\nnewtype Pattern a = Pattern (List a)\n\nderive instance eqPattern :: Eq a => Eq (Pattern a)\nderive instance ordPattern :: Ord a => Ord (Pattern a)\nderive instance newtypePattern :: Newtype (Pattern a) _\n\ninstance showPattern :: Show a => Show (Pattern a) where\n  show (Pattern s) = \"(Pattern \" <> show s <> \")\"\n\n\n-- | If the list starts with the given prefix, return the portion of the\n-- | list left after removing it, as a Just value. Otherwise, return Nothing.\n-- | * `stripPrefix (Pattern (1:Nil)) (1:2:Nil) == Just (2:Nil)`\n-- | * `stripPrefix (Pattern Nil) (1:Nil) == Just (1:Nil)`\n-- | * `stripPrefix (Pattern (2:Nil)) (1:Nil) == Nothing`\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to strip.\nstripPrefix :: forall a. Eq a => Pattern a -> List a -> Maybe (List a)\nstripPrefix (Pattern p') s = tailRecM2 go p' s\n  where\n  go prefix input = case prefix, input of\n    Cons p ps, Cons i is | p == i -> Just $ Loop { a: ps, b: is }\n    Nil, is -> Just $ Done is\n    _, _ -> Nothing\n\n-- | Extract a sublist by a start and end index.\nslice :: Int -> Int -> List ~> List\nslice start end xs = take (end - start) (drop start xs)\n\n-- | Take the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to take.\ntake :: forall a. Int -> List a -> List a\ntake = go Nil\n  where\n  go acc n _ | n < 1 = reverse acc\n  go acc _ Nil = reverse acc\n  go acc n (x : xs) = go (x : acc) (n - 1) xs\n\n-- | Take the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to take.\ntakeEnd :: forall a. Int -> List a -> List a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Take those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ntakeWhile :: forall a. (a -> Boolean) -> List a -> List a\ntakeWhile p = go Nil\n  where\n  go acc (x : xs) | p x = go (x : acc) xs\n  go acc _ = reverse acc\n\n-- | Drop the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to drop.\ndrop :: forall a. Int -> List a -> List a\ndrop n xs | n < 1 = xs\ndrop _ Nil = Nil\ndrop n (_ : xs) = drop (n - 1) xs\n\n-- | Drop the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to drop.\ndropEnd :: forall a. Int -> List a -> List a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Drop those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ndropWhile :: forall a. (a -> Boolean) -> List a -> List a\ndropWhile p = go\n  where\n  go (x : xs) | p x = go xs\n  go xs = xs\n\n-- | Split a list into two parts:\n-- |\n-- | 1. the longest initial segment for which all elements satisfy the specified predicate\n-- | 2. the remaining elements\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) (1 : 3 : 2 : 4 : 5 : Nil) == { init: (1 : 3 : Nil), rest: (2 : 4 : 5 : Nil) }\n-- | ```\n-- |\n-- | Running time: `O(n)`\nspan :: forall a. (a -> Boolean) -> List a -> { init :: List a, rest :: List a }\nspan p (x : xs') | p x = case span p xs' of\n  { init: ys, rest: zs } -> { init: x : ys, rest: zs }\nspan _ xs = { init: Nil, rest: xs }\n\n-- | Group equal, consecutive elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | group (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : (NonEmptyList (NonEmpty 1 Nil)) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroup :: forall a. Eq a => List a -> List (NEL.NonEmptyList a)\ngroup = groupBy (==)\n\n-- | Group equal elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupAll (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : 1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : Nil\n-- | ```\ngroupAll :: forall a. Ord a => List a -> List (NEL.NonEmptyList a)\ngroupAll = group <<< sort\n\n-- | Group equal, consecutive elements of a list into lists, using the specified\n-- | equivalence relation to determine equality.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) (1 : 3 : 2 : 4 : 3 : 3 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (3 : Nil))) : (NonEmptyList (NonEmpty 2 Nil)) : (NonEmptyList (NonEmpty 4 Nil)) : (NonEmptyList (NonEmpty 3 (3 : Nil))) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroupBy :: forall a. (a -> a -> Boolean) -> List a -> List (NEL.NonEmptyList a)\ngroupBy _ Nil = Nil\ngroupBy eq (x : xs) = case span (eq x) xs of\n  { init: ys, rest: zs } -> NEL.NonEmptyList (x :| ys) : groupBy eq zs\n\n-- | Sort, then group equal elements of a list into lists, using the provided comparison function.\n-- |\n-- | ```purescript\n-- | groupAllBy (compare `on` (_ `div` 10)) (32 : 31 : 21 : 22 : 11 : 33 : Nil) ==\n-- |   NonEmptyList (11 :| Nil) : NonEmptyList (21 :| 22 : Nil) : NonEmptyList (32 :| 31 : 33) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\ngroupAllBy :: forall a. (a -> a -> Ordering) -> List a -> List (NEL.NonEmptyList a)\ngroupAllBy p = groupBy (\\x y -> p x y == EQ) <<< sortBy p\n\n-- | Returns a lists of elements which do and do not satisfy a predicate.\n-- |\n-- | Running time: `O(n)`\npartition :: forall a. (a -> Boolean) -> List a -> { yes :: List a, no :: List a }\npartition p xs = foldr select { no: Nil, yes: Nil } xs\n  where\n    select x { no, yes } = if p x\n                           then { no, yes: x : yes }\n                           else { no: x : no, yes }\n\n-- | Returns all final segments of the argument, longest first. For example,\n-- |\n-- | ```purescript\n-- | tails (1 : 2 : 3 : Nil) == ((1 : 2 : 3 : Nil) : (2 : 3 : Nil) : (3 : Nil) : (Nil) : Nil)\n-- | ```\n-- | Running time: `O(n)`\ntails :: forall a. List a -> List (List a)\ntails Nil = singleton Nil\ntails list@(Cons _ tl)= list : tails tl\n\n--------------------------------------------------------------------------------\n-- Set-like operations ---------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nub 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnub :: forall a. Ord a => List a -> List a\nnub = nubBy compare\n\n-- | Remove duplicate elements from a list based on the provided comparison function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nubBy (compare `on` Array.length) ([1]:[2]:[3,4]:Nil) == [1]:[3,4]:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnubBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nnubBy p = reverse <<< go emptySet Nil\n  where\n    go _ acc Nil = acc\n    go s acc (a : as) =\n      let { found, result: s' } = insertAndLookupBy p a s\n      in if found\n        then go s' acc as\n        else go s' (a : acc) as\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubEq :: forall a. Eq a => List a -> List a\nnubEq = nubByEq eq\n\n-- | Remove duplicate elements from a list, using the provided equivalence function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | function, rather than an ordering function.\n-- |\n-- | ```purescript\n-- | mod3eq = eq `on` \\n -> mod n 3\n-- | nubByEq mod3eq 1:3:4:5:6:Nil == 1:3:5:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubByEq :: forall a. (a -> a -> Boolean) -> List a -> List a\nnubByEq _     Nil = Nil\nnubByEq eq' (x : xs) = x : nubByEq eq' (filter (\\y -> not (eq' x y)) xs)\n\n-- | Calculate the union of two lists.\n-- |\n-- | Running time: `O(n^2)`\nunion :: forall a. Eq a => List a -> List a -> List a\nunion = unionBy (==)\n\n-- | Calculate the union of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nunionBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first occurrence of an element from a list.\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> List a -> List a\ndelete = deleteBy (==)\n\n-- | Delete the first occurrence of an element from a list, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n)`\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> List a -> List a\ndeleteBy _ _ Nil = Nil\ndeleteBy eq' x (y : ys) | eq' x y = ys\ndeleteBy eq' x (y : ys) = y : deleteBy eq' x ys\n\ninfix 5 difference as \\\\\n\n-- | Delete the first occurrence of each element in the second list from the first list.\n-- |\n-- | Running time: `O(n^2)`\ndifference :: forall a. Eq a => List a -> List a -> List a\ndifference = foldl (flip delete)\n\n-- | Calculate the intersection of two lists.\n-- |\n-- | Running time: `O(n^2)`\nintersect :: forall a. Eq a => List a -> List a -> List a\nintersect = intersectBy (==)\n\n-- | Calculate the intersection of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nintersectBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nintersectBy _  Nil _   = Nil\nintersectBy _  _   Nil = Nil\nintersectBy eq xs  ys  = filter (\\x -> any (eq x) ys) xs\n\n--------------------------------------------------------------------------------\n-- Zipping ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Apply a function to pairs of elements at the same positions in two lists,\n-- | collecting the results in a new list.\n-- |\n-- | If one list is longer, elements will be discarded from the longer list.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) (1 : 2 : 3 : Nil) (4 : 5 : 6 : 7 Nil) == 4 : 10 : 18 : Nil\n-- | ```\n-- |\n-- | Running time: `O(min(m, n))`\nzipWith :: forall a b c. (a -> b -> c) -> List a -> List b -> List c\nzipWith f xs ys = reverse $ go xs ys Nil\n  where\n  go Nil _ acc = acc\n  go _ Nil acc = acc\n  go (a : as) (b : bs) acc = go as bs $ f a b : acc\n\n-- | A generalization of `zipWith` which accumulates results in some `Applicative`\n-- | functor.\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> List a -> List b -> m (List c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Collect pairs of elements at the same positions in two lists.\n-- |\n-- | Running time: `O(min(m, n))`\nzip :: forall a b. List a -> List b -> List (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms a list of pairs into a list of first components and a list of\n-- | second components.\nunzip :: forall a b. List (Tuple a b) -> Tuple (List a) (List b)\nunzip = foldr (\\(Tuple a b) (Tuple as bs) -> Tuple (a : as) (b : bs)) (Tuple Nil Nil)\n\n--------------------------------------------------------------------------------\n-- Transpose -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- |     transpose ((1:2:3:Nil) : (4:5:6:Nil) : Nil) ==\n-- |       ((1:4:Nil) : (2:5:Nil) : (3:6:Nil) : Nil)\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- |     transpose ((10:11:Nil) : (20:Nil) : Nil : (30:31:32:Nil) : Nil) ==\n-- |       ((10:20:30:Nil) : (11:31:Nil) : (32:Nil) : Nil)\ntranspose :: forall a. List (List a) -> List (List a)\ntranspose Nil = Nil\ntranspose (Nil : xss) = transpose xss\ntranspose ((x : xs) : xss) =\n  (x : mapMaybe head xss) : transpose (xs : mapMaybe tail xss)\n\n--------------------------------------------------------------------------------\n-- Folding ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Perform a fold using a monadic step function.\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> List a -> m b\nfoldM _ b Nil = pure b\nfoldM f b (a : as) = f b a >>= \\b' -> foldM f b' as\n","// module Partial.Unsafe\n\nexport const _unsafePartial = function (f) {\n  return f();\n};\n","// module Partial\n\nexport const _crashWith = function (msg) {\n  throw new Error(msg);\n};\n","-- | Some partial helper functions. See the README for more documentation.\nmodule Partial\n  ( crash\n  , crashWith\n  ) where\n\n-- | A partial function which crashes on any input with a default message.\ncrash :: forall a. Partial => a\ncrash = crashWith \"Partial.crash: partial function\"\n\n-- | A partial function which crashes on any input with the specified message.\ncrashWith :: forall a. Partial => String -> a\ncrashWith = _crashWith\n\nforeign import _crashWith :: forall a. String -> a\n","-- | Utilities for working with partial functions.\n-- | See the README for more documentation.\nmodule Partial.Unsafe\n  ( unsafePartial\n  , unsafeCrashWith\n  ) where\n\nimport Partial (crashWith)\n\n-- Note: this function's type signature is more like\n-- `(Unit -> a) -> a`. However, we would need to use\n-- `unsafeCoerce` to make this compile, incurring\n-- either a dependency or reimplementing it here.\n-- Rather than doing that, we'll use a type signature\n-- of `a -> b` instead.\nforeign import _unsafePartial :: forall a b. a -> b\n\n-- | Discharge a partiality constraint, unsafely.\nunsafePartial :: forall a. (Partial => a) -> a\nunsafePartial = _unsafePartial\n\n-- | A function which crashes with the specified error message.\nunsafeCrashWith :: forall a. String -> a\nunsafeCrashWith msg = unsafePartial (crashWith msg)\n","module Data.List.NonEmpty\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n  , fromList\n  , toList\n  , singleton\n  , length\n  , cons\n  , cons'\n  , snoc\n  , snoc'\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , updateAt\n  , modifyAt\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n  , appendFoldable\n  , sort\n  , sortBy\n  , take\n  , takeWhile\n  , drop\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , intersect\n  , intersectBy\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n  , foldM\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable)\nimport Data.List ((:))\nimport Data.List as L\nimport Data.List.Types (NonEmptyList(..))\nimport Data.Maybe (Maybe(..), fromMaybe, maybe)\nimport Data.NonEmpty ((:|))\nimport Data.NonEmpty as NE\nimport Data.Semigroup.Traversable (sequence1)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafeCrashWith)\n\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.Semigroup.Foldable (fold1, foldMap1, for1_, sequence1_, traverse1_) as Exports\nimport Data.Semigroup.Traversable (sequence1, traverse1, traverse1Default) as Exports\nimport Data.Traversable (scanl, scanr) as Exports\n\n-- | Internal function: any operation on a list that is guaranteed not to delete\n-- | all elements also applies to a NEL, this function is a helper for defining\n-- | those cases.\nwrappedOperation\n  :: forall a b\n   . String\n  -> (L.List a -> L.List b)\n  -> NonEmptyList a\n  -> NonEmptyList b\nwrappedOperation name f (NonEmptyList (x :| xs)) =\n  case f (x : xs) of\n    x' : xs' -> NonEmptyList (x' :| xs')\n    L.Nil -> unsafeCrashWith (\"Impossible: empty list in NonEmptyList \" <> name)\n\n-- | Like `wrappedOperation`, but for functions that operate on 2 lists.\nwrappedOperation2\n  :: forall a b c\n   . String\n  -> (L.List a -> L.List b -> L.List c)\n  -> NonEmptyList a\n  -> NonEmptyList b\n  -> NonEmptyList c\nwrappedOperation2 name f (NonEmptyList (x :| xs)) (NonEmptyList (y :| ys)) =\n  case f (x : xs) (y : ys) of\n    x' : xs' -> NonEmptyList (x' :| xs')\n    L.Nil -> unsafeCrashWith (\"Impossible: empty list in NonEmptyList \" <> name)\n\n-- | Lifts a function that operates on a list to work on a NEL. This does not\n-- | preserve the non-empty status of the result.\nlift :: forall a b. (L.List a -> b) -> NonEmptyList a -> b\nlift f (NonEmptyList (x :| xs)) = f (x : xs)\n\ntoUnfoldable :: forall f. Unfoldable f => NonEmptyList ~> f\ntoUnfoldable =\n  unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> L.uncons xs) <<< toList\n\nfromFoldable :: forall f a. Foldable f => f a -> Maybe (NonEmptyList a)\nfromFoldable = fromList <<< L.fromFoldable\n\nfromList :: forall a. L.List a -> Maybe (NonEmptyList a)\nfromList L.Nil = Nothing\nfromList (x : xs) = Just (NonEmptyList (x :| xs))\n\ntoList :: NonEmptyList ~> L.List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nsingleton :: forall a. a -> NonEmptyList a\nsingleton = NonEmptyList <<< NE.singleton\n\ncons :: forall a. a -> NonEmptyList a -> NonEmptyList a\ncons y (NonEmptyList (x :| xs)) = NonEmptyList (y :| x : xs)\n\ncons' :: forall a. a -> L.List a -> NonEmptyList a\ncons' x xs = NonEmptyList (x :| xs)\n\nsnoc :: forall a. NonEmptyList a -> a -> NonEmptyList a\nsnoc (NonEmptyList (x :| xs)) y = NonEmptyList (x :| L.snoc xs y)\n\nsnoc' :: forall a. L.List a -> a -> NonEmptyList a\nsnoc' (x : xs) y = NonEmptyList (x :| L.snoc xs y)\nsnoc' L.Nil y = singleton y\n\nhead :: forall a. NonEmptyList a -> a\nhead (NonEmptyList (x :| _)) = x\n\nlast :: forall a. NonEmptyList a -> a\nlast (NonEmptyList (x :| xs)) = fromMaybe x (L.last xs)\n\ntail :: NonEmptyList ~> L.List\ntail (NonEmptyList (_ :| xs)) = xs\n\ninit :: NonEmptyList ~> L.List\ninit (NonEmptyList (x :| xs)) = maybe L.Nil (x : _) (L.init xs)\n\nuncons :: forall a. NonEmptyList a -> { head :: a, tail :: L.List a }\nuncons (NonEmptyList (x :| xs)) = { head: x, tail: xs }\n\nunsnoc :: forall a. NonEmptyList a -> { init :: L.List a, last :: a }\nunsnoc (NonEmptyList (x :| xs)) = case L.unsnoc xs of\n  Nothing -> { init: L.Nil, last: x }\n  Just un -> { init: x : un.init, last: un.last }\n\nlength :: forall a. NonEmptyList a -> Int\nlength (NonEmptyList (_ :| xs)) = 1 + L.length xs\n\nindex :: forall a. NonEmptyList a -> Int -> Maybe a\nindex (NonEmptyList (x :| xs)) i\n  | i == 0 = Just x\n  | otherwise = L.index xs (i - 1)\n\ninfixl 8 index as !!\n\nelemIndex :: forall a. Eq a => a -> NonEmptyList a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\nelemLastIndex :: forall a. Eq a => a -> NonEmptyList a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\nfindIndex :: forall a. (a -> Boolean) -> NonEmptyList a -> Maybe Int\nfindIndex f (NonEmptyList (x :| xs))\n  | f x = Just 0\n  | otherwise = (_ + 1) <$> L.findIndex f xs\n\nfindLastIndex :: forall a. (a -> Boolean) -> NonEmptyList a -> Maybe Int\nfindLastIndex f (NonEmptyList (x :| xs)) =\n  case L.findLastIndex f xs of\n    Just i -> Just (i + 1)\n    Nothing\n      | f x -> Just 0\n      | otherwise -> Nothing\n\ninsertAt :: forall a. Int -> a -> NonEmptyList a -> Maybe (NonEmptyList a)\ninsertAt i a (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (a :| x : xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.insertAt (i - 1) a xs\n\nupdateAt :: forall a. Int -> a -> NonEmptyList a -> Maybe (NonEmptyList a)\nupdateAt i a (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (a :| xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.updateAt (i - 1) a xs\n\nmodifyAt :: forall a. Int -> (a -> a) -> NonEmptyList a -> Maybe (NonEmptyList a)\nmodifyAt i f (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (f x :| xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.modifyAt (i - 1) f xs\n\nreverse :: forall a. NonEmptyList a -> NonEmptyList a\nreverse = wrappedOperation \"reverse\" L.reverse\n\nfilter :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\nfilter = lift <<< L.filter\n\nfilterM :: forall m a. Monad m => (a -> m Boolean) -> NonEmptyList a -> m (L.List a)\nfilterM = lift <<< L.filterM\n\nmapMaybe :: forall a b. (a -> Maybe b) -> NonEmptyList a -> L.List b\nmapMaybe = lift <<< L.mapMaybe\n\ncatMaybes :: forall a. NonEmptyList (Maybe a) -> L.List a\ncatMaybes = lift L.catMaybes\n\nconcat :: forall a. NonEmptyList (NonEmptyList a) -> NonEmptyList a\nconcat = (_ >>= identity)\n\nconcatMap :: forall a b. (a -> NonEmptyList b) -> NonEmptyList a -> NonEmptyList b\nconcatMap = flip bind\n\nappendFoldable :: forall t a. Foldable t => NonEmptyList a -> t a -> NonEmptyList a\nappendFoldable (NonEmptyList (x :| xs)) ys =\n  NonEmptyList (x :| (xs <> L.fromFoldable ys))\n\nsort :: forall a. Ord a => NonEmptyList a -> NonEmptyList a\nsort xs = sortBy compare xs\n\nsortBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList a\nsortBy = wrappedOperation \"sortBy\" <<< L.sortBy\n\ntake :: forall a. Int -> NonEmptyList a -> L.List a\ntake = lift <<< L.take\n\ntakeWhile :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\ntakeWhile = lift <<< L.takeWhile\n\ndrop :: forall a. Int -> NonEmptyList a -> L.List a\ndrop = lift <<< L.drop\n\ndropWhile :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\ndropWhile = lift <<< L.dropWhile\n\nspan :: forall a. (a -> Boolean) -> NonEmptyList a -> { init :: L.List a, rest :: L.List a }\nspan = lift <<< L.span\n\ngroup :: forall a. Eq a => NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroup = wrappedOperation \"group\" L.group\n\ngroupAll :: forall a. Ord a => NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupAll = wrappedOperation \"groupAll\" L.groupAll\n\ngroupBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupBy = wrappedOperation \"groupBy\" <<< L.groupBy\n\ngroupAllBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupAllBy = wrappedOperation \"groupAllBy\" <<< L.groupAllBy\n\npartition :: forall a. (a -> Boolean) -> NonEmptyList a -> { yes :: L.List a, no :: L.List a }\npartition = lift <<< L.partition\n\nnub :: forall a. Ord a => NonEmptyList a -> NonEmptyList a\nnub = wrappedOperation \"nub\" L.nub\n\nnubBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList a\nnubBy = wrappedOperation \"nubBy\" <<< L.nubBy\n\nnubEq :: forall a. Eq a => NonEmptyList a -> NonEmptyList a\nnubEq = wrappedOperation \"nubEq\" L.nubEq\n\nnubByEq :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a\nnubByEq = wrappedOperation \"nubByEq\" <<< L.nubByEq\n\nunion :: forall a. Eq a => NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nunion = wrappedOperation2 \"union\" L.union\n\nunionBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nunionBy = wrappedOperation2 \"unionBy\" <<< L.unionBy\n\nintersect :: forall a. Eq a => NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nintersect = wrappedOperation2 \"intersect\" L.intersect\n\nintersectBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nintersectBy = wrappedOperation2 \"intersectBy\" <<< L.intersectBy\n\nzipWith :: forall a b c. (a -> b -> c) -> NonEmptyList a -> NonEmptyList b -> NonEmptyList c\nzipWith f (NonEmptyList (x :| xs)) (NonEmptyList (y :| ys)) =\n  NonEmptyList (f x y :| L.zipWith f xs ys)\n\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> NonEmptyList a -> NonEmptyList b -> m (NonEmptyList c)\nzipWithA f xs ys = sequence1 (zipWith f xs ys)\n\nzip :: forall a b. NonEmptyList a -> NonEmptyList b -> NonEmptyList (Tuple a b)\nzip = zipWith Tuple\n\nunzip :: forall a b. NonEmptyList (Tuple a b) -> Tuple (NonEmptyList a) (NonEmptyList b)\nunzip ts = Tuple (map fst ts) (map snd ts)\n\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> NonEmptyList a -> m b\nfoldM f b (NonEmptyList (a :| as)) = f b a >>= \\b' -> L.foldM f b' as\n","export const fromCharArray = function (a) {\n  return a.join(\"\");\n};\n\nexport const toCharArray = function (s) {\n  return s.split(\"\");\n};\n\nexport const singleton = function (c) {\n  return c;\n};\n\nexport const _charAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (s) {\n        return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;\n      };\n    };\n  };\n};\n\nexport const _toChar = function (just) {\n  return function (nothing) {\n    return function (s) {\n      return s.length === 1 ? just(s) : nothing;\n    };\n  };\n};\n\nexport const length = function (s) {\n  return s.length;\n};\n\nexport const countPrefix = function (p) {\n  return function (s) {\n    var i = 0;\n    while (i < s.length && p(s.charAt(i))) i++;\n    return i;\n  };\n};\n\nexport const _indexOf = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (s) {\n        var i = s.indexOf(x);\n        return i === -1 ? nothing : just(i);\n      };\n    };\n  };\n};\n\nexport const _indexOfStartingAt = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (startAt) {\n        return function (s) {\n          if (startAt < 0 || startAt > s.length) return nothing;\n          var i = s.indexOf(x, startAt);\n          return i === -1 ? nothing : just(i);\n        };\n      };\n    };\n  };\n};\n\nexport const _lastIndexOf = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (s) {\n        var i = s.lastIndexOf(x);\n        return i === -1 ? nothing : just(i);\n      };\n    };\n  };\n};\n\nexport const _lastIndexOfStartingAt = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (startAt) {\n        return function (s) {\n          var i = s.lastIndexOf(x, startAt);\n          return i === -1 ? nothing : just(i);\n        };\n      };\n    };\n  };\n};\n\nexport const take = function (n) {\n  return function (s) {\n    return s.substr(0, n);\n  };\n};\n\nexport const drop = function (n) {\n  return function (s) {\n    return s.substring(n);\n  };\n};\n\nexport const slice = function (b) {\n  return function (e) {\n    return function (s) {\n      return s.slice(b,e);\n    };\n  };\n};\n\nexport const splitAt = function (i) {\n  return function (s) {\n    return { before: s.substring(0, i), after: s.substring(i) };\n  };\n};\n","module Data.String.CodeUnits\n  ( stripPrefix\n  , stripSuffix\n  , contains\n  , singleton\n  , fromCharArray\n  , toCharArray\n  , charAt\n  , toChar\n  , uncons\n  , length\n  , countPrefix\n  , indexOf\n  , indexOf'\n  , lastIndexOf\n  , lastIndexOf'\n  , take\n  , takeRight\n  , takeWhile\n  , drop\n  , dropRight\n  , dropWhile\n  , slice\n  , splitAt\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..), isJust)\nimport Data.String.Pattern (Pattern(..))\nimport Data.String.Unsafe as U\n\n-------------------------------------------------------------------------------\n-- `stripPrefix`, `stripSuffix`, and `contains` are CodeUnit/CodePoint agnostic\n-- as they are based on patterns rather than lengths/indices, but they need to\n-- be defined in here to avoid a circular module dependency\n-------------------------------------------------------------------------------\n\n-- | If the string starts with the given prefix, return the portion of the\n-- | string left after removing it, as a `Just` value. Otherwise, return `Nothing`.\n-- |\n-- | ```purescript\n-- | stripPrefix (Pattern \"http:\") \"http://purescript.org\" == Just \"//purescript.org\"\n-- | stripPrefix (Pattern \"http:\") \"https://purescript.org\" == Nothing\n-- | ```\nstripPrefix :: Pattern -> String -> Maybe String\nstripPrefix (Pattern prefix) str =\n  let { before, after } = splitAt (length prefix) str in\n  if before == prefix then Just after else Nothing\n\n-- | If the string ends with the given suffix, return the portion of the\n-- | string left after removing it, as a `Just` value. Otherwise, return\n-- | `Nothing`.\n-- |\n-- | ```purescript\n-- | stripSuffix (Pattern \".exe\") \"psc.exe\" == Just \"psc\"\n-- | stripSuffix (Pattern \".exe\") \"psc\" == Nothing\n-- | ```\nstripSuffix :: Pattern -> String -> Maybe String\nstripSuffix (Pattern suffix) str =\n  let { before, after } = splitAt (length str - length suffix) str in\n  if after == suffix then Just before else Nothing\n\n-- | Checks whether the pattern appears in the given string.\n-- |\n-- | ```purescript\n-- | contains (Pattern \"needle\") \"haystack with needle\" == true\n-- | contains (Pattern \"needle\") \"haystack\" == false\n-- | ```\ncontains :: Pattern -> String -> Boolean\ncontains pat = isJust <<< indexOf pat\n\n-------------------------------------------------------------------------------\n-- all functions past this point are CodeUnit specific\n-------------------------------------------------------------------------------\n\n-- | Returns a string of length `1` containing the given character.\n-- |\n-- | ```purescript\n-- | singleton 'l' == \"l\"\n-- | ```\n-- |\nforeign import singleton :: Char -> String\n\n-- | Converts an array of characters into a string.\n-- |\n-- | ```purescript\n-- | fromCharArray ['H', 'e', 'l', 'l', 'o'] == \"Hello\"\n-- | ```\nforeign import fromCharArray :: Array Char -> String\n\n-- | Converts the string into an array of characters.\n-- |\n-- | ```purescript\n-- | toCharArray \"Hello☺\\n\" == ['H','e','l','l','o','☺','\\n']\n-- | ```\nforeign import toCharArray :: String -> Array Char\n\n-- | Returns the character at the given index, if the index is within bounds.\n-- |\n-- | ```purescript\n-- | charAt 2 \"Hello\" == Just 'l'\n-- | charAt 10 \"Hello\" == Nothing\n-- | ```\n-- |\ncharAt :: Int -> String -> Maybe Char\ncharAt = _charAt Just Nothing\n\nforeign import _charAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Int\n  -> String\n  -> Maybe Char\n\n-- | Converts the string to a character, if the length of the string is\n-- | exactly `1`.\n-- |\n-- | ```purescript\n-- | toChar \"l\" == Just 'l'\n-- | toChar \"Hi\" == Nothing -- since length is not 1\n-- | ```\ntoChar :: String -> Maybe Char\ntoChar = _toChar Just Nothing\n\nforeign import _toChar\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> String\n  -> Maybe Char\n\n-- | Returns the first character and the rest of the string,\n-- | if the string is not empty.\n-- |\n-- | ```purescript\n-- | uncons \"\" == Nothing\n-- | uncons \"Hello World\" == Just { head: 'H', tail: \"ello World\" }\n-- | ```\n-- |\nuncons :: String -> Maybe { head :: Char, tail :: String }\nuncons \"\" = Nothing\nuncons s  = Just { head: U.charAt zero s, tail: drop one s }\n\n-- | Returns the number of characters the string is composed of.\n-- |\n-- | ```purescript\n-- | length \"Hello World\" == 11\n-- | ```\n-- |\nforeign import length :: String -> Int\n\n-- | Returns the number of contiguous characters at the beginning\n-- | of the string for which the predicate holds.\n-- |\n-- | ```purescript\n-- | countPrefix (_ /= ' ') \"Hello World\" == 5 -- since length \"Hello\" == 5\n-- | ```\n-- |\nforeign import countPrefix :: (Char -> Boolean) -> String -> Int\n\n-- | Returns the index of the first occurrence of the pattern in the\n-- | given string. Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | indexOf (Pattern \"c\") \"abcdc\" == Just 2\n-- | indexOf (Pattern \"c\") \"aaa\" == Nothing\n-- | ```\n-- |\nindexOf :: Pattern -> String -> Maybe Int\nindexOf = _indexOf Just Nothing\n\nforeign import _indexOf\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the first occurrence of the pattern in the\n-- | given string, starting at the specified index. Returns `Nothing` if there is\n-- | no match.\n-- |\n-- | ```purescript\n-- | indexOf' (Pattern \"a\") 2 \"ababa\" == Just 2\n-- | indexOf' (Pattern \"a\") 3 \"ababa\" == Just 4\n-- | ```\n-- |\nindexOf' :: Pattern -> Int -> String -> Maybe Int\nindexOf' = _indexOfStartingAt Just Nothing\n\nforeign import _indexOfStartingAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> Int\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the last occurrence of the pattern in the\n-- | given string. Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | lastIndexOf (Pattern \"c\") \"abcdc\" == Just 4\n-- | lastIndexOf (Pattern \"c\") \"aaa\" == Nothing\n-- | ```\n-- |\nlastIndexOf :: Pattern -> String -> Maybe Int\nlastIndexOf = _lastIndexOf Just Nothing\n\nforeign import _lastIndexOf\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> String\n  -> Maybe Int\n\n-- | Returns the index of the last occurrence of the pattern in the\n-- | given string, starting at the specified index and searching\n-- | backwards towards the beginning of the string.\n-- |\n-- | Starting at a negative index is equivalent to starting at 0 and\n-- | starting at an index greater than the string length is equivalent\n-- | to searching in the whole string.\n-- |\n-- | Returns `Nothing` if there is no match.\n-- |\n-- | ```purescript\n-- | lastIndexOf' (Pattern \"a\") (-1) \"ababa\" == Just 0\n-- | lastIndexOf' (Pattern \"a\") 1 \"ababa\" == Just 0\n-- | lastIndexOf' (Pattern \"a\") 3 \"ababa\" == Just 2\n-- | lastIndexOf' (Pattern \"a\") 4 \"ababa\" == Just 4\n-- | lastIndexOf' (Pattern \"a\") 5 \"ababa\" == Just 4\n-- | ```\n-- |\nlastIndexOf' :: Pattern -> Int -> String -> Maybe Int\nlastIndexOf' = _lastIndexOfStartingAt Just Nothing\n\nforeign import _lastIndexOfStartingAt\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Pattern\n  -> Int\n  -> String\n  -> Maybe Int\n\n-- | Returns the first `n` characters of the string.\n-- |\n-- | ```purescript\n-- | take 5 \"Hello World\" == \"Hello\"\n-- | ```\n-- |\nforeign import take :: Int -> String -> String\n\n-- | Returns the last `n` characters of the string.\n-- |\n-- | ```purescript\n-- | takeRight 5 \"Hello World\" == \"World\"\n-- | ```\n-- |\ntakeRight :: Int -> String -> String\ntakeRight i s = drop (length s - i) s\n\n-- | Returns the longest prefix (possibly empty) of characters that satisfy\n-- | the predicate.\n-- |\n-- | ```purescript\n-- | takeWhile (_ /= ':') \"http://purescript.org\" == \"http\"\n-- | ```\n-- |\ntakeWhile :: (Char -> Boolean) -> String -> String\ntakeWhile p s = take (countPrefix p s) s\n\n-- | Returns the string without the first `n` characters.\n-- |\n-- | ```purescript\n-- | drop 6 \"Hello World\" == \"World\"\n-- | ```\n-- |\nforeign import drop :: Int -> String -> String\n\n-- | Returns the string without the last `n` characters.\n-- |\n-- | ```purescript\n-- | dropRight 6 \"Hello World\" == \"Hello\"\n-- | ```\n-- |\ndropRight :: Int -> String -> String\ndropRight i s = take (length s - i) s\n\n-- | Returns the suffix remaining after `takeWhile`.\n-- |\n-- | ```purescript\n-- | dropWhile (_ /= '.') \"Test.purs\" == \".purs\"\n-- | ```\n-- |\ndropWhile :: (Char -> Boolean) -> String -> String\ndropWhile p s = drop (countPrefix p s) s\n\n-- | Returns the substring at indices `[begin, end)`.\n-- | If either index is negative, it is normalised to `length s - index`,\n-- | where `s` is the input string. `\"\"` is returned if either\n-- | index is out of bounds or if `begin > end` after normalisation.\n-- |\n-- | ```purescript\n-- | slice 0 0   \"purescript\" == \"\"\n-- | slice 0 1   \"purescript\" == \"p\"\n-- | slice 3 6   \"purescript\" == \"esc\"\n-- | slice (-4) (-1) \"purescript\" == \"rip\"\n-- | slice (-4) 3  \"purescript\" == \"\"\n-- | ```\nforeign import slice :: Int -> Int -> String -> String\n\n-- | Splits a string into two substrings, where `before` contains the\n-- | characters up to (but not including) the given index, and `after` contains\n-- | the rest of the string, from that index on.\n-- |\n-- | ```purescript\n-- | splitAt 2 \"Hello World\" == { before: \"He\", after: \"llo World\"}\n-- | splitAt 10 \"Hi\" == { before: \"Hi\", after: \"\"}\n-- | ```\n-- |\n-- | Thus the length of `(splitAt i s).before` will equal either `i` or\n-- | `length s`, if that is shorter. (Or if `i` is negative the length will be\n-- | 0.)\n-- |\n-- | In code:\n-- | ```purescript\n-- | length (splitAt i s).before == min (max i 0) (length s)\n-- | (splitAt i s).before <> (splitAt i s).after == s\n-- | splitAt i s == {before: take i s, after: drop i s}\n-- | ```\nforeign import splitAt :: Int -> String -> { before :: String, after :: String }\n","-- | This module defines types and functions for working with _foreign_\n-- | data.\n-- |\n-- | `ExceptT (NonEmptyList ForeignError) m` is used in this library\n-- | to encode possible failures when dealing with foreign data.\n-- |\n-- | The `Alt` instance for `ExceptT` allows us to accumulate errors,\n-- | unlike `Either`, which preserves only the last error.\nmodule Foreign\n  ( Foreign\n  , ForeignError(..)\n  , MultipleErrors(..)\n  , F\n  , FT\n  , renderForeignError\n  , unsafeToForeign\n  , unsafeFromForeign\n  , unsafeReadTagged\n  , typeOf\n  , tagOf\n  , isNull\n  , isUndefined\n  , isArray\n  , readString\n  , readChar\n  , readBoolean\n  , readNumber\n  , readInt\n  , readArray\n  , readNull\n  , readUndefined\n  , readNullOrUndefined\n  , fail\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Except (Except, ExceptT, mapExceptT, throwError)\nimport Data.Either (Either(..), either)\nimport Data.Int as Int\nimport Data.List.NonEmpty (NonEmptyList)\nimport Data.List.NonEmpty as NEL\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.String.CodeUnits (toChar)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | A type for _foreign data_.\n-- |\n-- | Foreign data is data from any external _unknown_ or _unreliable_\n-- | source, for which it cannot be guaranteed that the runtime representation\n-- | conforms to that of any particular type.\n-- |\n-- | Suitable applications of `Foreign` are\n-- |\n-- | - To represent responses from web services\n-- | - To integrate with external JavaScript libraries.\nforeign import data Foreign :: Type\n\n-- | A type for foreign type errors\ndata ForeignError\n  = ForeignError String\n  | TypeMismatch String String\n  | ErrorAtIndex Int ForeignError\n  | ErrorAtProperty String ForeignError\n\nderive instance eqForeignError :: Eq ForeignError\nderive instance ordForeignError :: Ord ForeignError\n\ninstance showForeignError :: Show ForeignError where\n  show (ForeignError msg) = \"(ForeignError \" <> show msg <> \")\"\n  show (ErrorAtIndex i e) = \"(ErrorAtIndex \" <> show i <> \" \" <> show e <> \")\"\n  show (ErrorAtProperty prop e) = \"(ErrorAtProperty \" <> show prop <> \" \" <> show e <> \")\"\n  show (TypeMismatch exps act) = \"(TypeMismatch \" <> show exps <> \" \" <> show act <> \")\"\n\n-- | A type for accumulating multiple `ForeignError`s.\ntype MultipleErrors = NonEmptyList ForeignError\n\nrenderForeignError :: ForeignError -> String\nrenderForeignError (ForeignError msg) = msg\nrenderForeignError (ErrorAtIndex i e) = \"Error at array index \" <> show i <> \": \" <> renderForeignError e\nrenderForeignError (ErrorAtProperty prop e) = \"Error at property \" <> show prop <> \": \" <> renderForeignError e\nrenderForeignError (TypeMismatch exp act) = \"Type mismatch: expected \" <> exp <> \", found \" <> act\n\n-- | While this alias is not deprecated, it is recommended\n-- | that one use `Except (NonEmptyList ForeignError)` directly\n-- | for all future usages rather than this type alias.\n-- |\n-- | An error monad, used in this library to encode possible failures when\n-- | dealing with foreign data.\n-- |\n-- | The `Alt` instance for `Except` allows us to accumulate errors,\n-- | unlike `Either`, which preserves only the last error.\ntype F = Except MultipleErrors\n\n-- | While this alias is not deprecated, it is recommended\n-- | that one use `ExceptT (NonEmptyList ForeignError)` directly\n-- | for all future usages rather than this type alias.\ntype FT = ExceptT MultipleErrors\n\n-- | Coerce any value to the a `Foreign` value.\n-- |\n-- | This is considered unsafe as it's only intended to be used on primitive\n-- | JavaScript types, rather than PureScript types. Exporting PureScript values\n-- | via the FFI can be dangerous as they can be mutated by code outside the\n-- | PureScript program, resulting in difficult to diagnose problems elsewhere.\nunsafeToForeign :: forall a. a -> Foreign\nunsafeToForeign = unsafeCoerce\n\n-- | Unsafely coerce a `Foreign` value.\nunsafeFromForeign :: forall a. Foreign -> a\nunsafeFromForeign = unsafeCoerce\n\n-- | Read the Javascript _type_ of a value\nforeign import typeOf :: Foreign -> String\n\n-- | Read the Javascript _tag_ of a value.\n-- |\n-- | This function wraps the `Object.toString` method.\nforeign import tagOf :: Foreign -> String\n\n-- | Unsafely coerce a `Foreign` value when the value has a particular `tagOf`\n-- | value.\nunsafeReadTagged :: forall m a. Monad m => String -> Foreign -> ExceptT (NonEmptyList ForeignError) m a\nunsafeReadTagged tag value\n  | tagOf value == tag = pure (unsafeFromForeign value)\n  | otherwise = fail $ TypeMismatch tag (tagOf value)\n\n-- | Test whether a foreign value is null\nforeign import isNull :: Foreign -> Boolean\n\n-- | Test whether a foreign value is undefined\nforeign import isUndefined :: Foreign -> Boolean\n\n-- | Test whether a foreign value is an array\nforeign import isArray :: Foreign -> Boolean\n\n-- | Attempt to coerce a foreign value to a `String`.\nreadString :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m String\nreadString = unsafeReadTagged \"String\"\n\n-- | Attempt to coerce a foreign value to a `Char`.\nreadChar :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Char\nreadChar value = mapExceptT (map $ either (const error) fromString) (readString value)\n  where\n  fromString = maybe error pure <<< toChar\n  error = Left $ NEL.singleton $ TypeMismatch \"Char\" (tagOf value)\n\n-- | Attempt to coerce a foreign value to a `Boolean`.\nreadBoolean :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Boolean\nreadBoolean = unsafeReadTagged \"Boolean\"\n\n-- | Attempt to coerce a foreign value to a `Number`.\nreadNumber :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Number\nreadNumber = unsafeReadTagged \"Number\"\n\n-- | Attempt to coerce a foreign value to an `Int`.\nreadInt :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m Int\nreadInt value = mapExceptT (map $ either (const error) fromNumber) (readNumber value)\n  where\n  fromNumber = maybe error pure <<< Int.fromNumber\n  error = Left $ NEL.singleton $ TypeMismatch \"Int\" (tagOf value)\n\n-- | Attempt to coerce a foreign value to an array.\nreadArray :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Array Foreign)\nreadArray value\n  | isArray value = pure $ unsafeFromForeign value\n  | otherwise = fail $ TypeMismatch \"array\" (tagOf value)\n\nreadNull :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadNull value\n  | isNull value = pure Nothing\n  | otherwise = pure (Just value)\n\nreadUndefined :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadUndefined value\n  | isUndefined value = pure Nothing\n  | otherwise = pure (Just value)\n\nreadNullOrUndefined :: forall m. Monad m => Foreign -> ExceptT (NonEmptyList ForeignError) m (Maybe Foreign)\nreadNullOrUndefined value\n  | isNull value || isUndefined value = pure Nothing\n  | otherwise = pure (Just value)\n\n-- | Throws a failure error in `ExceptT (NonEmptyList ForeignError) m`.\nfail :: forall m a. Monad m => ForeignError -> ExceptT (NonEmptyList ForeignError) m a\nfail = throwError <<< NEL.singleton\n","export function _copyST(m) {\n  return function () {\n    var r = {};\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r[k] = m[k];\n      }\n    }\n    return r;\n  };\n}\n\nexport const empty = {};\n\nexport function runST(f) {\n  return f();\n}\n\nexport function _fmapObject(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _mapWithKey(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(k)(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _foldM(bind) {\n  return function (f) {\n    return function (mz) {\n      return function (m) {\n        var acc = mz;\n        function g(k) {\n          return function (z) {\n            return f(z)(k)(m[k]);\n          };\n        }\n        for (var k in m) {\n          if (hasOwnProperty.call(m, k)) {\n            acc = bind(acc)(g(k));\n          }\n        }\n        return acc;\n      };\n    };\n  };\n}\n\nexport function _foldSCObject(m, z, f, fromMaybe) {\n  var acc = z;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      var maybeR = f(acc)(k)(m[k]);\n      var r = fromMaybe(null)(maybeR);\n      if (r === null) return acc;\n      else acc = r;\n    }\n  }\n  return acc;\n}\n\nexport function all(f) {\n  return function (m) {\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k) && !f(k)(m[k])) return false;\n    }\n    return true;\n  };\n}\n\nexport function size(m) {\n  var s = 0;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      ++s;\n    }\n  }\n  return s;\n}\n\nexport function _lookup(no, yes, k, m) {\n  return k in m ? yes(m[k]) : no;\n}\n\nexport function _lookupST(no, yes, k, m) {\n  return function () {\n    return k in m ? yes(m[k]) : no;\n  };\n}\n\nexport function toArrayWithKey(f) {\n  return function (m) {\n    var r = [];\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r.push(f(k)(m[k]));\n      }\n    }\n    return r;\n  };\n}\n\nexport const keys = Object.keys || toArrayWithKey(function (k) {\n  return function () { return k; };\n});\n","-- | This module defines a type of native homogeneous Javascript Objects.\n-- |\n-- | To maximize performance, Javascript objects are not wrapped,\n-- | and some native code is used even when it's not necessary.\n\nmodule Foreign.Object\n  ( Object\n  , empty\n  , isEmpty\n  , size\n  , singleton\n  , insert\n  , lookup\n  , toUnfoldable\n  , toAscUnfoldable\n  , fromFoldable\n  , fromFoldableWith\n  , fromFoldableWithIndex\n  , fromHomogeneous\n  , delete\n  , pop\n  , member\n  , alter\n  , update\n  , mapWithKey\n  , filterWithKey\n  , filterKeys\n  , filter\n  , keys\n  , values\n  , union\n  , unionWith\n  , unions\n  , isSubmap\n  , fold\n  , foldMap\n  , foldM\n  , foldMaybe\n  , all\n  , thawST\n  , freezeST\n  , runST\n  , toArrayWithKey\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST)\nimport Control.Monad.ST as ST\nimport Data.Array as A\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, for_)\nimport Data.FoldableWithIndex (class FoldableWithIndex, forWithIndex_)\nimport Data.Function.Uncurried (Fn2, runFn2, Fn4, runFn4)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.Maybe (Maybe(..), maybe, fromMaybe)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), fst, uncurry)\nimport Data.Unfoldable (class Unfoldable)\nimport Foreign.Object.ST (STObject)\nimport Foreign.Object.ST as OST\nimport Type.Row.Homogeneous (class Homogeneous)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | `Object a` represents a homogeneous JS Object with values of type `a`.\nforeign import data Object :: Type -> Type\n\ntype role Object representational\n\nforeign import _copyST :: forall a b r. a -> ST r b\n\n-- | Convert an immutable Object into a mutable Object\nthawST :: forall a r. Object a -> ST r (STObject r a)\nthawST = _copyST\n\n-- | Convert a mutable Object into an immutable Object\nfreezeST :: forall a r. STObject r a -> ST r (Object a)\nfreezeST = _copyST\n\n-- | Freeze a mutable Object, creating an immutable Object. Use this function as you would use\n-- | `Control.Monad.ST.run` (from the `purescript-st` package) to freeze a mutable reference.\n-- |\n-- | The rank-2 type prevents the Object from escaping the scope of `runST`.\nforeign import runST :: forall a. (forall r. ST r (STObject r a)) -> Object a\n\nmutate :: forall a b. (forall r. STObject r a -> ST r b) -> Object a -> Object a\nmutate f m = runST do\n  s <- thawST m\n  _ <- f s\n  pure s\n\nforeign import _fmapObject :: forall a b. Fn2 (Object a) (a -> b) (Object b)\n\ninstance functorObject :: Functor Object where\n  map f m = runFn2 _fmapObject m f\n\ninstance functorWithIndexObject :: FunctorWithIndex String Object where\n  mapWithIndex = mapWithKey\n\nforeign import _foldM :: forall a m z. (m -> (z -> m) -> m) -> (z -> String -> a -> m) -> m -> Object a -> m\n\n-- | Fold the keys and values of an object\nfold :: forall a z. (z -> String -> a -> z) -> z -> Object a -> z\nfold = _foldM ((#))\n\n-- | Fold the keys and values of an object, accumulating values using some\n-- | `Monoid`.\nfoldMap :: forall a m. Monoid m => (String -> a -> m) -> Object a -> m\nfoldMap f = fold (\\acc k v -> acc <> f k v) mempty\n\n-- | Fold the keys and values of an object, accumulating values and effects in\n-- | some `Monad`.\nfoldM :: forall a m z. Monad m => (z -> String -> a -> m z) -> z -> Object a -> m z\nfoldM f z = _foldM bind f (pure z)\n\ninstance foldableObject :: Foldable Object where\n  foldl f = fold (\\z _ -> f z)\n  foldr f z m = foldr f z (values m)\n  foldMap f = foldMap (const f)\n\ninstance foldableWithIndexObject :: FoldableWithIndex String Object where\n  foldlWithIndex f = fold (flip f)\n  foldrWithIndex f z m = foldr (uncurry f) z (toArrayWithKey Tuple m)\n  foldMapWithIndex = foldMap\n\ninstance traversableObject :: Traversable Object where\n  traverse = traverseWithIndex <<< const\n  sequence = traverse identity\n\ninstance traversableWithIndexObject :: TraversableWithIndex String Object where\n  traverseWithIndex f ms =\n    fold (\\acc k v -> flip (insert k) <$> acc <*> f k v) (pure empty) ms\n\n-- Unfortunately the above are not short-circuitable (consider using purescript-machines)\n-- so we need special cases:\n\nforeign import _foldSCObject :: forall a z. Fn4 (Object a) z (z -> String -> a -> Maybe z) (forall b. b -> Maybe b -> b) z\n\n-- | Fold the keys and values of a map.\n-- |\n-- | This function allows the folding function to terminate the fold early,\n-- | using `Maybe`.\nfoldMaybe :: forall a z. (z -> String -> a -> Maybe z) -> z -> Object a -> z\nfoldMaybe f z m = runFn4 _foldSCObject m z f fromMaybe\n\n-- | Test whether all key/value pairs in a `Object` satisfy a predicate.\nforeign import all :: forall a. (String -> a -> Boolean) -> Object a -> Boolean\n\ninstance eqObject :: Eq a => Eq (Object a) where\n  eq m1 m2 = (isSubmap m1 m2) && (isSubmap m2 m1)\n\ninstance eq1Object :: Eq1 Object where\n  eq1 = eq\n\n-- Internal use\ntoAscArray :: forall v. Object v -> Array (Tuple String v)\ntoAscArray = toAscUnfoldable\n\ninstance ordObject :: Ord a => Ord (Object a) where\n  compare m1 m2 = compare (toAscArray m1) (toAscArray m2)\n\ninstance showObject :: Show a => Show (Object a) where\n  show m = \"(fromFoldable \" <> show (toArray m) <> \")\"\n\n-- | An empty map\nforeign import empty :: forall a. Object a\n\n-- | Test whether one map contains all of the keys and values contained in another map\nisSubmap :: forall a. Eq a => Object a -> Object a -> Boolean\nisSubmap m1 m2 = all f m1 where\n  f k v = runFn4 _lookup false ((==) v) k m2\n\n-- | Test whether a map is empty\nisEmpty :: forall a. Object a -> Boolean\nisEmpty = all (\\_ _ -> false)\n\n-- | Calculate the number of key/value pairs in a map\nforeign import size :: forall a. Object a -> Int\n\n-- | Create an `Object a` with one key/value pair\nsingleton :: forall a. String -> a -> Object a\nsingleton k v = runST (OST.poke k v =<< OST.new)\n\nforeign import _lookup :: forall a z. Fn4 z (a -> z) String (Object a) z\n\n-- | Lookup the value for a key in a map\nlookup :: forall a. String -> Object a -> Maybe a\nlookup = runFn4 _lookup Nothing Just\n\n-- | Test whether a `String` appears as a key in a map\nmember :: forall a. String -> Object a -> Boolean\nmember = runFn4 _lookup false (const true)\n\n-- | Insert or replace a key/value pair in a map\ninsert :: forall a. String -> a -> Object a -> Object a\ninsert k v = mutate (OST.poke k v)\n\n-- | Delete a key and value from a map\ndelete :: forall a. String -> Object a -> Object a\ndelete k = mutate (OST.delete k)\n\n-- | Delete a key and value from a map, returning the value\n-- | as well as the subsequent map\npop :: forall a. String -> Object a -> Maybe (Tuple a (Object a))\npop k m = lookup k m <#> \\a -> Tuple a (delete k m)\n\n-- | Insert, remove or update a value for a key in a map\nalter :: forall a. (Maybe a -> Maybe a) -> String -> Object a -> Object a\nalter f k m = case f (k `lookup` m) of\n  Nothing -> delete k m\n  Just v -> insert k v m\n\n-- | Remove or update a value for a key in a map\nupdate :: forall a. (a -> Maybe a) -> String -> Object a -> Object a\nupdate f k m = alter (maybe Nothing f) k m\n\n-- | Create an `Object a` from a foldable collection of key/value pairs\nfromFoldable :: forall f a. Foldable f => f (Tuple String a) -> Object a\nfromFoldable l = runST do\n  s <- OST.new\n  ST.foreach (A.fromFoldable l) \\(Tuple k v) -> void $ OST.poke k v s\n  pure s\n\n-- | Create an `Object a` from a `String`-indexed foldable collection\nfromFoldableWithIndex :: forall f a. FoldableWithIndex String f => f a -> Object a\nfromFoldableWithIndex l = runST do\n  s <- OST.new\n  forWithIndex_ l \\k v -> OST.poke k v s\n  pure s\n\nforeign import _lookupST :: forall a r z. Fn4 z (a -> z) String (STObject r a) (ST r z)\n\n-- | Create an `Object a` from a foldable collection of key/value pairs, using the\n-- | specified function to combine values for duplicate keys.\nfromFoldableWith :: forall f a. Foldable f => (a -> a -> a) -> f (Tuple String a) -> Object a\nfromFoldableWith f l = runST (do\n  s <- OST.new\n  for_ l (\\(Tuple k v) -> runFn4 _lookupST v (f v) k s >>= \\v' -> OST.poke k v' s)\n  pure s)\n\n-- | Create an `Object a` from a homogeneous record, i.e. all of the record\n-- | fields are of the same type.\nfromHomogeneous :: forall r a. Homogeneous r a => { | r } -> Object a\nfromHomogeneous = unsafeCoerce\n\nforeign import toArrayWithKey :: forall a b . (String -> a -> b) -> Object a -> Array b\n\n-- | Unfolds a map into a list of key/value pairs\ntoUnfoldable :: forall f a. Unfoldable f => Object a -> f (Tuple String a)\ntoUnfoldable = A.toUnfoldable <<< toArrayWithKey Tuple\n\n-- | Unfolds a map into a list of key/value pairs which is guaranteed to be\n-- | sorted by key\ntoAscUnfoldable :: forall f a. Unfoldable f => Object a -> f (Tuple String a)\ntoAscUnfoldable = A.toUnfoldable <<< A.sortWith fst <<< toArrayWithKey Tuple\n\n-- Internal\ntoArray :: forall a. Object a -> Array (Tuple String a)\ntoArray = toArrayWithKey Tuple\n\n-- | Get an array of the keys in a map\nforeign import keys :: forall a. Object a -> Array String\n\n-- | Get a list of the values in a map\nvalues :: forall a. Object a -> Array a\nvalues = toArrayWithKey (\\_ v -> v)\n\n-- | Compute the union of two maps, preferring the first map in the case of\n-- | duplicate keys.\nunion :: forall a. Object a -> Object a -> Object a\nunion m = mutate (\\s -> foldM (\\s' k v -> OST.poke k v s') s m)\n\n-- | Compute the union of two maps, using the specified function\n-- | to combine values for duplicate keys.\nunionWith :: forall a. (a -> a -> a) -> Object a -> Object a -> Object a\nunionWith f m1 m2 =\n  mutate (\\s1 -> foldM (\\s2 k v1 -> OST.poke k (runFn4 _lookup v1 (\\v2 -> f v1 v2) k m2) s2) s1 m1) m2\n\n-- | Compute the union of a collection of maps\nunions :: forall f a. Foldable f => f (Object a) -> Object a\nunions = foldl union empty\n\nforeign import _mapWithKey :: forall a b. Fn2 (Object a) (String -> a -> b) (Object b)\n\n-- | Apply a function of two arguments to each key/value pair, producing a new map\nmapWithKey :: forall a b. (String -> a -> b) -> Object a -> Object b\nmapWithKey f m = runFn2 _mapWithKey m f\n\ninstance semigroupObject :: (Semigroup a) => Semigroup (Object a) where\n  append = unionWith (<>)\n\ninstance monoidObject :: (Semigroup a) => Monoid (Object a) where\n  mempty = empty\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | fails to hold.\nfilterWithKey :: forall a. (String -> a -> Boolean) -> Object a -> Object a\nfilterWithKey predicate m = runST go\n  where\n  go :: forall r. ST r (STObject r a)\n  go = do\n    m' <- OST.new\n    foldM step m' m\n    where\n      step acc k v = if predicate k v then OST.poke k v acc else pure acc\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the key fails to hold.\nfilterKeys :: (String -> Boolean) -> Object ~> Object\nfilterKeys predicate = filterWithKey $ const <<< predicate\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the value fails to hold.\nfilter :: forall a. (a -> Boolean) -> Object a -> Object a\nfilter predicate = filterWithKey $ const predicate\n","export function eventListener(fn) {\n  return function () {\n    return function (event) {\n      return fn(event)();\n    };\n  };\n}\n\nexport function addEventListenerWithOptions(type) {\n  return function (listener) {\n    return function (options) {\n      return function (target) {\n        return function () {\n          return target.addEventListener(type, listener, options);\n        };\n      };\n    };\n  };\n}\n\nexport function addEventListener(type) {\n  return function (listener) {\n    return function (useCapture) {\n      return function (target) {\n        return function () {\n          return target.addEventListener(type, listener, useCapture);\n        };\n      };\n    };\n  };\n}\n\nexport function removeEventListener(type) {\n  return function (listener) {\n    return function (useCapture) {\n      return function (target) {\n        return function () {\n          return target.removeEventListener(type, listener, useCapture);\n        };\n      };\n    };\n  };\n}\n\nexport function dispatchEvent(event) {\n  return function (target) {\n    return function () {\n      return target.dispatchEvent(event);\n    };\n  };\n}\n","module Halogen.VDom.DOM.Prop\n  ( Prop(..)\n  , ElemRef(..)\n  , PropValue\n  , propFromString\n  , propFromBoolean\n  , propFromInt\n  , propFromNumber\n  , buildProp\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried as Fn\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (null, toNullable)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Effect (Effect)\nimport Effect.Ref as Ref\nimport Effect.Uncurried as EFn\nimport Foreign (typeOf)\nimport Foreign.Object as Object\nimport Halogen.VDom as V\nimport Halogen.VDom.Machine (Step'(..), mkStep)\nimport Halogen.VDom.Types (Namespace(..))\nimport Halogen.VDom.Util as Util\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element) as DOM\nimport Web.Event.Event (EventType(..), Event) as DOM\nimport Web.Event.EventTarget (eventListener) as DOM\n\n-- | Attributes, properties, event handlers, and element lifecycles.\n-- | Parameterized by the type of handlers outputs.\ndata Prop a\n  = Attribute (Maybe Namespace) String String\n  | Property String PropValue\n  | Handler DOM.EventType (DOM.Event → Maybe a)\n  | Ref (ElemRef DOM.Element → Maybe a)\n\ninstance functorProp ∷ Functor Prop where\n  map f (Handler ty g) = Handler ty (map f <$> g)\n  map f (Ref g) = Ref (map f <$> g)\n  map _ p = unsafeCoerce p\n\ndata ElemRef a\n  = Created a\n  | Removed a\n\ninstance functorElemRef ∷ Functor ElemRef where\n  map f (Created a) = Created (f a)\n  map f (Removed a) = Removed (f a)\n\nforeign import data PropValue ∷ Type\n\npropFromString ∷ String → PropValue\npropFromString = unsafeCoerce\n\npropFromBoolean ∷ Boolean → PropValue\npropFromBoolean = unsafeCoerce\n\npropFromInt ∷ Int → PropValue\npropFromInt = unsafeCoerce\n\npropFromNumber ∷ Number → PropValue\npropFromNumber = unsafeCoerce\n\n-- | A `Machine`` for applying attributes, properties, and event handlers.\n-- | An emitter effect must be provided to respond to events. For example,\n-- | to allow arbitrary effects in event handlers, one could use `id`.\nbuildProp\n  ∷ ∀ a\n  . (a → Effect Unit)\n  → DOM.Element\n  → V.Machine (Array (Prop a)) Unit\nbuildProp emit el = renderProp\n  where\n  renderProp = EFn.mkEffectFn1 \\ps1 → do\n    events ← Util.newMutMap\n    ps1' ← EFn.runEffectFn3 Util.strMapWithIxE ps1 propToStrKey (applyProp events)\n    let\n      state =\n        { events: Util.unsafeFreeze events\n        , props: ps1'\n        }\n    pure $ mkStep $ Step unit state patchProp haltProp\n\n  patchProp = EFn.mkEffectFn2 \\state ps2 → do\n    events ← Util.newMutMap\n    let\n      { events: prevEvents, props: ps1 } = state\n      onThese = Fn.runFn2 diffProp prevEvents events\n      onThis = removeProp prevEvents\n      onThat = applyProp events\n    props ← EFn.runEffectFn6 Util.diffWithKeyAndIxE ps1 ps2 propToStrKey onThese onThis onThat\n    let\n      nextState =\n        { events: Util.unsafeFreeze events\n        , props\n        }\n    pure $ mkStep $ Step unit nextState patchProp haltProp\n\n  haltProp = EFn.mkEffectFn1 \\state → do\n    case Object.lookup \"ref\" state.props of\n      Just (Ref f) →\n        EFn.runEffectFn1 mbEmit (f (Removed el))\n      _ → pure unit\n\n  mbEmit = EFn.mkEffectFn1 case _ of\n    Just a → emit a\n    _ → pure unit\n\n  applyProp events = EFn.mkEffectFn3 \\_ _ v →\n    case v of\n      Attribute ns attr val → do\n        EFn.runEffectFn4 Util.setAttribute (toNullable ns) attr val el\n        pure v\n      Property prop val → do\n        EFn.runEffectFn3 setProperty prop val el\n        pure v\n      Handler (DOM.EventType ty) f → do\n        case Fn.runFn2 Util.unsafeGetAny ty events of\n          handler | Fn.runFn2 Util.unsafeHasAny ty events → do\n            Ref.write f (snd handler)\n            pure v\n          _ → do\n            ref ← Ref.new f\n            listener ← DOM.eventListener \\ev → do\n              f' ← Ref.read ref\n              EFn.runEffectFn1 mbEmit (f' ev)\n            EFn.runEffectFn3 Util.pokeMutMap ty (Tuple listener ref) events\n            EFn.runEffectFn3 Util.addEventListener ty listener el\n            pure v\n      Ref f → do\n        EFn.runEffectFn1 mbEmit (f (Created el))\n        pure v\n\n  diffProp = Fn.mkFn2 \\prevEvents events → EFn.mkEffectFn4 \\_ _ v1 v2 →\n    case v1, v2 of\n      Attribute _ _ val1, Attribute ns2 attr2 val2 →\n        if val1 == val2\n          then pure v2\n          else do\n            EFn.runEffectFn4 Util.setAttribute (toNullable ns2) attr2 val2 el\n            pure v2\n      Property _ val1, Property prop2 val2 →\n        case Fn.runFn2 Util.refEq val1 val2, prop2 of\n          true, _ →\n            pure v2\n          _, \"value\" → do\n            let elVal = Fn.runFn2 unsafeGetProperty \"value\" el\n            if Fn.runFn2 Util.refEq elVal val2\n              then pure v2\n              else do\n                EFn.runEffectFn3 setProperty prop2 val2 el\n                pure v2\n          _, _ → do\n            EFn.runEffectFn3 setProperty prop2 val2 el\n            pure v2\n      Handler _ _, Handler (DOM.EventType ty) f → do\n        let\n          handler = Fn.runFn2 Util.unsafeLookup ty prevEvents\n        Ref.write f (snd handler)\n        EFn.runEffectFn3 Util.pokeMutMap ty handler events\n        pure v2\n      _, _ →\n        pure v2\n\n  removeProp prevEvents = EFn.mkEffectFn2 \\_ v →\n    case v of\n      Attribute ns attr _ →\n        EFn.runEffectFn3 Util.removeAttribute (toNullable ns) attr el\n      Property prop _ →\n        EFn.runEffectFn2 removeProperty prop el\n      Handler (DOM.EventType ty) _ → do\n        let\n          handler = Fn.runFn2 Util.unsafeLookup ty prevEvents\n        EFn.runEffectFn3 Util.removeEventListener ty (fst handler) el\n      Ref _ →\n        pure unit\n\npropToStrKey ∷ ∀ i. Prop i → String\npropToStrKey = case _ of\n  Attribute (Just (Namespace ns)) attr _ → \"attr/\" <> ns <> \":\" <> attr\n  Attribute _ attr _ → \"attr/:\" <> attr\n  Property prop _ → \"prop/\" <> prop\n  Handler (DOM.EventType ty) _ → \"handler/\" <> ty\n  Ref _ → \"ref\"\n\nsetProperty ∷ EFn.EffectFn3 String PropValue DOM.Element Unit\nsetProperty = Util.unsafeSetAny\n\nunsafeGetProperty ∷ Fn.Fn2 String DOM.Element PropValue\nunsafeGetProperty = Util.unsafeGetAny\n\nremoveProperty ∷ EFn.EffectFn2 String DOM.Element Unit\nremoveProperty = EFn.mkEffectFn2 \\key el →\n  EFn.runEffectFn3 Util.hasAttribute null key el >>= if _\n    then EFn.runEffectFn3 Util.removeAttribute null key el\n    else case typeOf (Fn.runFn2 Util.unsafeGetAny key el) of\n      \"string\" → EFn.runEffectFn3 Util.unsafeSetAny key \"\" el\n      _        → case key of\n        \"rowSpan\" → EFn.runEffectFn3 Util.unsafeSetAny key 1 el\n        \"colSpan\" → EFn.runEffectFn3 Util.unsafeSetAny key 1 el\n        _ → EFn.runEffectFn3 Util.unsafeSetAny key Util.jsUndefined el\n","module Web.HTML.Common where\n\nimport Prelude\n\nimport Data.Newtype (class Newtype)\n\n-- | A wrapper for property names.\n-- |\n-- | The phantom type `value` describes the type of value which this property\n-- | requires.\nnewtype PropName :: Type -> Type\nnewtype PropName value = PropName String\n\nderive instance newtypePropName :: Newtype (PropName value) _\nderive newtype instance eqPropName :: Eq (PropName value)\nderive newtype instance ordPropName :: Ord (PropName value)\n\n-- | A wrapper for attribute names.\nnewtype AttrName = AttrName String\n\nderive instance newtypeAttrName :: Newtype AttrName _\nderive newtype instance eqAttrName :: Eq AttrName\nderive newtype instance ordAttrName :: Ord AttrName\n\n-- | A wrapper for strings which are used as CSS classes.\nnewtype ClassName = ClassName String\n\nderive instance newtypeClassName :: Newtype ClassName _\nderive newtype instance eqClassName :: Eq ClassName\nderive newtype instance ordClassName :: Ord ClassName\n","module Halogen.HTML.Core\n  ( HTML(..)\n  , renderWidget\n  , widget\n  , text\n  , element\n  , keyed\n  , prop\n  , attr\n  , handler\n  , ref\n  , class IsProp\n  , toPropValue\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport DOM.HTML.Indexed.AutocompleteType (AutocompleteType, renderAutocompleteType)\nimport DOM.HTML.Indexed.ButtonType (ButtonType, renderButtonType)\nimport DOM.HTML.Indexed.CrossOriginValue (CrossOriginValue, renderCrossOriginValue)\nimport DOM.HTML.Indexed.DirValue (DirValue, renderDirValue)\nimport DOM.HTML.Indexed.FormMethod (FormMethod, renderFormMethod)\nimport DOM.HTML.Indexed.InputAcceptType (InputAcceptType, renderInputAcceptType)\nimport DOM.HTML.Indexed.InputType (InputType, renderInputType)\nimport DOM.HTML.Indexed.KindValue (KindValue, renderKindValue)\nimport DOM.HTML.Indexed.MenuType (MenuType, renderMenuType)\nimport DOM.HTML.Indexed.MenuitemType (MenuitemType, renderMenuitemType)\nimport DOM.HTML.Indexed.OrderedListType (OrderedListType, renderOrderedListType)\nimport DOM.HTML.Indexed.PreloadValue (PreloadValue, renderPreloadValue)\nimport DOM.HTML.Indexed.ScopeValue (ScopeValue, renderScopeValue)\nimport DOM.HTML.Indexed.StepValue (StepValue, renderStepValue)\nimport DOM.HTML.Indexed.WrapValue (WrapValue, renderWrapValue)\nimport Data.Bifunctor (class Bifunctor, bimap, rmap)\nimport Data.Maybe (Maybe(..))\nimport Data.MediaType (MediaType)\nimport Data.Newtype (class Newtype, un, unwrap)\nimport Data.Tuple (Tuple)\nimport Halogen.Query.Input (Input)\nimport Halogen.VDom (ElemName(..), Namespace(..)) as Exports\nimport Halogen.VDom.DOM.Prop (ElemRef(..), Prop(..), PropValue, propFromBoolean, propFromInt, propFromNumber, propFromString)\nimport Halogen.VDom.DOM.Prop (Prop(..), PropValue) as Exports\nimport Halogen.VDom.Types as VDom\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element)\nimport Web.Event.Event (Event, EventType)\nimport Web.HTML.Common (AttrName(..), ClassName(..), PropName(..)) as Exports\nimport Web.HTML.Common (AttrName(..), PropName(..))\n\nnewtype HTML w i = HTML (VDom.VDom (Array (Prop (Input i))) w)\n\nderive instance newtypeHTML :: Newtype (HTML w i) _\n\ninstance bifunctorHTML :: Bifunctor HTML where\n  bimap f g (HTML vdom) = HTML (bimap (map (map (map g))) f vdom)\n\ninstance functorHTML :: Functor (HTML p) where\n  map = rmap\n\nrenderWidget :: forall w x i j. (i -> j) -> (w -> HTML x j) -> HTML w i -> HTML x j\nrenderWidget f g (HTML vdom) =\n  HTML (VDom.renderWidget (map (map (map f))) (un HTML <<< g) vdom)\n\nwidget :: forall p q. p -> HTML p q\nwidget = HTML <<< VDom.Widget\n\n-- | Constructs a text node `HTML` value.\ntext :: forall w i. String -> HTML w i\ntext = HTML <<< VDom.Text\n\n-- | A smart constructor for HTML elements.\nelement :: forall w i. Maybe VDom.Namespace -> VDom.ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i\nelement ns =\n  coe (\\name props children -> VDom.Elem ns name props children)\n  where\n  coe\n    :: (VDom.ElemName -> Array (Prop i) -> Array (VDom.VDom (Array (Prop i)) w) -> VDom.VDom (Array (Prop i)) w)\n    -> VDom.ElemName\n    -> Array (Prop i)\n    -> Array (HTML w i)\n    -> HTML w i\n  coe = unsafeCoerce\n\n-- | A smart constructor for HTML elements with keyed children.\nkeyed :: forall w i. Maybe VDom.Namespace -> VDom.ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyed ns = coe (\\name props children -> VDom.Keyed ns name props children)\n  where\n  coe\n    :: (VDom.ElemName -> Array (Prop i) -> Array (Tuple String (VDom.VDom (Array (Prop i)) w)) -> VDom.VDom (Array (Prop i)) w)\n    -> VDom.ElemName\n    -> Array (Prop i)\n    -> Array (Tuple String (HTML w i))\n    -> HTML w i\n  coe = unsafeCoerce\n\n-- | Create a HTML property.\nprop :: forall value i. IsProp value => PropName value -> value -> Prop i\nprop (PropName name) = Property name <<< toPropValue\n\n-- | Create a HTML attribute.\nattr :: forall i. Maybe VDom.Namespace -> AttrName -> String -> Prop i\nattr ns (AttrName name) = Attribute ns name\n\n-- | Create an event handler.\nhandler :: forall i. EventType -> (Event -> Maybe i) -> Prop i\nhandler = Handler\n\nref :: forall i. (Maybe Element -> Maybe i) -> Prop i\nref f = Ref $ f <<< case _ of\n  Created x -> Just x\n  Removed _ -> Nothing\n\nclass IsProp a where\n  toPropValue :: a -> PropValue\n\ninstance isPropString :: IsProp String where\n  toPropValue = propFromString\n\ninstance isPropInt :: IsProp Int where\n  toPropValue = propFromInt\n\ninstance isPropNumber :: IsProp Number where\n  toPropValue = propFromNumber\n\ninstance isPropBoolean :: IsProp Boolean where\n  toPropValue = propFromBoolean\n\ninstance isPropMediaType :: IsProp MediaType where\n  toPropValue = propFromString <<< unwrap\n\ninstance isPropButtonType :: IsProp ButtonType where\n  toPropValue = propFromString <<< renderButtonType\n\ninstance isPropCrossOriginValue :: IsProp CrossOriginValue where\n  toPropValue = propFromString <<< renderCrossOriginValue\n\ninstance isPropDirValue :: IsProp DirValue where\n  toPropValue = propFromString <<< renderDirValue\n\ninstance isPropFormMethod :: IsProp FormMethod where\n  toPropValue = propFromString <<< renderFormMethod\n\ninstance isPropInputType :: IsProp InputType where\n  toPropValue = propFromString <<< renderInputType\n\ninstance isPropKindValue :: IsProp KindValue where\n  toPropValue = propFromString <<< renderKindValue\n\ninstance isPropMenuitemType :: IsProp MenuitemType where\n  toPropValue = propFromString <<< renderMenuitemType\n\ninstance isPropMenuType :: IsProp MenuType where\n  toPropValue = propFromString <<< renderMenuType\n\ninstance isPropAutocompleteType :: IsProp AutocompleteType where\n  toPropValue = propFromString <<< renderAutocompleteType\n\ninstance isPropOrderedListType :: IsProp OrderedListType where\n  toPropValue = propFromString <<< renderOrderedListType\n\ninstance isPropPreloadValue :: IsProp PreloadValue where\n  toPropValue = propFromString <<< renderPreloadValue\n\ninstance isPropScopeValue :: IsProp ScopeValue where\n  toPropValue = propFromString <<< renderScopeValue\n\ninstance isPropStepValue :: IsProp StepValue where\n  toPropValue = propFromString <<< renderStepValue\n\ninstance isPropWrapValue :: IsProp WrapValue where\n  toPropValue = propFromString <<< renderWrapValue\n\ninstance isPropInputAcceptType :: IsProp InputAcceptType where\n  toPropValue = propFromString <<< renderInputAcceptType\n","module Control.Applicative.Free\n  ( FreeAp\n  , liftFreeAp\n  , retractFreeAp\n  , foldFreeAp\n  , hoistFreeAp\n  , analyzeFreeAp\n  ) where\n\nimport Prelude\n\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.List (List(..))\nimport Data.List.NonEmpty as NEL\nimport Data.Newtype (unwrap)\nimport Data.NonEmpty ((:|))\nimport Data.Tuple (Tuple(..))\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The free applicative functor for a type constructor `f`.\ndata FreeAp f a\n  = Pure a\n  | Lift (f a)\n  | Ap (FreeAp f (Val -> a)) (FreeAp f Val)\n\ndata Val\n\n-- | Lift a value described by the type constructor `f` into\n-- | the free applicative functor.\nliftFreeAp :: forall f a. f a -> FreeAp f a\nliftFreeAp = Lift\n\ntype ApFunc g = { func :: g (Val -> Val), count :: Int }\ntype FuncStack g = List (ApFunc g)\ntype ValStack f = NEL.NonEmptyList (FreeAp f Val)\ntype Stack f g = Tuple (FuncStack g) (ValStack f)\n\n-- | Run a free applicative functor with a natural transformation from\n-- | the type constructor `f` to the applicative functor `g`.\nfoldFreeAp :: forall f g a. Applicative g => (f ~> g) -> FreeAp f a -> g a\nfoldFreeAp nat z =\n  unsafeToG $ go $ Tuple Nil (NEL.singleton $ unsafeToFVal z)\n  where\n  unsafeToG :: g Val -> g a\n  unsafeToG = unsafeCoerce\n\n  unsafeToFVal :: forall f' a'. FreeAp f' a' -> FreeAp f' Val\n  unsafeToFVal = unsafeCoerce\n\n  go :: Stack f g -> g Val\n  go (Tuple fStack (NEL.NonEmptyList (val :| vals))) =\n    case val of\n      Pure a -> case goApply fStack vals (pure a) of\n        Left x -> x\n        Right s -> go s\n      Lift a -> case goApply fStack vals (nat a) of\n        Left x -> x\n        Right s -> go s\n      Ap l r ->\n        let nextVals = NEL.NonEmptyList (r :| vals)\n        in go $ goLeft fStack nextVals nat l 1\n\ngoApply\n  :: forall f g\n  . Applicative g\n  => FuncStack g\n  -> List (FreeAp f Val)\n  -> g Val\n  -> Either (g Val) (Stack f g)\ngoApply fStack vals gVal =\n  case fStack of\n    Nil -> Left gVal\n    Cons f fs ->\n      let gRes = f.func <*> gVal\n      in if f.count == 1 then\n        case fs of\n          Nil ->\n            -- here vals must be empty\n            Left gRes\n          _ -> goApply fs vals gRes\n        else\n          case vals of\n            Nil -> Left gRes\n            Cons val vals' ->\n              Right $ Tuple\n                (Cons { func: unsafeToGFunc gRes, count: f.count - 1 } fs)\n                (NEL.NonEmptyList (val :| vals'))\n  where\n  unsafeToGFunc :: g Val -> g (Val -> Val)\n  unsafeToGFunc = unsafeCoerce\n\ngoLeft\n  :: forall f g\n  . Applicative g\n  => FuncStack g\n  -> ValStack f\n  -> (f ~> g)\n  -> FreeAp f (Val -> Val)\n  -> Int\n  -> Stack f g\ngoLeft fStack valStack nat func count = case func of\n  Pure a -> Tuple (Cons { func: pure a, count } fStack) valStack\n  Lift a -> Tuple (Cons { func: nat a, count } fStack) valStack\n  Ap l r -> goLeft fStack (NEL.cons r valStack) nat (unsafeToFunc l) (count + 1)\n  where\n  unsafeToFunc :: FreeAp f (Val -> Val -> Val) -> FreeAp f (Val -> Val)\n  unsafeToFunc = unsafeCoerce\n\n-- | Run a free applicative functor using the applicative instance for\n-- | the type constructor `f`.\nretractFreeAp :: forall f a. Applicative f => FreeAp f a -> f a\nretractFreeAp = foldFreeAp identity\n\n-- | Natural transformation from `FreeAp f a` to `FreeAp g a` given a\n-- | natural transformation from `f` to `g`.\nhoistFreeAp :: forall f g a. (f ~> g) -> FreeAp f a -> FreeAp g a\nhoistFreeAp f = foldFreeAp (f >>> liftFreeAp)\n\n-- | Perform monoidal analysis over the free applicative functor `f`.\nanalyzeFreeAp :: forall f m a. Monoid m => (forall b. f b -> m) -> FreeAp f a -> m\nanalyzeFreeAp k = unwrap <<< foldFreeAp (Const <<< k)\n\nmkAp :: forall f a b. FreeAp f (b -> a) -> FreeAp f b -> FreeAp f a\nmkAp fba fb = Ap (coerceFunc fba) (coerceValue fb)\n  where\n  coerceFunc :: FreeAp f (b -> a) -> FreeAp f (Val -> a)\n  coerceFunc = unsafeCoerce\n\n  coerceValue :: FreeAp f b -> FreeAp f Val\n  coerceValue = unsafeCoerce\n\ninstance functorFreeAp :: Functor (FreeAp f) where\n  map f x = mkAp (Pure f) x\n\ninstance applyFreeAp :: Apply (FreeAp f) where\n  apply fba fb = mkAp fba fb\n\ninstance applicativeFreeAp :: Applicative (FreeAp f) where\n  pure = Pure\n","-- | This module defines a strict double-ended queue.\n-- |\n-- | The queue implementation is based on a pair of lists where all\n-- | operations require `O(1)` amortized time.\n-- |\n-- | However, any single `uncons` operation may run in `O(n)` time.\n-- |\n-- | See [Simple and Efficient Purely Functional Queues and Dequeues](http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf) (Okasaki 1995)\nmodule Data.CatQueue\n  ( CatQueue(..)\n  , empty\n  , null\n  , singleton\n  , length\n  , cons\n  , snoc\n  , uncons\n  , unsnoc\n  , fromFoldable\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Foldable (class Foldable, foldMap, foldMapDefaultL, foldl, foldrDefault)\nimport Data.List (List(..), reverse)\nimport Data.List as L\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (class Traversable, sequenceDefault)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, class Unfoldable1)\n\n-- | A strict double-ended queue (dequeue) representated using a pair of lists.\ndata CatQueue a = CatQueue (List a) (List a)\n\n-- | Create an empty queue.\n-- |\n-- | Running time: `O(1)`\nempty :: forall a. CatQueue a\nempty = CatQueue Nil Nil\n\n-- | Test whether a queue is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. CatQueue a -> Boolean\nnull (CatQueue Nil Nil) = true\nnull _ = false\n\n-- | Create a queue containing a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> CatQueue a\nsingleton = snoc empty\n\n-- | Number of elements in queue.\n-- |\n-- | Running time: `O(n)` in length of queue.\nlength :: forall a. CatQueue a -> Int\nlength (CatQueue l r) = L.length l + L.length r\n\n-- | Append an element to the beginning of the queue, creating a new queue.\n-- |\n-- | Running time: `O(1)`\ncons :: forall a. a -> CatQueue a -> CatQueue a\ncons a (CatQueue l r) = CatQueue (Cons a l) r\n\n-- | Append an element to the end of the queue, creating a new queue.\n-- |\n-- | Running time: `O(1)`\nsnoc :: forall a. CatQueue a -> a -> CatQueue a\nsnoc (CatQueue l r) a = CatQueue l (Cons a r)\n\n-- | Decompose a queue into a `Tuple` of the first element and the rest of the queue.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nuncons :: forall a. CatQueue a -> Maybe (Tuple a (CatQueue a))\nuncons (CatQueue Nil Nil) = Nothing\nuncons (CatQueue Nil r) = uncons (CatQueue (reverse r) Nil)\nuncons (CatQueue (Cons a as) r) = Just (Tuple a (CatQueue as r))\n\n-- | Decompose a queue into a `Tuple` of the last element and the rest of the queue.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nunsnoc :: forall a. CatQueue a -> Maybe (Tuple a (CatQueue a))\nunsnoc (CatQueue l (Cons a as)) = Just (Tuple a (CatQueue l as))\nunsnoc (CatQueue Nil Nil) = Nothing\nunsnoc (CatQueue l Nil) = unsnoc (CatQueue Nil (reverse l))\n\n-- | Convert any `Foldable` into a `CatQueue`.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f a. Foldable f => f a -> CatQueue a\nfromFoldable f = foldMap singleton f\n\ncqEq :: forall a. Eq a => CatQueue a -> CatQueue a -> Boolean\ncqEq = go\n  where\n    elemEq = eq :: (a -> a -> Boolean)\n    go xs ys = case uncons xs, uncons ys of\n      Just (Tuple x xs'), Just (Tuple y ys')\n        | x `elemEq` y -> go xs' ys'\n      Nothing, Nothing -> true\n      _      , _       -> false\n\ncqCompare :: forall a. Ord a => CatQueue a -> CatQueue a -> Ordering\ncqCompare = go\n  where\n    elemCompare = compare :: (a -> a -> Ordering)\n    go xs ys = case uncons xs, uncons ys of\n      Just (Tuple x xs'), Just (Tuple y ys') ->\n        case elemCompare x y of\n             EQ       -> go xs' ys'\n             ordering -> ordering\n      Just _,   Nothing -> GT\n      Nothing,  Just _  -> LT\n      Nothing,  Nothing -> EQ\n\ninstance eqCatQueue :: Eq a => Eq (CatQueue a) where\n  eq = cqEq\n\ninstance ordCatQueue :: Ord a => Ord (CatQueue a) where\n  compare = cqCompare\n\n-- | Running time: `O(n) in the length of the second queue`\ninstance semigroupCatQueue :: Semigroup (CatQueue a) where\n  append = foldl snoc\n\ninstance monoidCatQueue :: Monoid (CatQueue a) where\n  mempty = empty\n\ninstance showCatQueue :: Show a => Show (CatQueue a) where\n  show (CatQueue l r) = \"(CatQueue \" <> show l <> \" \" <> show r <> \")\"\n\ninstance foldableCatQueue :: Foldable CatQueue where\n  foldMap = foldMapDefaultL\n  foldr f = foldrDefault f\n  foldl f = go\n    where\n    go acc q = case uncons q of\n       Just (Tuple x xs) -> go (f acc x) xs\n       Nothing -> acc\n\ninstance unfoldable1CatQueue :: Unfoldable1 CatQueue where\n  unfoldr1 f b = go b empty\n    where\n      go source memo = case f source of\n        Tuple one Nothing -> snoc memo one\n        Tuple one (Just rest) -> go rest (snoc memo one)\n\ninstance unfoldableCatQueue :: Unfoldable CatQueue where\n  unfoldr f b = go b empty\n    where\n      go source memo = case f source of\n        Nothing -> memo\n        Just (Tuple one rest) -> go rest (snoc memo one)\n\ninstance traversableCatQueue :: Traversable CatQueue where\n  traverse f =\n    map (foldl snoc empty)\n    <<< foldl (\\acc -> lift2 snoc acc <<< f) (pure empty)\n  sequence = sequenceDefault\n\ninstance functorCatQueue :: Functor CatQueue where\n  map f (CatQueue l r) = CatQueue (map f l) (map f r)\n\ninstance applyCatQueue :: Apply CatQueue where\n  apply = ap\n\ninstance applicativeCatQueue :: Applicative CatQueue where\n  pure = singleton\n\ninstance bindCatQueue :: Bind CatQueue where\n  bind = flip foldMap\n\ninstance monadCatQueue :: Monad CatQueue\n\ninstance altCatQueue :: Alt CatQueue where\n  alt = append\n\ninstance plusCatQueue :: Plus CatQueue where\n  empty = empty\n\ninstance alternativeCatQueue :: Alternative CatQueue\n\ninstance monadPlusCatQueue :: MonadPlus CatQueue\n","-- | This module defines a strict catenable list.\n-- |\n-- | The implementation is based on a queue where all operations require\n-- | `O(1)` amortized time.\n-- |\n-- | However, any single `uncons` operation may run in `O(n)` time.\n-- |\n-- | See [Purely Functional Data Structures](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf) (Okasaki 1996)\nmodule Data.CatList\n  ( CatList(..)\n  , empty\n  , null\n  , singleton\n  , length\n  , append\n  , cons\n  , snoc\n  , uncons\n  , fromFoldable\n  ) where\n\nimport Prelude hiding (append)\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.CatQueue as Q\nimport Data.Foldable (class Foldable, foldMapDefaultL)\nimport Data.Foldable as Foldable\nimport Data.List as L\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (sequence, traverse, class Traversable)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | A strict catenable list.\n-- |\n-- | `CatList` may be empty, represented by `CatNil`.\n-- |\n-- | `CatList` may be non-empty, represented by `CatCons`. The `CatCons`\n-- | data constructor takes the first element of the list and a queue of\n-- | `CatList`.\ndata CatList a = CatNil | CatCons a (Q.CatQueue (CatList a))\n\n-- | Create an empty catenable list.\n-- |\n-- | Running time: `O(1)`\nempty :: forall a. CatList a\nempty = CatNil\n\n-- | Test whether a catenable list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. CatList a -> Boolean\nnull CatNil = true\nnull _ = false\n\n-- | Number of elements in queue.\n-- |\n-- | Running time: `O(n)` in length of queue.\nlength :: forall a. CatList a -> Int\nlength = Foldable.length\n\n-- | Append all elements of a catenable list to the end of another\n-- | catenable list, create a new catenable list.\n-- |\n-- | Running time: `O(1)`\nappend :: forall a. CatList a -> CatList a -> CatList a\nappend = link\n\n-- | Append an element to the beginning of the catenable list, creating a new\n-- | catenable list.\n-- |\n-- | Running time: `O(1)`\ncons :: forall a. a -> CatList a -> CatList a\ncons a cat = append (CatCons a Q.empty) cat\n\n-- | Create a catenable list with a single item.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> CatList a\nsingleton a = cons a CatNil\n\n-- | Append an element to the end of the catenable list, creating a new\n-- | catenable list.\n-- |\n-- | Running time: `O(1)`\nsnoc :: forall a. CatList a -> a -> CatList a\nsnoc cat a = append cat (CatCons a Q.empty)\n\n-- | Decompose a catenable list into a `Tuple` of the first element and\n-- | the rest of the catenable list.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nuncons :: forall a. CatList a -> Maybe (Tuple a (CatList a))\nuncons CatNil = Nothing\nuncons (CatCons a q) = Just (Tuple a (if Q.null q then CatNil else (foldr link CatNil q)))\n\n-- | Links two catenable lists by making appending the queue in the\n-- | first catenable list to the second catenable list. This operation\n-- | creates a new catenable list.\n-- |\n-- | Running time: `O(1)`\nlink :: forall a. CatList a -> CatList a -> CatList a\nlink CatNil cat = cat\nlink cat CatNil = cat\nlink (CatCons a q) cat = CatCons a (Q.snoc q cat)\n\n-- | Tail recursive version of foldr on `CatList`.\n-- |\n-- | Ensures foldl on `List` is tail-recursive.\nfoldr :: forall a. (CatList a -> CatList a -> CatList a) -> CatList a -> Q.CatQueue (CatList a) -> CatList a\nfoldr k b q = go q L.Nil\n  where\n  go :: Q.CatQueue (CatList a) -> L.List (CatList a -> CatList a) -> CatList a\n  go xs ys = case Q.uncons xs of\n                  Nothing -> foldl (\\x i -> i x) b ys\n                  Just (Tuple a rest) -> go rest (L.Cons (k a) ys)\n\n  foldl :: forall b c. (c -> b -> c) -> c -> L.List b -> c\n  foldl _ c L.Nil = c\n  foldl k' c (L.Cons b' as) = foldl k' (k' c b') as\n\n-- | Convert any `Foldable` into a `CatList`.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> CatList\nfromFoldable f = Foldable.foldMap singleton f\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> CatList a -> m\nfoldMap _ CatNil = mempty\nfoldMap f (CatCons a q) =\n  let d = if Q.null q then CatNil else (foldr link CatNil q)\n  in f a <> foldMap f d\n\n-- | Running time: `O(1)`\ninstance semigroupCatList :: Semigroup (CatList a) where\n  append = append\n\ninstance monoidCatList :: Monoid (CatList a) where\n  mempty = CatNil\n\ninstance showCatList :: Show a => Show (CatList a) where\n  show CatNil = \"CatNil\"\n  show (CatCons a as) = \"(CatList \" <> show a <> \" \" <> show as <> \")\"\n\ninstance foldableCatList :: Foldable CatList where\n  foldMap = foldMapDefaultL\n  foldr f s l = Foldable.foldrDefault f s l\n  foldl f = go\n    where\n    go acc q = case uncons q of\n       Just (Tuple x xs) -> go (f acc x) xs\n       Nothing -> acc\n\ninstance unfoldableCatList :: Unfoldable CatList where\n  unfoldr f b = go b CatNil\n    where\n      go source memo = case f source of\n        Nothing -> memo\n        Just (Tuple one rest) -> go rest (snoc memo one)\n\ninstance unfoldable1CatList :: Unfoldable1 CatList where\n  unfoldr1 f b = go b CatNil\n    where\n      go source memo = case f source of\n        Tuple one Nothing -> snoc memo one\n        Tuple one (Just rest) -> go rest (snoc memo one)\n\ninstance traversableCatList :: Traversable CatList where\n  traverse _ CatNil = pure CatNil\n  traverse f (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in cons <$> f a <*> traverse f d\n  sequence CatNil = pure CatNil\n  sequence (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in cons <$> a <*> sequence d\n\ninstance functorCatList :: Functor CatList where\n  map _ CatNil = CatNil\n  map f (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in f a `cons` map f d\n\ninstance applyCatList :: Apply CatList where\n  apply = ap\n\ninstance applicativeCatList :: Applicative CatList where\n  pure = singleton\n\ninstance bindCatList :: Bind CatList where\n  bind = flip foldMap\n\ninstance monadCatList :: Monad CatList\n\ninstance altCatList :: Alt CatList where\n  alt = append\n\ninstance plusCatList :: Plus CatList where\n  empty = empty\n\ninstance alternativeCatList :: Alternative CatList\n\ninstance monadPlusCatList :: MonadPlus CatList\n","module Control.Monad.Free\n  ( Free\n  , suspendF\n  , wrap\n  , liftF\n  , hoistFree\n  , foldFree\n  , substFree\n  , runFree\n  , runFreeM\n  , resume\n  , resume'\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM)\nimport Control.Monad.Trans.Class (class MonadTrans)\n\nimport Data.CatList (CatList, empty, snoc, uncons)\nimport Data.Either (Either(..))\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.Maybe (Maybe(..))\nimport Data.Ord (class Ord1, compare1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.Tuple (Tuple(..))\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The free monad for a type constructor `f`.\n-- |\n-- | Implemented in the spirit of [Reflection without Remorse](http://okmij.org/ftp/Haskell/zseq.pdf),\n-- | the free monad is represented using a sequential data structure in\n-- | order to overcome the quadratic complexity of left-associated binds\n-- | and traversal through the free monad structure.\ndata Free f a = Free (FreeView f Val Val) (CatList (ExpF f))\n\nnewtype ExpF f = ExpF (Val -> Free f Val)\n\ndata FreeView f a b = Return a | Bind (f b) (b -> Free f a)\n\ndata Val\n\ninstance eqFree :: (Functor f, Eq1 f, Eq a) => Eq (Free f a) where\n  eq x y = case resume x, resume y of\n    Left fa, Left fb -> eq1 fa fb\n    Right a, Right b -> a == b\n    _, _ -> false\n\ninstance eq1Free :: (Functor f, Eq1 f) => Eq1 (Free f) where\n  eq1 = eq\n\ninstance ordFree :: (Functor f, Ord1 f, Ord a) => Ord (Free f a) where\n  compare x y = case resume x, resume y of\n    Left fa, Left fb -> compare1 fa fb\n    Left _, _ -> LT\n    _, Left _ -> GT\n    Right a, Right b -> compare a b\n\ninstance ord1Free :: (Functor f, Ord1 f) => Ord1 (Free f) where\n  compare1 = compare\n\ninstance freeFunctor :: Functor (Free f) where\n  map k f = pure <<< k =<< f\n\ninstance freeBind :: Bind (Free f) where\n  bind (Free v s) k = Free v (snoc s (ExpF (unsafeCoerceBind k)))\n    where\n    unsafeCoerceBind :: forall a b. (a -> Free f b) -> Val -> Free f Val\n    unsafeCoerceBind = unsafeCoerce\n\ninstance freeApplicative :: Applicative (Free f) where\n  pure = fromView <<< Return\n\ninstance freeApply :: Apply (Free f) where\n  apply = ap\n\ninstance freeMonad :: Monad (Free f)\n\ninstance freeMonadTrans :: MonadTrans Free where\n  lift = liftF\n\ninstance freeMonadRec :: MonadRec (Free f) where\n  tailRecM k a = k a >>= case _ of\n    Loop b -> tailRecM k b\n    Done r -> pure r\n\ninstance foldableFree :: (Functor f, Foldable f) => Foldable (Free f) where\n  foldMap f = go\n    where\n    go = resume >>> case _ of\n      Left fa -> foldMap go fa\n      Right a -> f a\n  foldl f = go\n    where\n    go r = resume >>> case _  of\n      Left fa -> foldl go r fa\n      Right a -> f r a\n  foldr f = go\n    where\n    go r = resume >>> case _ of\n      Left fa -> foldr (flip go) r fa\n      Right a -> f a r\n\ninstance traversableFree :: Traversable f => Traversable (Free f) where\n  traverse f = go\n    where\n    go = resume >>> case _ of\n      Left fa -> join <<< liftF <$> traverse go fa\n      Right a -> pure <$> f a\n  sequence tma = traverse identity tma\n\ninstance semigroupFree :: Semigroup a => Semigroup (Free f a) where\n  append = lift2 append\n\ninstance monoidFree :: Monoid a => Monoid (Free f a) where\n  mempty = pure mempty\n  \n-- | Lift an impure value described by the generating type constructor `f` into\n-- | the free monad.\nliftF :: forall f. f ~> Free f\nliftF f = fromView (Bind (unsafeCoerceF f) (pure <<< unsafeCoerceVal))\n  where\n  unsafeCoerceF :: forall a. f a -> f Val\n  unsafeCoerceF = unsafeCoerce\n\n  unsafeCoerceVal :: forall a. Val -> a\n  unsafeCoerceVal = unsafeCoerce\n\n-- | Add a layer.\nwrap :: forall f a. f (Free f a) -> Free f a\nwrap f = fromView (Bind (unsafeCoerceF f) unsafeCoerceVal)\n  where\n  unsafeCoerceF :: forall b. f (Free f b) -> f Val\n  unsafeCoerceF = unsafeCoerce\n\n  unsafeCoerceVal :: forall b. Val -> Free f b\n  unsafeCoerceVal = unsafeCoerce\n\n-- | Suspend a value given the applicative functor `f` into the free monad.\nsuspendF :: forall f. Applicative f => Free f ~> Free f\nsuspendF f = wrap (pure f)\n\n-- | Use a natural transformation to change the generating type constructor of a\n-- | free monad.\nhoistFree :: forall f g. (f ~> g) -> Free f ~> Free g\nhoistFree k = substFree (liftF <<< k)\n\n-- | Run a free monad with a natural transformation from the type constructor `f`\n-- | to the tail-recursive monad `m`. See the `MonadRec` type class for more\n-- | details.\nfoldFree :: forall f m. MonadRec m => (f ~> m) -> Free f ~> m\nfoldFree k = tailRecM go\n  where\n  go :: forall a. Free f a -> m (Step (Free f a) a)\n  go f = case toView f of\n    Return a -> Done <$> pure a\n    Bind g i -> (Loop <<< i) <$> k g\n\n-- | Like `foldFree`, but for folding into some other Free monad without the\n-- | overhead that `MonadRec` incurs.\nsubstFree :: forall f g. (f ~> Free g) -> Free f ~> Free g\nsubstFree k = go\n  where\n  go :: Free f ~> Free g\n  go f = case toView f of\n    Return a -> pure a\n    Bind g i -> k g >>= go <$> i\n\n-- | Run a free monad with a function that unwraps a single layer of the functor\n-- | `f` at a time.\nrunFree :: forall f a. Functor f => (f (Free f a) -> Free f a) -> Free f a -> a\nrunFree k = go\n  where\n  go :: Free f a -> a\n  go f = case toView f of\n    Return a -> a\n    Bind g i -> go (k (i <$> g))\n\n-- | Run a free monad with a function mapping a functor `f` to a tail-recursive\n-- | monad `m`. See the `MonadRec` type class for more details.\nrunFreeM\n  :: forall f m a\n   . Functor f\n  => MonadRec m\n  => (f (Free f a) -> m (Free f a))\n  -> Free f a\n  -> m a\nrunFreeM k = tailRecM go\n  where\n  go :: Free f a -> m (Step (Free f a) a)\n  go f = case toView f of\n    Return a -> Done <$> pure a\n    Bind g i -> Loop <$> k (i <$> g)\n\n-- | Unwraps a single layer of the functor `f`.\nresume\n  :: forall f a\n   . Functor f\n  => Free f a\n  -> Either (f (Free f a)) a\nresume = resume' (\\g i -> Left (i <$> g)) Right\n\n-- | Unwraps a single layer of `f`, providing the continuation.\nresume'\n  :: forall f a r\n   . (forall b. f b -> (b -> Free f a) -> r)\n  -> (a -> r)\n  -> Free f a\n  -> r\nresume' k j f = case toView f of\n  Return a -> j a\n  Bind g i -> k g i\n\nfromView :: forall f a. FreeView f a Val -> Free f a\nfromView f = Free (unsafeCoerceFreeView f) empty\n  where\n  unsafeCoerceFreeView :: FreeView f a Val -> FreeView f Val Val\n  unsafeCoerceFreeView = unsafeCoerce\n\ntoView :: forall f a. Free f a -> FreeView f a Val\ntoView (Free v s) =\n  case v of\n    Return a ->\n      case uncons s of\n        Nothing ->\n          Return (unsafeCoerceVal a)\n        Just (Tuple h t) ->\n          toView (unsafeCoerceFree (concatF ((runExpF h) a) t))\n    Bind f k ->\n      Bind f (\\a -> unsafeCoerceFree (concatF (k a) s))\n  where\n  concatF :: Free f Val -> CatList (ExpF f) -> Free f Val\n  concatF (Free v' l) r = Free v' (l <> r)\n\n  runExpF :: ExpF f -> (Val -> Free f Val)\n  runExpF (ExpF k) = k\n\n  unsafeCoerceFree :: Free f Val -> Free f a\n  unsafeCoerceFree = unsafeCoerce\n\n  unsafeCoerceVal :: Val -> a\n  unsafeCoerceVal = unsafeCoerce\n","/* globals setImmediate, clearImmediate, setTimeout, clearTimeout */\n/* eslint-disable no-unused-vars, no-prototype-builtins, no-use-before-define, no-unused-labels, no-param-reassign */\nvar Aff = function () {\n  // A unique value for empty.\n  var EMPTY = {};\n\n  /*\n\n  An awkward approximation. We elide evidence we would otherwise need in PS for\n  efficiency sake.\n\n  data Aff eff a\n    = Pure a\n    | Throw Error\n    | Catch (Aff eff a) (Error -> Aff eff a)\n    | Sync (Eff eff a)\n    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))\n    | forall b. Bind (Aff eff b) (b -> Aff eff a)\n    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)\n    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)\n    | Sequential (ParAff aff a)\n\n  */\n  var PURE    = \"Pure\";\n  var THROW   = \"Throw\";\n  var CATCH   = \"Catch\";\n  var SYNC    = \"Sync\";\n  var ASYNC   = \"Async\";\n  var BIND    = \"Bind\";\n  var BRACKET = \"Bracket\";\n  var FORK    = \"Fork\";\n  var SEQ     = \"Sequential\";\n\n  /*\n\n  data ParAff eff a\n    = forall b. Map (b -> a) (ParAff eff b)\n    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)\n    | Alt (ParAff eff a) (ParAff eff a)\n    | ?Par (Aff eff a)\n\n  */\n  var MAP   = \"Map\";\n  var APPLY = \"Apply\";\n  var ALT   = \"Alt\";\n\n  // Various constructors used in interpretation\n  var CONS      = \"Cons\";      // Cons-list, for stacks\n  var RESUME    = \"Resume\";    // Continue indiscriminately\n  var RELEASE   = \"Release\";   // Continue with bracket finalizers\n  var FINALIZER = \"Finalizer\"; // A non-interruptible effect\n  var FINALIZED = \"Finalized\"; // Marker for finalization\n  var FORKED    = \"Forked\";    // Reference to a forked fiber, with resumption stack\n  var FIBER     = \"Fiber\";     // Actual fiber reference\n  var THUNK     = \"Thunk\";     // Primed effect, ready to invoke\n\n  function Aff(tag, _1, _2, _3) {\n    this.tag = tag;\n    this._1  = _1;\n    this._2  = _2;\n    this._3  = _3;\n  }\n\n  function AffCtr(tag) {\n    var fn = function (_1, _2, _3) {\n      return new Aff(tag, _1, _2, _3);\n    };\n    fn.tag = tag;\n    return fn;\n  }\n\n  function nonCanceler(error) {\n    return new Aff(PURE, void 0);\n  }\n\n  function runEff(eff) {\n    try {\n      eff();\n    } catch (error) {\n      setTimeout(function () {\n        throw error;\n      }, 0);\n    }\n  }\n\n  function runSync(left, right, eff) {\n    try {\n      return right(eff());\n    } catch (error) {\n      return left(error);\n    }\n  }\n\n  function runAsync(left, eff, k) {\n    try {\n      return eff(k)();\n    } catch (error) {\n      k(left(error))();\n      return nonCanceler;\n    }\n  }\n\n  var Scheduler = function () {\n    var limit    = 1024;\n    var size     = 0;\n    var ix       = 0;\n    var queue    = new Array(limit);\n    var draining = false;\n\n    function drain() {\n      var thunk;\n      draining = true;\n      while (size !== 0) {\n        size--;\n        thunk     = queue[ix];\n        queue[ix] = void 0;\n        ix        = (ix + 1) % limit;\n        thunk();\n      }\n      draining = false;\n    }\n\n    return {\n      isDraining: function () {\n        return draining;\n      },\n      enqueue: function (cb) {\n        var i, tmp;\n        if (size === limit) {\n          tmp = draining;\n          drain();\n          draining = tmp;\n        }\n\n        queue[(ix + size) % limit] = cb;\n        size++;\n\n        if (!draining) {\n          drain();\n        }\n      }\n    };\n  }();\n\n  function Supervisor(util) {\n    var fibers  = {};\n    var fiberId = 0;\n    var count   = 0;\n\n    return {\n      register: function (fiber) {\n        var fid = fiberId++;\n        fiber.onComplete({\n          rethrow: true,\n          handler: function (result) {\n            return function () {\n              count--;\n              delete fibers[fid];\n            };\n          }\n        })();\n        fibers[fid] = fiber;\n        count++;\n      },\n      isEmpty: function () {\n        return count === 0;\n      },\n      killAll: function (killError, cb) {\n        return function () {\n          if (count === 0) {\n            return cb();\n          }\n\n          var killCount = 0;\n          var kills     = {};\n\n          function kill(fid) {\n            kills[fid] = fibers[fid].kill(killError, function (result) {\n              return function () {\n                delete kills[fid];\n                killCount--;\n                if (util.isLeft(result) && util.fromLeft(result)) {\n                  setTimeout(function () {\n                    throw util.fromLeft(result);\n                  }, 0);\n                }\n                if (killCount === 0) {\n                  cb();\n                }\n              };\n            })();\n          }\n\n          for (var k in fibers) {\n            if (fibers.hasOwnProperty(k)) {\n              killCount++;\n              kill(k);\n            }\n          }\n\n          fibers  = {};\n          fiberId = 0;\n          count   = 0;\n\n          return function (error) {\n            return new Aff(SYNC, function () {\n              for (var k in kills) {\n                if (kills.hasOwnProperty(k)) {\n                  kills[k]();\n                }\n              }\n            });\n          };\n        };\n      }\n    };\n  }\n\n  // Fiber state machine\n  var SUSPENDED   = 0; // Suspended, pending a join.\n  var CONTINUE    = 1; // Interpret the next instruction.\n  var STEP_BIND   = 2; // Apply the next bind.\n  var STEP_RESULT = 3; // Handle potential failure from a result.\n  var PENDING     = 4; // An async effect is running.\n  var RETURN      = 5; // The current stack has returned.\n  var COMPLETED   = 6; // The entire fiber has completed.\n\n  function Fiber(util, supervisor, aff) {\n    // Monotonically increasing tick, increased on each asynchronous turn.\n    var runTick = 0;\n\n    // The current branch of the state machine.\n    var status = SUSPENDED;\n\n    // The current point of interest for the state machine branch.\n    var step      = aff;  // Successful step\n    var fail      = null; // Failure step\n    var interrupt = null; // Asynchronous interrupt\n\n    // Stack of continuations for the current fiber.\n    var bhead = null;\n    var btail = null;\n\n    // Stack of attempts and finalizers for error recovery. Every `Cons` is also\n    // tagged with current `interrupt` state. We use this to track which items\n    // should be ignored or evaluated as a result of a kill.\n    var attempts = null;\n\n    // A special state is needed for Bracket, because it cannot be killed. When\n    // we enter a bracket acquisition or finalizer, we increment the counter,\n    // and then decrement once complete.\n    var bracketCount = 0;\n\n    // Each join gets a new id so they can be revoked.\n    var joinId  = 0;\n    var joins   = null;\n    var rethrow = true;\n\n    // Each invocation of `run` requires a tick. When an asynchronous effect is\n    // resolved, we must check that the local tick coincides with the fiber\n    // tick before resuming. This prevents multiple async continuations from\n    // accidentally resuming the same fiber. A common example may be invoking\n    // the provided callback in `makeAff` more than once, but it may also be an\n    // async effect resuming after the fiber was already cancelled.\n    function run(localRunTick) {\n      var tmp, result, attempt;\n      while (true) {\n        tmp       = null;\n        result    = null;\n        attempt   = null;\n\n        switch (status) {\n        case STEP_BIND:\n          status = CONTINUE;\n          try {\n            step   = bhead(step);\n            if (btail === null) {\n              bhead = null;\n            } else {\n              bhead = btail._1;\n              btail = btail._2;\n            }\n          } catch (e) {\n            status = RETURN;\n            fail   = util.left(e);\n            step   = null;\n          }\n          break;\n\n        case STEP_RESULT:\n          if (util.isLeft(step)) {\n            status = RETURN;\n            fail   = step;\n            step   = null;\n          } else if (bhead === null) {\n            status = RETURN;\n          } else {\n            status = STEP_BIND;\n            step   = util.fromRight(step);\n          }\n          break;\n\n        case CONTINUE:\n          switch (step.tag) {\n          case BIND:\n            if (bhead) {\n              btail = new Aff(CONS, bhead, btail);\n            }\n            bhead  = step._2;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case PURE:\n            if (bhead === null) {\n              status = RETURN;\n              step   = util.right(step._1);\n            } else {\n              status = STEP_BIND;\n              step   = step._1;\n            }\n            break;\n\n          case SYNC:\n            status = STEP_RESULT;\n            step   = runSync(util.left, util.right, step._1);\n            break;\n\n          case ASYNC:\n            status = PENDING;\n            step   = runAsync(util.left, step._1, function (result) {\n              return function () {\n                if (runTick !== localRunTick) {\n                  return;\n                }\n                runTick++;\n                Scheduler.enqueue(function () {\n                  // It's possible to interrupt the fiber between enqueuing and\n                  // resuming, so we need to check that the runTick is still\n                  // valid.\n                  if (runTick !== localRunTick + 1) {\n                    return;\n                  }\n                  status = STEP_RESULT;\n                  step   = result;\n                  run(runTick);\n                });\n              };\n            });\n            return;\n\n          case THROW:\n            status = RETURN;\n            fail   = util.left(step._1);\n            step   = null;\n            break;\n\n          // Enqueue the Catch so that we can call the error handler later on\n          // in case of an exception.\n          case CATCH:\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead    = null;\n            btail    = null;\n            status   = CONTINUE;\n            step     = step._1;\n            break;\n\n          // Enqueue the Bracket so that we can call the appropriate handlers\n          // after resource acquisition.\n          case BRACKET:\n            bracketCount++;\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead  = null;\n            btail  = null;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case FORK:\n            status = STEP_RESULT;\n            tmp    = Fiber(util, supervisor, step._2);\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n            if (step._1) {\n              tmp.run();\n            }\n            step = util.right(tmp);\n            break;\n\n          case SEQ:\n            status = CONTINUE;\n            step   = sequential(util, supervisor, step._1);\n            break;\n          }\n          break;\n\n        case RETURN:\n          bhead = null;\n          btail = null;\n          // If the current stack has returned, and we have no other stacks to\n          // resume or finalizers to run, the fiber has halted and we can\n          // invoke all join callbacks. Otherwise we need to resume.\n          if (attempts === null) {\n            status = COMPLETED;\n            step   = interrupt || fail || step;\n          } else {\n            // The interrupt status for the enqueued item.\n            tmp      = attempts._3;\n            attempt  = attempts._1;\n            attempts = attempts._2;\n\n            switch (attempt.tag) {\n            // We cannot recover from an unmasked interrupt. Otherwise we should\n            // continue stepping, or run the exception handler if an exception\n            // was raised.\n            case CATCH:\n              // We should compare the interrupt status as well because we\n              // only want it to apply if there has been an interrupt since\n              // enqueuing the catch.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                status = RETURN;\n              } else if (fail) {\n                status = CONTINUE;\n                step   = attempt._2(util.fromLeft(fail));\n                fail   = null;\n              }\n              break;\n\n            // We cannot resume from an unmasked interrupt or exception.\n            case RESUME:\n              // As with Catch, we only want to ignore in the case of an\n              // interrupt since enqueing the item.\n              if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {\n                status = RETURN;\n              } else {\n                bhead  = attempt._1;\n                btail  = attempt._2;\n                status = STEP_BIND;\n                step   = util.fromRight(step);\n              }\n              break;\n\n            // If we have a bracket, we should enqueue the handlers,\n            // and continue with the success branch only if the fiber has\n            // not been interrupted. If the bracket acquisition failed, we\n            // should not run either.\n            case BRACKET:\n              bracketCount--;\n              if (fail === null) {\n                result   = util.fromRight(step);\n                // We need to enqueue the Release with the same interrupt\n                // status as the Bracket that is initiating it.\n                attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp);\n                // We should only coninue as long as the interrupt status has not changed or\n                // we are currently within a non-interruptable finalizer.\n                if (interrupt === tmp || bracketCount > 0) {\n                  status = CONTINUE;\n                  step   = attempt._3(result);\n                }\n              }\n              break;\n\n            // Enqueue the appropriate handler. We increase the bracket count\n            // because it should not be cancelled.\n            case RELEASE:\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              // It has only been killed if the interrupt status has changed\n              // since we enqueued the item, and the bracket count is 0. If the\n              // bracket count is non-zero then we are in a masked state so it's\n              // impossible to be killed.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);\n              } else if (fail) {\n                step = attempt._1.failed(util.fromLeft(fail))(attempt._2);\n              } else {\n                step = attempt._1.completed(util.fromRight(step))(attempt._2);\n              }\n              fail = null;\n              bracketCount++;\n              break;\n\n            case FINALIZER:\n              bracketCount++;\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              step     = attempt._1;\n              break;\n\n            case FINALIZED:\n              bracketCount--;\n              status = RETURN;\n              step   = attempt._1;\n              fail   = attempt._2;\n              break;\n            }\n          }\n          break;\n\n        case COMPLETED:\n          for (var k in joins) {\n            if (joins.hasOwnProperty(k)) {\n              rethrow = rethrow && joins[k].rethrow;\n              runEff(joins[k].handler(step));\n            }\n          }\n          joins = null;\n          // If we have an interrupt and a fail, then the thread threw while\n          // running finalizers. This should always rethrow in a fresh stack.\n          if (interrupt && fail) {\n            setTimeout(function () {\n              throw util.fromLeft(fail);\n            }, 0);\n          // If we have an unhandled exception, and no other fiber has joined\n          // then we need to throw the exception in a fresh stack.\n          } else if (util.isLeft(step) && rethrow) {\n            setTimeout(function () {\n              // Guard on reathrow because a completely synchronous fiber can\n              // still have an observer which was added after-the-fact.\n              if (rethrow) {\n                throw util.fromLeft(step);\n              }\n            }, 0);\n          }\n          return;\n        case SUSPENDED:\n          status = CONTINUE;\n          break;\n        case PENDING: return;\n        }\n      }\n    }\n\n    function onComplete(join) {\n      return function () {\n        if (status === COMPLETED) {\n          rethrow = rethrow && join.rethrow;\n          join.handler(step)();\n          return function () {};\n        }\n\n        var jid    = joinId++;\n        joins      = joins || {};\n        joins[jid] = join;\n\n        return function() {\n          if (joins !== null) {\n            delete joins[jid];\n          }\n        };\n      };\n    }\n\n    function kill(error, cb) {\n      return function () {\n        if (status === COMPLETED) {\n          cb(util.right(void 0))();\n          return function () {};\n        }\n\n        var canceler = onComplete({\n          rethrow: false,\n          handler: function (/* unused */) {\n            return cb(util.right(void 0));\n          }\n        })();\n\n        switch (status) {\n        case SUSPENDED:\n          interrupt = util.left(error);\n          status    = COMPLETED;\n          step      = interrupt;\n          run(runTick);\n          break;\n        case PENDING:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            if (status === PENDING) {\n              attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);\n            }\n            status   = RETURN;\n            step     = null;\n            fail     = null;\n            run(++runTick);\n          }\n          break;\n        default:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            status = RETURN;\n            step   = null;\n            fail   = null;\n          }\n        }\n\n        return canceler;\n      };\n    }\n\n    function join(cb) {\n      return function () {\n        var canceler = onComplete({\n          rethrow: false,\n          handler: cb\n        })();\n        if (status === SUSPENDED) {\n          run(runTick);\n        }\n        return canceler;\n      };\n    }\n\n    return {\n      kill: kill,\n      join: join,\n      onComplete: onComplete,\n      isSuspended: function () {\n        return status === SUSPENDED;\n      },\n      run: function () {\n        if (status === SUSPENDED) {\n          if (!Scheduler.isDraining()) {\n            Scheduler.enqueue(function () {\n              run(runTick);\n            });\n          } else {\n            run(runTick);\n          }\n        }\n      }\n    };\n  }\n\n  function runPar(util, supervisor, par, cb) {\n    // Table of all forked fibers.\n    var fiberId   = 0;\n    var fibers    = {};\n\n    // Table of currently running cancelers, as a product of `Alt` behavior.\n    var killId    = 0;\n    var kills     = {};\n\n    // Error used for early cancelation on Alt branches.\n    var early     = new Error(\"[ParAff] Early exit\");\n\n    // Error used to kill the entire tree.\n    var interrupt = null;\n\n    // The root pointer of the tree.\n    var root      = EMPTY;\n\n    // Walks a tree, invoking all the cancelers. Returns the table of pending\n    // cancellation fibers.\n    function kill(error, par, cb) {\n      var step  = par;\n      var head  = null;\n      var tail  = null;\n      var count = 0;\n      var kills = {};\n      var tmp, kid;\n\n      loop: while (true) {\n        tmp = null;\n\n        switch (step.tag) {\n        case FORKED:\n          if (step._3 === EMPTY) {\n            tmp = fibers[step._1];\n            kills[count++] = tmp.kill(error, function (result) {\n              return function () {\n                count--;\n                if (count === 0) {\n                  cb(result)();\n                }\n              };\n            });\n          }\n          // Terminal case.\n          if (head === null) {\n            break loop;\n          }\n          // Go down the right side of the tree.\n          step = head._2;\n          if (tail === null) {\n            head = null;\n          } else {\n            head = tail._1;\n            tail = tail._2;\n          }\n          break;\n        case MAP:\n          step = step._2;\n          break;\n        case APPLY:\n        case ALT:\n          if (head) {\n            tail = new Aff(CONS, head, tail);\n          }\n          head = step;\n          step = step._1;\n          break;\n        }\n      }\n\n      if (count === 0) {\n        cb(util.right(void 0))();\n      } else {\n        // Run the cancelation effects. We alias `count` because it's mutable.\n        kid = 0;\n        tmp = count;\n        for (; kid < tmp; kid++) {\n          kills[kid] = kills[kid]();\n        }\n      }\n\n      return kills;\n    }\n\n    // When a fiber resolves, we need to bubble back up the tree with the\n    // result, computing the applicative nodes.\n    function join(result, head, tail) {\n      var fail, step, lhs, rhs, tmp, kid;\n\n      if (util.isLeft(result)) {\n        fail = result;\n        step = null;\n      } else {\n        step = result;\n        fail = null;\n      }\n\n      loop: while (true) {\n        lhs = null;\n        rhs = null;\n        tmp = null;\n        kid = null;\n\n        // We should never continue if the entire tree has been interrupted.\n        if (interrupt !== null) {\n          return;\n        }\n\n        // We've made it all the way to the root of the tree, which means\n        // the tree has fully evaluated.\n        if (head === null) {\n          cb(fail || step)();\n          return;\n        }\n\n        // The tree has already been computed, so we shouldn't try to do it\n        // again. This should never happen.\n        // TODO: Remove this?\n        if (head._3 !== EMPTY) {\n          return;\n        }\n\n        switch (head.tag) {\n        case MAP:\n          if (fail === null) {\n            head._3 = util.right(head._1(util.fromRight(step)));\n            step    = head._3;\n          } else {\n            head._3 = fail;\n          }\n          break;\n        case APPLY:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // If we have a failure we should kill the other side because we\n          // can't possible yield a result anymore.\n          if (fail) {\n            head._3 = fail;\n            tmp     = true;\n            kid     = killId++;\n\n            kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(fail, null, null);\n                } else {\n                  join(fail, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          } else if (lhs === EMPTY || rhs === EMPTY) {\n            // We can only proceed if both sides have resolved.\n            return;\n          } else {\n            step    = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n            head._3 = step;\n          }\n          break;\n        case ALT:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // We can only proceed if both have resolved or we have a success\n          if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {\n            return;\n          }\n          // If both sides resolve with an error, we should continue with the\n          // first error\n          if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n            fail    = step === lhs ? rhs : lhs;\n            step    = null;\n            head._3 = fail;\n          } else {\n            head._3 = step;\n            tmp     = true;\n            kid     = killId++;\n            // Once a side has resolved, we need to cancel the side that is still\n            // pending before we can continue.\n            kills[kid] = kill(early, step === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(step, null, null);\n                } else {\n                  join(step, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          }\n          break;\n        }\n\n        if (tail === null) {\n          head = null;\n        } else {\n          head = tail._1;\n          tail = tail._2;\n        }\n      }\n    }\n\n    function resolve(fiber) {\n      return function (result) {\n        return function () {\n          delete fibers[fiber._1];\n          fiber._3 = result;\n          join(result, fiber._2._1, fiber._2._2);\n        };\n      };\n    }\n\n    // Walks the applicative tree, substituting non-applicative nodes with\n    // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot\n    // as a mutable slot for memoization. In an unresolved state, the `_3`\n    // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk\n    // the left side first, because both operations are left-associative. As\n    // we `RETURN` from those branches, we then walk the right side.\n    function run() {\n      var status = CONTINUE;\n      var step   = par;\n      var head   = null;\n      var tail   = null;\n      var tmp, fid;\n\n      loop: while (true) {\n        tmp = null;\n        fid = null;\n\n        switch (status) {\n        case CONTINUE:\n          switch (step.tag) {\n          case MAP:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(MAP, step._1, EMPTY, EMPTY);\n            step = step._2;\n            break;\n          case APPLY:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(APPLY, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          case ALT:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(ALT, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          default:\n            // When we hit a leaf value, we suspend the stack in the `FORKED`.\n            // When the fiber resolves, it can bubble back up the tree.\n            fid    = fiberId++;\n            status = RETURN;\n            tmp    = step;\n            step   = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);\n            tmp    = Fiber(util, supervisor, tmp);\n            tmp.onComplete({\n              rethrow: false,\n              handler: resolve(step)\n            })();\n            fibers[fid] = tmp;\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n          }\n          break;\n        case RETURN:\n          // Terminal case, we are back at the root.\n          if (head === null) {\n            break loop;\n          }\n          // If we are done with the right side, we need to continue down the\n          // left. Otherwise we should continue up the stack.\n          if (head._1 === EMPTY) {\n            head._1 = step;\n            status  = CONTINUE;\n            step    = head._2;\n            head._2 = EMPTY;\n          } else {\n            head._2 = step;\n            step    = head;\n            if (tail === null) {\n              head  = null;\n            } else {\n              head  = tail._1;\n              tail  = tail._2;\n            }\n          }\n        }\n      }\n\n      // Keep a reference to the tree root so it can be cancelled.\n      root = step;\n\n      for (fid = 0; fid < fiberId; fid++) {\n        fibers[fid].run();\n      }\n    }\n\n    // Cancels the entire tree. If there are already subtrees being canceled,\n    // we need to first cancel those joins. We will then add fresh joins for\n    // all pending branches including those that were in the process of being\n    // canceled.\n    function cancel(error, cb) {\n      interrupt = util.left(error);\n      var innerKills;\n      for (var kid in kills) {\n        if (kills.hasOwnProperty(kid)) {\n          innerKills = kills[kid];\n          for (kid in innerKills) {\n            if (innerKills.hasOwnProperty(kid)) {\n              innerKills[kid]();\n            }\n          }\n        }\n      }\n\n      kills = null;\n      var newKills = kill(error, root, cb);\n\n      return function (killError) {\n        return new Aff(ASYNC, function (killCb) {\n          return function () {\n            for (var kid in newKills) {\n              if (newKills.hasOwnProperty(kid)) {\n                newKills[kid]();\n              }\n            }\n            return nonCanceler;\n          };\n        });\n      };\n    }\n\n    run();\n\n    return function (killError) {\n      return new Aff(ASYNC, function (killCb) {\n        return function () {\n          return cancel(killError, killCb);\n        };\n      });\n    };\n  }\n\n  function sequential(util, supervisor, par) {\n    return new Aff(ASYNC, function (cb) {\n      return function () {\n        return runPar(util, supervisor, par, cb);\n      };\n    });\n  }\n\n  Aff.EMPTY       = EMPTY;\n  Aff.Pure        = AffCtr(PURE);\n  Aff.Throw       = AffCtr(THROW);\n  Aff.Catch       = AffCtr(CATCH);\n  Aff.Sync        = AffCtr(SYNC);\n  Aff.Async       = AffCtr(ASYNC);\n  Aff.Bind        = AffCtr(BIND);\n  Aff.Bracket     = AffCtr(BRACKET);\n  Aff.Fork        = AffCtr(FORK);\n  Aff.Seq         = AffCtr(SEQ);\n  Aff.ParMap      = AffCtr(MAP);\n  Aff.ParApply    = AffCtr(APPLY);\n  Aff.ParAlt      = AffCtr(ALT);\n  Aff.Fiber       = Fiber;\n  Aff.Supervisor  = Supervisor;\n  Aff.Scheduler   = Scheduler;\n  Aff.nonCanceler = nonCanceler;\n\n  return Aff;\n}();\n\nexport const _pure = Aff.Pure;\nexport const _throwError = Aff.Throw;\n\nexport function _catchError(aff) {\n  return function (k) {\n    return Aff.Catch(aff, k);\n  };\n}\n\nexport function _map(f) {\n  return function (aff) {\n    if (aff.tag === Aff.Pure.tag) {\n      return Aff.Pure(f(aff._1));\n    } else {\n      return Aff.Bind(aff, function (value) {\n        return Aff.Pure(f(value));\n      });\n    }\n  };\n}\n\nexport function _bind(aff) {\n  return function (k) {\n    return Aff.Bind(aff, k);\n  };\n}\n\nexport function _fork(immediate) {\n  return function (aff) {\n    return Aff.Fork(immediate, aff);\n  };\n}\n\nexport const _liftEffect = Aff.Sync;\n\nexport function _parAffMap(f) {\n  return function (aff) {\n    return Aff.ParMap(f, aff);\n  };\n}\n\nexport function _parAffApply(aff1) {\n  return function (aff2) {\n    return Aff.ParApply(aff1, aff2);\n  };\n}\n\nexport function _parAffAlt(aff1) {\n  return function (aff2) {\n    return Aff.ParAlt(aff1, aff2);\n  };\n}\n\nexport const makeAff = Aff.Async;\n\nexport function generalBracket(acquire) {\n  return function (options) {\n    return function (k) {\n      return Aff.Bracket(acquire, options, k);\n    };\n  };\n}\n\nexport function _makeFiber(util, aff) {\n  return function () {\n    return Aff.Fiber(util, null, aff);\n  };\n}\n\nexport function _makeSupervisedFiber(util, aff) {\n  return function () {\n    var supervisor = Aff.Supervisor(util);\n    return {\n      fiber: Aff.Fiber(util, supervisor, aff),\n      supervisor: supervisor\n    };\n  };\n}\n\nexport function _killAll(error, supervisor, cb) {\n  return supervisor.killAll(error, cb);\n}\n\nexport const _delay = function () {\n  function setDelay(n, k) {\n    if (n === 0 && typeof setImmediate !== \"undefined\") {\n      return setImmediate(k);\n    } else {\n      return setTimeout(k, n);\n    }\n  }\n\n  function clearDelay(n, t) {\n    if (n === 0 && typeof clearImmediate !== \"undefined\") {\n      return clearImmediate(t);\n    } else {\n      return clearTimeout(t);\n    }\n  }\n\n  return function (right, ms) {\n    return Aff.Async(function (cb) {\n      return function () {\n        var timer = setDelay(ms, cb(right()));\n        return function () {\n          return Aff.Sync(function () {\n            return right(clearDelay(ms, timer));\n          });\n        };\n      };\n    });\n  };\n}();\n\nexport const _sequential = Aff.Seq;\n","module Control.Parallel.Class where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Monad.Cont.Trans (ContT(..), runContT)\nimport Control.Monad.Except.Trans (ExceptT(..))\nimport Control.Monad.Maybe.Trans (MaybeT(..))\nimport Control.Monad.Reader.Trans (mapReaderT, ReaderT)\nimport Control.Monad.Writer.Trans (mapWriterT, WriterT)\nimport Control.Plus (class Plus)\nimport Data.Either (Either)\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Costar (Costar(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Profunctor.Star (Star(..))\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Ref as Ref\n\n-- | The `Parallel` class abstracts over pairs of `Apply`s where one of them\n-- | (`m`) composes sequentially, and the other (`f`) composes in parallel.\n-- | `m` is usually a `Monad`, which enforces the sequential nature of its\n-- | composition, but it doesn't need to be.\nclass (Apply m, Apply f) <= Parallel f m | m -> f, f -> m where\n  parallel :: m ~> f\n  sequential :: f ~> m\n\ninstance monadParExceptT :: (Parallel f m, Monad m) => Parallel (Compose f (Either e)) (ExceptT e m) where\n  parallel (ExceptT ma) = Compose (parallel ma)\n  sequential (Compose fa) = ExceptT (sequential fa)\n\ninstance monadParReaderT :: Parallel f m => Parallel (ReaderT e f) (ReaderT e m) where\n  parallel = mapReaderT parallel\n  sequential = mapReaderT sequential\n\ninstance monadParWriterT :: (Monoid w, Parallel f m) => Parallel (WriterT w f) (WriterT w m) where\n  parallel = mapWriterT parallel\n  sequential = mapWriterT sequential\n\ninstance monadParMaybeT :: (Parallel f m, Monad m) => Parallel (Compose f Maybe) (MaybeT m) where\n  parallel (MaybeT ma) = Compose (parallel ma)\n  sequential (Compose fa) = MaybeT (sequential fa)\n\ninstance monadParStar :: Parallel f m => Parallel (Star f a) (Star m a) where\n  parallel (Star f) = (Star $ parallel <<< f)\n  sequential (Star f) = (Star $ sequential <<< f)\n\ninstance monadParCostar :: Parallel f m => Parallel (Costar f a) (Costar m a) where\n  parallel (Costar f) = (Costar $ sequential >>> f)\n  sequential (Costar f) = (Costar $ parallel >>> f)\n\n-- | The `ParCont` type constructor provides an `Applicative` instance\n-- | based on `ContT Unit m`, which waits for multiple continuations to be\n-- | resumed simultaneously.\n-- |\n-- | ParCont sections of code can be embedded in sequential code by using\n-- | the `parallel` and `sequential` functions:\n-- |\n-- | ```purescript\n-- | loadModel :: ContT Unit (Eff (ajax :: AJAX)) Model\n-- | loadModel = do\n-- |   token <- authenticate\n-- |   sequential $\n-- |     Model <$> parallel (get \"/products/popular/\" token)\n-- |           <*> parallel (get \"/categories/all\" token)\n-- | ```\nnewtype ParCont m a = ParCont (ContT Unit m a)\n\nderive instance newtypeParCont :: Newtype (ParCont m a) _\n\ninstance functorParCont :: MonadEffect m => Functor (ParCont m) where\n  map f = parallel <<< map f <<< sequential\n\ninstance applyParCont :: MonadEffect m => Apply (ParCont m) where\n  apply (ParCont ca) (ParCont cb) = ParCont $ ContT \\k -> do\n    ra <- liftEffect (Ref.new Nothing)\n    rb <- liftEffect (Ref.new Nothing)\n\n    runContT ca \\a -> do\n      mb <- liftEffect (Ref.read rb)\n      case mb of\n        Nothing -> liftEffect (Ref.write (Just a) ra)\n        Just b -> k (a b)\n\n    runContT cb \\b -> do\n      ma <- liftEffect (Ref.read ra)\n      case ma of\n        Nothing -> liftEffect (Ref.write (Just b) rb)\n        Just a -> k (a b)\n\ninstance applicativeParCont :: MonadEffect m => Applicative (ParCont m) where\n  pure = parallel <<< pure\n\ninstance altParCont :: MonadEffect m => Alt (ParCont m) where\n  alt (ParCont c1) (ParCont c2) = ParCont $ ContT \\k -> do\n    done <- liftEffect (Ref.new false)\n\n    runContT c1 \\a -> do\n      b <- liftEffect (Ref.read done)\n      if b\n        then pure unit\n        else do\n          liftEffect (Ref.write true done)\n          k a\n\n    runContT c2 \\a -> do\n      b <- liftEffect (Ref.read done)\n      if b\n        then pure unit\n        else do\n          liftEffect (Ref.write true done)\n          k a\n\ninstance plusParCont :: MonadEffect m => Plus (ParCont m) where\n  empty = ParCont $ ContT \\_ -> pure unit\n\ninstance alternativeParCont :: MonadEffect m => Alternative (ParCont m)\n\ninstance monadParParCont :: MonadEffect m => Parallel (ParCont m) (ContT Unit m) where\n  parallel = ParCont\n  sequential (ParCont ma) = ma\n","module Control.Parallel\n  ( parApply\n  , parTraverse\n  , parTraverse_\n  , parSequence\n  , parSequence_\n  , parOneOf\n  , parOneOfMap\n  , module Control.Parallel.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alternative)\nimport Control.Parallel.Class (class Parallel, parallel, sequential, ParCont(..))\n\nimport Data.Foldable (class Foldable, traverse_, oneOfMap)\nimport Data.Traversable (class Traversable, traverse)\n\n-- | Apply a function to an argument under a type constructor in parallel.\nparApply\n  :: forall f m a b\n   . Parallel f m\n   => m (a -> b)\n   -> m a\n   -> m b\nparApply mf ma = sequential(apply (parallel mf) (parallel ma))\n\n-- | Traverse a collection in parallel.\nparTraverse\n  :: forall f m t a b\n   . Parallel f m\n  => Applicative f\n  => Traversable t\n  => (a -> m b)\n  -> t a\n  -> m (t b)\nparTraverse f = sequential <<< traverse (parallel <<< f)\n\n-- | Traverse a collection in parallel, discarding any results.\nparTraverse_\n  :: forall f m t a b\n   . Parallel f m\n  => Applicative f\n  => Foldable t\n  => (a -> m b)\n  -> t a\n  -> m Unit\nparTraverse_ f = sequential <<< traverse_ (parallel <<< f)\n\nparSequence\n  :: forall a t m f\n   . Parallel f m\n  => Applicative f\n  => Traversable t\n  => t (m a)\n  -> m (t a)\nparSequence = parTraverse identity\n\nparSequence_\n  :: forall a t m f\n   . Parallel f m\n  => Applicative f\n  => Foldable t\n  => t (m a)\n  -> m Unit\nparSequence_ = parTraverse_ identity\n\n-- | Race a collection in parallel.\nparOneOf\n  :: forall a t m f\n   . Parallel f m\n  => Alternative f\n  => Foldable t\n  => Functor t\n  => t (m a)\n  -> m a\nparOneOf = sequential <<< oneOfMap parallel\n\n-- | Race a collection in parallel while mapping to some effect.\nparOneOfMap\n  :: forall a b t m f\n   . Parallel f m\n  => Alternative f\n  => Foldable t\n  => Functor t\n  => (a -> m b)\n  -> t a\n  -> m b\nparOneOfMap f = sequential <<< oneOfMap (parallel <<< f)\n","export const unsafePerformEffect = function (f) {\n  return f();\n};\n","module Effect.Aff\n  ( Aff\n  , Fiber\n  , ParAff(..)\n  , Canceler(..)\n  , makeAff\n  , launchAff\n  , launchAff_\n  , launchSuspendedAff\n  , runAff\n  , runAff_\n  , runSuspendedAff\n  , forkAff\n  , suspendAff\n  , supervise\n  , attempt\n  , apathize\n  , delay\n  , never\n  , finally\n  , invincible\n  , killFiber\n  , joinFiber\n  , cancelWith\n  , bracket\n  , BracketConditions\n  , generalBracket\n  , nonCanceler\n  , effectCanceler\n  , fiberCanceler\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Error.Class (class MonadError, class MonadThrow, throwError, catchError, try)\nimport Control.Monad.Error.Class (try, throwError, catchError) as Exports\nimport Control.Monad.Rec.Class (class MonadRec, Step(..))\nimport Control.Monad.ST.Class (class MonadST, liftST)\nimport Control.Monad.ST.Global (Global)\nimport Control.Parallel (parSequence_, parallel)\nimport Control.Parallel.Class (class Parallel)\nimport Control.Parallel.Class (sequential, parallel) as Exports\nimport Control.Plus (class Plus, empty)\nimport Data.Either (Either(..))\nimport Data.Function.Uncurried as Fn\nimport Data.Newtype (class Newtype)\nimport Data.Time.Duration (Milliseconds(..))\nimport Data.Time.Duration (Milliseconds(..)) as Exports\nimport Effect (Effect)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Exception (Error, error)\nimport Effect.Exception (Error, error, message) as Exports\nimport Effect.Unsafe (unsafePerformEffect)\nimport Partial.Unsafe (unsafeCrashWith)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An `Aff a` is an asynchronous computation with effects. The\n-- | computation may either error with an exception, or produce a result of\n-- | type `a`. `Aff` effects are assembled from primitive `Effect` effects using\n-- | `makeAff` or `liftEffect`.\nforeign import data Aff :: Type -> Type\n\ntype role Aff representational\n\ninstance functorAff :: Functor Aff where\n  map = _map\n\ninstance applyAff :: Apply Aff where\n  apply = ap\n\ninstance applicativeAff :: Applicative Aff where\n  pure = _pure\n\ninstance bindAff :: Bind Aff where\n  bind = _bind\n\ninstance monadAff :: Monad Aff\n\ninstance semigroupAff :: Semigroup a => Semigroup (Aff a) where\n  append = lift2 append\n\ninstance monoidAff :: Monoid a => Monoid (Aff a) where\n  mempty = pure mempty\n\ninstance altAff :: Alt Aff where\n  alt a1 a2 = catchError a1 (const a2)\n\ninstance plusAff :: Plus Aff where\n  empty = throwError (error \"Always fails\")\n\n-- | This instance is provided for compatibility. `Aff` is always stack-safe\n-- | within a given fiber. This instance will just result in unnecessary\n-- | bind overhead.\ninstance monadRecAff :: MonadRec Aff where\n  tailRecM k = go\n    where\n    go a = do\n      res <- k a\n      case res of\n        Done r -> pure r\n        Loop b -> go b\n\ninstance monadThrowAff :: MonadThrow Error Aff where\n  throwError = _throwError\n\ninstance monadErrorAff :: MonadError Error Aff where\n  catchError = _catchError\n\ninstance monadEffectAff :: MonadEffect Aff where\n  liftEffect = _liftEffect\n\ninstance lazyAff :: Lazy (Aff a) where\n  defer f = pure unit >>= f\n\ninstance monadSTAff :: MonadST Global Aff where\n  liftST = liftST >>> liftEffect\n\n-- | Applicative for running parallel effects. Any `Aff` can be coerced to a\n-- | `ParAff` and back using the `Parallel` class.\nforeign import data ParAff :: Type -> Type\n\ntype role ParAff representational\n\ninstance functorParAff :: Functor ParAff where\n  map = _parAffMap\n\n-- | Runs effects in parallel, combining their results.\ninstance applyParAff :: Apply ParAff where\n  apply = _parAffApply\n\ninstance applicativeParAff :: Applicative ParAff where\n  pure = parallel <<< pure\n\ninstance semigroupParAff :: Semigroup a => Semigroup (ParAff a) where\n  append = lift2 append\n\ninstance monoidParAff :: Monoid a => Monoid (ParAff a) where\n  mempty = pure mempty\n\n-- | Races effects in parallel. Returns the first successful result or the\n-- | first error if all fail with an exception. Losing branches will be\n-- | cancelled.\ninstance altParAff :: Alt ParAff where\n  alt = _parAffAlt\n\ninstance plusParAff :: Plus ParAff where\n  empty = parallel empty\n\ninstance alternativeParAff :: Alternative ParAff\n\ninstance parallelAff :: Parallel ParAff Aff where\n  parallel = (unsafeCoerce :: forall a. Aff a -> ParAff a)\n  sequential = _sequential\n\ntype OnComplete a =\n  { rethrow :: Boolean\n  , handler :: (Either Error a -> Effect Unit) -> Effect Unit\n  }\n\n-- | Represents a forked computation by way of `forkAff`. `Fiber`s are\n-- | memoized, so their results are only computed once.\nnewtype Fiber a = Fiber\n  { run :: Effect Unit\n  , kill :: Fn.Fn2 Error (Either Error Unit -> Effect Unit) (Effect (Effect Unit))\n  , join :: (Either Error a -> Effect Unit) -> Effect (Effect Unit)\n  , onComplete :: OnComplete a -> Effect (Effect Unit)\n  , isSuspended :: Effect Boolean\n  }\n\ninstance functorFiber :: Functor Fiber where\n  map f t = unsafePerformEffect (makeFiber (f <$> joinFiber t))\n\ninstance applyFiber :: Apply Fiber where\n  apply t1 t2 = unsafePerformEffect (makeFiber (joinFiber t1 <*> joinFiber t2))\n\ninstance applicativeFiber :: Applicative Fiber where\n  pure a = unsafePerformEffect (makeFiber (pure a))\n\n-- | Invokes pending cancelers in a fiber and runs cleanup effects. Blocks\n-- | until the fiber has fully exited.\nkillFiber :: forall a. Error -> Fiber a -> Aff Unit\nkillFiber e (Fiber t) = do\n  suspended <- liftEffect t.isSuspended\n  if suspended then\n    liftEffect $ void $ Fn.runFn2 t.kill e (const (pure unit))\n  else\n    makeAff \\k -> effectCanceler <$> Fn.runFn2 t.kill e k\n\n-- | Blocks until the fiber completes, yielding the result. If the fiber\n-- | throws an exception, it is rethrown in the current fiber.\njoinFiber :: Fiber ~> Aff\njoinFiber (Fiber t) = makeAff \\k -> effectCanceler <$> t.join k\n\n-- | A cancellation effect for actions run via `makeAff`. If a `Fiber` is\n-- | killed, and an async action is pending, the canceler will be called to\n-- | clean it up.\nnewtype Canceler = Canceler (Error -> Aff Unit)\n\nderive instance newtypeCanceler :: Newtype Canceler _\n\ninstance semigroupCanceler :: Semigroup Canceler where\n  append (Canceler c1) (Canceler c2) =\n    Canceler \\err -> parSequence_ [ c1 err, c2 err ]\n\n-- | A no-op `Canceler` can be constructed with `mempty`.\ninstance monoidCanceler :: Monoid Canceler where\n  mempty = nonCanceler\n\n-- | A canceler which does not cancel anything.\nnonCanceler :: Canceler\nnonCanceler = Canceler (const (pure unit))\n\n-- | A canceler from an Effect action.\neffectCanceler :: Effect Unit -> Canceler\neffectCanceler = Canceler <<< const <<< liftEffect\n\n-- | A canceler from a Fiber.\nfiberCanceler :: forall a. Fiber a -> Canceler\nfiberCanceler = Canceler <<< flip killFiber\n\n-- | Forks an `Aff` from an `Effect` context, returning the `Fiber`.\nlaunchAff :: forall a. Aff a -> Effect (Fiber a)\nlaunchAff aff = do\n  fiber <- makeFiber aff\n  case fiber of Fiber f -> f.run\n  pure fiber\n\n-- | Forks an `Aff` from an `Effect` context, discarding the `Fiber`.\nlaunchAff_ :: Aff Unit -> Effect Unit\nlaunchAff_ = void <<< launchAff\n\n-- | Suspends an `Aff` from an `Effect` context, returning the `Fiber`.\nlaunchSuspendedAff :: forall a. Aff a -> Effect (Fiber a)\nlaunchSuspendedAff = makeFiber\n\n-- | Forks an `Aff` from an `Effect` context and also takes a callback to run when\n-- | it completes. Returns the pending `Fiber`.\nrunAff :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect (Fiber Unit)\nrunAff k aff = launchAff $ liftEffect <<< k =<< try aff\n\n-- | Forks an `Aff` from an `Effect` context and also takes a callback to run when\n-- | it completes, discarding the `Fiber`.\nrunAff_ :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect Unit\nrunAff_ k aff = void $ runAff k aff\n\n-- | Suspends an `Aff` from an `Effect` context and also takes a callback to run\n-- | when it completes. Returns the suspended `Fiber`.\nrunSuspendedAff :: forall a. (Either Error a -> Effect Unit) -> Aff a -> Effect (Fiber Unit)\nrunSuspendedAff k aff = launchSuspendedAff $ liftEffect <<< k =<< try aff\n\n-- | Forks an `Aff` from within a parent `Aff` context, returning the `Fiber`.\nforkAff :: forall a. Aff a -> Aff (Fiber a)\nforkAff = _fork true\n\n-- | Suspends an `Aff` from within a parent `Aff` context, returning the `Fiber`.\n-- | A suspended `Aff` is not executed until a consumer observes the result\n-- | with `joinFiber`.\nsuspendAff :: forall a. Aff a -> Aff (Fiber a)\nsuspendAff = _fork false\n\n-- | Pauses the running fiber.\ndelay :: Milliseconds -> Aff Unit\ndelay (Milliseconds n) = Fn.runFn2 _delay Right n\n\n-- | An async computation which does not resolve.\nnever :: forall a. Aff a\nnever = makeAff \\_ -> pure mempty\n\n-- | A monomorphic version of `try`. Catches thrown errors and lifts them\n-- | into an `Either`.\nattempt :: forall a. Aff a -> Aff (Either Error a)\nattempt = try\n\n-- | Ignores any errors.\napathize :: forall a. Aff a -> Aff Unit\napathize = attempt >>> map (const unit)\n\n-- | Runs the first effect after the second, regardless of whether it completed\n-- | successfully or the fiber was cancelled.\nfinally :: forall a. Aff Unit -> Aff a -> Aff a\nfinally fin a = bracket (pure unit) (const fin) (const a)\n\n-- | Runs an effect such that it cannot be killed.\ninvincible :: forall a. Aff a -> Aff a\ninvincible a = bracket a (const (pure unit)) pure\n\n-- | Attaches a custom `Canceler` to an action. If the computation is canceled,\n-- | then the custom `Canceler` will be run afterwards.\ncancelWith :: forall a. Aff a -> Canceler -> Aff a\ncancelWith aff (Canceler cancel) =\n  generalBracket (pure unit)\n    { killed: \\e _ -> cancel e\n    , failed: const pure\n    , completed: const pure\n    }\n    (const aff)\n\n-- | Guarantees resource acquisition and cleanup. The first effect may acquire\n-- | some resource, while the second will dispose of it. The third effect makes\n-- | use of the resource. Disposal is always run last, regardless. Neither\n-- | acquisition nor disposal may be cancelled and are guaranteed to run until\n-- | they complete.\nbracket :: forall a b. Aff a -> (a -> Aff Unit) -> (a -> Aff b) -> Aff b\nbracket acquire completed =\n  generalBracket acquire\n    { killed: const completed\n    , failed: const completed\n    , completed: const completed\n    }\n\ntype Supervised a =\n  { fiber :: Fiber a\n  , supervisor :: Supervisor\n  }\n\n-- | Creates a new supervision context for some `Aff`, guaranteeing fiber\n-- | cleanup when the parent completes. Any pending fibers forked within\n-- | the context will be killed and have their cancelers run.\nsupervise :: forall a. Aff a -> Aff a\nsupervise aff =\n  generalBracket (liftEffect acquire)\n    { killed: \\err sup -> parSequence_ [ killFiber err sup.fiber, killAll err sup ]\n    , failed: const (killAll killError)\n    , completed: const (killAll killError)\n    }\n    (joinFiber <<< _.fiber)\n  where\n  killError :: Error\n  killError =\n    error \"[Aff] Child fiber outlived parent\"\n\n  killAll :: Error -> Supervised a -> Aff Unit\n  killAll err sup = makeAff \\k ->\n    Fn.runFn3 _killAll err sup.supervisor (k (pure unit))\n\n  acquire :: Effect (Supervised a)\n  acquire = do\n    sup <- Fn.runFn2 _makeSupervisedFiber ffiUtil aff\n    case sup.fiber of Fiber f -> f.run\n    pure sup\n\nforeign import data Supervisor :: Type\nforeign import _pure :: forall a. a -> Aff a\nforeign import _throwError :: forall a. Error -> Aff a\nforeign import _catchError :: forall a. Aff a -> (Error -> Aff a) -> Aff a\nforeign import _fork :: forall a. Boolean -> Aff a -> Aff (Fiber a)\nforeign import _map :: forall a b. (a -> b) -> Aff a -> Aff b\nforeign import _bind :: forall a b. Aff a -> (a -> Aff b) -> Aff b\nforeign import _delay :: forall a. Fn.Fn2 (Unit -> Either a Unit) Number (Aff Unit)\nforeign import _liftEffect :: forall a. Effect a -> Aff a\nforeign import _parAffMap :: forall a b. (a -> b) -> ParAff a -> ParAff b\nforeign import _parAffApply :: forall a b. ParAff (a -> b) -> ParAff a -> ParAff b\nforeign import _parAffAlt :: forall a. ParAff a -> ParAff a -> ParAff a\nforeign import _makeFiber :: forall a. Fn.Fn2 FFIUtil (Aff a) (Effect (Fiber a))\nforeign import _makeSupervisedFiber :: forall a. Fn.Fn2 FFIUtil (Aff a) (Effect (Supervised a))\nforeign import _killAll :: Fn.Fn3 Error Supervisor (Effect Unit) (Effect Canceler)\nforeign import _sequential :: ParAff ~> Aff\n\ntype BracketConditions a b =\n  { killed :: Error -> a -> Aff Unit\n  , failed :: Error -> a -> Aff Unit\n  , completed :: b -> a -> Aff Unit\n  }\n\n-- | A general purpose bracket which lets you observe the status of the\n-- | bracketed action. The bracketed action may have been killed with an\n-- | exception, thrown an exception, or completed successfully.\nforeign import generalBracket :: forall a b. Aff a -> BracketConditions a b -> (a -> Aff b) -> Aff b\n\n-- | Constructs an `Aff` from low-level `Effect` effects using a callback. A\n-- | `Canceler` effect should be returned to cancel the pending action. The\n-- | supplied callback may be invoked only once. Subsequent invocation are\n-- | ignored.\nforeign import makeAff :: forall a. ((Either Error a -> Effect Unit) -> Effect Canceler) -> Aff a\n\nmakeFiber :: forall a. Aff a -> Effect (Fiber a)\nmakeFiber aff = Fn.runFn2 _makeFiber ffiUtil aff\n\nnewtype FFIUtil = FFIUtil\n  { isLeft :: forall a b. Either a b -> Boolean\n  , fromLeft :: forall a b. Either a b -> a\n  , fromRight :: forall a b. Either a b -> b\n  , left :: forall a b. a -> Either a b\n  , right :: forall a b. b -> Either a b\n  }\n\nffiUtil :: FFIUtil\nffiUtil = FFIUtil\n  { isLeft\n  , fromLeft: unsafeFromLeft\n  , fromRight: unsafeFromRight\n  , left: Left\n  , right: Right\n  }\n  where\n  isLeft :: forall a b. Either a b -> Boolean\n  isLeft = case _ of\n    Left _ -> true\n    Right _ -> false\n\n  unsafeFromLeft :: forall a b. Either a b -> a\n  unsafeFromLeft = case _ of\n    Left a -> a\n    Right _ -> unsafeCrashWith \"unsafeFromLeft: Right\"\n\n  unsafeFromRight :: forall a b. Either a b -> b\n  unsafeFromRight = case _ of\n    Right a -> a\n    Left _ -> unsafeCrashWith \"unsafeFromRight: Left\"\n","module Effect.Aff.Class where\n\nimport Prelude\nimport Control.Monad.Cont.Trans (ContT)\nimport Control.Monad.Except.Trans (ExceptT)\nimport Control.Monad.List.Trans (ListT)\nimport Control.Monad.Maybe.Trans (MaybeT)\nimport Control.Monad.Reader.Trans (ReaderT)\nimport Control.Monad.RWS.Trans (RWST)\nimport Control.Monad.State.Trans (StateT)\nimport Control.Monad.Trans.Class (lift)\nimport Control.Monad.Writer.Trans (WriterT)\nimport Effect.Aff (Aff)\nimport Effect.Class (class MonadEffect)\n\nclass MonadEffect m <= MonadAff m where\n  liftAff :: Aff ~> m\n\ninstance monadAffAff :: MonadAff Aff where\n  liftAff = identity\n\ninstance monadAffContT :: MonadAff m => MonadAff (ContT r m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffExceptT :: MonadAff m => MonadAff (ExceptT e m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffListT :: MonadAff m => MonadAff (ListT m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffMaybe :: MonadAff m => MonadAff (MaybeT m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffReader :: MonadAff m => MonadAff (ReaderT r m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffRWS :: (MonadAff m, Monoid w) => MonadAff (RWST r w s m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffState :: MonadAff m => MonadAff (StateT s m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffWriter :: (MonadAff m, Monoid w) => MonadAff (WriterT w m) where\n  liftAff = lift <<< liftAff\n","module Halogen.Query.ChildQuery where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Halogen.Data.Slot (SlotStorage)\nimport Unsafe.Coerce (unsafeCoerce)\n\ndata ChildQueryBox :: Row Type -> Type -> Type\ndata ChildQueryBox (ps :: Row Type) a\n\ndata ChildQuery ps g o a f b =\n  ChildQuery\n    (forall slot m. Applicative m => (slot g o -> m (Maybe b)) -> SlotStorage ps slot -> m (f b))\n    (g b)\n    (f b -> a)\n\ninstance functorChildQuery :: Functor (ChildQueryBox ps) where\n  map f = unChildQueryBox \\(ChildQuery u q k) ->\n    mkChildQueryBox (ChildQuery u q (f <<< k))\n\nmkChildQueryBox\n  :: forall ps g o a f b\n   . ChildQuery ps g o a f b\n  -> ChildQueryBox ps a\nmkChildQueryBox = unsafeCoerce\n\nunChildQueryBox\n  :: forall ps a r\n   . (forall g o f b. ChildQuery ps g o a f b -> r)\n  -> ChildQueryBox ps a\n  -> r\nunChildQueryBox = unsafeCoerce\n","export function reallyUnsafeRefEq(a) {\n  return function (b) {\n    return a === b;\n  };\n}\n","module Unsafe.Reference\n  ( unsafeRefEq\n  , reallyUnsafeRefEq\n  , UnsafeRefEq(..)\n  , UnsafeRefEqFallback(..)\n  ) where\n\nimport Prelude\n\n-- | Compares two values of the same type using strict (`===`) equality.\nunsafeRefEq :: forall a. a -> a -> Boolean\nunsafeRefEq = reallyUnsafeRefEq\n\n-- | Compares two values of different types using strict (`===`) equality.\nforeign import reallyUnsafeRefEq :: forall a b. a -> b -> Boolean\n\n-- | The `Eq` instance is defined by `unsafeRefEq`.\nnewtype UnsafeRefEq a = UnsafeRefEq a\n\ninstance eqUnsafeRefEq :: Eq (UnsafeRefEq a) where\n  eq (UnsafeRefEq l) (UnsafeRefEq r) = unsafeRefEq l r\n\n-- | The `Eq` instance first checks `unsafeRefEq`, if `false` falls back to\n-- | the underlying `Eq` instance.\nnewtype UnsafeRefEqFallback a = UnsafeRefEqFallback a\n\ninstance eqUnsafeRefEqFallback ::\n  Eq a =>\n  Eq (UnsafeRefEqFallback a) where\n  eq (UnsafeRefEqFallback l) (UnsafeRefEqFallback r) =\n    unsafeRefEq l r || l == r\n\n","module Halogen.Subscription\n  ( SubscribeIO(..)\n  , create\n  , Listener\n  , notify\n  , Emitter\n  , makeEmitter\n  , Subscription\n  , subscribe\n  , unsubscribe\n  , fold\n  , filter\n  , fix\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Plus (class Plus)\nimport Data.Array (deleteBy)\nimport Data.Foldable (traverse_)\nimport Data.Functor.Contravariant (class Contravariant)\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Ref as Ref\nimport Effect.Unsafe (unsafePerformEffect)\nimport Safe.Coerce (coerce)\nimport Unsafe.Reference (unsafeRefEq)\n\n-- | A paired `Listener` and `Emitter` produced with the `create` function.\ntype SubscribeIO a =\n  { listener :: Listener a\n  , emitter :: Emitter a\n  }\n\n-- | Create a paired `Listener` and `Emitter`, where you can push values to\n-- | the listener and subscribe to values from the emitter.\n-- |\n-- | ```purs\n-- | { emitter, listener } <- create\n-- |\n-- | -- Push values into the listener:\n-- | notify listener \"hello\"\n-- |\n-- | -- Subscribe to outputs from the emitter with a callback:\n-- | subscription <- subscribe emitter \\value ->\n-- |   Console.log value\n-- |\n-- | -- Unsubscribe at any time:\n-- | unsubscribe subscription\n-- | ```\ncreate :: forall a. Effect (SubscribeIO a)\ncreate = do\n  subscribers <- Ref.new []\n  pure\n    { emitter: Emitter \\k -> do\n        Ref.modify_ (_ <> [k]) subscribers\n        pure $ Subscription do\n          Ref.modify_ (deleteBy unsafeRefEq k) subscribers\n    , listener: Listener \\a -> do\n        Ref.read subscribers >>= traverse_ \\k -> k a\n    }\n\n-- | An `Emitter` represents a collection of discrete occurrences of an event;\n-- | conceptually, an emitter is a possibly-infinite list of values.\n-- |\n-- | Emitters are created from real events like timers or mouse clicks and can\n-- | be combined or transformed with the functions and instances in this module.\n-- |\n-- | Emitters are consumed by providing a callback via the `subscribe` function.\nnewtype Emitter a = Emitter ((a -> Effect Unit) -> Effect Subscription)\n\ninstance functorEmitter :: Functor Emitter where\n  map f (Emitter e) = Emitter \\k -> e (k <<< f)\n\ninstance applyEmitter :: Apply Emitter where\n  apply (Emitter e1) (Emitter e2) = Emitter \\k -> do\n    latestA <- Ref.new Nothing\n    latestB <- Ref.new Nothing\n    Subscription c1 <- e1 \\a -> do\n      Ref.write (Just a) latestA\n      Ref.read latestB >>= traverse_ (k <<< a)\n    Subscription c2 <- e2 \\b -> do\n      Ref.write (Just b) latestB\n      Ref.read latestA >>= traverse_ (k <<< (_ $ b))\n    pure (Subscription (c1 *> c2))\n\ninstance applicativeEmitter :: Applicative Emitter where\n  pure a = Emitter \\k -> do\n    k a\n    pure (Subscription (pure unit))\n\ninstance altEmitter :: Alt Emitter where\n  alt (Emitter f) (Emitter g) = Emitter \\k -> do\n    Subscription c1 <- f k\n    Subscription c2 <- g k\n    pure (Subscription (c1 *> c2))\n\ninstance plusEmitter :: Plus Emitter where\n  empty = Emitter \\_ -> pure (Subscription (pure unit))\n\ninstance alternativeEmitter :: Alternative Emitter\n\ninstance semigroupEmitter :: Semigroup a => Semigroup (Emitter a) where\n  append = lift2 append\n\ninstance monoidEmitter :: Monoid a => Monoid (Emitter a) where\n  mempty = Emitter mempty\n\n-- | Make an `Emitter` from a function which accepts a callback and returns an\n-- | unsubscription function.\n-- |\n-- | Note: You should use `create` unless you need explicit control over\n-- | unsubscription.\nmakeEmitter\n  :: forall a\n   . ((a -> Effect Unit) -> Effect (Effect Unit))\n  -> Emitter a\nmakeEmitter = coerce\n\n-- | Conceptually, a `Listener` represents an input source to an `Emitter`. You\n-- | can push a value to its paired emitter with the `notify` function.\nnewtype Listener a = Listener (a -> Effect Unit)\n\ninstance contravariantListener :: Contravariant Listener where\n  cmap f (Listener g) = coerce (g <<< f)\n\n-- | Push a value to the `Emitter` paired with the provided `Listener` argument.\n-- |\n-- | ```purs\n-- | -- Create an emitter and listener with `create`:\n-- | { emitter, listener } <- create\n-- |\n-- | -- Then, push values to the emitter via the listener with `notify`:\n-- | notify listener \"hello\"\n-- | ```\nnotify :: forall a. Listener a -> a -> Effect Unit\nnotify (Listener f) a = f a\n\n-- | A `Subscription` results from subscribing to an `Emitter` with `subscribe`;\n-- | the subscription can be ended at any time with `unsubscribe`.\nnewtype Subscription = Subscription (Effect Unit)\n\nderive newtype instance semigroupSubscription :: Semigroup Subscription\nderive newtype instance monoidSubscription :: Monoid Subscription\n\n-- | Subscribe to an `Emitter` by providing a callback to run on values produced\n-- | by the emitter:\n-- |\n-- | ```purs\n-- | -- Produce an emitter / listener pair with `create`:\n-- | { emitter, listener } <- create\n-- |\n-- | -- Then, subscribe to the emitter by providing a callback:\n-- | subscription <- subscribe emitter \\emitted ->\n-- |   doSomethingWith emitted\n-- |\n-- | -- End the subscription at any time with `unsubscribe`:\n-- | unsubscribe subscription\n-- | ```\nsubscribe\n  :: forall r a\n   . Emitter a\n  -> (a -> Effect r)\n  -> Effect Subscription\nsubscribe (Emitter e) k = e (void <<< k)\n\n-- | End a subscription to an `Emitter`.\nunsubscribe :: Subscription -> Effect Unit\nunsubscribe (Subscription unsub) = unsub\n\n-- | Fold over values received from some `Emitter`, creating a new `Emitter`.\nfold :: forall a b. (a -> b -> b) -> Emitter a -> b -> Emitter b\nfold f (Emitter e) b = Emitter \\k -> do\n  result <- Ref.new b\n  e \\a -> Ref.modify (f a) result >>= k\n\n-- | Create an `Emitter` which only fires when a predicate holds.\nfilter :: forall a. (a -> Boolean) -> Emitter a -> Emitter a\nfilter p (Emitter e) = Emitter \\k -> e \\a -> if p a then k a else pure unit\n\n-- | Compute a fixed point.\nfix :: forall i o. (Emitter i -> { input :: Emitter i, output :: Emitter o }) -> Emitter o\nfix f = Emitter \\k -> do\n  Subscription c1 <- subscribe input (notify listener)\n  Subscription c2 <- subscribe output k\n  pure (Subscription (c1 *> c2))\n  where\n  { emitter, listener } = unsafePerformEffect create\n  { input, output } = f emitter\n","module Halogen.Query.HalogenM where\n\nimport Prelude\n\nimport Control.Applicative.Free (FreeAp, liftFreeAp, hoistFreeAp)\nimport Control.Monad.Error.Class (class MonadThrow, throwError)\nimport Control.Monad.Free (Free, hoistFree, liftF)\nimport Control.Monad.Reader.Class (class MonadAsk, ask)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.State.Class (class MonadState)\nimport Control.Monad.Trans.Class (class MonadTrans)\nimport Control.Monad.Writer.Class (class MonadTell, tell)\nimport Control.Parallel.Class (class Parallel)\nimport Data.Bifunctor (lmap)\nimport Data.FoldableWithIndex (foldrWithIndex)\nimport Data.Map (Map)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype, over)\nimport Data.Symbol (class IsSymbol)\nimport Data.Traversable (traverse)\nimport Data.Tuple (Tuple)\nimport Effect.Aff.Class (class MonadAff, liftAff)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Halogen.Data.Slot (Slot)\nimport Halogen.Data.Slot as Slot\nimport Halogen.Query.ChildQuery as CQ\nimport Halogen.Query.Input (RefLabel)\nimport Halogen.Subscription as HS\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Web.DOM (Element)\n\n-- | The Halogen component eval algebra.\n-- |\n-- | - `state` is the component's state\n-- | - `action` is the type of actions; events internal to the component that\n-- |   can be evaluated\n-- | - `slots` is the set of slots for addressing child components\n-- | - `output` is the type of output messages the component can raise\n-- | - `m` is the monad used during evaluation\n-- | - `a` is the result of the HalogenF expression (see HalogenM for an example).\ndata HalogenF state action slots output m a\n  = State (state -> Tuple a state)\n  | Subscribe (SubscriptionId -> HS.Emitter action) (SubscriptionId -> a)\n  | Unsubscribe SubscriptionId a\n  | Lift (m a)\n  | ChildQuery (CQ.ChildQueryBox slots a)\n  | Raise output a\n  | Par (HalogenAp state action slots output m a)\n  | Fork (HalogenM state action slots output m Unit) (ForkId -> a)\n  | Join ForkId a\n  | Kill ForkId a\n  | GetRef RefLabel (Maybe Element -> a)\n\ninstance functorHalogenF :: Functor m => Functor (HalogenF state action slots output m) where\n  map f = case _ of\n    State k -> State (lmap f <<< k)\n    Subscribe fes k -> Subscribe fes (f <<< k)\n    Unsubscribe sid a -> Unsubscribe sid (f a)\n    Lift q -> Lift (map f q)\n    ChildQuery cq -> ChildQuery (map f cq)\n    Raise o a -> Raise o (f a)\n    Par pa -> Par (map f pa)\n    Fork hmu k -> Fork hmu (f <<< k)\n    Join fid a -> Join fid (f a)\n    Kill fid a -> Kill fid (f a)\n    GetRef p k -> GetRef p (f <<< k)\n\n-- | The Halogen component eval effect monad.\n-- |\n-- | - `state` is the component's state\n-- | - `action` is the type of actions; events internal to the component that\n-- |   can be evaluated\n-- | - `slots` is the set of slots for addressing child components\n-- | - `output` is the type of output messages the component can raise\n-- | - `m` is the monad used during evaluation\n-- | - `a` is the result of the HalogenM expression. Use the following pattern:\n-- |     `handleAction :: Action -> H.HalogenM State Action Slots Output m Unit`\n-- |     `handleQuery  :: forall a. Query a -> H.HalogenM State Action Slots Output m (Maybe a)`\nnewtype HalogenM state action slots output m a = HalogenM (Free (HalogenF state action slots output m) a)\n\nderive newtype instance functorHalogenM :: Functor (HalogenM state action slots output m)\nderive newtype instance applyHalogenM :: Apply (HalogenM state action slots output m)\nderive newtype instance applicativeHalogenM :: Applicative (HalogenM state action slots output m)\nderive newtype instance bindHalogenM :: Bind (HalogenM state action slots output m)\nderive newtype instance monadHalogenM :: Monad (HalogenM state action slots output m)\nderive newtype instance semigroupHalogenM :: Semigroup a => Semigroup (HalogenM state action slots output m a)\nderive newtype instance monoidHalogenM :: Monoid a => Monoid (HalogenM state action slots output m a)\n\ninstance monadEffectHalogenM :: MonadEffect m => MonadEffect (HalogenM state action slots output m) where\n  liftEffect = HalogenM <<< liftF <<< Lift <<< liftEffect\n\ninstance monadAffHalogenM :: MonadAff m => MonadAff (HalogenM state action slots output m) where\n  liftAff = HalogenM <<< liftF <<< Lift <<< liftAff\n\ninstance parallelHalogenM :: Parallel (HalogenAp state action slots output m) (HalogenM state action slots output m) where\n  parallel = HalogenAp <<< liftFreeAp\n  sequential = HalogenM <<< liftF <<< Par\n\ninstance monadTransHalogenM :: MonadTrans (HalogenM state action slots o) where\n  lift = HalogenM <<< liftF <<< Lift\n\ninstance monadRecHalogenM :: MonadRec (HalogenM state action slots output m) where\n  tailRecM k a = k a >>= case _ of\n    Loop x -> tailRecM k x\n    Done y -> pure y\n\ninstance monadStateHalogenM :: MonadState state (HalogenM state action slots output m) where\n  state = HalogenM <<< liftF <<< State\n\ninstance monadAskHalogenM :: MonadAsk r m => MonadAsk r (HalogenM state action slots output m) where\n  ask = HalogenM $ liftF $ Lift ask\n\ninstance monadTellHalogenM :: MonadTell w m => MonadTell w (HalogenM state action slots output m) where\n  tell = HalogenM <<< liftF <<< Lift <<< tell\n\ninstance monadThrowHalogenM :: MonadThrow e m => MonadThrow e (HalogenM state action slots output m) where\n  throwError = HalogenM <<< liftF <<< Lift <<< throwError\n\n-- | An applicative-only version of `HalogenM` to allow for parallel evaluation.\nnewtype HalogenAp state action slots output m a = HalogenAp (FreeAp (HalogenM state action slots output m) a)\n\nderive instance newtypeHalogenAp :: Newtype (HalogenAp state query slots output m a) _\nderive newtype instance functorHalogenAp :: Functor (HalogenAp state query slots output m)\nderive newtype instance applyHalogenAp :: Apply (HalogenAp state query slots output m)\nderive newtype instance applicativeHalogenAp :: Applicative (HalogenAp state query slots output m)\n\n-- | Raises an output message for the component.\nraise :: forall state action slots output m. output -> HalogenM state action slots output m Unit\nraise o = HalogenM $ liftF $ Raise o unit\n\n-- | Sends a query to a child of a component at the specified slot.\nquery\n  :: forall state action output m label slots query output' slot a _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> query a\n  -> HalogenM state action slots output m (Maybe a)\nquery label p q = HalogenM $ liftF $ ChildQuery $ CQ.mkChildQueryBox $\n  CQ.ChildQuery (\\k -> maybe (pure Nothing) k <<< Slot.lookup label p) q identity\n\n-- | Sends a query to all children of a component at a given slot label.\nqueryAll\n  :: forall state action output m label slots query output' slot a _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> query a\n  -> HalogenM state action slots output m (Map slot a)\nqueryAll label q =\n  HalogenM $ liftF $ ChildQuery $ CQ.mkChildQueryBox $\n    CQ.ChildQuery (\\k -> map catMapMaybes <<< traverse k <<< Slot.slots label) q identity\n  where\n  catMapMaybes :: forall k v. Ord k => Map k (Maybe v) -> Map k v\n  catMapMaybes = foldrWithIndex (\\k v acc -> maybe acc (flip (Map.insert k) acc) v) Map.empty\n\n-- | The ID value associated with a subscription. Allows the subscription to be\n-- | stopped at a later time.\nnewtype SubscriptionId = SubscriptionId Int\n\nderive newtype instance eqSubscriptionId :: Eq SubscriptionId\nderive newtype instance ordSubscriptionId :: Ord SubscriptionId\n\n-- | Subscribes a component to an `Emitter`.\n-- |\n-- | When a component is disposed of any active subscriptions will automatically\n-- | be stopped and no further subscriptions will be possible during\n-- | finalization.\nsubscribe :: forall state action slots output m. HS.Emitter action -> HalogenM state action slots output m SubscriptionId\nsubscribe es = HalogenM $ liftF $ Subscribe (\\_ -> es) identity\n\n-- | An alternative to `subscribe`, intended for subscriptions that unsubscribe\n-- | themselves. Instead of returning the `SubscriptionId` from `subscribe'`, it\n-- | is passed into an `Emitter` constructor. This allows emitted queries\n-- | to include the `SubscriptionId`, rather than storing it in the state of the\n-- | component.\n-- |\n-- | When a component is disposed of any active subscriptions will automatically\n-- | be stopped and no further subscriptions will be possible during\n-- | finalization.\nsubscribe' :: forall state action slots output m. (SubscriptionId -> HS.Emitter action) -> HalogenM state action slots output m Unit\nsubscribe' esc = HalogenM $ liftF $ Subscribe esc (const unit)\n\n-- | Unsubscribes a component from a subscription. If the subscription associated\n-- | with the ID has already ended this will have no effect.\nunsubscribe :: forall state action slots output m. SubscriptionId -> HalogenM state action slots output m Unit\nunsubscribe sid = HalogenM $ liftF $ Unsubscribe sid unit\n\n-- | The ID value associated with a forked process. Allows the fork to be killed\n-- | at a later time.\nnewtype ForkId = ForkId Int\n\nderive newtype instance eqForkId :: Eq ForkId\nderive newtype instance ordForkId :: Ord ForkId\n\n-- | Starts a `HalogenM` process running independent from the current `eval`\n-- | \"thread\".\n-- |\n-- | A commonly use case for `fork` is in component initializers where some\n-- | async action is started. Normally all interaction with the component will\n-- | be blocked until the initializer completes, but if the async action is\n-- | `fork`ed instead, the initializer can complete synchronously while the\n-- | async action continues.\n-- |\n-- | Some care needs to be taken when using a `fork` that can modify the\n-- | component state, as it's easy for the forked process to \"clobber\" the state\n-- | (overwrite some or all of it with an old value) by mistake.\n-- |\n-- | When a component is disposed of any active forks will automatically\n-- | be killed. New forks can be started during finalization but there will be\n-- | no means of killing them.\nfork :: forall state action slots output m. HalogenM state action slots output m Unit -> HalogenM state action slots output m ForkId\nfork hmu = HalogenM $ liftF $ Fork hmu identity\n\n-- | Joins a forked process. Attempting to join a forked process that has\n-- | already ended will result in eval continuing immediately. Attempting\n-- | to join a forked process that has been killed will also terminate the\n-- | current eval.\njoin :: forall state action slots output m. ForkId -> HalogenM state action slots output m Unit\njoin fid = HalogenM $ liftF $ Join fid unit\n\n-- | Kills a forked process if it is still running. Attempting to kill a forked\n-- | process that has already ended will have no effect.\nkill :: forall state action slots output m. ForkId -> HalogenM state action slots output m Unit\nkill fid = HalogenM $ liftF $ Kill fid unit\n\n-- | Retrieves an `Element` value that is associated with a `Ref` in the\n-- | rendered output of a component. If there is no currently rendered value for\n-- | the requested ref this will return `Nothing`.\ngetRef :: forall state action slots output m. RefLabel -> HalogenM state action slots output m (Maybe Element)\ngetRef p = HalogenM $ liftF $ GetRef p identity\n\nimapState\n  :: forall state state' action slots output m a\n   . (state -> state')\n  -> (state' -> state)\n  -> HalogenM state action slots output m a\n  -> HalogenM state' action slots output m a\nimapState f f' (HalogenM h) = HalogenM (hoistFree go h)\n  where\n  go :: HalogenF state action slots output m ~> HalogenF state' action slots output m\n  go = case _ of\n    State fs -> State (map f <<< fs <<< f')\n    Subscribe fes k -> Subscribe fes k\n    Unsubscribe sid a -> Unsubscribe sid a\n    Lift q -> Lift q\n    ChildQuery cq -> ChildQuery cq\n    Raise o a -> Raise o a\n    Par p -> Par (over HalogenAp (hoistFreeAp (imapState f f')) p)\n    Fork hmu k -> Fork (imapState f f' hmu) k\n    Join fid a -> Join fid a\n    Kill fid a -> Kill fid a\n    GetRef p k -> GetRef p k\n\nmapAction\n  :: forall state action action' slots output m a\n   . Functor m\n  => (action -> action')\n  -> HalogenM state action slots output m a\n  -> HalogenM state action' slots output m a\nmapAction f (HalogenM h) = HalogenM (hoistFree go h)\n  where\n  go :: HalogenF state action slots output m ~> HalogenF state action' slots output m\n  go = case _ of\n    State fs -> State fs\n    Subscribe fes k -> Subscribe (map f <<< fes) k\n    Unsubscribe sid a -> Unsubscribe sid a\n    Lift q -> Lift q\n    ChildQuery cq -> ChildQuery cq\n    Raise o a -> Raise o a\n    Par p -> Par (over HalogenAp (hoistFreeAp (mapAction f)) p)\n    Fork hmu k -> Fork (mapAction f hmu) k\n    Join fid a -> Join fid a\n    Kill fid a -> Kill fid a\n    GetRef p k -> GetRef p k\n\nmapOutput\n  :: forall state action slots output output' m a\n   . (output -> output')\n  -> HalogenM state action slots output m a\n  -> HalogenM state action slots output' m a\nmapOutput f (HalogenM h) = HalogenM (hoistFree go h)\n  where\n  go :: HalogenF state action slots output m ~> HalogenF state action slots output' m\n  go = case _ of\n    State fs -> State fs\n    Subscribe fes k -> Subscribe fes k\n    Unsubscribe sid a -> Unsubscribe sid a\n    Lift q -> Lift q\n    ChildQuery cq -> ChildQuery cq\n    Raise o a -> Raise (f o) a\n    Par p -> Par (over HalogenAp (hoistFreeAp (mapOutput f)) p)\n    Fork hmu k -> Fork (mapOutput f hmu) k\n    Join fid a -> Join fid a\n    Kill fid a -> Kill fid a\n    GetRef p k -> GetRef p k\n\nhoist\n  :: forall state action slots output m m' a\n   . Functor m'\n  => (m ~> m')\n  -> HalogenM state action slots output m a\n  -> HalogenM state action slots output m' a\nhoist nat (HalogenM fa) = HalogenM (hoistFree go fa)\n  where\n  go :: HalogenF state action slots output m ~> HalogenF state action slots output m'\n  go = case _ of\n    State f -> State f\n    Subscribe fes k -> Subscribe fes k\n    Unsubscribe sid a -> Unsubscribe sid a\n    Lift q -> Lift (nat q)\n    ChildQuery cq -> ChildQuery cq\n    Raise o a -> Raise o a\n    Par p -> Par (over HalogenAp (hoistFreeAp (hoist nat)) p)\n    Fork hmu k -> Fork (hoist nat hmu) k\n    Join fid a -> Join fid a\n    Kill fid a -> Kill fid a\n    GetRef p k -> GetRef p k\n","module Halogen.Query.HalogenQ where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Coyoneda (Coyoneda)\n\ndata HalogenQ query action input a\n  = Initialize a\n  | Finalize a\n  | Receive input a\n  | Action action a\n  | Query (Coyoneda query a) (Unit -> a)\n\ninstance bifunctorHalogenQ :: Bifunctor (HalogenQ query action) where\n  bimap f g = case _ of\n    Initialize a -> Initialize (g a)\n    Finalize a -> Finalize (g a)\n    Receive i a -> Receive (f i) (g a)\n    Action action a -> Action action (g a)\n    Query fa k -> Query (map g fa) (map g k)\n\nderive instance functorHalogenQ :: Functor (HalogenQ query action input)\n","module Halogen.VDom.Thunk\n  ( Thunk\n  , buildThunk\n  , runThunk\n  , hoist\n  , mapThunk\n  , thunked\n  , thunk1\n  , thunk2\n  , thunk3\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried as Fn\nimport Effect.Uncurried as EFn\nimport Halogen.VDom as V\nimport Halogen.VDom.Machine as M\nimport Halogen.VDom.Util as Util\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Node (Node)\n\nforeign import data ThunkArg ∷ Type\n\nforeign import data ThunkId ∷ Type\n\ndata Thunk :: (Type -> Type) -> Type -> Type\ndata Thunk f i = Thunk ThunkId (Fn.Fn2 ThunkArg ThunkArg Boolean) (ThunkArg → f i) ThunkArg\n\nunsafeThunkId ∷ ∀ a. a → ThunkId\nunsafeThunkId = unsafeCoerce\n\ninstance functorThunk ∷ Functor f ⇒ Functor (Thunk f) where\n  map f (Thunk a b c d) = Thunk a b (c >>> map f) d\n\nhoist ∷ ∀ f g. (f ~> g) → Thunk f ~> Thunk g\nhoist = mapThunk\n\nmapThunk ∷ ∀ f g i j. (f i -> g j) → Thunk f i -> Thunk g j\nmapThunk k (Thunk a b c d) = Thunk a b (c >>> k) d\n\nthunk ∷ ∀ a f i. Fn.Fn4 ThunkId (Fn.Fn2 a a Boolean) (a → f i) a (Thunk f i)\nthunk = Fn.mkFn4 \\tid eqFn f a →\n  Thunk tid\n    (unsafeCoerce eqFn ∷ Fn.Fn2 ThunkArg ThunkArg Boolean)\n    (unsafeCoerce f ∷ ThunkArg → f i)\n    (unsafeCoerce a ∷ ThunkArg)\n\nthunked ∷ ∀ a f i. (a → a → Boolean) → (a → f i) → a → Thunk f i\nthunked eqFn f =\n  let\n    tid = unsafeThunkId { f }\n    eqFn' = Fn.mkFn2 eqFn\n  in\n    \\a → Fn.runFn4 thunk tid eqFn' f a\n\nthunk1 ∷ ∀ a f i. Fn.Fn2 (a → f i) a (Thunk f i)\nthunk1 = Fn.mkFn2 \\f a → Fn.runFn4 thunk (unsafeThunkId f) Util.refEq f a\n\nthunk2 ∷ ∀ a b f i. Fn.Fn3 (a → b → f i) a b (Thunk f i)\nthunk2 =\n  let\n    eqFn = Fn.mkFn2 \\a b →\n      Fn.runFn2 Util.refEq a._1 b._1 &&\n      Fn.runFn2 Util.refEq a._2 b._2\n  in\n    Fn.mkFn3 \\f a b →\n      Fn.runFn4 thunk (unsafeThunkId f) eqFn (\\{ _1, _2 } → f _1 _2) { _1: a, _2: b }\n\nthunk3 ∷ ∀ a b c f i. Fn.Fn4 (a → b → c → f i) a b c (Thunk f i)\nthunk3 =\n  let\n    eqFn = Fn.mkFn2 \\a b →\n      Fn.runFn2 Util.refEq a._1 b._1 &&\n      Fn.runFn2 Util.refEq a._2 b._2 &&\n      Fn.runFn2 Util.refEq a._3 b._3\n  in\n    Fn.mkFn4 \\f a b c →\n      Fn.runFn4 thunk (unsafeThunkId f) eqFn (\\{ _1, _2, _3 } → f _1 _2 _3) { _1: a, _2: b, _3: c }\n\nrunThunk ∷ ∀ f i. Thunk f i → f i\nrunThunk (Thunk _ _ render arg) = render arg\n\nunsafeEqThunk ∷ ∀ f i. Fn.Fn2 (Thunk f i) (Thunk f i) Boolean\nunsafeEqThunk = Fn.mkFn2 \\(Thunk a1 b1 _ d1) (Thunk a2 b2 _ d2) →\n  Fn.runFn2 Util.refEq a1 a2 &&\n  Fn.runFn2 Util.refEq b1 b2 &&\n  Fn.runFn2 b1 d1 d2\n\ntype ThunkState :: (Type -> Type) -> Type -> Type -> Type -> Type\ntype ThunkState f i a w =\n  { thunk ∷ Thunk f i\n  , vdom ∷ M.Step (V.VDom a w) Node\n  }\n\nbuildThunk\n  ∷ ∀ f i a w\n  . (f i → V.VDom a w)\n  → V.VDomSpec a w\n  → V.Machine (Thunk f i) Node\nbuildThunk toVDom = renderThunk\n  where\n  renderThunk ∷ V.VDomSpec a w → V.Machine (Thunk f i) Node\n  renderThunk spec = EFn.mkEffectFn1 \\t → do\n    vdom ← EFn.runEffectFn1 (V.buildVDom spec) (toVDom (runThunk t))\n    pure $ M.mkStep $ M.Step (M.extract vdom) { thunk: t, vdom } patchThunk haltThunk\n\n  patchThunk ∷ EFn.EffectFn2 (ThunkState f i a w) (Thunk f i) (V.Step (Thunk f i) Node)\n  patchThunk = EFn.mkEffectFn2 \\state t2 → do\n    let { vdom: prev, thunk: t1 } = state\n    if Fn.runFn2 unsafeEqThunk t1 t2\n      then pure $ M.mkStep $ M.Step (M.extract prev) state patchThunk haltThunk\n      else do\n        vdom ← EFn.runEffectFn2 M.step prev (toVDom (runThunk t2))\n        pure $ M.mkStep $ M.Step (M.extract vdom) { vdom, thunk: t2 } patchThunk haltThunk\n\n  haltThunk ∷ EFn.EffectFn1 (ThunkState f i a w) Unit\n  haltThunk = EFn.mkEffectFn1 \\state → do\n    EFn.runEffectFn1 M.halt state.vdom\n","module Halogen.Component\n  ( Component\n  , ComponentSpec\n  , mkComponent\n  , unComponent\n  , hoist\n  , EvalSpec\n  , mkEval\n  , defaultEval\n  , ComponentSlotBox\n  , ComponentSlot(..)\n  , componentSlot\n  , ComponentSlotSpec\n  , mkComponentSlot\n  , unComponentSlot\n  , hoistSlot\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (bimap, lmap)\nimport Data.Coyoneda (unCoyoneda)\nimport Data.Foldable (traverse_)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Symbol (class IsSymbol)\nimport Data.Tuple (Tuple)\nimport Halogen.Data.Slot (Slot, SlotStorage)\nimport Halogen.Data.Slot as Slot\nimport Halogen.HTML.Core as HC\nimport Halogen.Query.HalogenM (HalogenM)\nimport Halogen.Query.HalogenM as HM\nimport Halogen.Query.HalogenQ (HalogenQ(..))\nimport Halogen.VDom.Thunk (Thunk)\nimport Halogen.VDom.Thunk as Thunk\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | The \"public\" type for a component, with details of the component internals\n-- | existentially hidden.\n-- |\n-- |   `HTML`\n-- | - `query` is the query algebra; the requests that can be made of the\n-- |   component\n-- | - `input` is the input value that will be received when the parent of\n-- |   this component renders\n-- | - `output` is the type of messages the component can raise\n-- | - `m` is the effect monad used during evaluation\ndata Component\n  (query :: Type -> Type)\n  (input :: Type)\n  (output :: Type)\n  (m :: Type -> Type)\n\n-- | The spec for a component.\n-- |\n-- | The type variables involved:\n-- | - `state` is the component's state\n-- | - `query` is the query algebra; the requests that can be made of the\n-- |   component\n-- | - `action` is the type of actions; messages internal to the component that\n-- |   can be evaluated\n-- | - `slots` is the set of slots for addressing child components\n-- | - `input` is the input value that will be received when the parent of\n-- |   this component renders\n-- | - `output` is the type of messages the component can raise\n-- | - `m` is the effect monad used during evaluation\n-- |\n-- | The values in the record:\n-- | - `initialState` is a function that accepts an input value and produces the\n-- |   state the component will start with. If the input value is unused\n-- |   (`Unit`), or irrelevant to the state construction, this will often be\n-- |   `const ?someInitialStateValue`.\n-- | - `render` is a function that accepts the component's current state and\n-- |   produces a value to render (`HTML` usually). The rendered output can\n-- |   raise actions that will be handled in `eval`.\n-- | - `eval` is a function that handles the `HalogenQ` algebra that deals with\n-- |   component lifecycle, handling actions, and responding to requests.\ntype ComponentSpec state query action slots input output m =\n  { initialState :: input -> state\n  , render :: state -> HC.HTML (ComponentSlot slots m action) action\n  , eval :: HalogenQ query action input ~> HalogenM state action slots output m\n  }\n\n-- | Constructs a [`Component`](#t:Component) from a [`ComponentSpec`](#t:ComponentSpec).\nmkComponent\n  :: forall state query action slots input output m\n   . ComponentSpec state query action slots input output m\n  -> Component query input output m\nmkComponent = unsafeCoerce\n\n-- | Exposes the inner details of a [`Component`](#t:Component) to a function\n-- | to produce a new result.\n-- |\n-- | The hidden details will not be allowed to be revealed in the result\n-- | of the function - if any of the hidden types (state, action, set of slots)\n-- | appear in the result, the compiler will complain about an escaped skolem.\nunComponent\n  :: forall query input output m a\n   . (forall state action slots. ComponentSpec state query action slots input output m -> a)\n  -> Component query input output m\n  -> a\nunComponent = unsafeCoerce\n\n-- | Changes the [`Component`](#t:Component)'s `m` type. A use case for this\n-- | might be to interpret some `Free` monad as `Aff` so the component can be\n-- | used with `runUI`.\nhoist\n  :: forall query input output m m'\n   . Functor m'\n  => (m ~> m')\n  -> Component query input output m\n  -> Component query input output m'\nhoist nat = unComponent \\c ->\n  mkComponent\n    { initialState: c.initialState\n    , render: lmap (hoistSlot nat) <<< c.render\n    , eval: HM.hoist nat <<< c.eval\n    }\n\n-- | The spec record that `mkEval` accepts to construct a component `eval`\n-- | function.\n-- |\n-- | It's not a requirement to use `mkEval`, and sometimes it's preferrable\n-- | to write a component `eval` function from scratch, but often `mkEval` is\n-- | more convenient for common cases.\n-- |\n-- | See below for more details about `mkEval` and `defaultEval`.\ntype EvalSpec state query action slots input output m =\n  { handleAction :: action -> HalogenM state action slots output m Unit\n  , handleQuery :: forall a. query a -> HalogenM state action slots output m (Maybe a)\n  , receive :: input -> Maybe action\n  , initialize :: Maybe action\n  , finalize :: Maybe action\n  }\n\n-- | A default value for `mkEval` that will result in an `eval` that nothing at\n-- | all - all incoming actions and queries will be ignored, and no receiver,\n-- | initializer, or finalizer will be specified.\n-- |\n-- | Usually this will be used with record update syntax to override fields to\n-- | specify things as needed. If a component only needs to handle actions,\n-- | for instance, a usage might be something like this:\n-- |\n-- | ```purescript\n-- | H.mkComponent\n-- |   { initialState\n-- |   , render\n-- |   , eval: H.mkEval (H.defaultEval { handleAction = ?handleAction })\n-- |   }\n-- | ```\ndefaultEval :: forall state query action slots input output m. EvalSpec state query action slots input output m\ndefaultEval =\n  { handleAction: const (pure unit)\n  , handleQuery: const (pure Nothing)\n  , receive: const Nothing\n  , initialize: Nothing\n  , finalize: Nothing\n  }\n\n-- | Accepts an `EvalSpec` to produce an `eval` function for a component. For\n-- | example:\n-- |\n-- | ```purescript\n-- | -- use `defaultEval` and override fields selectively\n-- | H.mkEval (H.defaultEval { handleAction = ?handleAction })\n-- |\n-- | -- or specify all the fields in the `EvalSpec`\n-- | H.mkEval\n-- |   { handleAction: ?handleAction\n-- |   , handleQuery: ?handleQuery\n-- |   , receive: ?receive\n-- |   , initialize: ?initialize\n-- |   , finalize: ?finalize\n-- |   }\n-- | ```\nmkEval\n  :: forall state query action slots input output m a\n   . EvalSpec state query action slots input output m\n  -> HalogenQ query action input a\n  -> HalogenM state action slots output m a\nmkEval args = case _ of\n  Initialize a ->\n    traverse_ args.handleAction args.initialize $> a\n  Finalize a ->\n    traverse_ args.handleAction args.finalize $> a\n  Receive i a ->\n    traverse_ args.handleAction (args.receive i) $> a\n  Action action a ->\n    args.handleAction action $> a\n  Query req f ->\n    unCoyoneda (\\g -> map (maybe (f unit) g) <<< args.handleQuery) req\n\n-- | A slot for a child component in a component's rendered content.\ndata ComponentSlotBox\n  (slots :: Row Type)\n  (m :: Type -> Type)\n  (action :: Type)\n\ninstance functorComponentSlotBox :: Functor (ComponentSlotBox slots m) where\n  map f = unComponentSlot \\slot ->\n    mkComponentSlot $ slot { output = map f <$> slot.output }\n\ndata ComponentSlot slots m action\n  = ComponentSlot (ComponentSlotBox slots m action)\n  | ThunkSlot (Thunk (HC.HTML (ComponentSlot slots m action)) action)\n\ninstance functorComponentSlot :: Functor (ComponentSlot slots m) where\n  map f = case _ of\n    ComponentSlot box -> ComponentSlot (map f box)\n    ThunkSlot thunk -> ThunkSlot (Thunk.mapThunk (bimap (map f) f) thunk)\n\n-- | Constructs a [`ComponentSlot`](#t:ComponentSlot).\n-- |\n-- | Takes:\n-- | - the slot address label\n-- | - the slot address index\n-- | - the component for the slot\n-- | - the input value to pass to the component\n-- | - a function mapping outputs from the component to a query in the parent\ncomponentSlot\n  :: forall query input output slots m action label slot _1\n   . Row.Cons label (Slot query output slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Component query input output m\n  -> input\n  -> (output -> Maybe action)\n  -> ComponentSlotBox slots m action\ncomponentSlot label p comp input output =\n  mkComponentSlot\n    { get: Slot.lookup label p\n    , pop: Slot.pop label p\n    , set: Slot.insert label p\n    , component: comp\n    , input: input\n    , output\n    }\n\n-- | The internal representation used for a [`ComponentSlot`](#t:ComponentSlot).\ntype ComponentSlotSpec query input output slots m action =\n  { get :: forall slot. SlotStorage slots slot -> Maybe (slot query output)\n  , pop :: forall slot. SlotStorage slots slot -> Maybe (Tuple (slot query output) (SlotStorage slots slot))\n  , set :: forall slot. slot query output -> SlotStorage slots slot -> SlotStorage slots slot\n  , component :: Component query input output m\n  , input :: input\n  , output :: output -> Maybe action\n  }\n\n-- | Constructs [`ComponentSlotBox`](#t:ComponentSlot) from a [`ComponentSlotSpec`](#t:ComponentSlotSpec).\nmkComponentSlot\n  :: forall query input output slots m action\n   . ComponentSlotSpec query input output slots m action\n  -> ComponentSlotBox slots m action\nmkComponentSlot = unsafeCoerce\n\n-- | Exposes the inner details of a [`ComponentSlot`](#t:ComponentSlot) to a\n-- | function to produce a new result.\n-- |\n-- |  The hidden details will not be allowed to be revealed in the result\n-- | of the function - if any of the hidden types (state, action, set of slots)\n-- | appear in the result, the compiler will complain about an escaped skolem.\nunComponentSlot\n  :: forall slots m action a\n   . (forall query input output. ComponentSlotSpec query input output slots m action -> a)\n  -> ComponentSlotBox slots m action\n  -> a\nunComponentSlot = unsafeCoerce\n\n-- | Changes the [`ComponentSlot`](#t:ComponentSlot)'s `m` type.\nhoistSlot\n  :: forall slots m m' action\n   . Functor m'\n  => (m ~> m')\n  -> ComponentSlot slots m action\n  -> ComponentSlot slots m' action\nhoistSlot nat = case _ of\n  ComponentSlot cs ->\n    cs # unComponentSlot \\slot ->\n      ComponentSlot $ mkComponentSlot $ slot { component = hoist nat slot.component }\n  ThunkSlot t ->\n    ThunkSlot $ Thunk.hoist (lmap (hoistSlot nat)) t\n","module Halogen.HTML.Elements\n  ( Node\n  , Leaf\n  , element\n  , elementNS\n  , keyed\n  , keyedNS\n  , withKeys\n  , withKeys_\n  , a\n  , a_\n  , abbr\n  , abbr_\n  , address\n  , address_\n  , area\n  , article\n  , article_\n  , aside\n  , aside_\n  , audio\n  , audio_\n  , b\n  , b_\n  , base\n  , bdi\n  , bdi_\n  , bdo\n  , bdo_\n  , blockquote\n  , blockquote_\n  , body\n  , body_\n  , br\n  , br_\n  , button\n  , button_\n  , canvas\n  , caption\n  , caption_\n  , cite\n  , cite_\n  , code\n  , code_\n  , col\n  , colgroup\n  , colgroup_\n  , command\n  , datalist\n  , datalist_\n  , dd\n  , dd_\n  , del\n  , del_\n  , details\n  , details_\n  , dfn\n  , dfn_\n  , dialog\n  , dialog_\n  , div\n  , div_\n  , dl\n  , dl_\n  , dt\n  , dt_\n  , em\n  , em_\n  , embed\n  , embed_\n  , fieldset\n  , fieldset_\n  , figcaption\n  , figcaption_\n  , figure\n  , figure_\n  , footer\n  , footer_\n  , form\n  , form_\n  , h1\n  , h1_\n  , h2\n  , h2_\n  , h3\n  , h3_\n  , h4\n  , h4_\n  , h5\n  , h5_\n  , h6\n  , h6_\n  , head\n  , head_\n  , header\n  , header_\n  , hr\n  , hr_\n  , html\n  , html_\n  , i\n  , i_\n  , iframe\n  , img\n  , input\n  , ins\n  , ins_\n  , kbd\n  , kbd_\n  , label\n  , label_\n  , legend\n  , legend_\n  , li\n  , li_\n  , link\n  , main\n  , main_\n  , map\n  , map_\n  , mark\n  , mark_\n  , menu\n  , menu_\n  , menuitem\n  , menuitem_\n  , meta\n  , meter\n  , meter_\n  , nav\n  , nav_\n  , noscript\n  , noscript_\n  , object\n  , object_\n  , ol\n  , ol_\n  , optgroup\n  , optgroup_\n  , option\n  , option_\n  , output\n  , output_\n  , p\n  , p_\n  , param\n  , pre\n  , pre_\n  , progress\n  , progress_\n  , q\n  , q_\n  , rp\n  , rp_\n  , rt\n  , rt_\n  , ruby\n  , ruby_\n  , samp\n  , samp_\n  , script\n  , script_\n  , section\n  , section_\n  , select\n  , select_\n  , small\n  , small_\n  , source\n  , span\n  , span_\n  , strong\n  , strong_\n  , style\n  , style_\n  , sub\n  , sub_\n  , summary\n  , summary_\n  , sup\n  , sup_\n  , table\n  , table_\n  , tbody\n  , tbody_\n  , td\n  , td_\n  , textarea\n  , tfoot\n  , tfoot_\n  , th\n  , th_\n  , thead\n  , thead_\n  , time\n  , time_\n  , title\n  , title_\n  , tr\n  , tr_\n  , track\n  , u\n  , u_\n  , ul\n  , ul_\n  , var\n  , var_\n  , video\n  , video_\n  , wbr\n  ) where\n\nimport Prelude ((#), (>>>), pure)\nimport Data.Maybe (Maybe(Nothing))\nimport Data.Tuple (Tuple)\n\nimport DOM.HTML.Indexed as I\n\nimport Halogen.HTML.Core (ElemName(..), HTML(..), Namespace, Prop)\nimport Halogen.HTML.Core as Core\nimport Halogen.HTML.Properties (IProp)\nimport Halogen.Query.Input (Input)\nimport Halogen.VDom as VDom\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An HTML element that admits children.\ntype Node r w i = Array (IProp r i) -> Array (HTML w i) -> HTML w i\n\n-- | An HTML element that does not admit children.\ntype Leaf r w i = Array (IProp r i) -> HTML w i\n\n-- | Creates an HTML element that expects indexed properties.\nelement :: forall r w i. ElemName -> Array (IProp r i) -> Array (HTML w i) -> HTML w i\nelement =\n  Core.element Nothing #\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (HTML w i)\n        -> HTML w i\n    )\n\n-- | Creates a Namespaced HTML element that expects indexed properties.\nelementNS :: forall r w i. Namespace -> ElemName -> Array (IProp r i) -> Array (HTML w i) -> HTML w i\nelementNS =\n  pure >>> Core.element >>>\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (HTML w i)\n        -> HTML w i\n    )\n\n-- | Creates an HTML element that expects indexed properties, with keyed\n-- | children.\nkeyed :: forall r w i. ElemName -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyed =\n  Core.keyed Nothing #\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (Tuple String (HTML w i))\n        -> HTML w i\n    )\n\n-- | Creates a Namespaced HTML element that expects indexed properties, with\n-- | keyed children.\nkeyedNS :: forall r w i. Namespace -> ElemName -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyedNS =\n  pure >>> Core.keyed >>>\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (Tuple String (HTML w i))\n        -> HTML w i\n    )\n\nwithKeys :: forall r w i. (Array (IProp r i) -> Array (HTML w i) -> HTML w i) -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nwithKeys ctor props children =\n  case ctor props [] of\n    HTML (VDom.Elem x y z _) -> HTML (VDom.Keyed x y z (coe children))\n    h -> h\n  where\n  coe :: Array (Tuple String (HTML w i)) -> Array (Tuple String (VDom.VDom (Array (Prop (Input i))) w))\n  coe = unsafeCoerce\n\nwithKeys_ :: forall w i. (Array (HTML w i) -> HTML w i) -> Array (Tuple String (HTML w i)) -> HTML w i\nwithKeys_ ctor children =\n  case ctor [] of\n    HTML (VDom.Elem x y z _) -> HTML (VDom.Keyed x y z (coe children))\n    h -> h\n  where\n  coe :: Array (Tuple String (HTML w i)) -> Array (Tuple String (VDom.VDom (Array (Prop (Input i))) w))\n  coe = unsafeCoerce\n\na :: forall w i. Node I.HTMLa w i\na = element (ElemName \"a\")\n\na_ :: forall w i. Array (HTML w i) -> HTML w i\na_ = a []\n\nabbr :: forall w i. Node I.HTMLabbr w i\nabbr = element (ElemName \"abbr\")\n\nabbr_ :: forall w i. Array (HTML w i) -> HTML w i\nabbr_ = abbr []\n\naddress :: forall w i. Node I.HTMLaddress w i\naddress = element (ElemName \"address\")\n\naddress_ :: forall w i. Array (HTML w i) -> HTML w i\naddress_ = address []\n\narea :: forall w i. Leaf I.HTMLarea w i\narea props = element (ElemName \"area\") props []\n\narticle :: forall w i. Node I.HTMLarticle w i\narticle = element (ElemName \"article\")\n\narticle_ :: forall w i. Array (HTML w i) -> HTML w i\narticle_ = article []\n\naside :: forall w i. Node I.HTMLaside w i\naside = element (ElemName \"aside\")\n\naside_ :: forall w i. Array (HTML w i) -> HTML w i\naside_ = aside []\n\naudio :: forall w i. Node I.HTMLaudio w i\naudio = element (ElemName \"audio\")\n\naudio_ :: forall w i. Array (HTML w i) -> HTML w i\naudio_ = audio []\n\nb :: forall w i. Node I.HTMLb w i\nb = element (ElemName \"b\")\n\nb_ :: forall w i. Array (HTML w i) -> HTML w i\nb_ = b []\n\nbase :: forall w i. Leaf I.HTMLbase w i\nbase props = element (ElemName \"base\") props []\n\nbdi :: forall w i. Node I.HTMLbdi w i\nbdi = element (ElemName \"bdi\")\n\nbdi_ :: forall w i. Array (HTML w i) -> HTML w i\nbdi_ = bdi []\n\nbdo :: forall w i. Node I.HTMLbdo w i\nbdo = element (ElemName \"bdo\")\n\nbdo_ :: forall w i. Array (HTML w i) -> HTML w i\nbdo_ = bdo []\n\nblockquote :: forall w i. Node I.HTMLblockquote w i\nblockquote = element (ElemName \"blockquote\")\n\nblockquote_ :: forall w i. Array (HTML w i) -> HTML w i\nblockquote_ = blockquote []\n\nbody :: forall w i. Node I.HTMLbody w i\nbody = element (ElemName \"body\")\n\nbody_ :: forall w i. Array (HTML w i) -> HTML w i\nbody_ = body []\n\nbr :: forall w i. Leaf I.HTMLbr w i\nbr props = element (ElemName \"br\") props []\n\nbr_ :: forall w i. HTML w i\nbr_ = br []\n\nbutton :: forall w i. Node I.HTMLbutton w i\nbutton = element (ElemName \"button\")\n\nbutton_ :: forall w i. Array (HTML w i) -> HTML w i\nbutton_ = button []\n\ncanvas :: forall w i. Leaf I.HTMLcanvas w i\ncanvas props = element (ElemName \"canvas\") props []\n\ncaption :: forall w i. Node I.HTMLcaption w i\ncaption = element (ElemName \"caption\")\n\ncaption_ :: forall w i. Array (HTML w i) -> HTML w i\ncaption_ = caption []\n\ncite :: forall w i. Node I.HTMLcite w i\ncite = element (ElemName \"cite\")\n\ncite_ :: forall w i. Array (HTML w i) -> HTML w i\ncite_ = cite []\n\ncode :: forall w i. Node I.HTMLcode w i\ncode = element (ElemName \"code\")\n\ncode_ :: forall w i. Array (HTML w i) -> HTML w i\ncode_ = code []\n\ncol :: forall w i. Leaf I.HTMLcol w i\ncol props = element (ElemName \"col\") props []\n\ncolgroup :: forall w i. Node I.HTMLcolgroup w i\ncolgroup = element (ElemName \"colgroup\")\n\ncolgroup_ :: forall w i. Array (HTML w i) -> HTML w i\ncolgroup_ = colgroup []\n\ncommand :: forall w i. Leaf I.HTMLcommand w i\ncommand props = element (ElemName \"command\") props []\n\ndatalist :: forall w i. Node I.HTMLdatalist w i\ndatalist = element (ElemName \"datalist\")\n\ndatalist_ :: forall w i. Array (HTML w i) -> HTML w i\ndatalist_ = datalist []\n\ndd :: forall w i. Node I.HTMLdd w i\ndd = element (ElemName \"dd\")\n\ndd_ :: forall w i. Array (HTML w i) -> HTML w i\ndd_ = dd []\n\ndel :: forall w i. Node I.HTMLdel w i\ndel = element (ElemName \"del\")\n\ndel_ :: forall w i. Array (HTML w i) -> HTML w i\ndel_ = del []\n\ndetails :: forall w i. Node I.HTMLdetails w i\ndetails = element (ElemName \"details\")\n\ndetails_ :: forall w i. Array (HTML w i) -> HTML w i\ndetails_ = details []\n\ndfn :: forall w i. Node I.HTMLdfn w i\ndfn = element (ElemName \"dfn\")\n\ndfn_ :: forall w i. Array (HTML w i) -> HTML w i\ndfn_ = dfn []\n\ndialog :: forall w i. Node I.HTMLdialog w i\ndialog = element (ElemName \"dialog\")\n\ndialog_ :: forall w i. Array (HTML w i) -> HTML w i\ndialog_ = dialog []\n\ndiv :: forall w i. Node I.HTMLdiv w i\ndiv = element (ElemName \"div\")\n\ndiv_ :: forall w i. Array (HTML w i) -> HTML w i\ndiv_ = div []\n\ndl :: forall w i. Node I.HTMLdl w i\ndl = element (ElemName \"dl\")\n\ndl_ :: forall w i. Array (HTML w i) -> HTML w i\ndl_ = dl []\n\ndt :: forall w i. Node (I.HTMLdt) w i\ndt = element (ElemName \"dt\")\n\ndt_ :: forall w i. Array (HTML w i) -> HTML w i\ndt_ = dt []\n\nem :: forall w i. Node I.HTMLem w i\nem = element (ElemName \"em\")\n\nem_ :: forall w i. Array (HTML w i) -> HTML w i\nem_ = em []\n\nembed :: forall w i. Node I.HTMLembed w i\nembed = element (ElemName \"embed\")\n\nembed_ :: forall w i. Array (HTML w i) -> HTML w i\nembed_ = embed []\n\nfieldset :: forall w i. Node I.HTMLfieldset w i\nfieldset = element (ElemName \"fieldset\")\n\nfieldset_ :: forall w i. Array (HTML w i) -> HTML w i\nfieldset_ = fieldset []\n\nfigcaption :: forall w i. Node I.HTMLfigcaption w i\nfigcaption = element (ElemName \"figcaption\")\n\nfigcaption_ :: forall w i. Array (HTML w i) -> HTML w i\nfigcaption_ = figcaption []\n\nfigure :: forall w i. Node I.HTMLfigure w i\nfigure = element (ElemName \"figure\")\n\nfigure_ :: forall w i. Array (HTML w i) -> HTML w i\nfigure_ = figure []\n\nfooter :: forall w i. Node I.HTMLfooter w i\nfooter = element (ElemName \"footer\")\n\nfooter_ :: forall w i. Array (HTML w i) -> HTML w i\nfooter_ = footer []\n\nform :: forall w i. Node I.HTMLform w i\nform = element (ElemName \"form\")\n\nform_ :: forall w i. Array (HTML w i) -> HTML w i\nform_ = form []\n\nh1 :: forall w i. Node I.HTMLh1 w i\nh1 = element (ElemName \"h1\")\n\nh1_ :: forall w i. Array (HTML w i) -> HTML w i\nh1_ = h1 []\n\nh2 :: forall w i. Node I.HTMLh2 w i\nh2 = element (ElemName \"h2\")\n\nh2_ :: forall w i. Array (HTML w i) -> HTML w i\nh2_ = h2 []\n\nh3 :: forall w i. Node I.HTMLh3 w i\nh3 = element (ElemName \"h3\")\n\nh3_ :: forall w i. Array (HTML w i) -> HTML w i\nh3_ = h3 []\n\nh4 :: forall w i. Node I.HTMLh4 w i\nh4 = element (ElemName \"h4\")\n\nh4_ :: forall w i. Array (HTML w i) -> HTML w i\nh4_ = h4 []\n\nh5 :: forall w i. Node I.HTMLh5 w i\nh5 = element (ElemName \"h5\")\n\nh5_ :: forall w i. Array (HTML w i) -> HTML w i\nh5_ = h5 []\n\nh6 :: forall w i. Node I.HTMLh6 w i\nh6 = element (ElemName \"h6\")\n\nh6_ :: forall w i. Array (HTML w i) -> HTML w i\nh6_ = h6 []\n\nhead :: forall w i. Node I.HTMLhead w i\nhead = element (ElemName \"head\")\n\nhead_ :: forall w i. Array (HTML w i) -> HTML w i\nhead_ = head []\n\nheader :: forall w i. Node I.HTMLheader w i\nheader = element (ElemName \"header\")\n\nheader_ :: forall w i. Array (HTML w i) -> HTML w i\nheader_ = header []\n\nhr :: forall w i. Leaf I.HTMLhr w i\nhr props = element (ElemName \"hr\") props []\n\nhr_ :: forall w i. HTML w i\nhr_ = hr []\n\nhtml :: forall w i. Node I.HTMLhtml w i\nhtml = element (ElemName \"html\")\n\nhtml_ :: forall w i. Array (HTML w i) -> HTML w i\nhtml_ = html []\n\ni :: forall w i. Node I.HTMLi w i\ni = element (ElemName \"i\")\n\ni_ :: forall w i. Array (HTML w i) -> HTML w i\ni_ = i []\n\niframe :: forall w i. Leaf I.HTMLiframe w i\niframe props = element (ElemName \"iframe\") props []\n\nimg :: forall w i. Leaf I.HTMLimg w i\nimg props = element (ElemName \"img\") props []\n\ninput :: forall w i. Leaf I.HTMLinput w i\ninput props = element (ElemName \"input\") props []\n\nins :: forall w i. Node I.HTMLins w i\nins = element (ElemName \"ins\")\n\nins_ :: forall w i. Array (HTML w i) -> HTML w i\nins_ = ins []\n\nkbd :: forall w i. Node I.HTMLkbd w i\nkbd = element (ElemName \"kbd\")\n\nkbd_ :: forall w i. Array (HTML w i) -> HTML w i\nkbd_ = kbd []\n\nlabel :: forall w i. Node I.HTMLlabel w i\nlabel = element (ElemName \"label\")\n\nlabel_ :: forall w i. Array (HTML w i) -> HTML w i\nlabel_ = label []\n\nlegend :: forall w i. Node I.HTMLlegend w i\nlegend = element (ElemName \"legend\")\n\nlegend_ :: forall w i. Array (HTML w i) -> HTML w i\nlegend_ = legend []\n\nli :: forall w i. Node I.HTMLli w i\nli = element (ElemName \"li\")\n\nli_ :: forall w i. Array (HTML w i) -> HTML w i\nli_ = li []\n\nlink :: forall w i. Leaf I.HTMLlink w i\nlink props = element (ElemName \"link\") props []\n\nmain :: forall w i. Node I.HTMLmain w i\nmain = element (ElemName \"main\")\n\nmain_ :: forall w i. Array (HTML w i) -> HTML w i\nmain_ = main []\n\nmap :: forall w i. Node I.HTMLmap w i\nmap = element (ElemName \"map\")\n\nmap_ :: forall w i. Array (HTML w i) -> HTML w i\nmap_ = map []\n\nmark :: forall w i. Node I.HTMLmark w i\nmark = element (ElemName \"mark\")\n\nmark_ :: forall w i. Array (HTML w i) -> HTML w i\nmark_ = mark []\n\nmenu :: forall w i. Node I.HTMLmenu w i\nmenu = element (ElemName \"menu\")\n\nmenu_ :: forall w i. Array (HTML w i) -> HTML w i\nmenu_ = menu []\n\nmenuitem :: forall w i. Node I.HTMLmenuitem w i\nmenuitem = element (ElemName \"menuitem\")\n\nmenuitem_ :: forall w i. Array (HTML w i) -> HTML w i\nmenuitem_ = menuitem []\n\nmeta :: forall w i. Leaf I.HTMLmeta w i\nmeta props = element (ElemName \"meta\") props []\n\nmeter :: forall w i. Node I.HTMLmeter w i\nmeter = element (ElemName \"meter\")\n\nmeter_ :: forall w i. Array (HTML w i) -> HTML w i\nmeter_ = meter []\n\nnav :: forall w i. Node I.HTMLnav w i\nnav = element (ElemName \"nav\")\n\nnav_ :: forall w i. Array (HTML w i) -> HTML w i\nnav_ = nav []\n\nnoscript :: forall w i. Node I.HTMLnoscript w i\nnoscript = element (ElemName \"noscript\")\n\nnoscript_ :: forall w i. Array (HTML w i) -> HTML w i\nnoscript_ = noscript []\n\nobject :: forall w i. Node I.HTMLobject w i\nobject = element (ElemName \"object\")\n\nobject_ :: forall w i. Array (HTML w i) -> HTML w i\nobject_ = object []\n\nol :: forall w i. Node I.HTMLol w i\nol = element (ElemName \"ol\")\n\nol_ :: forall w i. Array (HTML w i) -> HTML w i\nol_ = ol []\n\noptgroup :: forall w i. Node I.HTMLoptgroup w i\noptgroup = element (ElemName \"optgroup\")\n\noptgroup_ :: forall w i. Array (HTML w i) -> HTML w i\noptgroup_ = optgroup []\n\noption :: forall w i. Node I.HTMLoption w i\noption = element (ElemName \"option\")\n\noption_ :: forall w i. Array (HTML w i) -> HTML w i\noption_ = option []\n\noutput :: forall w i. Node I.HTMLoutput w i\noutput = element (ElemName \"output\")\n\noutput_ :: forall w i. Array (HTML w i) -> HTML w i\noutput_ = output []\n\np :: forall w i. Node I.HTMLp w i\np = element (ElemName \"p\")\n\np_ :: forall w i. Array (HTML w i) -> HTML w i\np_ = p []\n\nparam :: forall w i. Leaf I.HTMLparam w i\nparam props = element (ElemName \"param\") props []\n\npre :: forall w i. Node I.HTMLpre w i\npre = element (ElemName \"pre\")\n\npre_ :: forall w i. Array (HTML w i) -> HTML w i\npre_ = pre []\n\nprogress :: forall w i. Node I.HTMLprogress w i\nprogress = element (ElemName \"progress\")\n\nprogress_ :: forall w i. Array (HTML w i) -> HTML w i\nprogress_ = progress []\n\nq :: forall w i. Node I.HTMLq w i\nq = element (ElemName \"q\")\n\nq_ :: forall w i. Array (HTML w i) -> HTML w i\nq_ = q []\n\nrp :: forall w i. Node I.HTMLrp w i\nrp = element (ElemName \"rp\")\n\nrp_ :: forall w i. Array (HTML w i) -> HTML w i\nrp_ = rp []\n\nrt :: forall w i. Node I.HTMLrt w i\nrt = element (ElemName \"rt\")\n\nrt_ :: forall w i. Array (HTML w i) -> HTML w i\nrt_ = rt []\n\nruby :: forall w i. Node I.HTMLruby w i\nruby = element (ElemName \"ruby\")\n\nruby_ :: forall w i. Array (HTML w i) -> HTML w i\nruby_ = ruby []\n\nsamp :: forall w i. Node I.HTMLsamp w i\nsamp = element (ElemName \"samp\")\n\nsamp_ :: forall w i. Array (HTML w i) -> HTML w i\nsamp_ = samp []\n\nscript :: forall w i. Node I.HTMLscript w i\nscript = element (ElemName \"script\")\n\nscript_ :: forall w i. Array (HTML w i) -> HTML w i\nscript_ = script []\n\nsection :: forall w i. Node I.HTMLsection w i\nsection = element (ElemName \"section\")\n\nsection_ :: forall w i. Array (HTML w i) -> HTML w i\nsection_ = section []\n\nselect :: forall w i. Node I.HTMLselect w i\nselect = element (ElemName \"select\")\n\nselect_ :: forall w i. Array (HTML w i) -> HTML w i\nselect_ = select []\n\nsmall :: forall w i. Node I.HTMLsmall w i\nsmall = element (ElemName \"small\")\n\nsmall_ :: forall w i. Array (HTML w i) -> HTML w i\nsmall_ = small []\n\nsource :: forall w i. Leaf I.HTMLsource w i\nsource props = element (ElemName \"source\") props []\n\nspan :: forall w i. Node I.HTMLspan w i\nspan = element (ElemName \"span\")\n\nspan_ :: forall w i. Array (HTML w i) -> HTML w i\nspan_ = span []\n\nstrong :: forall w i. Node I.HTMLstrong w i\nstrong = element (ElemName \"strong\")\n\nstrong_ :: forall w i. Array (HTML w i) -> HTML w i\nstrong_ = strong []\n\nstyle :: forall w i. Node I.HTMLstyle w i\nstyle = element (ElemName \"style\")\n\nstyle_ :: forall w i. Array (HTML w i) -> HTML w i\nstyle_ = style []\n\nsub :: forall w i. Node I.HTMLsub w i\nsub = element (ElemName \"sub\")\n\nsub_ :: forall w i. Array (HTML w i) -> HTML w i\nsub_ = sub []\n\nsummary :: forall w i. Node I.HTMLsummary w i\nsummary = element (ElemName \"summary\")\n\nsummary_ :: forall w i. Array (HTML w i) -> HTML w i\nsummary_ = summary []\n\nsup :: forall w i. Node I.HTMLsup w i\nsup = element (ElemName \"sup\")\n\nsup_ :: forall w i. Array (HTML w i) -> HTML w i\nsup_ = sup []\n\ntable :: forall w i. Node I.HTMLtable w i\ntable = element (ElemName \"table\")\n\ntable_ :: forall w i. Array (HTML w i) -> HTML w i\ntable_ = table []\n\ntbody :: forall w i. Node I.HTMLtbody w i\ntbody = element (ElemName \"tbody\")\n\ntbody_ :: forall w i. Array (HTML w i) -> HTML w i\ntbody_ = tbody []\n\ntd :: forall w i. Node I.HTMLtd w i\ntd = element (ElemName \"td\")\n\ntd_ :: forall w i. Array (HTML w i) -> HTML w i\ntd_ = td []\n\ntextarea :: forall w i. Leaf I.HTMLtextarea w i\ntextarea es = element (ElemName \"textarea\") es []\n\ntfoot :: forall w i. Node I.HTMLtfoot w i\ntfoot = element (ElemName \"tfoot\")\n\ntfoot_ :: forall w i. Array (HTML w i) -> HTML w i\ntfoot_ = tfoot []\n\nth :: forall w i. Node I.HTMLth w i\nth = element (ElemName \"th\")\n\nth_ :: forall w i. Array (HTML w i) -> HTML w i\nth_ = th []\n\nthead :: forall w i. Node I.HTMLthead w i\nthead = element (ElemName \"thead\")\n\nthead_ :: forall w i. Array (HTML w i) -> HTML w i\nthead_ = thead []\n\ntime :: forall w i. Node I.HTMLtime w i\ntime = element (ElemName \"time\")\n\ntime_ :: forall w i. Array (HTML w i) -> HTML w i\ntime_ = time []\n\ntitle :: forall w i. Node I.HTMLtitle w i\ntitle = element (ElemName \"title\")\n\ntitle_ :: forall w i. Array (HTML w i) -> HTML w i\ntitle_ = title []\n\ntr :: forall w i. Node I.HTMLtr w i\ntr = element (ElemName \"tr\")\n\ntr_ :: forall w i. Array (HTML w i) -> HTML w i\ntr_ = tr []\n\ntrack :: forall w i. Leaf I.HTMLtrack w i\ntrack props = element (ElemName \"track\") props []\n\nu :: forall w i. Node I.HTMLu w i\nu = element (ElemName \"u\")\n\nu_ :: forall w i. Array (HTML w i) -> HTML w i\nu_ = u []\n\nul :: forall w i. Node I.HTMLul w i\nul = element (ElemName \"ul\")\n\nul_ :: forall w i. Array (HTML w i) -> HTML w i\nul_ = ul []\n\nvar :: forall w i. Node I.HTMLvar w i\nvar = element (ElemName \"var\")\n\nvar_ :: forall w i. Array (HTML w i) -> HTML w i\nvar_ = var []\n\nvideo :: forall w i. Node I.HTMLvideo w i\nvideo = element (ElemName \"video\")\n\nvideo_ :: forall w i. Array (HTML w i) -> HTML w i\nvideo_ = video []\n\nwbr :: forall w i. Leaf I.HTMLwbr w i\nwbr props = element (ElemName \"wbr\") props []\n","\nmodule Control.Monad.Except\n  ( Except\n  , runExcept\n  , mapExcept\n  , withExcept\n  , module Control.Monad.Error.Class\n  , module Control.Monad.Except.Trans\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Error.Class (class MonadError, catchError, catchJust, throwError)\nimport Control.Monad.Except.Trans (class MonadTrans, ExceptT(..), except, lift, mapExceptT, runExceptT, withExceptT)\n\nimport Data.Either (Either)\nimport Data.Identity (Identity(..))\nimport Data.Newtype (unwrap)\n\n-- | A parametrizable exception monad; computations are either exceptions or\n-- | pure values. If an exception is thrown (see `throwError`), the computation\n-- | terminates with that value. Exceptions may also be caught with `catchError`,\n-- | allowing the computation to resume and exit successfully.\n-- |\n-- | The type parameter `e` is the type of exceptions, and `a` is the type\n-- | of successful results.\n-- |\n-- | A mechanism for trying many different computations until one succeeds is\n-- | provided via the `Alt` instance, specifically the `(<|>)` function.\n-- | The first computation to succeed is returned; if all fail, the exceptions\n-- | are combined using their `Semigroup` instance. The `Plus` instance goes\n-- | further and adds the possibility of a computation failing with an 'empty'\n-- | exception; naturally, this requires the stronger constraint of a `Monoid`\n-- | instance for the exception type.\ntype Except e = ExceptT e Identity\n\n-- | Run a computation in the `Except` monad. The inverse of `except`.\nrunExcept :: forall e a. Except e a -> Either e a\nrunExcept = unwrap <<< runExceptT\n\n-- | Transform the unwrapped computation using the given function.\nmapExcept :: forall e e' a b. (Either e a -> Either e' b) -> Except e a -> Except e' b\nmapExcept f = mapExceptT (Identity <<< f <<< unwrap)\n\n-- | Transform any exceptions thrown by an `Except` computation using the given function.\nwithExcept :: forall e e' a. (e -> e') -> Except e a -> Except e' a\nwithExcept = withExceptT\n","export function unsafeReadPropImpl(f, s, key, value) {\n  return value == null ? f : s(value[key]);\n}\n\nexport function unsafeHasOwnProperty(prop, value) {\n  return Object.prototype.hasOwnProperty.call(value, prop);\n}\n\nexport function unsafeHasProperty(prop, value) {\n  return prop in value;\n}\n","-- | This module defines a type class for types which act like\n-- | _property indices_.\n\nmodule Foreign.Index\n  ( class Index\n  , class Indexable\n  , readProp\n  , readIndex\n  , ix, (!)\n  , index\n  , hasProperty\n  , hasOwnProperty\n  , errorAt\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Except.Trans (ExceptT)\n\nimport Foreign (Foreign, ForeignError(..), typeOf, isUndefined, isNull, fail)\nimport Data.Function.Uncurried (Fn2, runFn2, Fn4, runFn4)\nimport Data.List.NonEmpty (NonEmptyList)\n\n-- | This type class identifies types that act like _property indices_.\n-- |\n-- | The canonical instances are for `String`s and `Int`s.\nclass Index i m | i -> m where\n  index :: Foreign -> i -> ExceptT (NonEmptyList ForeignError) m Foreign\n  hasProperty :: i -> Foreign -> Boolean\n  hasOwnProperty :: i -> Foreign -> Boolean\n  errorAt :: i -> ForeignError -> ForeignError\n\nclass Indexable a m | a -> m where\n  ix :: forall i. Index i m => a -> i -> ExceptT (NonEmptyList ForeignError) m Foreign\n\ninfixl 9 ix as !\n\nforeign import unsafeReadPropImpl :: forall r k. Fn4 r (Foreign -> r) k Foreign r\n\nunsafeReadProp :: forall k m. Monad m => k -> Foreign -> ExceptT (NonEmptyList ForeignError) m Foreign\nunsafeReadProp k value =\n  runFn4 unsafeReadPropImpl (fail (TypeMismatch \"object\" (typeOf value))) pure k value\n\n-- | Attempt to read a value from a foreign value property\nreadProp :: forall m. Monad m => String -> Foreign -> ExceptT (NonEmptyList ForeignError) m Foreign\nreadProp = unsafeReadProp\n\n-- | Attempt to read a value from a foreign value at the specified numeric index\nreadIndex :: forall m. Monad m => Int -> Foreign -> ExceptT (NonEmptyList ForeignError) m Foreign\nreadIndex = unsafeReadProp\n\nforeign import unsafeHasOwnProperty :: forall k. Fn2 k Foreign Boolean\n\nhasOwnPropertyImpl :: forall k. k -> Foreign -> Boolean\nhasOwnPropertyImpl _ value | isNull value = false\nhasOwnPropertyImpl _ value | isUndefined value = false\nhasOwnPropertyImpl p value | typeOf value == \"object\" || typeOf value == \"function\" = runFn2 unsafeHasOwnProperty p value\nhasOwnPropertyImpl _ _ = false\n\nforeign import unsafeHasProperty :: forall k. Fn2 k Foreign Boolean\n\nhasPropertyImpl :: forall k. k -> Foreign -> Boolean\nhasPropertyImpl _ value | isNull value = false\nhasPropertyImpl _ value | isUndefined value = false\nhasPropertyImpl p value | typeOf value == \"object\" || typeOf value == \"function\" = runFn2 unsafeHasProperty p value\nhasPropertyImpl _ _ = false\n\ninstance indexString :: Monad m => Index String m where\n  index = flip readProp\n  hasProperty = hasPropertyImpl\n  hasOwnProperty = hasOwnPropertyImpl\n  errorAt = ErrorAtProperty\n\ninstance indexInt :: Monad m => Index Int m where\n  index = flip readIndex\n  hasProperty = hasPropertyImpl\n  hasOwnProperty = hasOwnPropertyImpl\n  errorAt = ErrorAtIndex\n\ninstance indexableForeign :: Monad m => Indexable Foreign m where\n  ix = index\n\ninstance indexableExceptT :: Monad m => Indexable (ExceptT (NonEmptyList ForeignError) m Foreign) m where\n  ix f i = flip index i =<< f\n","export function bubbles(e) {\n  return e.bubbles;\n}\n\nexport function cancelable(e) {\n  return e.cancelable;\n}\n\nexport function _currentTarget(e) {\n  return e.currentTarget;\n}\n\nexport function defaultPrevented(e) {\n  return function() {\n    return e.defaultPrevented;\n  };\n}\n\nexport function eventPhaseIndex(e) {\n  return e.eventPhase;\n}\n\nexport function _target(e) {\n  return e.target;\n}\n\nexport function timeStamp(e) {\n  return e.timeStamp;\n}\n\nexport function type_(e) {\n  return e.type;\n}\n\nexport function preventDefault(e) {\n  return function () {\n    return e.preventDefault();\n  };\n}\n\nexport function stopImmediatePropagation(e) {\n  return function () {\n    return e.stopImmediatePropagation();\n  };\n}\n\nexport function stopPropagation(e) {\n  return function () {\n    return e.stopPropagation();\n  };\n}\n","module Control.Alternative\n  ( class Alternative\n  , guard\n  , module Control.Alt\n  , module Control.Applicative\n  , module Control.Apply\n  , module Control.Plus\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\nimport Control.Applicative (class Applicative, pure, liftA1, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Plus (class Plus, empty)\n\nimport Data.Unit (Unit, unit)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Alternative` type class has no members of its own; it just specifies\n-- | that the type constructor has both `Applicative` and `Plus` instances.\n-- |\n-- | Types which have `Alternative` instances should also satisfy the following\n-- | laws:\n-- |\n-- | - Distributivity: `(f <|> g) <*> x == (f <*> x) <|> (g <*> x)`\n-- | - Annihilation: `empty <*> f = empty`\nclass (Applicative f, Plus f) <= Alternative f\n\ninstance alternativeArray :: Alternative Array\n\n-- | Fail using `Plus` if a condition does not hold, or\n-- | succeed using `Applicative` if it does.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Prelude\n-- | import Control.Alternative (guard)\n-- | import Data.Array ((..))\n-- |\n-- | factors :: Int -> Array Int\n-- | factors n = do\n-- |   a <- 1..n\n-- |   b <- 1..n\n-- |   guard $ a * b == n\n-- |   pure a\n-- | ```\nguard :: forall m. Alternative m => Boolean -> m Unit\nguard true = pure unit\nguard false = empty\n","module Web.Event.Event\n  ( module Exports\n  , EventType(..)\n  , type_\n  , target\n  , currentTarget\n  , eventPhase\n  , stopPropagation\n  , stopImmediatePropagation\n  , bubbles\n  , cancelable\n  , preventDefault\n  , defaultPrevented\n  , timeStamp\n  ) where\n\nimport Prelude\n\nimport Data.DateTime.Instant (Instant)\nimport Data.Enum (toEnum)\nimport Data.Maybe (Maybe, fromJust)\nimport Data.Newtype (class Newtype)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Web.Event.EventPhase (EventPhase)\nimport Web.Event.Internal.Types (Event) as Exports\nimport Web.Event.Internal.Types (Event, EventTarget)\n\n-- | The type of strings used for event types.\nnewtype EventType = EventType String\n\nderive instance newtypeEventType :: Newtype EventType _\nderive newtype instance eqEventType :: Eq EventType\nderive newtype instance ordEventType :: Ord EventType\n\n-- | The event type.\nforeign import type_ :: Event -> EventType\n\n-- | The element that was the source of the event.\ntarget :: Event -> Maybe EventTarget\ntarget = toMaybe <<< _target\n\nforeign import _target :: Event -> Nullable EventTarget\n\n-- | The element that the event listener was added to.\ncurrentTarget :: Event -> Maybe EventTarget\ncurrentTarget = toMaybe <<< _currentTarget\n\nforeign import _currentTarget :: Event -> Nullable EventTarget\n\n-- | Indicates which phase of the event flow that is currently being processed\n-- | for the event.\neventPhase :: Partial => Event -> EventPhase\neventPhase = fromJust <<< toEnum <<< eventPhaseIndex\n\n-- | The integer value for the current event phase.\nforeign import eventPhaseIndex :: Event -> Int\n\n-- | Prevents the event from bubbling up to futher event listeners. Other event\n-- | listeners on the current target will still fire.\nforeign import stopPropagation :: Event -> Effect Unit\n\n-- | Prevents all other listeners for the event from being called. This includes\n-- | event listeners added to the current target after the current listener.\nforeign import stopImmediatePropagation :: Event -> Effect Unit\n\n-- | Indicates whether the event will bubble up through the DOM or not.\nforeign import bubbles :: Event -> Boolean\n\n-- | Indicates whether the event can be cancelled.\nforeign import cancelable :: Event -> Boolean\n\n-- | Cancels the event if it can be cancelled.\nforeign import preventDefault :: Event -> Effect Unit\n\n-- | Indicates whether `preventDefault` was called on the event.\nforeign import defaultPrevented :: Event -> Effect Boolean\n\n-- | The time in milliseconds between 01/01/1970 and when the event was\n-- | dispatched.\nforeign import timeStamp :: Event -> Instant\n","module Web.HTML.Event.DragEvent.EventTypes where\n\nimport Web.Event.Event (EventType(..))\n\ndragstart :: EventType\ndragstart = EventType \"dragstart\"\n\ndrag :: EventType\ndrag = EventType \"drag\"\n\ndragenter :: EventType\ndragenter = EventType \"dragenter\"\n\ndragexit :: EventType\ndragexit = EventType \"dragexit\"\n\ndragleave :: EventType\ndragleave = EventType \"dragleave\"\n\ndragover :: EventType\ndragover = EventType \"dragover\"\n\ndrop :: EventType\ndrop = EventType \"drop\"\n\ndragend :: EventType\ndragend = EventType \"dragend\"\n","module Web.HTML.Event.EventTypes where\n\nimport Web.Event.Event (EventType(..))\n\nabort :: EventType\nabort = EventType \"abort\"\n\nafterprint :: EventType\nafterprint = EventType \"afterprint\"\n\nafterscriptexecute :: EventType\nafterscriptexecute = EventType \"afterscriptexecute\"\n\nbeforeprint :: EventType\nbeforeprint = EventType \"beforeprint\"\n\nbeforescriptexecute :: EventType\nbeforescriptexecute = EventType \"beforescriptexecute\"\n\nblur :: EventType\nblur = EventType \"blur\"\n\ncancel :: EventType\ncancel = EventType \"cancel\"\n\nchange :: EventType\nchange = EventType \"change\"\n\nclick :: EventType\nclick = EventType \"click\"\n\nclose :: EventType\nclose = EventType \"close\"\n\ncopy :: EventType\ncopy = EventType \"copy\"\n\ncut :: EventType\ncut = EventType \"cut\"\n\ndomcontentloaded :: EventType\ndomcontentloaded = EventType \"DOMContentLoaded\"\n\nerror :: EventType\nerror = EventType \"error\"\n\nfocus :: EventType\nfocus = EventType \"focus\"\n\ninput :: EventType\ninput = EventType \"input\"\n\ninvalid :: EventType\ninvalid = EventType \"invalid\"\n\nlanguagechange :: EventType\nlanguagechange = EventType \"languagechange\"\n\nload :: EventType\nload = EventType \"load\"\n\nloadend :: EventType\nloadend = EventType \"loadend\"\n\nloadstart :: EventType\nloadstart = EventType \"loadstart\"\n\nmessage :: EventType\nmessage = EventType \"message\"\n\noffline :: EventType\noffline = EventType \"offline\"\n\nonline :: EventType\nonline = EventType \"online\"\n\npaste :: EventType\npaste = EventType \"paste\"\n\nprogress :: EventType\nprogress = EventType \"progress\"\n\nreadystatechange :: EventType\nreadystatechange = EventType \"readystatechange\"\n\nreset :: EventType\nreset = EventType \"reset\"\n\nselect :: EventType\nselect = EventType \"select\"\n\nstorage :: EventType\nstorage = EventType \"storage\"\n\nsubmit :: EventType\nsubmit = EventType \"submit\"\n\ntoggle :: EventType\ntoggle = EventType \"toggle\"\n\nunload :: EventType\nunload = EventType \"unload\"\n","export function accept(input) {\n  return function () {\n    return input.accept;\n  };\n}\n\nexport function setAccept(accept) {\n  return function (input) {\n    return function () {\n      input.accept = accept;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function alt(input) {\n  return function () {\n    return input.alt;\n  };\n}\n\nexport function setAlt(alt) {\n  return function (input) {\n    return function () {\n      input.alt = alt;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function autocomplete(input) {\n  return function () {\n    return input.autocomplete;\n  };\n}\n\nexport function setAutocomplete(autocomplete) {\n  return function (input) {\n    return function () {\n      input.autocomplete = autocomplete;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function autofocus(input) {\n  return function () {\n    return input.autofocus;\n  };\n}\n\nexport function setAutofocus(autofocus) {\n  return function (input) {\n    return function () {\n      input.autofocus = autofocus;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function defaultChecked(input) {\n  return function () {\n    return input.defaultChecked;\n  };\n}\n\nexport function setDefaultChecked(defaultChecked) {\n  return function (input) {\n    return function () {\n      input.defaultChecked = defaultChecked;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checked(input) {\n  return function () {\n    return input.checked;\n  };\n}\n\nexport function setChecked(checked) {\n  return function (input) {\n    return function () {\n      input.checked = checked;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function dirName(input) {\n  return function () {\n    return input.dirName;\n  };\n}\n\nexport function setDirName(dirName) {\n  return function (input) {\n    return function () {\n      input.dirName = dirName;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function disabled(input) {\n  return function () {\n    return input.disabled;\n  };\n}\n\nexport function setDisabled(disabled) {\n  return function (input) {\n    return function () {\n      input.disabled = disabled;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _form(input) {\n  return function () {\n    return input.form;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _files(input) {\n  return function () {\n    return input.files;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formAction(input) {\n  return function () {\n    return input.formAction;\n  };\n}\n\nexport function setFormAction(formAction) {\n  return function (input) {\n    return function () {\n      input.formAction = formAction;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formEnctype(input) {\n  return function () {\n    return input.formEnctype;\n  };\n}\n\nexport function setFormEnctype(formEnctype) {\n  return function (input) {\n    return function () {\n      input.formEnctype = formEnctype;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formMethod(input) {\n  return function () {\n    return input.formMethod;\n  };\n}\n\nexport function setFormMethod(formMethod) {\n  return function (input) {\n    return function () {\n      input.formMethod = formMethod;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formNoValidate(input) {\n  return function () {\n    return input.formNoValidate;\n  };\n}\n\nexport function setFormNoValidate(formNoValidate) {\n  return function (input) {\n    return function () {\n      input.formNoValidate = formNoValidate;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function formTarget(input) {\n  return function () {\n    return input.formTarget;\n  };\n}\n\nexport function setFormTarget(formTarget) {\n  return function (input) {\n    return function () {\n      input.formTarget = formTarget;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function height(input) {\n  return function () {\n    return input.height;\n  };\n}\n\nexport function setHeight(height) {\n  return function (input) {\n    return function () {\n      input.height = height;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function indeterminate(input) {\n  return function () {\n    return input.indeterminate;\n  };\n}\n\nexport function setIndeterminate(indeterminate) {\n  return function (input) {\n    return function () {\n      input.indeterminate = indeterminate;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function _list(input) {\n  return function () {\n    return input.list;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function max(input) {\n  return function () {\n    return input.max;\n  };\n}\n\nexport function setMax(max) {\n  return function (input) {\n    return function () {\n      input.max = max;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function maxLength(input) {\n  return function () {\n    return input.maxLength;\n  };\n}\n\nexport function setMaxLength(maxLength) {\n  return function (input) {\n    return function () {\n      input.maxLength = maxLength;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function min(input) {\n  return function () {\n    return input.min;\n  };\n}\n\nexport function setMin(min) {\n  return function (input) {\n    return function () {\n      input.min = min;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function minLength(input) {\n  return function () {\n    return input.minLength;\n  };\n}\n\nexport function setMinLength(minLength) {\n  return function (input) {\n    return function () {\n      input.minLength = minLength;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function multiple(input) {\n  return function () {\n    return input.multiple;\n  };\n}\n\nexport function setMultiple(multiple) {\n  return function (input) {\n    return function () {\n      input.multiple = multiple;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function name(input) {\n  return function () {\n    return input.name;\n  };\n}\n\nexport function setName(name) {\n  return function (input) {\n    return function () {\n      input.name = name;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function pattern(input) {\n  return function () {\n    return input.pattern;\n  };\n}\n\nexport function setPattern(pattern) {\n  return function (input) {\n    return function () {\n      input.pattern = pattern;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function placeholder(input) {\n  return function () {\n    return input.placeholder;\n  };\n}\n\nexport function setPlaceholder(placeholder) {\n  return function (input) {\n    return function () {\n      input.placeholder = placeholder;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function readOnly(input) {\n  return function () {\n    return input.readOnly;\n  };\n}\n\nexport function setReadOnly(readOnly) {\n  return function (input) {\n    return function () {\n      input.readOnly = readOnly;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function required(input) {\n  return function () {\n    return input.required;\n  };\n}\n\nexport function setRequired(required) {\n  return function (input) {\n    return function () {\n      input.required = required;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function size(input) {\n  return function () {\n    return input.size;\n  };\n}\n\nexport function setSize(size) {\n  return function (input) {\n    return function () {\n      input.size = size;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function src(input) {\n  return function () {\n    return input.src;\n  };\n}\n\nexport function setSrc(src) {\n  return function (input) {\n    return function () {\n      input.src = src;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function step(input) {\n  return function () {\n    return input.step;\n  };\n}\n\nexport function setStep(step) {\n  return function (input) {\n    return function () {\n      input.step = step;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function type_(input) {\n  return function () {\n    return input.type;\n  };\n}\n\nexport function setType(type) {\n  return function (input) {\n    return function () {\n      input.type = type;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function defaultValue(input) {\n  return function () {\n    return input.defaultValue;\n  };\n}\n\nexport function setDefaultValue(defaultValue) {\n  return function (input) {\n    return function () {\n      input.defaultValue = defaultValue;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function value(input) {\n  return function () {\n    return input.value;\n  };\n}\n\nexport function setValue(value) {\n  return function (input) {\n    return function () {\n      input.value = value;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function valueAsDate(input) {\n  return function () {\n    return input.valueAsDate;\n  };\n}\n\nexport function setValueAsDate(valueAsDate) {\n  return function (input) {\n    return function () {\n      input.valueAsDate = valueAsDate;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function valueAsNumber(input) {\n  return function () {\n    return input.valueAsNumber;\n  };\n}\n\nexport function setValueAsNumber(valueAsNumber) {\n  return function (input) {\n    return function () {\n      input.valueAsNumber = valueAsNumber;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function width(input) {\n  return function () {\n    return input.width;\n  };\n}\n\nexport function setWidth(width) {\n  return function (input) {\n    return function () {\n      input.width = width;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function stepUpBy(n) {\n  return function (input) {\n    return function () {\n      input.stepUp(n);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function stepDownBy(n) {\n  return function (input) {\n    return function () {\n      input.stepDown(n);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function willValidate(input) {\n  return function () {\n    return input.willValidate;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validity(input) {\n  return function () {\n    return input.validity;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function validationMessage(input) {\n  return function () {\n    return input.validationMessage;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function checkValidity(input) {\n  return function () {\n    return input.checkValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function reportValidity(input) {\n  return function () {\n    return input.reportValidity();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setCustomValidity(value) {\n  return function (input) {\n    return function () {\n      input.setCustomValidity(value);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function labels(input) {\n  return function () {\n    return input.labels;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function select(input) {\n  return function () {\n    input.select();\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionStart(input) {\n  return function () {\n    return input.selectionStart;\n  };\n}\n\nexport function setSelectionStart(selectionStart) {\n  return function (input) {\n    return function () {\n      input.selectionStart = selectionStart;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionEnd(input) {\n  return function () {\n    return input.selectionEnd;\n  };\n}\n\nexport function setSelectionEnd(selectionEnd) {\n  return function (input) {\n    return function () {\n      input.selectionEnd = selectionEnd;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function selectionDirection(input) {\n  return function () {\n    return input.selectionDirection;\n  };\n}\n\nexport function setSelectionDirection(selectionDirection) {\n  return function (input) {\n    return function () {\n      input.selectionDirection = selectionDirection;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setRangeText(replacement) {\n  return function (input) {\n    return function () {\n      input.setRangeText(replacement);\n    };\n  };\n}\n\nexport function _setRangeText(replacement, start, end, selectionMode, textarea) {\n  textarea.setRangeText(replacement, start, end, selectionMode);\n}\n\n// ----------------------------------------------------------------------------\n\nexport function setSelectionRange(start) {\n  return function (end) {\n    return function (direction) {\n      return function (input) {\n        return function () {\n          input.setSelectionRange(start, end, direction, input);\n        };\n      };\n    };\n  };\n}\n","module Web.HTML.HTMLInputElement\n  ( HTMLInputElement\n  , fromHTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toHTMLElement\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , accept\n  , setAccept\n  , alt\n  , setAlt\n  , autocomplete\n  , setAutocomplete\n  , autofocus\n  , setAutofocus\n  , defaultChecked\n  , setDefaultChecked\n  , checked\n  , setChecked\n  , dirName\n  , setDirName\n  , disabled\n  , setDisabled\n  , form\n  , files\n  , formAction\n  , setFormAction\n  , formEnctype\n  , setFormEnctype\n  , formMethod\n  , setFormMethod\n  , formNoValidate\n  , setFormNoValidate\n  , formTarget\n  , setFormTarget\n  , height\n  , setHeight\n  , indeterminate\n  , setIndeterminate\n  , list\n  , max\n  , setMax\n  , maxLength\n  , setMaxLength\n  , min\n  , setMin\n  , minLength\n  , setMinLength\n  , multiple\n  , setMultiple\n  , name\n  , setName\n  , pattern\n  , setPattern\n  , placeholder\n  , setPlaceholder\n  , readOnly\n  , setReadOnly\n  , required\n  , setRequired\n  , size\n  , setSize\n  , src\n  , setSrc\n  , step\n  , setStep\n  , type_\n  , setType\n  , defaultValue\n  , setDefaultValue\n  , value\n  , setValue\n  , valueAsDate\n  , setValueAsDate\n  , valueAsNumber\n  , setValueAsNumber\n  , width\n  , setWidth\n  , stepUp\n  , stepUp'\n  , stepDown\n  , stepDown'\n  , willValidate\n  , validity\n  , validationMessage\n  , checkValidity\n  , reportValidity\n  , setCustomValidity\n  , labels\n  , select\n  , selectionStart\n  , setSelectionStart\n  , selectionEnd\n  , setSelectionEnd\n  , selectionDirection\n  , setSelectionDirection\n  , setRangeText\n  , setRangeText'\n  , setSelectionRange\n  ) where\n\nimport Prelude\n\nimport Data.JSDate (JSDate)\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Effect.Uncurried (EffectFn5, runEffectFn5)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode, Element, Node, NonDocumentTypeChildNode, ParentNode)\nimport Web.DOM.NodeList (NodeList)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.File.FileList (FileList)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLFormElement (HTMLFormElement)\nimport Web.HTML.SelectionMode (SelectionMode)\nimport Web.HTML.SelectionMode as SelectionMode\nimport Web.HTML.ValidityState (ValidityState)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLInputElement :: Type\n\nfromHTMLElement :: HTMLElement -> Maybe HTMLInputElement\nfromHTMLElement = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromElement :: Element -> Maybe HTMLInputElement\nfromElement = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromNode :: Node -> Maybe HTMLInputElement\nfromNode = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromChildNode :: ChildNode -> Maybe HTMLInputElement\nfromChildNode = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLInputElement\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromParentNode :: ParentNode -> Maybe HTMLInputElement\nfromParentNode = unsafeReadProtoTagged \"HTMLInputElement\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLInputElement\nfromEventTarget = unsafeReadProtoTagged \"HTMLInputElement\"\n\ntoHTMLElement :: HTMLInputElement -> HTMLElement\ntoHTMLElement = unsafeCoerce\n\ntoElement :: HTMLInputElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLInputElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLInputElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLInputElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLInputElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLInputElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import accept :: HTMLInputElement -> Effect String\nforeign import setAccept :: String -> HTMLInputElement -> Effect Unit\n\nforeign import alt :: HTMLInputElement -> Effect Boolean\nforeign import setAlt :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import autocomplete :: HTMLInputElement -> Effect String\nforeign import setAutocomplete :: String -> HTMLInputElement -> Effect Unit\n\nforeign import autofocus :: HTMLInputElement -> Effect Boolean\nforeign import setAutofocus :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import defaultChecked :: HTMLInputElement -> Effect Boolean\nforeign import setDefaultChecked :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import checked :: HTMLInputElement -> Effect Boolean\nforeign import setChecked :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import dirName :: HTMLInputElement -> Effect String\nforeign import setDirName :: String -> HTMLInputElement -> Effect Unit\n\nforeign import disabled :: HTMLInputElement -> Effect Boolean\nforeign import setDisabled :: Boolean -> HTMLInputElement -> Effect Unit\n\nform :: HTMLInputElement -> Effect (Maybe HTMLFormElement)\nform = map toMaybe <<< _form\n\nforeign import _form :: HTMLInputElement -> Effect (Nullable HTMLFormElement)\n\nfiles :: HTMLInputElement -> Effect (Maybe FileList)\nfiles = map toMaybe <<< _files\n\nforeign import _files :: HTMLInputElement -> Effect (Nullable FileList)\n\nforeign import formAction :: HTMLInputElement -> Effect String\nforeign import setFormAction :: String -> HTMLInputElement -> Effect Unit\n\nforeign import formEnctype :: HTMLInputElement -> Effect String\nforeign import setFormEnctype :: String -> HTMLInputElement -> Effect Unit\n\nforeign import formMethod :: HTMLInputElement -> Effect String\nforeign import setFormMethod :: String -> HTMLInputElement -> Effect Unit\n\nforeign import formNoValidate :: HTMLInputElement -> Effect Boolean\nforeign import setFormNoValidate :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import formTarget :: HTMLInputElement -> Effect String\nforeign import setFormTarget :: String -> HTMLInputElement -> Effect Unit\n\nforeign import height :: HTMLInputElement -> Effect Int\nforeign import setHeight :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import indeterminate :: HTMLInputElement -> Effect Boolean\nforeign import setIndeterminate :: Boolean -> HTMLInputElement -> Effect Unit\n\nlist :: HTMLInputElement -> Effect (Maybe HTMLElement)\nlist = map toMaybe <<< _list\n\nforeign import _list :: HTMLInputElement -> Effect (Nullable HTMLElement)\n\nforeign import max :: HTMLInputElement -> Effect String\nforeign import setMax :: String -> HTMLInputElement -> Effect Unit\n\nforeign import maxLength :: HTMLInputElement -> Effect Int\nforeign import setMaxLength :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import min :: HTMLInputElement -> Effect String\nforeign import setMin :: String -> HTMLInputElement -> Effect Unit\n\nforeign import minLength :: HTMLInputElement -> Effect Int\nforeign import setMinLength :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import multiple :: HTMLInputElement -> Effect Boolean\nforeign import setMultiple :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import name :: HTMLInputElement -> Effect String\nforeign import setName :: String -> HTMLInputElement -> Effect Unit\n\nforeign import pattern :: HTMLInputElement -> Effect String\nforeign import setPattern :: String -> HTMLInputElement -> Effect Unit\n\nforeign import placeholder :: HTMLInputElement -> Effect String\nforeign import setPlaceholder :: String -> HTMLInputElement -> Effect Unit\n\nforeign import readOnly :: HTMLInputElement -> Effect Boolean\nforeign import setReadOnly :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import required :: HTMLInputElement -> Effect Boolean\nforeign import setRequired :: Boolean -> HTMLInputElement -> Effect Unit\n\nforeign import size :: HTMLInputElement -> Effect Int\nforeign import setSize :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import src :: HTMLInputElement -> Effect String\nforeign import setSrc :: String -> HTMLInputElement -> Effect Unit\n\nforeign import step :: HTMLInputElement -> Effect String\nforeign import setStep :: String -> HTMLInputElement -> Effect Unit\n\nforeign import type_ :: HTMLInputElement -> Effect String\nforeign import setType :: String -> HTMLInputElement -> Effect Unit\n\nforeign import defaultValue :: HTMLInputElement -> Effect String\nforeign import setDefaultValue :: String -> HTMLInputElement -> Effect Unit\n\nforeign import value :: HTMLInputElement -> Effect String\nforeign import setValue :: String -> HTMLInputElement -> Effect Unit\n\nforeign import valueAsDate :: HTMLInputElement -> Effect JSDate\nforeign import setValueAsDate :: JSDate -> HTMLInputElement -> Effect Unit\n\nforeign import valueAsNumber :: HTMLInputElement -> Effect Number\nforeign import setValueAsNumber :: Number -> HTMLInputElement -> Effect Unit\n\nforeign import width :: HTMLInputElement -> Effect Int\nforeign import setWidth :: Int -> HTMLInputElement -> Effect Unit\n\nstepUp :: HTMLInputElement -> Effect Unit\nstepUp = stepUp' 1\n\nforeign import stepUpBy :: Int -> HTMLInputElement -> Effect Unit\n\nstepUp' :: Int -> HTMLInputElement -> Effect Unit\nstepUp' = stepUpBy\n\nstepDown :: HTMLInputElement -> Effect Unit\nstepDown = stepDown' 1\n\nforeign import stepDownBy :: Int -> HTMLInputElement -> Effect Unit\n\nstepDown' :: Int -> HTMLInputElement -> Effect Unit\nstepDown' = stepDownBy\n\nforeign import willValidate :: HTMLInputElement -> Effect Boolean\n\nforeign import validity :: HTMLInputElement -> Effect ValidityState\n\nforeign import validationMessage :: HTMLInputElement -> Effect String\n\nforeign import checkValidity :: HTMLInputElement -> Effect Boolean\n\nforeign import reportValidity :: HTMLInputElement -> Effect Boolean\n\nforeign import setCustomValidity :: String -> HTMLInputElement -> Effect Unit\n\nforeign import labels :: HTMLInputElement -> Effect NodeList\n\nforeign import select :: HTMLInputElement -> Effect Unit\n\nforeign import selectionStart :: HTMLInputElement -> Effect Int\nforeign import setSelectionStart :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import selectionEnd :: HTMLInputElement -> Effect Int\nforeign import setSelectionEnd :: Int -> HTMLInputElement -> Effect Unit\n\nforeign import selectionDirection :: HTMLInputElement -> Effect String\nforeign import setSelectionDirection :: String -> HTMLInputElement -> Effect Unit\n\nforeign import setRangeText :: String -> HTMLInputElement -> Effect Unit\n\nsetRangeText' :: String -> Int -> Int -> SelectionMode -> HTMLInputElement -> Effect Unit\nsetRangeText' rpl s e mode area =\n  runEffectFn5 _setRangeText rpl s e (SelectionMode.print mode) area\n\nforeign import _setRangeText :: EffectFn5 String Int Int String HTMLInputElement Unit\n\nforeign import setSelectionRange :: Int -> Int -> String -> HTMLInputElement -> Effect Unit\n","module Web.UIEvent.FocusEvent.EventTypes where\n\nimport Web.Event.Event (EventType(..))\n\nblur :: EventType\nblur = EventType \"blur\"\n\nfocus :: EventType\nfocus = EventType \"focus\"\n\nfocusin :: EventType\nfocusin = EventType \"focusin\"\n\nfocusout :: EventType\nfocusout = EventType \"focusout\"\n","module Web.UIEvent.MouseEvent.EventTypes where\n\nimport Web.Event.Event (EventType(..))\n\nauxclick :: EventType\nauxclick = EventType \"auxclick\"\n\nclick :: EventType\nclick = EventType \"click\"\n\ndblclick :: EventType\ndblclick = EventType \"dblclick\"\n\nmousedown :: EventType\nmousedown = EventType \"mousedown\"\n\nmouseenter :: EventType\nmouseenter = EventType \"mouseenter\"\n\nmouseleave :: EventType\nmouseleave = EventType \"mouseleave\"\n\nmousemove :: EventType\nmousemove = EventType \"mousemove\"\n\nmouseout :: EventType\nmouseout = EventType \"mouseout\"\n\nmouseover :: EventType\nmouseover = EventType \"mouseover\"\n\nmouseup :: EventType\nmouseup = EventType \"mouseup\"\n","module Halogen.HTML.Events\n  ( handler\n  , handler'\n  , onAbort\n  , onError\n  , onLoad\n  , onScroll\n  , onChange\n  , onFileUpload\n  , onInput\n  , onInvalid\n  , onReset\n  , onSelect\n  , onSubmit\n  , onTransitionEnd\n  , onCopy\n  , onPaste\n  , onCut\n  , onAuxClick\n  , onClick\n  -- , onContextMenu\n  , onDoubleClick\n  , onMouseDown\n  , onMouseEnter\n  , onMouseLeave\n  , onMouseMove\n  , onMouseOver\n  , onMouseOut\n  , onMouseUp\n  , onWheel\n  , onKeyDown\n  -- , onKeyPress\n  , onKeyUp\n  , onBlur\n  , onFocus\n  , onFocusIn\n  , onFocusOut\n  , onDrag\n  , onDragEnd\n  , onDragExit\n  , onDragEnter\n  , onDragLeave\n  , onDragOver\n  , onDragStart\n  , onDrop\n  , onTouchCancel\n  , onTouchEnd\n  , onTouchEnter\n  , onTouchLeave\n  , onTouchMove\n  , onTouchStart\n  , onResize\n  , onValueChange\n  , onValueInput\n  , onSelectedIndexChange\n  , onChecked\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Except (runExcept)\nimport Data.Either (either)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Unfoldable (class Unfoldable, none)\nimport Foreign (F, Foreign, readBoolean, readInt, readString, unsafeToForeign)\nimport Foreign.Index (readProp)\nimport Halogen.HTML.Core (Prop)\nimport Halogen.HTML.Core as Core\nimport Halogen.HTML.Properties (IProp)\nimport Halogen.Query.Input (Input(..))\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.Clipboard.ClipboardEvent (ClipboardEvent)\nimport Web.Clipboard.ClipboardEvent.EventTypes as CET\nimport Web.Event.Event (Event, EventType(..))\nimport Web.Event.Event as EE\nimport Web.Event.Event as Event\nimport Web.File.File (File)\nimport Web.File.FileList (items)\nimport Web.HTML.Event.DragEvent (DragEvent)\nimport Web.HTML.Event.DragEvent.EventTypes as DET\nimport Web.HTML.Event.EventTypes as ET\nimport Web.HTML.HTMLInputElement as HTMLInputElement\nimport Web.TouchEvent.TouchEvent (TouchEvent)\nimport Web.UIEvent.FocusEvent (FocusEvent)\nimport Web.UIEvent.FocusEvent.EventTypes as FET\nimport Web.UIEvent.KeyboardEvent (KeyboardEvent)\nimport Web.UIEvent.KeyboardEvent.EventTypes as KET\nimport Web.UIEvent.MouseEvent (MouseEvent)\nimport Web.UIEvent.MouseEvent.EventTypes as MET\nimport Web.UIEvent.WheelEvent (WheelEvent)\nimport Web.UIEvent.WheelEvent.EventTypes as WET\nimport Effect.Unsafe (unsafePerformEffect)\n\nhandler :: forall r i. EventType -> (Event -> i) -> IProp r i\nhandler et f =\n  (unsafeCoerce :: (EventType -> (Event -> Maybe i) -> Prop i) -> EventType -> (Event -> Maybe (Input i)) -> IProp r i)\n    Core.handler\n    et\n    \\ev -> Just (Action (f ev))\n\nhandler' :: forall r i. EventType -> (Event -> Maybe i) -> IProp r i\nhandler' et f =\n  (unsafeCoerce :: (EventType -> (Event -> Maybe i) -> Prop i) -> EventType -> (Event -> Maybe (Input i)) -> IProp r i)\n    Core.handler\n    et\n    \\ev -> Action <$> f ev\n\nonAbort :: forall r i. (Event -> i) -> IProp (onAbort :: Event | r) i\nonAbort = handler (EventType \"abort\")\n\nonError :: forall r i. (Event -> i) -> IProp (onError :: Event | r) i\nonError = handler ET.error\n\nonLoad :: forall r i. (Event -> i) -> IProp (onLoad :: Event | r) i\nonLoad = handler ET.load\n\nonScroll :: forall r i. (Event -> i) -> IProp (onScroll :: Event | r) i\nonScroll = handler (EventType \"scroll\")\n\nonChange :: forall r i. (Event -> i) -> IProp (onChange :: Event | r) i\nonChange = handler ET.change\n\nonFileUpload\n  :: forall r i t\n   . Unfoldable t\n  => (t File -> i)\n  -> IProp (onChange :: Event | r) i\nonFileUpload f = handler ET.change $\n  ( Event.target\n      >=> HTMLInputElement.fromEventTarget\n      >=>\n        HTMLInputElement.files >>> unsafePerformEffect\n  )\n    >>> maybe none items\n    >>> f\n\nonInput :: forall r i. (Event -> i) -> IProp (onInput :: Event | r) i\nonInput = handler ET.input\n\nonInvalid :: forall r i. (Event -> i) -> IProp (onInvalid :: Event | r) i\nonInvalid = handler ET.invalid\n\nonReset :: forall r i. (Event -> i) -> IProp (onReset :: Event | r) i\nonReset = handler (EventType \"reset\")\n\nonSelect :: forall r i. (Event -> i) -> IProp (onSelect :: Event | r) i\nonSelect = handler ET.select\n\nonSubmit :: forall r i. (Event -> i) -> IProp (onSubmit :: Event | r) i\nonSubmit = handler (EventType \"submit\")\n\nonTransitionEnd :: forall r i. (Event -> i) -> IProp (onTransitionEnd :: Event | r) i\nonTransitionEnd = handler (EventType \"transitionend\")\n\nonCopy :: forall r i. (ClipboardEvent -> i) -> IProp (onCopy :: ClipboardEvent | r) i\nonCopy = handler CET.copy <<< clipboardHandler\n\nonPaste :: forall r i. (ClipboardEvent -> i) -> IProp (onPaste :: ClipboardEvent | r) i\nonPaste = handler CET.paste <<< clipboardHandler\n\nonCut :: forall r i. (ClipboardEvent -> i) -> IProp (onCut :: ClipboardEvent | r) i\nonCut = handler CET.cut <<< clipboardHandler\n\nonAuxClick :: forall r i. (MouseEvent -> i) -> IProp (onAuxClick :: MouseEvent | r) i\nonAuxClick = handler MET.auxclick <<< mouseHandler\n\nonClick :: forall r i. (MouseEvent -> i) -> IProp (onClick :: MouseEvent | r) i\nonClick = handler MET.click <<< mouseHandler\n\n-- onContextMenu :: forall r i. (MouseEvent -> i) -> IProp (onContextMenu :: MouseEvent | r) i\n-- onContextMenu = handler ET.contextmenu <<< mouseHandler\n\nonDoubleClick :: forall r i. (MouseEvent -> i) -> IProp (onDoubleClick :: MouseEvent | r) i\nonDoubleClick = handler MET.dblclick <<< mouseHandler\n\nonMouseDown :: forall r i. (MouseEvent -> i) -> IProp (onMouseDown :: MouseEvent | r) i\nonMouseDown = handler MET.mousedown <<< mouseHandler\n\nonMouseEnter :: forall r i. (MouseEvent -> i) -> IProp (onMouseEnter :: MouseEvent | r) i\nonMouseEnter = handler MET.mouseenter <<< mouseHandler\n\nonMouseLeave :: forall r i. (MouseEvent -> i) -> IProp (onMouseLeave :: MouseEvent | r) i\nonMouseLeave = handler MET.mouseleave <<< mouseHandler\n\nonMouseMove :: forall r i. (MouseEvent -> i) -> IProp (onMouseMove :: MouseEvent | r) i\nonMouseMove = handler MET.mousemove <<< mouseHandler\n\nonMouseOver :: forall r i. (MouseEvent -> i) -> IProp (onMouseOver :: MouseEvent | r) i\nonMouseOver = handler MET.mouseover <<< mouseHandler\n\nonMouseOut :: forall r i. (MouseEvent -> i) -> IProp (onMouseOut :: MouseEvent | r) i\nonMouseOut = handler MET.mouseout <<< mouseHandler\n\nonMouseUp :: forall r i. (MouseEvent -> i) -> IProp (onMouseUp :: MouseEvent | r) i\nonMouseUp = handler MET.mouseup <<< mouseHandler\n\nonWheel :: forall r i. (WheelEvent -> i) -> IProp (onWheel :: WheelEvent | r) i\nonWheel = handler WET.wheel <<< wheelHandler\n\nonKeyDown :: forall r i. (KeyboardEvent -> i) -> IProp (onKeyDown :: KeyboardEvent | r) i\nonKeyDown = handler KET.keydown <<< keyHandler\n\n-- onKeyPress :: forall r i. (KeyboardEvent -> i) -> IProp (onKeyPress :: KeyboardEvent | r) i\n-- onKeyPress = handler KET.keypress <<< keyHandler\n\nonKeyUp :: forall r i. (KeyboardEvent -> i) -> IProp (onKeyUp :: KeyboardEvent | r) i\nonKeyUp = handler KET.keyup <<< keyHandler\n\nonBlur :: forall r i. (FocusEvent -> i) -> IProp (onBlur :: FocusEvent | r) i\nonBlur = handler ET.blur <<< focusHandler\n\nonFocus :: forall r i. (FocusEvent -> i) -> IProp (onFocus :: FocusEvent | r) i\nonFocus = handler FET.focus <<< focusHandler\n\nonFocusIn :: forall r i. (FocusEvent -> i) -> IProp (onFocusIn :: FocusEvent | r) i\nonFocusIn = handler FET.focusin <<< focusHandler\n\nonFocusOut :: forall r i. (FocusEvent -> i) -> IProp (onFocusOut :: FocusEvent | r) i\nonFocusOut = handler FET.focusout <<< focusHandler\n\nonDrag :: forall r i. (DragEvent -> i) -> IProp (onDrag :: DragEvent | r) i\nonDrag = handler DET.drag <<< dragHandler\n\nonDragEnd :: forall r i. (DragEvent -> i) -> IProp (onDragEnd :: DragEvent | r) i\nonDragEnd = handler DET.dragend <<< dragHandler\n\nonDragExit :: forall r i. (DragEvent -> i) -> IProp (onDragExit :: DragEvent | r) i\nonDragExit = handler DET.dragexit <<< dragHandler\n\nonDragEnter :: forall r i. (DragEvent -> i) -> IProp (onDragEnter :: DragEvent | r) i\nonDragEnter = handler DET.dragenter <<< dragHandler\n\nonDragLeave :: forall r i. (DragEvent -> i) -> IProp (onDragLeave :: DragEvent | r) i\nonDragLeave = handler DET.dragleave <<< dragHandler\n\nonDragOver :: forall r i. (DragEvent -> i) -> IProp (onDragOver :: DragEvent | r) i\nonDragOver = handler DET.dragover <<< dragHandler\n\nonDragStart :: forall r i. (DragEvent -> i) -> IProp (onDragStart :: DragEvent | r) i\nonDragStart = handler DET.dragstart <<< dragHandler\n\nonDrop :: forall r i. (DragEvent -> i) -> IProp (onDrop :: DragEvent | r) i\nonDrop = handler DET.drop <<< dragHandler\n\nonTouchCancel :: forall r i. (TouchEvent -> i) -> IProp (onTouchCancel :: TouchEvent | r) i\nonTouchCancel = handler (EventType \"touchcancel\") <<< touchHandler\n\nonTouchEnd :: forall r i. (TouchEvent -> i) -> IProp (onTouchEnd :: TouchEvent | r) i\nonTouchEnd = handler (EventType \"touchend\") <<< touchHandler\n\nonTouchEnter :: forall r i. (TouchEvent -> i) -> IProp (onTouchEnter :: TouchEvent | r) i\nonTouchEnter = handler (EventType \"touchenter\") <<< touchHandler\n\nonTouchLeave :: forall r i. (TouchEvent -> i) -> IProp (onTouchEnter :: TouchEvent | r) i\nonTouchLeave = handler (EventType \"touchleave\") <<< touchHandler\n\nonTouchMove :: forall r i. (TouchEvent -> i) -> IProp (onTouchMove :: TouchEvent | r) i\nonTouchMove = handler (EventType \"touchmove\") <<< touchHandler\n\nonTouchStart :: forall r i. (TouchEvent -> i) -> IProp (onTouchStart :: TouchEvent | r) i\nonTouchStart = handler (EventType \"touchstart\") <<< touchHandler\n\nonResize :: forall r i. (Event -> i) -> IProp (onResize :: Event | r) i\nonResize = handler (EventType \"resize\")\n\nkeyHandler :: forall i. (KeyboardEvent -> i) -> Event -> i\nkeyHandler = unsafeCoerce\n\nmouseHandler :: forall i. (MouseEvent -> i) -> Event -> i\nmouseHandler = unsafeCoerce\n\nwheelHandler :: forall i. (WheelEvent -> i) -> Event -> i\nwheelHandler = unsafeCoerce\n\nfocusHandler :: forall i. (FocusEvent -> i) -> Event -> i\nfocusHandler = unsafeCoerce\n\ndragHandler :: forall i. (DragEvent -> i) -> Event -> i\ndragHandler = unsafeCoerce\n\nclipboardHandler :: forall i. (ClipboardEvent -> i) -> Event -> i\nclipboardHandler = unsafeCoerce\n\ntouchHandler :: forall i. (TouchEvent -> i) -> Event -> i\ntouchHandler = unsafeCoerce\n\n-- | Attaches event handler to event `key` with getting `prop` field as an\n-- | argument of `handler`.\naddForeignPropHandler :: forall r i value. EventType -> String -> (Foreign -> F value) -> (value -> i) -> IProp r i\naddForeignPropHandler key prop reader f =\n  handler' key $ EE.currentTarget >=> \\e -> either (const Nothing) (Just <<< f) $ runExcept $ go e\n  where\n  go a = reader <=< readProp prop $ unsafeToForeign a\n\n-- | Attaches an event handler which will produce an input when the value of an\n-- | input field changes.\nonValueChange :: forall r i. (String -> i) -> IProp (value :: String, onChange :: Event | r) i\nonValueChange = addForeignPropHandler ET.change \"value\" readString\n\n-- | Attaches an event handler which will produce an input when the seleced index of a\n-- | `select` element changes.\nonSelectedIndexChange :: forall r i. (Int -> i) -> IProp (selectedIndex :: Int, onChange :: Event | r) i\nonSelectedIndexChange = addForeignPropHandler ET.change \"selectedIndex\" readInt\n\n-- | Attaches an event handler which will fire on input.\nonValueInput :: forall r i. (String -> i) -> IProp (value :: String, onInput :: Event | r) i\nonValueInput = addForeignPropHandler ET.input \"value\" readString\n\n-- | Attaches an event handler which will fire when a checkbox is checked or\n-- | unchecked.\nonChecked :: forall r i. (Boolean -> i) -> IProp (checked :: Boolean, onChange :: Event | r) i\nonChecked = addForeignPropHandler ET.change \"checked\" readBoolean\n","-- | A closed signature of type-indexed (refined) HTML properties; these can be\n-- | used to ensure correctness by construction, and then erased into the\n-- | standard unrefined versions.\nmodule Halogen.HTML.Properties\n  ( IProp(..)\n  , prop\n  , attr\n  , attrNS\n  , ref\n  , expand\n\n  , alt\n  , charset\n  , class_\n  , classes\n  , cols\n  , rows\n  , colSpan\n  , rowSpan\n  , for\n  , height\n  , width\n  , href\n  , id\n  , name\n  , rel\n  , src\n  , srcDoc\n  , style\n  , scope\n  , target\n  , title\n  , download\n\n  , method\n  , action\n  , enctype\n  , noValidate\n\n  , type_\n  , value\n  , min\n  , max\n  , step\n  , disabled\n  , enabled\n  , required\n  , readOnly\n  , spellcheck\n  , checked\n  , selected\n  , selectedIndex\n  , placeholder\n  , autocomplete\n  , list\n  , autofocus\n  , multiple\n  , pattern\n  , accept\n\n  , autoplay\n  , controls\n  , loop\n  , muted\n  , poster\n  , preload\n\n  , draggable\n  , tabIndex\n\n  , module I\n  ) where\n\nimport Prelude\n\nimport DOM.HTML.Indexed (CSSPixel) as I\nimport DOM.HTML.Indexed.AutocompleteType (AutocompleteType(..)) as I\nimport DOM.HTML.Indexed.ButtonType (ButtonType(..)) as I\nimport DOM.HTML.Indexed.FormMethod (FormMethod(..)) as I\nimport DOM.HTML.Indexed.InputAcceptType (InputAcceptType(..)) as I\nimport DOM.HTML.Indexed.InputType (InputType(..)) as I\nimport DOM.HTML.Indexed.MenuType (MenuType(..)) as I\nimport DOM.HTML.Indexed.MenuitemType (MenuitemType(..)) as I\nimport DOM.HTML.Indexed.OrderedListType (OrderedListType(..)) as I\nimport DOM.HTML.Indexed.PreloadValue (PreloadValue(..)) as I\nimport DOM.HTML.Indexed.ScopeValue (ScopeValue(..)) as I\nimport DOM.HTML.Indexed.StepValue (StepValue(..)) as I\nimport Data.Maybe (Maybe(..))\nimport Data.MediaType (MediaType)\nimport Data.Newtype (class Newtype, unwrap)\nimport Data.String (joinWith)\nimport Halogen.HTML.Core (class IsProp, AttrName(..), ClassName, Namespace, PropName(..), Prop)\nimport Halogen.HTML.Core as Core\nimport Halogen.Query.Input (Input(..), RefLabel)\nimport Prim.Row as Row\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element)\n\n-- | The phantom row `r` can be thought of as a context which is synthesized in\n-- | the course of constructing a refined HTML expression.\nnewtype IProp (r :: Row Type) i = IProp (Prop (Input i))\n\nderive instance newtypeIProp :: Newtype (IProp r i) _\nderive instance functorIProp :: Functor (IProp r)\n\n-- | Creates an indexed HTML property.\nprop\n  :: forall value r i\n   . IsProp value\n  => PropName value\n  -> value\n  -> IProp r i\nprop = (unsafeCoerce :: (PropName value -> value -> Prop (Input i)) -> PropName value -> value -> IProp r i) Core.prop\n\n-- | Creates an indexed HTML attribute.\nattr :: forall r i. AttrName -> String -> IProp r i\nattr =\n  Core.attr Nothing #\n    ( unsafeCoerce\n        :: (AttrName -> String -> Prop (Input i))\n        -> AttrName\n        -> String\n        -> IProp r i\n    )\n\n-- | Creates an indexed HTML attribute.\nattrNS :: forall r i. Namespace -> AttrName -> String -> IProp r i\nattrNS =\n  pure >>> Core.attr >>>\n    ( unsafeCoerce\n        :: (AttrName -> String -> Prop (Input i))\n        -> AttrName\n        -> String\n        -> IProp r i\n    )\n\n-- | The `ref` property allows an input to be raised once a `HTMLElement` has\n-- | been created or destroyed in the DOM for the element that the property is\n-- | attached to.\nref :: forall r i. RefLabel -> IProp r i\nref = (unsafeCoerce :: ((Maybe Element -> Maybe (Input i)) -> Prop (Input i)) -> (Maybe Element -> Maybe (Input i)) -> IProp r i) Core.ref <<< go\n  where\n  go :: RefLabel -> Maybe Element -> Maybe (Input i)\n  go p mel = Just (RefUpdate p mel)\n\n-- | Every `IProp lt i` can be cast to some `IProp gt i` as long as `lt` is a\n-- | subset of `gt`.\nexpand :: forall lt gt a i. Row.Union lt a gt => IProp lt i -> IProp gt i\nexpand = unsafeCoerce\n\nalt :: forall r i. String -> IProp (alt :: String | r) i\nalt = prop (PropName \"alt\")\n\ncharset :: forall r i. String -> IProp (charset :: String | r) i\ncharset = prop (PropName \"charset\")\n\nclass_ :: forall r i. ClassName -> IProp (class :: String | r) i\nclass_ = prop (PropName \"className\") <<< unwrap\n\nclasses :: forall r i. Array ClassName -> IProp (class :: String | r) i\nclasses = prop (PropName \"className\") <<< joinWith \" \" <<< map unwrap\n\ncols :: forall r i. Int -> IProp (cols :: Int | r) i\ncols = prop (PropName \"cols\")\n\nrows :: forall r i. Int -> IProp (rows :: Int | r) i\nrows = prop (PropName \"rows\")\n\ncolSpan :: forall r i. Int -> IProp (colSpan :: Int | r) i\ncolSpan = prop (PropName \"colSpan\")\n\nrowSpan :: forall r i. Int -> IProp (rowSpan :: Int | r) i\nrowSpan = prop (PropName \"rowSpan\")\n\nfor :: forall r i. String -> IProp (for :: String | r) i\nfor = prop (PropName \"htmlFor\")\n\nheight :: forall r i. I.CSSPixel -> IProp (height :: I.CSSPixel | r) i\nheight = prop (PropName \"height\")\n\nwidth :: forall r i. I.CSSPixel -> IProp (width :: I.CSSPixel | r) i\nwidth = prop (PropName \"width\")\n\nhref :: forall r i. String -> IProp (href :: String | r) i\nhref = prop (PropName \"href\")\n\nid :: forall r i. String -> IProp (id :: String | r) i\nid = prop (PropName \"id\")\n\nname :: forall r i. String -> IProp (name :: String | r) i\nname = prop (PropName \"name\")\n\nrel :: forall r i. String -> IProp (rel :: String | r) i\nrel = prop (PropName \"rel\")\n\nsrc :: forall r i. String -> IProp (src :: String | r) i\nsrc = prop (PropName \"src\")\n\nsrcDoc :: forall r i. String -> IProp (srcDoc :: String | r) i\nsrcDoc = prop (PropName \"srcdoc\")\n\n-- | Sets the `style` attribute to the specified string.\n-- |\n-- | ```purs\n-- | ... [ style \"height: 50px;\" ]\n-- | ```\n-- |\n-- | If you prefer to use typed CSS for this attribute, you can use the purescript-halogen-css library:\n-- | https://github.com/purescript-halogen/purescript-halogen-css\nstyle :: forall r i. String -> IProp (style :: String | r) i\nstyle = attr (AttrName \"style\")\n\nscope :: forall r i. I.ScopeValue -> IProp (scope :: I.ScopeValue | r) i\nscope = prop (PropName \"scope\")\n\ntarget :: forall r i. String -> IProp (target :: String | r) i\ntarget = prop (PropName \"target\")\n\ntitle :: forall r i. String -> IProp (title :: String | r) i\ntitle = prop (PropName \"title\")\n\ndownload :: forall r i. String -> IProp (download :: String | r) i\ndownload = prop (PropName \"download\")\n\nmethod :: forall r i. I.FormMethod -> IProp (method :: I.FormMethod | r) i\nmethod = prop (PropName \"method\")\n\naction :: forall r i. String -> IProp (action :: String | r) i\naction = prop (PropName \"action\")\n\nenctype :: forall r i. MediaType -> IProp (enctype :: MediaType | r) i\nenctype = prop (PropName \"enctype\")\n\nnoValidate :: forall r i. Boolean -> IProp (noValidate :: Boolean | r) i\nnoValidate = prop (PropName \"noValidate\")\n\ntype_ :: forall r i value. IsProp value => value -> IProp (type :: value | r) i\ntype_ = prop (PropName \"type\")\n\nvalue :: forall r i value. IsProp value => value -> IProp (value :: value | r) i\nvalue = prop (PropName \"value\")\n\nmin :: forall r i. Number -> IProp (min :: Number | r) i\nmin = prop (PropName \"min\")\n\nmax :: forall r i. Number -> IProp (max :: Number | r) i\nmax = prop (PropName \"max\")\n\nstep :: forall r i. I.StepValue -> IProp (step :: I.StepValue | r) i\nstep = prop (PropName \"step\")\n\nenabled :: forall r i. Boolean -> IProp (disabled :: Boolean | r) i\nenabled = disabled <<< not\n\ndisabled :: forall r i. Boolean -> IProp (disabled :: Boolean | r) i\ndisabled = prop (PropName \"disabled\")\n\nrequired :: forall r i. Boolean -> IProp (required :: Boolean | r) i\nrequired = prop (PropName \"required\")\n\nreadOnly :: forall r i. Boolean -> IProp (readOnly :: Boolean | r) i\nreadOnly = prop (PropName \"readOnly\")\n\nspellcheck :: forall r i. Boolean -> IProp (spellcheck :: Boolean | r) i\nspellcheck = prop (PropName \"spellcheck\")\n\nchecked :: forall r i. Boolean -> IProp (checked :: Boolean | r) i\nchecked = prop (PropName \"checked\")\n\nselected :: forall r i. Boolean -> IProp (selected :: Boolean | r) i\nselected = prop (PropName \"selected\")\n\nselectedIndex :: forall r i. Int -> IProp (selectedIndex :: Int | r) i\nselectedIndex = prop (PropName \"selectedIndex\")\n\nplaceholder :: forall r i. String -> IProp (placeholder :: String | r) i\nplaceholder = prop (PropName \"placeholder\")\n\nautocomplete :: forall r i. I.AutocompleteType -> IProp (autocomplete :: I.AutocompleteType | r) i\nautocomplete = prop (PropName \"autocomplete\")\n\nlist :: forall r i. String -> IProp (list :: String | r) i\nlist = attr (AttrName \"list\")\n\nautofocus :: forall r i. Boolean -> IProp (autofocus :: Boolean | r) i\nautofocus = prop (PropName \"autofocus\")\n\nmultiple :: forall r i. Boolean -> IProp (multiple :: Boolean | r) i\nmultiple = prop (PropName \"multiple\")\n\naccept :: forall r i. I.InputAcceptType -> IProp (accept :: I.InputAcceptType | r) i\naccept = prop (PropName \"accept\")\n\npattern :: forall r i. String -> IProp (pattern :: String | r) i\npattern = prop (PropName \"pattern\")\n\nautoplay :: forall r i. Boolean -> IProp (autoplay :: Boolean | r) i\nautoplay = prop (PropName \"autoplay\")\n\ncontrols :: forall r i. Boolean -> IProp (controls :: Boolean | r) i\ncontrols = prop (PropName \"controls\")\n\nloop :: forall r i. Boolean -> IProp (loop :: Boolean | r) i\nloop = prop (PropName \"loop\")\n\nmuted :: forall r i. Boolean -> IProp (muted :: Boolean | r) i\nmuted = prop (PropName \"muted\")\n\nposter :: forall r i. String -> IProp (poster :: String | r) i\nposter = prop (PropName \"poster\")\n\npreload :: forall r i. I.PreloadValue -> IProp (preload :: I.PreloadValue | r) i\npreload = prop (PropName \"preload\")\n\ndraggable :: forall r i. Boolean -> IProp (draggable :: Boolean | r) i\ndraggable = prop (PropName \"draggable\")\n\ntabIndex :: forall r i. Int -> IProp (tabIndex :: Int | r) i\ntabIndex = prop (PropName \"tabIndex\")\n","module Record\n  ( get\n  , set\n  , modify\n  , insert\n  , delete\n  , rename\n  , equal\n  , merge\n  , union\n  , disjointUnion\n  , nub\n  , class EqualFields\n  , equalFields\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried (runFn2)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Prim.Row (class Lacks, class Cons, class Nub, class Union)\nimport Prim.RowList (class RowToList, RowList, Cons, Nil)\nimport Record.Unsafe (unsafeGet, unsafeSet, unsafeDelete)\nimport Record.Unsafe.Union (unsafeUnionFn)\nimport Type.Proxy (Proxy(..))\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Get a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | get (Proxy :: Proxy \"x\") :: forall r a. { x :: a | r } -> a\n-- | ```\nget\n  :: forall r r' l a\n   . IsSymbol l\n  => Cons l a r' r\n  => Proxy l\n  -> Record r\n  -> a\nget l r = unsafeGet (reflectSymbol l) r\n\n-- | Set a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | set (Proxy :: Proxy \"x\")\n-- |   :: forall r a b. a -> { x :: b | r } -> { x :: a | r }\n-- | ```\nset\n  :: forall r1 r2 r l a b\n   . IsSymbol l\n  => Cons l a r r1\n  => Cons l b r r2\n  => Proxy l\n  -> b\n  -> Record r1\n  -> Record r2\nset l b r = unsafeSet (reflectSymbol l) b r\n\n-- | Modify a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | modify (Proxy :: Proxy \"x\")\n-- |   :: forall r a b. (a -> b) -> { x :: a | r } -> { x :: b | r }\n-- | ```\nmodify\n  :: forall r1 r2 r l a b\n   . IsSymbol l\n  => Cons l a r r1\n  => Cons l b r r2\n  => Proxy l\n  -> (a -> b)\n  -> Record r1\n  -> Record r2\nmodify l f r = set l (f (get l r)) r\n\n-- | Insert a new property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | insert (Proxy :: Proxy \"x\")\n-- |   :: forall r a. Lacks \"x\" r => a -> { | r } -> { x :: a | r }\n-- | ```\ninsert\n  :: forall r1 r2 l a\n   . IsSymbol l\n  => Lacks l r1\n  => Cons l a r1 r2\n  => Proxy l\n  -> a\n  -> Record r1\n  -> Record r2\ninsert l a r = unsafeSet (reflectSymbol l) a r\n\n-- | Delete a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | Note that the type of the resulting row must _lack_ the specified property.\n-- | Since duplicate labels are allowed, this is checked with a type class constraint.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | delete (Proxy :: Proxy \"x\")\n-- |   :: forall r a. Lacks \"x\" r => { x :: a | r } -> { | r }\n-- | ```\ndelete\n  :: forall r1 r2 l a\n   . IsSymbol l\n  => Lacks l r1\n  => Cons l a r1 r2\n  => Proxy l\n  -> Record r2\n  -> Record r1\ndelete l r = unsafeDelete (reflectSymbol l) r\n\n-- | Rename a property for a label which is specified using a value-level proxy for\n-- | a type-level string.\n-- |\n-- | Note that the type of the resulting row must _lack_ the specified property.\n-- | Since duplicate labels are allowed, this is checked with a type class constraint.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | rename (Proxy :: Proxy \"x\") (Proxy :: Proxy \"y\")\n-- |   :: forall a r. Lacks \"x\" r => Lacks \"y\" r => { x :: a | r} -> { y :: a | r}\n-- | ```\nrename :: forall prev next ty input inter output\n   . IsSymbol prev\n  => IsSymbol next\n  => Cons prev ty inter input\n  => Lacks prev inter\n  => Cons next ty inter output\n  => Lacks next inter\n  => Proxy prev\n  -> Proxy next\n  -> Record input\n  -> Record output\nrename prev next record =\n  insert next (get prev record) (delete prev record :: Record inter)\n\n-- | Merges two records with the first record's labels taking precedence in the\n-- | case of overlaps.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | merge { x: 1, y: \"y\" } { y: 2, z: true }\n-- |  :: { x :: Int, y :: String, z :: Boolean }\n-- | ```\nmerge\n  :: forall r1 r2 r3 r4\n   . Union r1 r2 r3\n  => Nub r3 r4\n  => Record r1\n  -> Record r2\n  -> Record r4\nmerge l r = runFn2 unsafeUnionFn l r\n\n-- | Merges two records with the first record's labels taking precedence in the\n-- | case of overlaps. Unlike `merge`, this does not remove duplicate labels\n-- | from the resulting record type. This can result in better inference for\n-- | some pipelines, deferring the need for a `Nub` constraint.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | union { x: 1, y: \"y\" } { y: 2, z: true }\n-- |  :: { x :: Int, y :: String, y :: Int, z :: Boolean }\n-- | ```\nunion\n  :: forall r1 r2 r3\n   . Union r1 r2 r3\n  => Record r1\n  -> Record r2\n  -> Record r3\nunion l r = runFn2 unsafeUnionFn l r\n\n-- | Merges two records where no labels overlap. This restriction exhibits\n-- | better inference than `merge` when the resulting record type is known,\n-- | but one argument is not.\n-- |\n-- | For example, hole `?help` is inferred to have type `{ b :: Int }` here:\n-- |\n-- | ```purescript\n-- | disjointUnion { a: 5 } ?help :: { a :: Int, b :: Int }\n-- | ```\ndisjointUnion\n  :: forall r1 r2 r3\n   . Union r1 r2 r3\n  => Nub r3 r3\n  => Record r1\n  -> Record r2\n  -> Record r3\ndisjointUnion l r = runFn2 unsafeUnionFn l r\n\n-- | A coercion which removes duplicate labels from a record's type.\nnub\n  :: forall r1 r2\n   . Nub r1 r2\n  => Record r1\n  -> Record r2\nnub = unsafeCoerce\n\n-- | Check two records of the same type for equality.\nequal\n  :: forall r rs\n   . RowToList r rs\n  => EqualFields rs r\n  => Record r\n  -> Record r\n  -> Boolean\nequal a b = equalFields (Proxy :: Proxy rs) a b\n\nclass EqualFields (rs :: RowList Type) (row :: Row Type) | rs -> row where\n  equalFields :: Proxy rs -> Record row -> Record row -> Boolean\n\ninstance equalFieldsCons\n  ::\n  ( IsSymbol name\n  , Eq ty\n  , Cons name ty tailRow row\n  , EqualFields tail row\n  ) => EqualFields (Cons name ty tail) row where\n  equalFields _ a b = get' a == get' b && equalRest a b\n    where\n      get' = get (Proxy :: Proxy name)\n      equalRest = equalFields (Proxy :: Proxy tail)\n\ninstance equalFieldsNil :: EqualFields Nil row where\n  equalFields _ _ _ = true\n","module Util.Halogen where\n\nimport Prelude\n\nimport Halogen.HTML as H\nimport Halogen.HTML as HH\nimport Halogen.HTML.Events as HE\nimport Halogen.HTML.Properties as HP\n\n----------------------------------------------------------------\n\nempty :: forall w i. HH.HTML w i\nempty = HH.text mempty\n\nfa :: forall w i. String -> Array H.ClassName -> HH.HTML w i\nfa s c = HH.i [ HP.classes $ [ H.ClassName (\"fa-solid \" <> s) ] <> c ] []\n\nfa_ :: forall w i. String -> HH.HTML w i\nfa_ s = HH.i [ HP.class_ $ H.ClassName (\"fa-solid \" <> s) ] []\n\nplusButton :: forall w i. i -> HH.HTML w i\nplusButton = button (fa_ \"fa-plus\") $ H.ClassName \"border border-sky-500 text-sky-700 hover:bg-sky-200\"\n\nremoveButton :: forall w i. i -> HH.HTML w i\nremoveButton = button (fa_ \"fa-xmark\") $ H.ClassName \"text-gray-500 hover:bg-gray-200\"\n\ntoggleButton :: forall w i. i -> HH.HTML w i\ntoggleButton = button (fa_ \"fa-arrows-rotate\") $ H.ClassName \"text-gray-500 hover:bg-gray-200\"\n\nupButton :: forall w i. i -> HH.HTML w i\nupButton = button (fa_ \"fa-angle-up\") $ H.ClassName \"text-gray-500 hover:bg-gray-200\"\n\ndownButton :: forall w i. i -> HH.HTML w i\ndownButton = button (fa_ \"fa-angle-down\") $ H.ClassName \"text-gray-500 hover:bg-gray-200\"\n\nbutton :: forall w i. HH.HTML w i -> H.ClassName -> i -> HH.HTML w i\nbutton content style h =\n  HH.button\n    [ HP.classes\n        [ H.ClassName \"rounded w-full h-full py-1 px-2 transition-colors duration-75\"\n        , style\n        ]\n    , HE.onClick $ const h\n    ]\n    [ content ]\n","module App.Selector where\n\nimport Prelude\n\nimport Control.Monad.Maybe.Trans (runMaybeT)\nimport Data.Array as Array\nimport Data.Maybe (Maybe(..), maybe)\nimport Halogen as H\nimport Halogen.HTML as HH\nimport Halogen.HTML.Events as HE\nimport Halogen.HTML.Properties as HP\nimport Record as Record\nimport Type.Proxy (Proxy(..))\nimport Util.Halogen as HU\n\n----------------------------------------------------------------\n\ntype Item key = { id :: key, value :: String, selected :: Boolean }\n\ntype Items key = Array (Item key)\n\ntype Input key = Array { id :: key, value :: String }\n\ntype Output key = Array key\n\ndata Action key\n  = EnterEdit\n  | LeaveEdit\n  | Toggle key\n  | Receive (Input key)\n\ndata Query key a\n  = SetItems (Items key) a\n\n----------------------------------------------------------------\n\ncomponent :: forall m k. Eq k => H.Component (Query k) (Input k) (Output k) m\ncomponent = H.mkComponent\n  { initialState\n  , render\n  , eval: H.mkEval $ H.defaultEval\n      { handleAction = action\n      , handleQuery = runMaybeT <<< query\n      , receive = Just <<< Receive\n      }\n  }\n  where\n\n  initialState :: _ -> { items :: Items k, isEditMode :: Boolean }\n  initialState = { items: _, isEditMode: false } <<< map (Record.insert (Proxy @\"selected\") false)\n\n  render { items, isEditMode } =\n    HH.div\n      [ HP.class_ $ H.ClassName \"mx-1 flex\" ]\n      [ if Array.all (not _.selected) items || isEditMode then renderAddButton else HU.empty\n      , renderBackground isEditMode\n      , HH.ul\n          [ HP.class_ if isEditMode\n              then H.ClassName \"break-anywhere absolute flex min-w-48 flex-col gap-0.5 bg-white p-4 shadow-md\"\n              else H.ClassName \"break-anywhere flex w-full flex-wrap gap-1\"\n          , HE.onClick $ const EnterEdit\n          ]\n          $ items <#> renderItem isEditMode\n      ]\n\n  renderBackground isEditMode =\n    HH.div\n      [ HP.class_ if isEditMode then H.ClassName \"fixed inset-0 bg-black opacity-20\" else H.ClassName \"hidden\"\n      , HE.onClick $ const LeaveEdit\n      ]\n      []\n\n  renderItem isEditMode item =\n    HH.li\n      [ HP.class_ if item.selected || isEditMode then H.ClassName \"min-w-0\" else H.ClassName \"hidden\" ]\n      [ HH.button\n          [ HP.classes\n              [ H.ClassName \"h-full w-full rounded border px-3 py-1 transition-colors duration-75\"\n              , if item.selected\n                  then H.ClassName \"border-sky-700 bg-sky-500 text-white hover:bg-sky-600\"\n                  else H.ClassName \"border-gray-800 bg-gray-300 text-black hover:bg-gray-400\"\n              ]\n          , HE.onClick $ const (Toggle item.id)\n          ]\n          [ HH.text item.value ]\n      ]\n\n  renderAddButton =\n    HH.div_\n      [ HU.plusButton EnterEdit ]\n\n  action = case _ of\n    EnterEdit -> do\n      H.modify_ _ { isEditMode = true }\n    LeaveEdit -> do\n      { items } <- H.modify _ { isEditMode = false }\n      H.raise $ items # Array.filter _.selected <#> _.id\n    Toggle id -> do\n      whenM (H.gets _.isEditMode) do\n        H.modify_ do\n          items <- _.items\n          let items' = items <#> \\item -> if item.id == id then item { selected = not item.selected } else item\n          _ { items = items' }\n    Receive input -> do\n      H.modify_ do\n        items <- _.items\n        let items' = input <#> \\{ id, value } -> { id, value, selected: maybe false _.selected (Array.find (_.id >>> (_ == id)) items) }\n        _ { items = items' }\n\n  query :: _ ~> _\n  query = case _ of\n    SetItems items a -> do\n      H.put { items, isEditMode: false }\n      pure a\n","-- | This module re-exports the types for the `HTML` DSL, and values for all\n-- | supported HTML elements.\nmodule Halogen.HTML\n  ( ComponentHTML\n  , PlainHTML\n  , fromPlainHTML\n  , slot\n  , slot_\n  , memoized\n  , lazy\n  , lazy2\n  , lazy3\n  , module Halogen.HTML.Core\n  , module Halogen.HTML.Elements\n  , module Halogen.HTML.Properties\n  ) where\n\nimport Halogen.HTML.Elements\n\nimport Data.Function (const)\nimport Data.Function.Uncurried as Fn\nimport Data.Maybe (Maybe(..))\nimport Data.Symbol (class IsSymbol)\nimport Halogen.Component (Component, ComponentSlot(..), componentSlot)\nimport Halogen.Data.Slot (Slot)\nimport Halogen.HTML.Core (class IsProp, AttrName(..), ClassName(..), HTML(..), Namespace(..), PropName(..), ElemName(..), text, handler)\nimport Halogen.HTML.Core as Core\nimport Halogen.HTML.Properties (IProp, attr, attrNS, prop)\nimport Halogen.VDom.Thunk (thunk1, thunk2, thunk3, thunked)\nimport Prelude (class Ord, Void, (<<<), (<$>))\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | A convenience synonym for the output type of a `render` function for a\n-- | component that renders HTML.\n-- |\n-- | - `action` is the type of actions, events internal to the component that can\n-- |   be evaluated with the `handleAction` function\n-- | - `slots` is the set of child component types that can be used in the HTML\n-- | - `m` is the monad used by the child component during evaluation\ntype ComponentHTML action slots m = HTML (ComponentSlot slots m action) action\n\n-- | A type useful for a chunk of HTML with no slot-embedding or query-raising.\n-- |\n-- | Often a polymorphic usage of `HTML` is good enough for this, but sometimes\n-- | it's useful to have a type like this (and accompanying coercion) when doing\n-- | things like creating components that accept a chunk of HTML as part of\n-- | their configuration.\ntype PlainHTML = HTML Void Void\n\n-- | Relaxes the type of `PlainHTML` to make it compatible with all `HTML`.\nfromPlainHTML :: forall w i. PlainHTML -> HTML w i\nfromPlainHTML = unsafeCoerce -- ≅ bimap absurd absurd\n\n-- | Defines a slot for a child component. Takes:\n-- | - the slot address label\n-- | - the slot address index\n-- | - the component for the slot\n-- | - the input value to pass to the component\n-- | - a function mapping outputs from the component to a query in the parent\nslot\n  :: forall query action input output slots m label slot _1\n   . Row.Cons label (Slot query output slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Component query input output m\n  -> input\n  -> (output -> action)\n  -> ComponentHTML action slots m\nslot label p component input outputQuery =\n  Core.widget (ComponentSlot (componentSlot label p component input (Just <<< outputQuery)))\n\n-- | Defines a slot for a child component, ignoring its output.\n-- |\n-- | This variant may be used when the component produces output, but it is not\n-- | needed in the current context, or instead of passing `absurd` to `slot`\n-- | when the output type is `Void`.\n-- |\n-- | Takes:\n-- | - the slot address label\n-- | - the slot address index\n-- | - the component for the slot\n-- | - the input value to pass to the component\nslot_\n  :: forall query action input output slots m label slot _1\n   . Row.Cons label (Slot query output slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Component query input output m\n  -> input\n  -> ComponentHTML action slots m\nslot_ label p component input =\n  Core.widget (ComponentSlot (componentSlot label p component input (const Nothing)))\n\n-- | Optimizes rendering of a subtree given an equality predicate. If an argument\n-- | is deemed equivalent to the previous value, rendering and diffing will be\n-- | skipped. You should not use this function fully saturated, but instead\n-- | partially apply it for use within a Component's scope. For example, to skip\n-- | rendering for equal states, just wrap your `render` function.\n-- |\n-- | ```purescript\n-- | myComponent = component\n-- |  { render: memoized eq render\n-- |  , ...\n-- |  }\n-- | ```\nmemoized\n  :: forall a action slots m\n   . (a -> a -> Boolean)\n  -> (a -> ComponentHTML action slots m)\n  -> a\n  -> ComponentHTML action slots m\nmemoized eqFn f =\n  -- Note: This implementation must not be eta-expanded, as it relies on\n  -- partial application to work.\n  Core.widget <<< ThunkSlot <$> thunked eqFn f\n\n-- | Skips rendering for referentially equal arguments. You should not use this\n-- | function fully saturated, but instead partially apply it for use within a\n-- | Component's scope.\nlazy\n  :: forall a action slots m\n   . (a -> ComponentHTML action slots m)\n  -> a\n  -> ComponentHTML action slots m\nlazy f a = Core.widget (ThunkSlot (Fn.runFn2 thunk1 f a))\n\n-- | Like `lazy`, but for a rendering function which takes 2 arguments.\nlazy2\n  :: forall a b action slots m\n   . (a -> b -> ComponentHTML action slots m)\n  -> a\n  -> b\n  -> ComponentHTML action slots m\nlazy2 f a b = Core.widget (ThunkSlot (Fn.runFn3 thunk2 f a b))\n\n-- | Like `lazy`, but for a rendering function which takes 3 arguments.\nlazy3\n  :: forall a b c action slots m\n   . (a -> b -> c -> ComponentHTML action slots m)\n  -> a\n  -> b\n  -> c\n  -> ComponentHTML action slots m\nlazy3 f a b c = Core.widget (ThunkSlot (Fn.runFn4 thunk3 f a b c))\n","export function _read(nothing, just, value) {\n  var tag = Object.prototype.toString.call(value);\n  if (tag.indexOf(\"[object HTML\") === 0 && tag.indexOf(\"Element]\") === tag.length - 8) {\n    return just(value);\n  } else {\n    return nothing;\n  }\n}\n\n// ----------------------------------------------------------------------------\n\nexport function title(elt) {\n  return function () {\n    return elt.title;\n  };\n}\n\nexport function setTitle(title) {\n  return function (elt) {\n    return function () {\n      elt.title = title;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function lang(elt) {\n  return function () {\n    return elt.lang;\n  };\n}\n\nexport function setLang(lang) {\n  return function (elt) {\n    return function () {\n      elt.lang = lang;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function dir(elt) {\n  return function () {\n    return elt.dir;\n  };\n}\n\nexport function setDir(dir) {\n  return function (elt) {\n    return function () {\n      elt.dir = dir;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function hidden(elt) {\n  return function () {\n    return elt.hidden;\n  };\n}\n\nexport function setHidden(hidden) {\n  return function (elt) {\n    return function () {\n      elt.hidden = hidden;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function tabIndex(elt) {\n  return function () {\n    return elt.tabIndex;\n  };\n}\n\nexport function setTabIndex(tabIndex) {\n  return function (elt) {\n    return function () {\n      elt.tabIndex = tabIndex;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function draggable(elt) {\n  return function () {\n    return elt.draggable;\n  };\n}\n\nexport function setDraggable(draggable) {\n  return function (elt) {\n    return function () {\n      elt.draggable = draggable;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function contentEditable(elt) {\n  return function () {\n    return elt.contentEditable;\n  };\n}\n\nexport function setContentEditable(contentEditable) {\n  return function (elt) {\n    return function () {\n      elt.contentEditable = contentEditable;\n    };\n  };\n}\n\nexport function isContentEditable(elt) {\n  return function () {\n    return elt.isContentEditable;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function spellcheck(elt) {\n  return function () {\n    return elt.spellcheck;\n  };\n}\n\nexport function setSpellcheck(spellcheck) {\n  return function (elt) {\n    return function () {\n      elt.spellcheck = spellcheck;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function click(elt) {\n  return function () {\n    return elt.click();\n  };\n}\n\nexport function focus(elt) {\n  return function () {\n    return elt.focus();\n  };\n}\n\nexport function blur(elt) {\n  return function () {\n    return elt.blur();\n  };\n}\n\n// - CSSOM ---------------------------------------------------------------------\n\nexport function _offsetParent(el) {\n  return function () {\n    return el.offsetParent;\n  };\n}\n\nexport function offsetTop(el) {\n  return function () {\n    return el.offsetTop;\n  };\n}\n\nexport function offsetLeft(el) {\n  return function () {\n    return el.offsetLeft;\n  };\n}\n\nexport function offsetWidth(el) {\n  return function () {\n    return el.offsetWidth;\n  };\n}\n\nexport function offsetHeight(el) {\n  return function () {\n    return el.offsetHeight;\n  };\n}\n","module Web.HTML.HTMLElement\n  ( HTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , title\n  , setTitle\n  , lang\n  , setLang\n  , dir\n  , setDir\n  , hidden\n  , setHidden\n  , tabIndex\n  , setTabIndex\n  , draggable\n  , setDraggable\n  , contentEditable\n  , setContentEditable\n  , isContentEditable\n  , spellcheck\n  , setSpellcheck\n  , click\n  , focus\n  , blur\n  , offsetParent\n  , offsetTop\n  , offsetLeft\n  , offsetWidth\n  , offsetHeight\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode)\nimport Web.DOM.Element (Element)\nimport Web.DOM.Internal.Types (Node)\nimport Web.DOM.NonDocumentTypeChildNode (NonDocumentTypeChildNode)\nimport Web.DOM.ParentNode (ParentNode)\nimport Web.Event.EventTarget (EventTarget)\n\nforeign import data HTMLElement :: Type\n\nforeign import _read :: forall a. Fn3 (forall x. Maybe x) (forall x. x -> Maybe x) a (Maybe HTMLElement)\n\nfromElement :: Element -> Maybe HTMLElement\nfromElement x = runFn3 _read Nothing Just x\n\nfromNode :: Node -> Maybe HTMLElement\nfromNode x = runFn3 _read Nothing Just x\n\nfromChildNode :: ChildNode -> Maybe HTMLElement\nfromChildNode x = runFn3 _read Nothing Just x\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLElement\nfromNonDocumentTypeChildNode x = runFn3 _read Nothing Just x\n\nfromParentNode :: ParentNode -> Maybe HTMLElement\nfromParentNode x = runFn3 _read Nothing Just x\n\nfromEventTarget :: EventTarget -> Maybe HTMLElement\nfromEventTarget x = runFn3 _read Nothing Just x\n\ntoElement :: HTMLElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import title :: HTMLElement -> Effect String\nforeign import setTitle :: String -> HTMLElement -> Effect Unit\n\nforeign import lang :: HTMLElement -> Effect String\nforeign import setLang :: String -> HTMLElement -> Effect Unit\n\nforeign import dir :: HTMLElement -> Effect String\nforeign import setDir :: String -> HTMLElement -> Effect Unit\n\nforeign import hidden :: HTMLElement -> Effect Boolean\nforeign import setHidden :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import tabIndex :: HTMLElement -> Effect Int\nforeign import setTabIndex :: Int -> HTMLElement -> Effect Unit\n\nforeign import draggable :: HTMLElement -> Effect Boolean\nforeign import setDraggable :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import contentEditable :: HTMLElement -> Effect String\nforeign import setContentEditable :: String -> HTMLElement -> Effect Unit\nforeign import isContentEditable :: HTMLElement -> Effect Boolean\n\nforeign import spellcheck :: HTMLElement -> Effect Boolean\nforeign import setSpellcheck :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import click :: HTMLElement -> Effect Unit\nforeign import focus :: HTMLElement -> Effect Unit\nforeign import blur :: HTMLElement -> Effect Unit\n\nforeign import _offsetParent :: HTMLElement -> Effect (Nullable Element)\n\noffsetParent :: HTMLElement -> Effect (Maybe Element)\noffsetParent = map toMaybe <<< _offsetParent\n\nforeign import offsetTop :: HTMLElement -> Effect Number\nforeign import offsetLeft :: HTMLElement -> Effect Number\nforeign import offsetWidth :: HTMLElement -> Effect Number\nforeign import offsetHeight :: HTMLElement -> Effect Number\n","-- | Functions and types used to describe the `HalogenF` algebra used in a\n-- | component's `eval` function.\nmodule Halogen.Query\n  ( Tell\n  , mkTell\n  , tell\n  , tellAll\n  , Request\n  , mkRequest\n  , request\n  , requestAll\n  , getHTMLElementRef\n  , module Exports\n  , module Halogen.Query.Input\n  , module Halogen.Query.HalogenM\n  , module Halogen.Query.HalogenQ\n  ) where\n\nimport Prelude hiding (join)\n\nimport Control.Monad.State.Class (get, gets, modify, modify_, put) as Exports\nimport Control.Monad.Trans.Class (lift) as Exports\nimport Data.Map (Map)\nimport Data.Maybe (Maybe)\nimport Data.Symbol (class IsSymbol)\nimport Effect.Aff.Class (liftAff) as Exports\nimport Effect.Class (liftEffect) as Exports\nimport Halogen.Data.Slot (Slot)\nimport Halogen.Query.HalogenM (ForkId, HalogenF(..), HalogenM(..), SubscriptionId, fork, getRef, join, kill, query, queryAll, raise, subscribe, subscribe', unsubscribe)\nimport Halogen.Query.HalogenQ (HalogenQ(..))\nimport Halogen.Query.Input (RefLabel(..))\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLElement as HTMLElement\n\n-- | Type synonym for a \"tell-style\" query - queries that only cause effects,\n-- | but that cannot receive a return value.\n-- |\n-- | In a query algebra, a tell constructor carries the algebra's type variable\n-- | as its last argument. For example:\n-- |\n-- | ``` purescript\n-- | data Query a\n-- |   = SomeTell a\n-- |   | SomeOtherTell String a\n-- |   | NotATell (Boolean -> a)\n-- | ```\n-- |\n-- | Both `SomeTell` and `SomeOtherTell` carry a plain `a` as a value, whereas\n-- | `NotATell` has `a` as the result of a function so is considered to be a\n-- | \"request\" ([see below](#Request)).\ntype Tell f = Unit -> f Unit\n\n-- | Takes a data constructor of query algebra `f` and creates a tell query.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | data Query a = Tick a\n-- |\n-- | sendTick :: forall o. H.HalogenIO Query o Aff -> Aff (Maybe Unit)\n-- | sendTick app = app.query (H.mkTell Tick)\n-- | ```\nmkTell :: forall f. Tell f -> f Unit\nmkTell act = act unit\n\ntell\n  :: forall state action output m label slots query output' slot _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Tell query\n  -> HalogenM state action slots output m Unit\ntell slot label req = void $ query slot label (req unit)\n\ntellAll\n  :: forall state action output m label slots query output' slot _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> Tell query\n  -> HalogenM state action slots output m Unit\ntellAll label req = void $ queryAll label (req unit)\n\n-- | Type synonym for an \"request-style\" query - queries that can cause effects\n-- | as well as fetching some information from a component.\n-- |\n-- | In a query algebra, a request constructor carries the algebra's type\n-- | variable as the return value of a function as its last argument. For\n-- | example:\n-- |\n-- | ``` purescript\n-- | data Query a = SomeRequest (Boolean -> a)\n-- | ```\ntype Request f a = (a -> a) -> f a\n\n-- | Takes a data constructor of query algebra `f` and creates a request query.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | data Query a = GetTickCount (Int -> a)\n-- |\n-- | getTickCount :: forall o. H.HalogenIO Query o Aff -> Aff (Maybe Int)\n-- | getTickCount app = app.query (H.mkRequest GetTickCount)\n-- | ```\nmkRequest :: forall f a. Request f a -> f a\nmkRequest req = req identity\n\nrequest\n  :: forall state action output m label slots query output' slot a _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> slot\n  -> Request query a\n  -> HalogenM state action slots output m (Maybe a)\nrequest slot label req = query slot label (req identity)\n\nrequestAll\n  :: forall state action output m label slots query output' slot a _1\n   . Row.Cons label (Slot query output' slot) _1 slots\n  => IsSymbol label\n  => Ord slot\n  => Proxy label\n  -> Request query a\n  -> HalogenM state action slots output m (Map slot a)\nrequestAll label req = queryAll label (req identity)\n\n-- | Retrieves a `HTMLElement` value that is associated with a `Ref` in the\n-- | rendered output of a component. If there is no currently rendered value (or\n-- | it is not an `HTMLElement`) for the request will return `Nothing`.\ngetHTMLElementRef\n  :: forall state action slots output m\n   . RefLabel\n  -> HalogenM state action slots output m (Maybe HTMLElement)\ngetHTMLElementRef = map (HTMLElement.fromElement =<< _) <<< getRef\n","/* eslint-disable no-eq-null, eqeqeq */\nfunction id(x) {\n  return x;\n}\n\nexport {id as fromBoolean};\nexport {id as fromNumber};\nexport {id as fromString};\nexport {id as fromArray};\nexport {id as fromObject};\nexport const jsonNull = null;\n\nexport function stringify(j) {\n  return JSON.stringify(j);\n}\n\nexport function stringifyWithIndent(i) {\n  return function (j) {\n    return JSON.stringify(j, null, i);\n  };\n}\n\nfunction isArray(a) {\n  return Object.prototype.toString.call(a) === \"[object Array]\";\n}\n\nexport function _caseJson(isNull, isBool, isNum, isStr, isArr, isObj, j) {\n  if (j == null) return isNull();\n  else if (typeof j === \"boolean\") return isBool(j);\n  else if (typeof j === \"number\") return isNum(j);\n  else if (typeof j === \"string\") return isStr(j);\n  else if (Object.prototype.toString.call(j) === \"[object Array]\")\n    return isArr(j);\n  else return isObj(j);\n}\n\nexport function _compare(EQ, GT, LT, a, b) {\n  if (a == null) {\n    if (b == null) return EQ;\n    else return LT;\n  } else if (typeof a === \"boolean\") {\n    if (typeof b === \"boolean\") {\n      // boolean / boolean\n      if (a === b) return EQ;\n      else if (a === false) return LT;\n      else return GT;\n    } else if (b == null) return GT;\n    else return LT;\n  } else if (typeof a === \"number\") {\n    if (typeof b === \"number\") {\n      if (a === b) return EQ;\n      else if (a < b) return LT;\n      else return GT;\n    } else if (b == null) return GT;\n    else if (typeof b === \"boolean\") return GT;\n    else return LT;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      if (a === b) return EQ;\n      else if (a < b) return LT;\n      else return GT;\n    } else if (b == null) return GT;\n    else if (typeof b === \"boolean\") return GT;\n    else if (typeof b === \"number\") return GT;\n    else return LT;\n  } else if (isArray(a)) {\n    if (isArray(b)) {\n      for (var i = 0; i < Math.min(a.length, b.length); i++) {\n        var ca = _compare(EQ, GT, LT, a[i], b[i]);\n        if (ca !== EQ) return ca;\n      }\n      if (a.length === b.length) return EQ;\n      else if (a.length < b.length) return LT;\n      else return GT;\n    } else if (b == null) return GT;\n    else if (typeof b === \"boolean\") return GT;\n    else if (typeof b === \"number\") return GT;\n    else if (typeof b === \"string\") return GT;\n    else return LT;\n  } else {\n    if (b == null) return GT;\n    else if (typeof b === \"boolean\") return GT;\n    else if (typeof b === \"number\") return GT;\n    else if (typeof b === \"string\") return GT;\n    else if (isArray(b)) return GT;\n    else {\n      var akeys = Object.keys(a);\n      var bkeys = Object.keys(b);\n      if (akeys.length < bkeys.length) return LT;\n      else if (akeys.length > bkeys.length) return GT;\n      var keys = akeys.concat(bkeys).sort();\n      for (var j = 0; j < keys.length; j++) {\n        var k = keys[j];\n        if (a[k] === undefined) return LT;\n        else if (b[k] === undefined) return GT;\n        var ck = _compare(EQ, GT, LT, a[k], b[k]);\n        if (ck !== EQ) return ck;\n      }\n      return EQ;\n    }\n  }\n}\n","-- | This module defines a data type and various functions for creating and\n-- | manipulating JSON values. The README contains additional documentation\n-- | for this module.\nmodule Data.Argonaut.Core\n  ( Json\n  , caseJson\n  , caseJsonNull\n  , caseJsonBoolean\n  , caseJsonNumber\n  , caseJsonString\n  , caseJsonArray\n  , caseJsonObject\n  , isNull\n  , isBoolean\n  , isNumber\n  , isString\n  , isArray\n  , isObject\n  , fromBoolean\n  , fromNumber\n  , fromString\n  , fromArray\n  , fromObject\n  , toNull\n  , toBoolean\n  , toNumber\n  , toString\n  , toArray\n  , toObject\n  , jsonNull\n  , jsonTrue\n  , jsonFalse\n  , jsonZero\n  , jsonEmptyString\n  , jsonEmptyArray\n  , jsonSingletonArray\n  , jsonEmptyObject\n  , jsonSingletonObject\n  , stringify\n  , stringifyWithIndent\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried (Fn5, runFn5, Fn7, runFn7)\nimport Data.Maybe (Maybe(..))\nimport Foreign.Object (Object)\nimport Foreign.Object as Obj\n\n-- | The type of JSON data. The underlying representation is the same as what\n-- | would be returned from JavaScript's `JSON.parse` function; that is,\n-- | ordinary JavaScript booleans, strings, arrays, objects, etc.\nforeign import data Json :: Type\n\ninstance eqJson :: Eq Json where\n  eq j1 j2 = compare j1 j2 == EQ\n\ninstance ordJson :: Ord Json where\n  compare a b = runFn5 _compare EQ GT LT a b\n\n-- | The type of null values inside JSON data. There is exactly one value of\n-- | this type: in JavaScript, it is written `null`. This module exports this\n-- | value as `jsonNull`.\nforeign import data JNull :: Type\n\ninstance eqJNull :: Eq JNull where\n  eq _ _ = true\n\ninstance ordJNull :: Ord JNull where\n  compare _ _ = EQ\n\n-- | Case analysis for `Json` values. See the README for more information.\ncaseJson\n  :: forall a\n   . (Unit -> a)\n  -> (Boolean -> a)\n  -> (Number -> a)\n  -> (String -> a)\n  -> (Array Json -> a)\n  -> (Object Json -> a)\n  -> Json\n  -> a\ncaseJson a b c d e f json = runFn7 _caseJson a b c d e f json\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was null, and a default value for all other cases.\ncaseJsonNull :: forall a. a -> (Unit -> a) -> Json -> a\ncaseJsonNull d f j = runFn7 _caseJson f (const d) (const d) (const d) (const d) (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was a `Boolean`, and a default value for all other cases.\ncaseJsonBoolean :: forall a. a -> (Boolean -> a) -> Json -> a\ncaseJsonBoolean d f j = runFn7 _caseJson (const d) f (const d) (const d) (const d) (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was a `Number`, and a default value for all other cases.\ncaseJsonNumber :: forall a. a -> (Number -> a) -> Json -> a\ncaseJsonNumber d f j = runFn7 _caseJson (const d) (const d) f (const d) (const d) (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was a `String`, and a default value for all other cases.\ncaseJsonString :: forall a. a -> (String -> a) -> Json -> a\ncaseJsonString d f j = runFn7 _caseJson (const d) (const d) (const d) f (const d) (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was a `Array Json`, and a default value for all other cases.\ncaseJsonArray :: forall a. a -> (Array Json -> a) -> Json -> a\ncaseJsonArray d f j = runFn7 _caseJson (const d) (const d) (const d) (const d) f (const d) j\n\n-- | A simpler version of `caseJson` which accepts a callback for when the\n-- | `Json` argument was an `Object`, and a default value for all other cases.\ncaseJsonObject :: forall a. a -> (Object Json -> a) -> Json -> a\ncaseJsonObject d f j = runFn7 _caseJson (const d) (const d) (const d) (const d) (const d) f j\n\nverbJsonType :: forall a b. b -> (a -> b) -> (b -> (a -> b) -> Json -> b) -> Json -> b\nverbJsonType def f g = g def f\n\n-- Tests\n\nisJsonType :: forall a. (Boolean -> (a -> Boolean) -> Json -> Boolean) -> Json -> Boolean\nisJsonType = verbJsonType false (const true)\n\n-- | Check if the provided `Json` is the `null` value\nisNull :: Json -> Boolean\nisNull = isJsonType caseJsonNull\n\n-- | Check if the provided `Json` is a `Boolean`\nisBoolean :: Json -> Boolean\nisBoolean = isJsonType caseJsonBoolean\n\n-- | Check if the provided `Json` is a `Number`\nisNumber :: Json -> Boolean\nisNumber = isJsonType caseJsonNumber\n\n-- | Check if the provided `Json` is a `String`\nisString :: Json -> Boolean\nisString = isJsonType caseJsonString\n\n-- | Check if the provided `Json` is an `Array`\nisArray :: Json -> Boolean\nisArray = isJsonType caseJsonArray\n\n-- | Check if the provided `Json` is an `Object`\nisObject :: Json -> Boolean\nisObject = isJsonType caseJsonObject\n\n-- Decoding\n\ntoJsonType\n  :: forall a\n   . (Maybe a -> (a -> Maybe a) -> Json -> Maybe a)\n  -> Json\n  -> Maybe a\ntoJsonType = verbJsonType Nothing Just\n\n-- | Convert `Json` to the `Unit` value if the `Json` is the null value\ntoNull :: Json -> Maybe Unit\ntoNull = toJsonType caseJsonNull\n\n-- | Convert `Json` to a `Boolean` value, if the `Json` is a boolean.\ntoBoolean :: Json -> Maybe Boolean\ntoBoolean = toJsonType caseJsonBoolean\n\n-- | Convert `Json` to a `Number` value, if the `Json` is a number.\ntoNumber :: Json -> Maybe Number\ntoNumber = toJsonType caseJsonNumber\n\n-- | Convert `Json` to a `String` value, if the `Json` is a string. To write a\n-- | `Json` value to a JSON string, see `stringify`.\ntoString :: Json -> Maybe String\ntoString = toJsonType caseJsonString\n\n-- | Convert `Json` to an `Array` of `Json` values, if the `Json` is an array.\ntoArray :: Json -> Maybe (Array Json)\ntoArray = toJsonType caseJsonArray\n\n-- | Convert `Json` to an `Object` of `Json` values, if the `Json` is an object.\ntoObject :: Json -> Maybe (Object Json)\ntoObject = toJsonType caseJsonObject\n\n-- Encoding\n\n-- | Construct `Json` from a `Boolean` value\nforeign import fromBoolean :: Boolean -> Json\n\n-- | Construct `Json` from a `Number` value\nforeign import fromNumber :: Number -> Json\n\n-- | Construct the `Json` representation of a `String` value.\n-- | Note that this function only produces `Json` containing a single piece of `String`\n-- | data (similar to `fromBoolean`, `fromNumber`, etc.).\n-- | This function does NOT convert the `String` encoding of a JSON value to `Json` - For that\n-- | purpose, you'll need to use `jsonParser`.\nforeign import fromString :: String -> Json\n\n-- | Construct `Json` from an array of `Json` values\nforeign import fromArray :: Array Json -> Json\n\n-- | Construct `Json` from an object with `Json` values\nforeign import fromObject :: Object Json -> Json\n\n-- Defaults\n\n-- | The JSON null value represented as `Json`\nforeign import jsonNull :: Json\n\n-- | The true boolean value represented as `Json`\njsonTrue :: Json\njsonTrue = fromBoolean true\n\n-- | The false boolean value represented as `Json`\njsonFalse :: Json\njsonFalse = fromBoolean false\n\n-- | The number zero represented as `Json`\njsonZero :: Json\njsonZero = fromNumber 0.0\n\n-- | An empty string represented as `Json`\njsonEmptyString :: Json\njsonEmptyString = fromString \"\"\n\n-- | An empty array represented as `Json`\njsonEmptyArray :: Json\njsonEmptyArray = fromArray []\n\n-- | An empty object represented as `Json`\njsonEmptyObject :: Json\njsonEmptyObject = fromObject Obj.empty\n\n-- | Constructs a `Json` array value containing only the provided value\njsonSingletonArray :: Json -> Json\njsonSingletonArray j = fromArray [ j ]\n\n-- | Constructs a `Json` object value containing only the provided key and value\njsonSingletonObject :: String -> Json -> Json\njsonSingletonObject key val = fromObject (Obj.singleton key val)\n\n-- | Converts a `Json` value to a JSON string. To retrieve a string from a `Json`\n-- | string value, see `fromString`.\nforeign import stringify :: Json -> String\n\n-- | Converts a `Json` value to a JSON string.\n-- | The first `Int` argument specifies the amount of white space characters to use as indentation.\n-- | This number is capped at 10 (if it is greater, the value is just 10). Values less than 1 indicate that no space should be used.\nforeign import stringifyWithIndent :: Int -> Json -> String\n\nforeign import _caseJson\n  :: forall z\n   . Fn7\n       (Unit -> z)\n       (Boolean -> z)\n       (Number -> z)\n       (String -> z)\n       (Array Json -> z)\n       (Object Json -> z)\n       Json\n       z\n\nforeign import _compare :: Fn5 Ordering Ordering Ordering Json Json Ordering\n","-- | Originally implemented in:\n-- | https://github.com/garyb/purescript-codec-argonaut\nmodule Data.Argonaut.Decode.Error where\n\nimport Prelude\n\nimport Data.Argonaut.Core (Json, stringify)\nimport Data.Generic.Rep (class Generic)\n\n-- | Error type for failures while decoding.\ndata JsonDecodeError\n  = TypeMismatch String\n  | UnexpectedValue Json\n  | AtIndex Int JsonDecodeError\n  | AtKey String JsonDecodeError\n  | Named String JsonDecodeError\n  | MissingValue\n\nderive instance eqJsonDecodeError :: Eq JsonDecodeError\nderive instance ordJsonDecodeError :: Ord JsonDecodeError\nderive instance genericJsonDecodeError :: Generic JsonDecodeError _\n\ninstance showJsonDecodeError :: Show JsonDecodeError where\n  show = case _ of\n    TypeMismatch s -> \"(TypeMismatch \" <> show s <> \")\"\n    UnexpectedValue j -> \"(UnexpectedValue \" <> stringify j <> \")\"\n    AtIndex i e -> \"(AtIndex \" <> show i <> \" \" <> show e <> \")\"\n    AtKey k e -> \"(AtKey \" <> show k <> \" \" <> show e <> \")\"\n    Named s e -> \"(Named \" <> show s <> \" \" <> show e <> \")\"\n    MissingValue -> \"MissingValue\"\n\n-- | Prints a `JsonDecodeError` as a readable error message.\nprintJsonDecodeError :: JsonDecodeError -> String\nprintJsonDecodeError err =\n  \"An error occurred while decoding a JSON value:\\n\" <> go err\n  where\n  go = case _ of\n    TypeMismatch ty -> \"  Expected value of type '\" <> ty <> \"'.\"\n    UnexpectedValue val -> \"  Unexpected value \" <> stringify val <> \".\"\n    AtIndex ix inner -> \"  At array index \" <> show ix <> \":\\n\" <> go inner\n    AtKey key inner -> \"  At object key \\'\" <> key <> \"\\':\\n\" <> go inner\n    Named name inner -> \"  Under '\" <> name <> \"':\\n\" <> go inner\n    MissingValue -> \"  No value was found.\"\n","-- | This module exports the `NonEmptyArray` constructor.\n-- |\n-- | It is **NOT** intended for public use and is **NOT** versioned.\n-- |\n-- | Its content may change **in any way**, **at any time** and\n-- | **without notice**.\n\nmodule Data.Array.NonEmpty.Internal (NonEmptyArray(..)) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable)\nimport Data.FoldableWithIndex (class FoldableWithIndex)\nimport Data.Function.Uncurried (Fn2, Fn3, runFn2, runFn3)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.Ord (class Ord1)\nimport Data.Semigroup.Foldable (class Foldable1, foldMap1DefaultL)\nimport Data.Semigroup.Traversable (class Traversable1, sequence1Default)\nimport Data.Traversable (class Traversable)\nimport Data.TraversableWithIndex (class TraversableWithIndex)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | An array that is known not to be empty.\n-- |\n-- | You can use the constructor to create a `NonEmptyArray` that isn't\n-- | non-empty, breaking the guarantee behind this newtype. It is\n-- | provided as an escape hatch mainly for the `Data.Array.NonEmpty`\n-- | and `Data.Array` modules. Use this at your own risk when you know\n-- | what you are doing.\nnewtype NonEmptyArray a = NonEmptyArray (Array a)\n\ninstance showNonEmptyArray :: Show a => Show (NonEmptyArray a) where\n  show (NonEmptyArray xs) = \"(NonEmptyArray \" <> show xs <> \")\"\n\nderive newtype instance eqNonEmptyArray :: Eq a => Eq (NonEmptyArray a)\nderive newtype instance eq1NonEmptyArray :: Eq1 NonEmptyArray\n\nderive newtype instance ordNonEmptyArray :: Ord a => Ord (NonEmptyArray a)\nderive newtype instance ord1NonEmptyArray :: Ord1 NonEmptyArray\n\nderive newtype instance semigroupNonEmptyArray :: Semigroup (NonEmptyArray a)\n\nderive newtype instance functorNonEmptyArray :: Functor NonEmptyArray\nderive newtype instance functorWithIndexNonEmptyArray :: FunctorWithIndex Int NonEmptyArray\n\nderive newtype instance foldableNonEmptyArray :: Foldable NonEmptyArray\nderive newtype instance foldableWithIndexNonEmptyArray :: FoldableWithIndex Int NonEmptyArray\n\ninstance foldable1NonEmptyArray :: Foldable1 NonEmptyArray where\n  foldMap1 = foldMap1DefaultL\n  foldr1 = runFn2 foldr1Impl\n  foldl1 = runFn2 foldl1Impl\n\nderive newtype instance unfoldable1NonEmptyArray :: Unfoldable1 NonEmptyArray\nderive newtype instance traversableNonEmptyArray :: Traversable NonEmptyArray\nderive newtype instance traversableWithIndexNonEmptyArray :: TraversableWithIndex Int NonEmptyArray\n\ninstance traversable1NonEmptyArray :: Traversable1 NonEmptyArray where\n  traverse1 f = runFn3 traverse1Impl apply map f\n  sequence1 = sequence1Default\n\nderive newtype instance applyNonEmptyArray :: Apply NonEmptyArray\n\nderive newtype instance applicativeNonEmptyArray :: Applicative NonEmptyArray\n\nderive newtype instance bindNonEmptyArray :: Bind NonEmptyArray\n\nderive newtype instance monadNonEmptyArray :: Monad NonEmptyArray\n\nderive newtype instance altNonEmptyArray :: Alt NonEmptyArray\n\n-- we use FFI here to avoid the unncessary copy created by `tail`\nforeign import foldr1Impl :: forall a. Fn2 (a -> a -> a) (NonEmptyArray a) a\nforeign import foldl1Impl :: forall a. Fn2 (a -> a -> a) (NonEmptyArray a) a\n\nforeign import traverse1Impl\n  :: forall m a b\n   . Fn3\n       (forall a' b'. (m (a' -> b') -> m a' -> m b'))\n       (forall a' b'. (a' -> b') -> m a' -> m b')\n       (a -> m b)\n       (NonEmptyArray a -> m (NonEmptyArray b))\n","module Data.Array.NonEmpty\n  ( module Internal\n  , fromArray\n  , fromNonEmpty\n  , toArray\n  , toNonEmpty\n\n  , fromFoldable\n  , fromFoldable1\n  , toUnfoldable\n  , toUnfoldable1\n  , singleton\n  , (..), range\n  , replicate\n  , some\n\n  , length\n\n  , (:), cons\n  , cons'\n  , snoc\n  , snoc'\n  , appendArray\n  , prependArray\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elem\n  , notElem\n  , elemIndex\n  , elemLastIndex\n  , find\n  , findMap\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , intersperse\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , splitAt\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n  , foldl1\n  , foldr1\n  , foldMap1\n  , fold1\n  , intercalate\n  , transpose\n  , transpose'\n  , scanl\n  , scanr\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , union'\n  , unionBy\n  , unionBy'\n  , delete\n  , deleteBy\n\n  , (\\\\), difference\n  , difference'\n  , intersect\n  , intersect'\n  , intersectBy\n  , intersectBy'\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , any\n  , all\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Rec.Class (class MonadRec)\nimport Data.Array as A\nimport Data.Array.NonEmpty.Internal (NonEmptyArray(..))\nimport Data.Array.NonEmpty.Internal (NonEmptyArray) as Internal\nimport Data.Bifunctor (bimap)\nimport Data.Foldable (class Foldable)\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Foldable as F\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1, unfoldr1)\nimport Partial.Unsafe (unsafePartial)\nimport Safe.Coerce (coerce)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Internal - adapt an Array transform to NonEmptyArray\n--\n-- Note that this is unsafe: if the transform returns an empty array, this can\n-- explode at runtime.\nunsafeAdapt :: forall a b. (Array a -> Array b) -> NonEmptyArray a -> NonEmptyArray b\nunsafeAdapt f = unsafeFromArray <<< adaptAny f\n\n-- | Internal - adapt an Array transform to NonEmptyArray,\n--   with polymorphic result.\n--\n-- Note that this is unsafe: if the transform returns an empty array, this can\n-- explode at runtime.\nadaptAny :: forall a b. (Array a -> b) -> NonEmptyArray a -> b\nadaptAny f = f <<< toArray\n\n-- | Internal - adapt Array functions returning Maybes to NonEmptyArray\nadaptMaybe :: forall a b. (Array a -> Maybe b) -> NonEmptyArray a -> b\nadaptMaybe f = unsafePartial $ fromJust <<< f <<< toArray\n\nfromArray :: forall a. Array a -> Maybe (NonEmptyArray a)\nfromArray xs\n  | A.length xs > 0 = Just (unsafeFromArray xs)\n  | otherwise = Nothing\n\n-- | INTERNAL\nunsafeFromArray :: forall a. Array a -> NonEmptyArray a\nunsafeFromArray = NonEmptyArray\n\nunsafeFromArrayF :: forall f a. f (Array a) -> f (NonEmptyArray a)\nunsafeFromArrayF = unsafeCoerce\n\nfromNonEmpty :: forall a. NonEmpty Array a -> NonEmptyArray a\nfromNonEmpty (x :| xs) = cons' x xs\n\ntoArray :: forall a. NonEmptyArray a -> Array a\ntoArray (NonEmptyArray xs) = xs\n\ntoNonEmpty :: forall a. NonEmptyArray a -> NonEmpty Array a\ntoNonEmpty = uncons >>> \\{head: x, tail: xs} -> x :| xs\n\nfromFoldable :: forall f a. Foldable f => f a -> Maybe (NonEmptyArray a)\nfromFoldable = fromArray <<< A.fromFoldable\n\nfromFoldable1 :: forall f a. Foldable1 f => f a -> NonEmptyArray a\nfromFoldable1 = unsafeFromArray <<< A.fromFoldable\n\ntoUnfoldable :: forall f a. Unfoldable f => NonEmptyArray a -> f a\ntoUnfoldable = adaptAny A.toUnfoldable\n\ntoUnfoldable1 :: forall f a. Unfoldable1 f => NonEmptyArray a -> f a\ntoUnfoldable1 xs = unfoldr1 f 0\n  where\n  len = length xs\n  f i = Tuple (unsafePartial unsafeIndex xs i) $\n          if i < (len - 1) then Just (i + 1) else Nothing\n\nsingleton :: forall a. a -> NonEmptyArray a\nsingleton = unsafeFromArray <<< A.singleton\n\nrange :: Int -> Int -> NonEmptyArray Int\nrange x y = unsafeFromArray $ A.range x y\n\ninfix 8 range as ..\n\n-- | Replicate an item at least once\nreplicate :: forall a. Int -> a -> NonEmptyArray a\nreplicate i x = unsafeFromArray $ A.replicate (max 1 i) x\n\nsome\n  :: forall f a\n   . Alternative f\n  => Lazy (f (Array a))\n  => f a -> f (NonEmptyArray a)\nsome = unsafeFromArrayF <<< A.some\n\nlength :: forall a. NonEmptyArray a -> Int\nlength = adaptAny A.length\n\ncons :: forall a. a -> NonEmptyArray a -> NonEmptyArray a\ncons x = unsafeAdapt $ A.cons x\n\ninfixr 6 cons as :\n\ncons' :: forall a. a -> Array a -> NonEmptyArray a\ncons' x xs = unsafeFromArray $ A.cons x xs\n\nsnoc :: forall a. NonEmptyArray a -> a -> NonEmptyArray a\nsnoc xs x = unsafeFromArray $ A.snoc (toArray xs) x\n\nsnoc' :: forall a. Array a -> a -> NonEmptyArray a\nsnoc' xs x = unsafeFromArray $ A.snoc xs x\n\nappendArray :: forall a. NonEmptyArray a -> Array a -> NonEmptyArray a\nappendArray xs ys = unsafeFromArray $ toArray xs <> ys\n\nprependArray :: forall a. Array a -> NonEmptyArray a -> NonEmptyArray a\nprependArray xs ys = unsafeFromArray $ xs <> toArray ys\n\ninsert :: forall a. Ord a => a -> NonEmptyArray a -> NonEmptyArray a\ninsert x = unsafeAdapt $ A.insert x\n\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> NonEmptyArray a -> NonEmptyArray a\ninsertBy f x = unsafeAdapt $ A.insertBy f x\n\nhead :: forall a. NonEmptyArray a -> a\nhead = adaptMaybe A.head\n\nlast :: forall a. NonEmptyArray a -> a\nlast = adaptMaybe A.last\n\ntail :: forall a. NonEmptyArray a -> Array a\ntail = adaptMaybe A.tail\n\ninit :: forall a. NonEmptyArray a -> Array a\ninit = adaptMaybe A.init\n\nuncons :: forall a. NonEmptyArray a -> { head :: a, tail :: Array a }\nuncons = adaptMaybe A.uncons\n\nunsnoc :: forall a. NonEmptyArray a -> { init :: Array a, last :: a }\nunsnoc = adaptMaybe A.unsnoc\n\nindex :: forall a. NonEmptyArray a -> Int -> Maybe a\nindex = adaptAny A.index\n\ninfixl 8 index as !!\n\nelem :: forall a. Eq a => a -> NonEmptyArray a -> Boolean\nelem x = adaptAny $ A.elem x\n\nnotElem :: forall a. Eq a => a -> NonEmptyArray a -> Boolean\nnotElem x = adaptAny $ A.notElem x\n\nelemIndex :: forall a. Eq a => a -> NonEmptyArray a -> Maybe Int\nelemIndex x = adaptAny $ A.elemIndex x\n\nelemLastIndex :: forall a. Eq a => a -> NonEmptyArray a -> Maybe Int\nelemLastIndex x = adaptAny $ A.elemLastIndex x\n\nfind :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe a\nfind p = adaptAny $ A.find p\n\nfindMap :: forall a b. (a -> Maybe b) -> NonEmptyArray a -> Maybe b\nfindMap p = adaptAny $ A.findMap p\n\nfindIndex :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe Int\nfindIndex p = adaptAny $ A.findIndex p\n\nfindLastIndex :: forall a. (a -> Boolean) -> NonEmptyArray a -> Maybe Int\nfindLastIndex x = adaptAny $ A.findLastIndex x\n\ninsertAt :: forall a. Int -> a -> NonEmptyArray a -> Maybe (NonEmptyArray a)\ninsertAt i x = unsafeFromArrayF <<< A.insertAt i x <<< toArray\n\ndeleteAt :: forall a. Int -> NonEmptyArray a -> Maybe (Array a)\ndeleteAt i = adaptAny $ A.deleteAt i\n\nupdateAt :: forall a. Int -> a -> NonEmptyArray a -> Maybe (NonEmptyArray a)\nupdateAt i x = unsafeFromArrayF <<< A.updateAt i x <<< toArray\n\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> NonEmptyArray a -> NonEmptyArray a\nupdateAtIndices pairs = unsafeAdapt $ A.updateAtIndices pairs\n\nmodifyAt :: forall a. Int -> (a -> a) -> NonEmptyArray a -> Maybe (NonEmptyArray a)\nmodifyAt i f = unsafeFromArrayF <<< A.modifyAt i f <<< toArray\n\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> NonEmptyArray a -> NonEmptyArray a\nmodifyAtIndices is f = unsafeAdapt $ A.modifyAtIndices is f\n\nalterAt :: forall a. Int -> (a -> Maybe a) -> NonEmptyArray a -> Maybe (Array a)\nalterAt i f = A.alterAt i f <<< toArray\n\nintersperse :: forall a. a -> NonEmptyArray a -> NonEmptyArray a\nintersperse x = unsafeAdapt $ A.intersperse x\n\nreverse :: forall a. NonEmptyArray a -> NonEmptyArray a\nreverse = unsafeAdapt A.reverse\n\nconcat :: forall a. NonEmptyArray (NonEmptyArray a) -> NonEmptyArray a\nconcat = unsafeFromArray <<< A.concat <<< toArray <<< map toArray\n\nconcatMap :: forall a b. (a -> NonEmptyArray b) -> NonEmptyArray a -> NonEmptyArray b\nconcatMap = flip bind\n\nfilter :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\nfilter f = adaptAny $ A.filter f\n\npartition\n  :: forall a\n   . (a -> Boolean)\n  -> NonEmptyArray a\n  -> { yes :: Array a, no :: Array a}\npartition f = adaptAny $ A.partition f\n\nfilterA\n  :: forall a f\n   . Applicative f\n  => (a -> f Boolean)\n  -> NonEmptyArray a\n  -> f (Array a)\nfilterA f = adaptAny $ A.filterA f\n\nsplitAt :: forall a. Int -> NonEmptyArray a -> { before :: Array a, after :: Array a }\nsplitAt i xs = A.splitAt i $ toArray xs\n\nmapMaybe :: forall a b. (a -> Maybe b) -> NonEmptyArray a -> Array b\nmapMaybe f = adaptAny $ A.mapMaybe f\n\ncatMaybes :: forall a. NonEmptyArray (Maybe a) -> Array a\ncatMaybes = adaptAny A.catMaybes\n\nmapWithIndex :: forall a b. (Int -> a -> b) -> NonEmptyArray a -> NonEmptyArray b\nmapWithIndex f = unsafeAdapt $ A.mapWithIndex f\n\nfoldl1 :: forall a. (a -> a -> a) -> NonEmptyArray a -> a\nfoldl1 = F.foldl1\n\nfoldr1 :: forall a. (a -> a -> a) -> NonEmptyArray a -> a\nfoldr1 = F.foldr1\n\nfoldMap1 :: forall a m. Semigroup m => (a -> m) -> NonEmptyArray a -> m\nfoldMap1 = F.foldMap1\n\nfold1 :: forall m. Semigroup m => NonEmptyArray m -> m\nfold1 = F.fold1\n\nintercalate :: forall a. Semigroup a => a -> NonEmptyArray a -> a\nintercalate = F.intercalate\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- | ```purescript\n-- | transpose \n-- |   (NonEmptyArray [ NonEmptyArray [1, 2, 3]\n-- |                  , NonEmptyArray [4, 5, 6]\n-- |                  ]) == \n-- |   (NonEmptyArray [ NonEmptyArray [1, 4]\n-- |                  , NonEmptyArray [2, 5]\n-- |                  , NonEmptyArray [3, 6]\n-- |                  ])\n-- | ```\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- | ```purescript\n-- | transpose \n-- |   (NonEmptyArray [ NonEmptyArray [10, 11]\n-- |                  , NonEmptyArray [20]\n-- |                  , NonEmptyArray [30, 31, 32]\n-- |                  ]) == \n-- |   (NomEmptyArray [ NonEmptyArray [10, 20, 30]\n-- |                  , NonEmptyArray [11, 31]\n-- |                  , NonEmptyArray [32]\n-- |                  ])\n-- | ```\ntranspose :: forall a. NonEmptyArray (NonEmptyArray a) -> NonEmptyArray (NonEmptyArray a)\ntranspose = \n  (coerce :: (Array (Array a)) -> (NonEmptyArray (NonEmptyArray a))) \n    <<< A.transpose <<< coerce\n\n-- | `transpose`' is identical to `transpose` other than that the inner arrays are each\n-- | a standard `Array` and not a `NonEmptyArray`. However, the result is wrapped in a \n-- | `Maybe` to cater for the case where the inner `Array` is empty and must return `Nothing`.\ntranspose' :: forall a. NonEmptyArray (Array a) -> Maybe (NonEmptyArray (Array a))\ntranspose' = fromArray <<< A.transpose <<< coerce\n\nscanl :: forall a b. (b -> a -> b) -> b -> NonEmptyArray a -> NonEmptyArray b\nscanl f x = unsafeAdapt $ A.scanl f x\n\nscanr :: forall a b. (a -> b -> b) -> b -> NonEmptyArray a -> NonEmptyArray b\nscanr f x = unsafeAdapt $ A.scanr f x\n\nsort :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray a\nsort = unsafeAdapt A.sort\n\nsortBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray a\nsortBy f = unsafeAdapt $ A.sortBy f\n\nsortWith :: forall a b. Ord b => (a -> b) -> NonEmptyArray a -> NonEmptyArray a\nsortWith f = unsafeAdapt $ A.sortWith f\n\nslice :: forall a. Int -> Int -> NonEmptyArray a -> Array a\nslice start end = adaptAny $ A.slice start end\n\ntake :: forall a. Int -> NonEmptyArray a -> Array a\ntake i = adaptAny $ A.take i\n\ntakeEnd :: forall a. Int -> NonEmptyArray a -> Array a\ntakeEnd i = adaptAny $ A.takeEnd i\n\ntakeWhile :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\ntakeWhile f = adaptAny $ A.takeWhile f\n\ndrop :: forall a. Int -> NonEmptyArray a -> Array a\ndrop i = adaptAny $ A.drop i\n\ndropEnd :: forall a. Int -> NonEmptyArray a -> Array a\ndropEnd i = adaptAny $ A.dropEnd i\n\ndropWhile :: forall a. (a -> Boolean) -> NonEmptyArray a -> Array a\ndropWhile f = adaptAny $ A.dropWhile f\n\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> NonEmptyArray a\n  -> { init :: Array a, rest :: Array a }\nspan f = adaptAny $ A.span f\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group (NonEmptyArray [1, 1, 2, 2, 1]) ==\n-- |   NonEmptyArray [NonEmptyArray [1, 1], NonEmptyArray [2, 2], NonEmptyArray [1]]\n-- | ```\ngroup :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroup = unsafeAdapt $ A.group\n\n-- | Group equal elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | groupAll (NonEmptyArray [1, 1, 2, 2, 1]) ==\n-- |   NonEmptyArray [NonEmptyArray [1, 1, 1], NonEmptyArray [2, 2]]\n-- | `\ngroupAll :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupAll = groupAllBy compare\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to determine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) (NonEmptyArray [1, 3, 2, 4, 3, 3])\n-- |    = NonEmptyArray [NonEmptyArray [1, 3], NonEmptyArray [2], NonEmptyArray [4], NonEmptyArray [3, 3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupBy op = unsafeAdapt $ A.groupBy op\n\n-- | Group equal elements of an array into arrays, using the specified\n-- | comparison function to determine equality.\n-- |\n-- | ```purescript\n-- | groupAllBy (comparing Down) (NonEmptyArray [1, 3, 2, 4, 3, 3])\n-- |    = NonEmptyArray [NonEmptyArray [4], NonEmptyArray [3, 3, 3], NonEmptyArray [2], NonEmptyArray [1]]\n-- | ```\ngroupAllBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray (NonEmptyArray a)\ngroupAllBy op = unsafeAdapt $ A.groupAllBy op\n\nnub :: forall a. Ord a => NonEmptyArray a -> NonEmptyArray a\nnub = unsafeAdapt A.nub\n\nnubEq :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a\nnubEq = unsafeAdapt A.nubEq\n\nnubBy :: forall a. (a -> a -> Ordering) -> NonEmptyArray a -> NonEmptyArray a\nnubBy f = unsafeAdapt $ A.nubBy f\n\nnubByEq :: forall a. (a -> a -> Boolean) -> NonEmptyArray a -> NonEmptyArray a\nnubByEq f = unsafeAdapt $ A.nubByEq f\n\nunion :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a -> NonEmptyArray a\nunion = unionBy (==)\n\nunion' :: forall a. Eq a => NonEmptyArray a -> Array a -> NonEmptyArray a\nunion' = unionBy' (==)\n\nunionBy\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> NonEmptyArray a\n  -> NonEmptyArray a\nunionBy eq xs = unionBy' eq xs <<< toArray\n\nunionBy'\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> Array a\n  -> NonEmptyArray a\nunionBy' eq xs = unsafeFromArray <<< A.unionBy eq (toArray xs)\n\ndelete :: forall a. Eq a => a -> NonEmptyArray a -> Array a\ndelete x = adaptAny $ A.delete x\n\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> NonEmptyArray a -> Array a\ndeleteBy f x = adaptAny $ A.deleteBy f x\n\ndifference :: forall a. Eq a => NonEmptyArray a -> NonEmptyArray a -> Array a\ndifference xs = adaptAny $ difference' xs\n\ndifference' :: forall a. Eq a => NonEmptyArray a -> Array a -> Array a\ndifference' xs = A.difference $ toArray xs\n\nintersect :: forall a . Eq a => NonEmptyArray a -> NonEmptyArray a -> Array a\nintersect = intersectBy eq\n\nintersect' :: forall a . Eq a => NonEmptyArray a -> Array a -> Array a\nintersect' = intersectBy' eq\n\nintersectBy\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> NonEmptyArray a\n  -> Array a\nintersectBy eq xs = intersectBy' eq xs <<< toArray\n\nintersectBy'\n  :: forall a\n   . (a -> a -> Boolean)\n  -> NonEmptyArray a\n  -> Array a\n  -> Array a\nintersectBy' eq xs = A.intersectBy eq (toArray xs)\n\ninfix 5 difference as \\\\\n\nzipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> NonEmptyArray a\n  -> NonEmptyArray b\n  -> NonEmptyArray c\nzipWith f xs ys = unsafeFromArray $ A.zipWith f (toArray xs) (toArray ys)\n\n\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> NonEmptyArray a\n  -> NonEmptyArray b\n  -> m (NonEmptyArray c)\nzipWithA f xs ys = unsafeFromArrayF $ A.zipWithA f (toArray xs) (toArray ys)\n\nzip :: forall a b. NonEmptyArray a -> NonEmptyArray b -> NonEmptyArray (Tuple a b)\nzip xs ys = unsafeFromArray $ toArray xs `A.zip` toArray ys\n\nunzip :: forall a b. NonEmptyArray (Tuple a b) -> Tuple (NonEmptyArray a) (NonEmptyArray b)\nunzip = bimap unsafeFromArray unsafeFromArray <<< A.unzip <<< toArray\n\nany :: forall a. (a -> Boolean) -> NonEmptyArray a -> Boolean\nany p = adaptAny $ A.any p\n\nall :: forall a. (a -> Boolean) -> NonEmptyArray a -> Boolean\nall p = adaptAny $ A.all p\n\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> NonEmptyArray a -> m b\nfoldM f acc = adaptAny $ A.foldM f acc\n\nfoldRecM :: forall m a b. MonadRec m => (b -> a -> m b) -> b -> NonEmptyArray a -> m b\nfoldRecM f acc = adaptAny $ A.foldRecM f acc\n\nunsafeIndex :: forall a. Partial => NonEmptyArray a -> Int -> a\nunsafeIndex = adaptAny A.unsafeIndex\n","/* global Symbol */\n\nvar hasArrayFrom = typeof Array.from === \"function\";\nvar hasStringIterator =\n  typeof Symbol !== \"undefined\" &&\n  Symbol != null &&\n  typeof Symbol.iterator !== \"undefined\" &&\n  typeof String.prototype[Symbol.iterator] === \"function\";\nvar hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\nvar hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\nexport const _unsafeCodePointAt0 = function (fallback) {\n  return hasCodePointAt\n    ? function (str) { return str.codePointAt(0); }\n    : fallback;\n};\n\nexport const _codePointAt = function (fallback) {\n  return function (Just) {\n    return function (Nothing) {\n      return function (unsafeCodePointAt0) {\n        return function (index) {\n          return function (str) {\n            var length = str.length;\n            if (index < 0 || index >= length) return Nothing;\n            if (hasStringIterator) {\n              var iter = str[Symbol.iterator]();\n              for (var i = index;; --i) {\n                var o = iter.next();\n                if (o.done) return Nothing;\n                if (i === 0) return Just(unsafeCodePointAt0(o.value));\n              }\n            }\n            return fallback(index)(str);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const _countPrefix = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasStringIterator) {\n      return function (pred) {\n        return function (str) {\n          var iter = str[Symbol.iterator]();\n          for (var cpCount = 0; ; ++cpCount) {\n            var o = iter.next();\n            if (o.done) return cpCount;\n            var cp = unsafeCodePointAt0(o.value);\n            if (!pred(cp)) return cpCount;\n          }\n        };\n      };\n    }\n    return fallback;\n  };\n};\n\nexport const _fromCodePointArray = function (singleton) {\n  return hasFromCodePoint\n    ? function (cps) {\n      // Function.prototype.apply will fail for very large second parameters,\n      // so we don't use it for arrays with 10,000 or more entries.\n      if (cps.length < 10e3) {\n        return String.fromCodePoint.apply(String, cps);\n      }\n      return cps.map(singleton).join(\"\");\n    }\n    : function (cps) {\n      return cps.map(singleton).join(\"\");\n    };\n};\n\nexport const _singleton = function (fallback) {\n  return hasFromCodePoint ? String.fromCodePoint : fallback;\n};\n\nexport const _take = function (fallback) {\n  return function (n) {\n    if (hasStringIterator) {\n      return function (str) {\n        var accum = \"\";\n        var iter = str[Symbol.iterator]();\n        for (var i = 0; i < n; ++i) {\n          var o = iter.next();\n          if (o.done) return accum;\n          accum += o.value;\n        }\n        return accum;\n      };\n    }\n    return fallback(n);\n  };\n};\n\nexport const _toCodePointArray = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasArrayFrom) {\n      return function (str) {\n        return Array.from(str, unsafeCodePointAt0);\n      };\n    }\n    return fallback;\n  };\n};\n","module Data.Argonaut.Decode.Decoders where\n\nimport Prelude\n\nimport Data.Argonaut.Core (Json, caseJsonBoolean, caseJsonNull, caseJsonNumber, caseJsonString, isNull, toArray, toObject, toString, fromString)\nimport Data.Argonaut.Decode.Error (JsonDecodeError(..))\nimport Data.Array as Arr\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Array.NonEmpty as NEA\nimport Data.Bifunctor (lmap)\nimport Data.Either (Either(..), note)\nimport Data.Identity (Identity(..))\nimport Data.Int (fromNumber)\nimport Data.List (List, fromFoldable)\nimport Data.List as L\nimport Data.List.NonEmpty (NonEmptyList)\nimport Data.List.NonEmpty as NEL\nimport Data.String.NonEmpty (NonEmptyString)\nimport Data.String.NonEmpty as NonEmptyString\nimport Data.Map as M\nimport Data.Maybe (maybe, Maybe(..))\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.Set as S\nimport Data.String (CodePoint, codePointAt)\nimport Data.Traversable (traverse)\nimport Data.TraversableWithIndex (traverseWithIndex)\nimport Data.Tuple (Tuple(..))\nimport Foreign.Object as FO\n\ndecodeIdentity\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (Identity a)\ndecodeIdentity decoder json = Identity <$> decoder json\n\ndecodeMaybe\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (Maybe a)\ndecodeMaybe decoder json\n  | isNull json = pure Nothing\n  | otherwise = Just <$> decoder json\n\ndecodeTuple\n  :: forall a b\n   . (Json -> Either JsonDecodeError a)\n  -> (Json -> Either JsonDecodeError b)\n  -> Json\n  -> Either JsonDecodeError (Tuple a b)\ndecodeTuple decoderA decoderB json = decodeArray Right json >>= f\n  where\n  f :: Array Json -> Either JsonDecodeError (Tuple a b)\n  f = case _ of\n    [ a, b ] -> Tuple <$> decoderA a <*> decoderB b\n    _ -> Left $ TypeMismatch \"Tuple\"\n\ndecodeEither\n  :: forall a b\n   . (Json -> Either JsonDecodeError a)\n  -> (Json -> Either JsonDecodeError b)\n  -> Json\n  -> Either JsonDecodeError (Either a b)\ndecodeEither decoderA decoderB json =\n  lmap (Named \"Either\") $ decodeJObject json >>= \\obj -> do\n    tag <- note (AtKey \"tag\" MissingValue) $ FO.lookup \"tag\" obj\n    val <- note (AtKey \"value\" MissingValue) $ FO.lookup \"value\" obj\n    case toString tag of\n      Just \"Right\" -> Right <$> decoderB val\n      Just \"Left\" -> Left <$> decoderA val\n      _ -> Left $ AtKey \"tag\" (UnexpectedValue tag)\n\ndecodeNull :: Json -> Either JsonDecodeError Unit\ndecodeNull = caseJsonNull (Left $ TypeMismatch \"null\") (const $ Right unit)\n\ndecodeBoolean :: Json -> Either JsonDecodeError Boolean\ndecodeBoolean = caseJsonBoolean (Left $ TypeMismatch \"Boolean\") Right\n\ndecodeNumber :: Json -> Either JsonDecodeError Number\ndecodeNumber = caseJsonNumber (Left $ TypeMismatch \"Number\") Right\n\ndecodeInt :: Json -> Either JsonDecodeError Int\ndecodeInt = note (TypeMismatch \"Integer\") <<< fromNumber <=< decodeNumber\n\ndecodeString :: Json -> Either JsonDecodeError String\ndecodeString = caseJsonString (Left $ TypeMismatch \"String\") Right\n\ndecodeNonEmptyString :: Json -> Either JsonDecodeError NonEmptyString\ndecodeNonEmptyString json =\n  note (Named \"NonEmptyString\" $ UnexpectedValue json)\n    =<< map (NonEmptyString.fromString) (decodeString json)\n\ndecodeNonEmpty_Array\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (NonEmpty Array a)\ndecodeNonEmpty_Array decoder =\n  lmap (Named \"NonEmpty Array\")\n    <<< traverse decoder\n    <=< map (\\x -> x.head :| x.tail)\n      <<< note (TypeMismatch \"NonEmpty Array\")\n      <<< Arr.uncons\n    <=< decodeJArray\n\ndecodeNonEmptyArray\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (NonEmptyArray a)\ndecodeNonEmptyArray decoder =\n  lmap (Named \"NonEmptyArray\")\n    <<< traverse decoder\n    <=< map (\\x -> NEA.cons' x.head x.tail)\n      <<< note (TypeMismatch \"NonEmptyArray\")\n      <<< Arr.uncons\n    <=< decodeJArray\n\ndecodeNonEmpty_List\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (NonEmpty List a)\ndecodeNonEmpty_List decoder =\n  lmap (Named \"NonEmpty List\")\n    <<< traverse decoder\n    <=< map (\\x -> x.head :| x.tail)\n      <<< note (TypeMismatch \"NonEmpty List\")\n      <<< L.uncons\n    <=< map (map fromFoldable) decodeJArray\n\ndecodeNonEmptyList\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (NonEmptyList a)\ndecodeNonEmptyList decoder =\n  lmap (Named \"NonEmptyList\")\n    <<< traverse decoder\n    <=< map (\\x -> NEL.cons' x.head x.tail)\n      <<< note (TypeMismatch \"NonEmptyList\")\n      <<< L.uncons\n    <=< map (map fromFoldable) decodeJArray\n\ndecodeCodePoint :: Json -> Either JsonDecodeError CodePoint\ndecodeCodePoint json =\n  note (Named \"CodePoint\" $ UnexpectedValue json)\n    =<< map (codePointAt 0) (decodeString json)\n\ndecodeForeignObject\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (FO.Object a)\ndecodeForeignObject decoder =\n  lmap (Named \"ForeignObject\")\n    <<< traverse decoder\n    <=< decodeJObject\n\ndecodeArray\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (Array a)\ndecodeArray decoder =\n  lmap (Named \"Array\")\n    <<< traverseWithIndex (\\i -> lmap (AtIndex i) <<< decoder)\n    <=< decodeJArray\n\ndecodeList\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (List a)\ndecodeList decoder =\n  lmap (Named \"List\")\n    <<< traverse decoder\n    <=< map (map fromFoldable) decodeJArray\n\ndecodeSet\n  :: forall a\n   . Ord a\n  => (Json -> Either JsonDecodeError a)\n  -> Json\n  -> Either JsonDecodeError (S.Set a)\ndecodeSet decoder =\n  map (S.fromFoldable :: List a -> S.Set a) <<< decodeList decoder\n\ndecodeMap\n  :: forall a b\n   . Ord a\n  => (Json -> Either JsonDecodeError a)\n  -> (Json -> Either JsonDecodeError b)\n  -> Json\n  -> Either JsonDecodeError (M.Map a b)\ndecodeMap decoderA decoderB =\n  map (M.fromFoldable :: List (Tuple a b) -> M.Map a b)\n    <<< decodeList (decodeTuple decoderA decoderB)\n\ndecodeVoid :: Json -> Either JsonDecodeError Void\ndecodeVoid _ = Left $ UnexpectedValue $ fromString \"Value cannot be Void\"\n\ndecodeJArray :: Json -> Either JsonDecodeError (Array Json)\ndecodeJArray = note (TypeMismatch \"Array\") <<< toArray\n\ndecodeJObject :: Json -> Either JsonDecodeError (FO.Object Json)\ndecodeJObject = note (TypeMismatch \"Object\") <<< toObject\n\ngetField\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> FO.Object Json\n  -> String\n  -> Either JsonDecodeError a\ngetField decoder obj str =\n  maybe\n    (Left $ AtKey str MissingValue)\n    (lmap (AtKey str) <<< decoder)\n    (FO.lookup str obj)\n\ngetFieldOptional\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> FO.Object Json\n  -> String\n  -> Either JsonDecodeError (Maybe a)\ngetFieldOptional decoder obj str =\n  maybe (pure Nothing) (map Just <<< decode) (FO.lookup str obj)\n  where\n  decode = lmap (AtKey str) <<< decoder\n\ngetFieldOptional'\n  :: forall a\n   . (Json -> Either JsonDecodeError a)\n  -> FO.Object Json\n  -> String\n  -> Either JsonDecodeError (Maybe a)\ngetFieldOptional' decoder obj str =\n  maybe (pure Nothing) decode (FO.lookup str obj)\n  where\n  decode json =\n    if isNull json then\n      pure Nothing\n    else\n      Just <$> (lmap (AtKey str) <<< decoder) json\n","module Data.Argonaut.Decode.Class where\n\nimport Data.Argonaut.Decode.Decoders\n\nimport Data.Argonaut.Core (Json, toObject)\nimport Data.Argonaut.Decode.Error (JsonDecodeError(..))\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Bifunctor (lmap)\nimport Data.Either (Either(..))\nimport Data.Identity (Identity)\nimport Data.List (List)\nimport Data.List.NonEmpty (NonEmptyList)\nimport Data.String.NonEmpty (NonEmptyString)\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.NonEmpty (NonEmpty)\nimport Data.Set as S\nimport Data.String (CodePoint)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Tuple (Tuple)\nimport Foreign.Object as FO\nimport Prelude (class Ord, Unit, Void, bind, ($), (<$>))\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record as Record\nimport Type.Proxy (Proxy(..))\n\nclass DecodeJson a where\n  decodeJson :: Json -> Either JsonDecodeError a\n\ninstance decodeIdentity :: DecodeJson a => DecodeJson (Identity a) where\n  decodeJson = decodeIdentity decodeJson\n\ninstance decodeJsonMaybe :: DecodeJson a => DecodeJson (Maybe a) where\n  decodeJson = decodeMaybe decodeJson\n\ninstance decodeJsonTuple :: (DecodeJson a, DecodeJson b) => DecodeJson (Tuple a b) where\n  decodeJson = decodeTuple decodeJson decodeJson\n\ninstance decodeJsonEither :: (DecodeJson a, DecodeJson b) => DecodeJson (Either a b) where\n  decodeJson = decodeEither decodeJson decodeJson\n\ninstance decodeJsonNull :: DecodeJson Unit where\n  decodeJson = decodeNull\n\ninstance decodeJsonBoolean :: DecodeJson Boolean where\n  decodeJson = decodeBoolean\n\ninstance decodeJsonNumber :: DecodeJson Number where\n  decodeJson = decodeNumber\n\ninstance decodeJsonInt :: DecodeJson Int where\n  decodeJson = decodeInt\n\ninstance decodeJsonString :: DecodeJson String where\n  decodeJson = decodeString\n\ninstance decodeJsonNonEmptyString :: DecodeJson NonEmptyString where\n  decodeJson = decodeNonEmptyString\n\ninstance decodeJsonJson :: DecodeJson Json where\n  decodeJson = Right\n\ninstance decodeJsonNonEmpty_Array :: (DecodeJson a) => DecodeJson (NonEmpty Array a) where\n  decodeJson = decodeNonEmpty_Array decodeJson\n\ninstance decodeJsonNonEmptyArray :: (DecodeJson a) => DecodeJson (NonEmptyArray a) where\n  decodeJson = decodeNonEmptyArray decodeJson\n\ninstance decodeJsonNonEmpty_List :: (DecodeJson a) => DecodeJson (NonEmpty List a) where\n  decodeJson = decodeNonEmpty_List decodeJson\n\ninstance decodeJsonNonEmptyList :: (DecodeJson a) => DecodeJson (NonEmptyList a) where\n  decodeJson = decodeNonEmptyList decodeJson\n\ninstance decodeJsonCodePoint :: DecodeJson CodePoint where\n  decodeJson = decodeCodePoint\n\ninstance decodeForeignObject :: DecodeJson a => DecodeJson (FO.Object a) where\n  decodeJson = decodeForeignObject decodeJson\n\ninstance decodeArray :: DecodeJson a => DecodeJson (Array a) where\n  decodeJson = decodeArray decodeJson\n\ninstance decodeList :: DecodeJson a => DecodeJson (List a) where\n  decodeJson = decodeList decodeJson\n\ninstance decodeSet :: (Ord a, DecodeJson a) => DecodeJson (S.Set a) where\n  decodeJson = decodeSet decodeJson\n\ninstance decodeMap :: (Ord a, DecodeJson a, DecodeJson b) => DecodeJson (M.Map a b) where\n  decodeJson = decodeMap decodeJson decodeJson\n\ninstance decodeVoid :: DecodeJson Void where\n  decodeJson = decodeVoid\n\ninstance decodeRecord ::\n  ( GDecodeJson row list\n  , RL.RowToList row list\n  ) =>\n  DecodeJson (Record row) where\n  decodeJson json =\n    case toObject json of\n      Just object -> gDecodeJson object (Proxy :: Proxy list)\n      Nothing -> Left $ TypeMismatch \"Object\"\n\nclass GDecodeJson (row :: Row Type) (list :: RL.RowList Type) | list -> row where\n  gDecodeJson :: forall proxy. FO.Object Json -> proxy list -> Either JsonDecodeError (Record row)\n\ninstance gDecodeJsonNil :: GDecodeJson () RL.Nil where\n  gDecodeJson _ _ = Right {}\n\ninstance gDecodeJsonCons ::\n  ( DecodeJsonField value\n  , GDecodeJson rowTail tail\n  , IsSymbol field\n  , Row.Cons field value rowTail row\n  , Row.Lacks field rowTail\n  ) =>\n  GDecodeJson row (RL.Cons field value tail) where\n  gDecodeJson object _ = do\n    let\n      _field = Proxy :: Proxy field\n      fieldName = reflectSymbol _field\n      fieldValue = FO.lookup fieldName object\n\n    case decodeJsonField fieldValue of\n      Just fieldVal -> do\n        val <- lmap (AtKey fieldName) fieldVal\n        rest <- gDecodeJson object (Proxy :: Proxy tail)\n        Right $ Record.insert _field val rest\n\n      Nothing ->\n        Left $ AtKey fieldName MissingValue\n\nclass DecodeJsonField a where\n  decodeJsonField :: Maybe Json -> Maybe (Either JsonDecodeError a)\n\ninstance decodeFieldMaybe ::\n  DecodeJson a =>\n  DecodeJsonField (Maybe a) where\n  decodeJsonField Nothing = Just $ Right Nothing\n  decodeJsonField (Just j) = Just $ decodeJson j\n\nelse instance decodeFieldId ::\n  DecodeJson a =>\n  DecodeJsonField a where\n  decodeJsonField j = decodeJson <$> j\n","module Data.Argonaut.Encode.Encoders where\n\nimport Prelude\n\nimport Data.Argonaut.Core (Json, fromArray, fromBoolean, fromNumber, fromObject, fromString, jsonNull, caseJsonObject, jsonSingletonObject)\nimport Data.Array as Arr\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Array.NonEmpty as NEA\nimport Data.Either (Either, either)\nimport Data.Identity (Identity(..))\nimport Data.Int (toNumber)\nimport Data.List (List(..), (:), toUnfoldable)\nimport Data.List.NonEmpty as NEL\nimport Data.List.Types (NonEmptyList)\nimport Data.String.NonEmpty (NonEmptyString)\nimport Data.String.NonEmpty as NonEmptyString\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.NonEmpty (NonEmpty(..))\nimport Data.Set as S\nimport Data.String (CodePoint)\nimport Data.String.CodePoints as CP\nimport Data.String.CodeUnits as CU\nimport Data.Tuple (Tuple(..))\nimport Foreign.Object as FO\n\nencodeIdentity :: forall a. (a -> Json) -> Identity a -> Json\nencodeIdentity encoder (Identity a) = encoder a\n\nencodeMaybe :: forall a. (a -> Json) -> Maybe a -> Json\nencodeMaybe encoder = case _ of\n  Nothing -> jsonNull\n  Just a -> encoder a\n\nencodeTuple :: forall a b. (a -> Json) -> (b -> Json) -> Tuple a b -> Json\nencodeTuple encoderA encoderB (Tuple a b) = fromArray [ encoderA a, encoderB b ]\n\nencodeEither :: forall a b. (a -> Json) -> (b -> Json) -> Either a b -> Json\nencodeEither encoderA encoderB = either (obj encoderA \"Left\") (obj encoderB \"Right\")\n  where\n  obj :: forall c. (c -> Json) -> String -> c -> Json\n  obj encoder tag x =\n    fromObject\n      $ FO.fromFoldable\n      $ Tuple \"tag\" (fromString tag) : Tuple \"value\" (encoder x) : Nil\n\nencodeUnit :: Unit -> Json\nencodeUnit = const jsonNull\n\nencodeBoolean :: Boolean -> Json\nencodeBoolean = fromBoolean\n\nencodeNumber :: Number -> Json\nencodeNumber = fromNumber\n\nencodeInt :: Int -> Json\nencodeInt = fromNumber <<< toNumber\n\nencodeString :: String -> Json\nencodeString = fromString\n\nencodeCodePoint :: CodePoint -> Json\nencodeCodePoint = encodeString <<< CP.singleton\n\nencodeNonEmptyString :: NonEmptyString -> Json\nencodeNonEmptyString = fromString <<< NonEmptyString.toString\n\nencodeNonEmpty_Array :: forall a. (a -> Json) -> NonEmpty Array a -> Json\nencodeNonEmpty_Array encoder (NonEmpty h t) = encodeArray encoder (Arr.cons h t)\n\nencodeNonEmptyArray :: forall a. (a -> Json) -> NonEmptyArray a -> Json\nencodeNonEmptyArray encoder = encodeArray encoder <<< NEA.toArray\n\nencodeNonEmpty_List :: forall a. (a -> Json) -> NonEmpty List a -> Json\nencodeNonEmpty_List encoder (NonEmpty h t) = encodeList encoder (h : t)\n\nencodeNonEmptyList :: forall a. (a -> Json) -> NonEmptyList a -> Json\nencodeNonEmptyList encoder = encodeList encoder <<< NEL.toList\n\nencodeChar :: Char -> Json\nencodeChar = encodeString <<< CU.singleton\n\nencodeArray :: forall a. (a -> Json) -> Array a -> Json\nencodeArray encoder = fromArray <<< map encoder\n\nencodeList :: forall a. (a -> Json) -> List a -> Json\nencodeList encoder = fromArray <<< map encoder <<< toUnfoldable\n\nencodeForeignObject :: forall a. (a -> Json) -> FO.Object a -> Json\nencodeForeignObject encoder = fromObject <<< map encoder\n\nencodeSet :: forall a. Ord a => (a -> Json) -> S.Set a -> Json\nencodeSet encoder = encodeList encoder <<< (S.toUnfoldable :: S.Set a -> List a)\n\nencodeMap :: forall a b. Ord a => (a -> Json) -> (b -> Json) -> M.Map a b -> Json\nencodeMap encoderA encoderB =\n  encodeList (encodeTuple encoderA encoderB)\n    <<< (M.toUnfoldable :: M.Map a b -> List (Tuple a b))\n\nencodeVoid :: Void -> Json\nencodeVoid = absurd\n\nassoc :: forall a. (a -> Json) -> String -> a -> Tuple String Json\nassoc encoder k = Tuple k <<< encoder\n\nassocOptional\n  :: forall a\n   . (a -> Json)\n  -> String\n  -> Maybe a\n  -> Maybe (Tuple String Json)\nassocOptional encoder k = map (Tuple k <<< encoder)\n\nextend :: forall a. (a -> Json) -> Tuple String Json -> a -> Json\nextend encoder (Tuple k v) =\n  caseJsonObject (jsonSingletonObject k v) (fromObject <<< FO.insert k v)\n    <<< encoder\n\n-- | The named Encoders of the `(~>?)` operator.\nextendOptional :: forall a. (a -> Json) -> Maybe (Tuple String Json) -> a -> Json\nextendOptional encoder = case _ of\n  Just kv -> extend encoder kv\n  Nothing -> encoder\n","module Data.Argonaut.Encode.Class where\n\nimport Data.Argonaut.Encode.Encoders\n\nimport Data.Argonaut.Core (Json, fromObject)\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.String.NonEmpty (NonEmptyString)\nimport Data.Either (Either)\nimport Data.Identity (Identity)\nimport Data.List (List)\nimport Data.List.Types (NonEmptyList)\nimport Data.Map as M\nimport Data.Maybe (Maybe)\nimport Data.NonEmpty (NonEmpty)\nimport Data.Set as S\nimport Data.String (CodePoint)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Tuple (Tuple)\nimport Foreign.Object as FO\nimport Prelude (class Ord, Unit, Void, identity, ($))\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record as Record\nimport Type.Proxy (Proxy(..))\n\nclass EncodeJson a where\n  encodeJson :: a -> Json\n\ninstance encodeIdentity :: EncodeJson a => EncodeJson (Identity a) where\n  encodeJson = encodeIdentity encodeJson\n\ninstance encodeJsonMaybe :: EncodeJson a => EncodeJson (Maybe a) where\n  encodeJson = encodeMaybe encodeJson\n\ninstance encodeJsonTuple :: (EncodeJson a, EncodeJson b) => EncodeJson (Tuple a b) where\n  encodeJson = encodeTuple encodeJson encodeJson\n\ninstance encodeJsonEither :: (EncodeJson a, EncodeJson b) => EncodeJson (Either a b) where\n  encodeJson = encodeEither encodeJson encodeJson\n\ninstance encodeJsonUnit :: EncodeJson Unit where\n  encodeJson = encodeUnit\n\ninstance encodeJsonJBoolean :: EncodeJson Boolean where\n  encodeJson = encodeBoolean\n\ninstance encodeJsonJNumber :: EncodeJson Number where\n  encodeJson = encodeNumber\n\ninstance encodeJsonInt :: EncodeJson Int where\n  encodeJson = encodeInt\n\ninstance encodeJsonJString :: EncodeJson String where\n  encodeJson = encodeString\n\ninstance encodeJsonJson :: EncodeJson Json where\n  encodeJson = identity\n\ninstance encodeJsonCodePoint :: EncodeJson CodePoint where\n  encodeJson = encodeCodePoint\n\ninstance encodeNonEmptyString :: EncodeJson NonEmptyString where\n  encodeJson = encodeNonEmptyString\n\ninstance encodeJsonNonEmpty_Array :: (EncodeJson a) => EncodeJson (NonEmpty Array a) where\n  encodeJson = encodeNonEmpty_Array encodeJson\n\ninstance encodeJsonNonEmptyArray :: (EncodeJson a) => EncodeJson (NonEmptyArray a) where\n  encodeJson = encodeNonEmptyArray encodeJson\n\ninstance encodeJsonNonEmpty_List :: (EncodeJson a) => EncodeJson (NonEmpty List a) where\n  encodeJson = encodeNonEmpty_List encodeJson\n\ninstance encodeJsonNonEmptyList :: (EncodeJson a) => EncodeJson (NonEmptyList a) where\n  encodeJson = encodeNonEmptyList encodeJson\n\ninstance encodeJsonChar :: EncodeJson Char where\n  encodeJson = encodeChar\n\ninstance encodeJsonArray :: EncodeJson a => EncodeJson (Array a) where\n  encodeJson = encodeArray encodeJson\n\ninstance encodeJsonList :: EncodeJson a => EncodeJson (List a) where\n  encodeJson = encodeList encodeJson\n\ninstance encodeForeignObject :: EncodeJson a => EncodeJson (FO.Object a) where\n  encodeJson = encodeForeignObject encodeJson\n\ninstance encodeSet :: (Ord a, EncodeJson a) => EncodeJson (S.Set a) where\n  encodeJson = encodeSet encodeJson\n\ninstance encodeMap :: (Ord a, EncodeJson a, EncodeJson b) => EncodeJson (M.Map a b) where\n  encodeJson = encodeMap encodeJson encodeJson\n\ninstance encodeVoid :: EncodeJson Void where\n  encodeJson = encodeVoid\n\ninstance encodeRecord ::\n  ( GEncodeJson row list\n  , RL.RowToList row list\n  ) =>\n  EncodeJson (Record row) where\n  encodeJson rec = fromObject $ gEncodeJson rec (Proxy :: Proxy list)\n\nclass GEncodeJson (row :: Row Type) (list :: RL.RowList Type) where\n  gEncodeJson :: forall proxy. Record row -> proxy list -> FO.Object Json\n\ninstance gEncodeJsonNil :: GEncodeJson row RL.Nil where\n  gEncodeJson _ _ = FO.empty\n\ninstance gEncodeJsonCons ::\n  ( EncodeJson value\n  , GEncodeJson row tail\n  , IsSymbol field\n  , Row.Cons field value tail' row\n  ) =>\n  GEncodeJson row (RL.Cons field value tail) where\n  gEncodeJson row _ = do\n    let _field = Proxy :: Proxy field\n    FO.insert\n      (reflectSymbol _field)\n      (encodeJson $ Record.get _field row)\n      (gEncodeJson row (Proxy :: Proxy tail))\n","export const intercalate = function (separator) {\n  return function (xs) {\n    return xs.join(separator);\n  };\n};\n","module Data.Show.Generic\n  ( class GenericShow\n  , genericShow'\n  , genericShow\n  , class GenericShowArgs\n  , genericShowArgs\n  ) where\n\nimport Prelude (class Show, show, (<>))\nimport Data.Generic.Rep\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Type.Proxy (Proxy(..))\n\nclass GenericShow a where\n  genericShow' :: a -> String\n\nclass GenericShowArgs a where\n  genericShowArgs :: a -> Array String\n\ninstance genericShowNoConstructors :: GenericShow NoConstructors where\n  genericShow' a = genericShow' a\n\ninstance genericShowArgsNoArguments :: GenericShowArgs NoArguments where\n  genericShowArgs _ = []\n\ninstance genericShowSum :: (GenericShow a, GenericShow b) => GenericShow (Sum a b) where\n  genericShow' (Inl a) = genericShow' a\n  genericShow' (Inr b) = genericShow' b\n\ninstance genericShowArgsProduct ::\n  ( GenericShowArgs a\n  , GenericShowArgs b\n  ) =>\n  GenericShowArgs (Product a b) where\n  genericShowArgs (Product a b) = genericShowArgs a <> genericShowArgs b\n\ninstance genericShowConstructor ::\n  ( GenericShowArgs a\n  , IsSymbol name\n  ) =>\n  GenericShow (Constructor name a) where\n  genericShow' (Constructor a) =\n    case genericShowArgs a of\n      [] -> ctor\n      args -> \"(\" <> intercalate \" \" ([ ctor ] <> args) <> \")\"\n    where\n    ctor :: String\n    ctor = reflectSymbol (Proxy :: Proxy name)\n\ninstance genericShowArgsArgument :: Show a => GenericShowArgs (Argument a) where\n  genericShowArgs (Argument a) = [ show a ]\n\n-- | A `Generic` implementation of the `show` member from the `Show` type class.\ngenericShow :: forall a rep. Generic a rep => GenericShow rep => a -> String\ngenericShow x = genericShow' (from x)\n\nforeign import intercalate :: String -> Array String -> String\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return unsafeStringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","// module Data.UUID\nimport { v3, v4, v5, validate } from \"uuid\";\n\nexport const getUUID3Impl = function (str) {\n  return function (namespace) {\n    return v3(str, namespace);\n  };\n};\n\nexport const getUUIDImpl = v4;\n\nexport const getUUID5Impl = function (str) {\n  return function (namespace) {\n    return v5(str, namespace);\n  };\n};\n\nexport const validateV4UUID = validate;\n","module Data.UUID\n  ( UUID\n  , emptyUUID\n  , genUUID\n  , parseUUID\n  , genv3UUID\n  , genv5UUID\n  , toString\n  ) where\n\nimport Prelude\nimport Data.Maybe (Maybe(Nothing, Just))\nimport Effect (Effect)\n\nnewtype UUID\n  = UUID String\n\nemptyUUID :: UUID\nemptyUUID = UUID \"00000000-0000-0000-0000-000000000000\"\n\nforeign import getUUIDImpl :: Effect String\n\n-- | Generates a v4 UUID\ngenUUID :: Effect UUID\ngenUUID = getUUIDImpl >>= pure <<< UUID\n\nforeign import validateV4UUID :: String -> Boolean\n\n-- | Validates a String as a v4 UUID\nparseUUID :: String -> Maybe UUID\nparseUUID str = case validateV4UUID str of\n  true -> Just $ UUID str\n  _ -> Nothing\n\nforeign import getUUID3Impl :: String -> String -> String\n\ngenv3UUID :: String -> UUID -> UUID\ngenv3UUID s (UUID n) = UUID $ getUUID3Impl s n\n\nforeign import getUUID5Impl :: String -> String -> String\n\ngenv5UUID :: String -> UUID -> UUID\ngenv5UUID s (UUID n) = UUID (getUUID5Impl s n)\n\ninstance showUUID :: Show UUID where\n  show (UUID uuid) = \"(UUID \" <> uuid <> \")\"\n\nderive instance eqUUID :: Eq UUID\n\nderive instance ordUUID :: Ord UUID\n\ntoString :: UUID -> String\ntoString (UUID uuid) = uuid\n","module TcgCalculator.Types.Id where\n\nimport Prelude\n\nimport Data.Argonaut.Decode (class DecodeJson, decodeJson)\nimport Data.Argonaut.Encode (class EncodeJson, encodeJson)\nimport Data.Maybe (Maybe, maybe')\nimport Data.Newtype (class Newtype)\nimport Data.UUID (UUID)\nimport Data.UUID as UUID\nimport Effect.Class (class MonadEffect, liftEffect)\n\n----------------------------------------------------------------\n\nnewtype Id = Id UUID\n\nderive instance Eq Id\nderive instance Ord Id\n\nderive instance Newtype Id _\n\ninstance Show Id where\n  show (Id uuid) = \"\\\"\" <> UUID.toString uuid <> \"\\\"\"\n\ninstance EncodeJson Id where\n  encodeJson (Id uuid) = encodeJson $ UUID.toString uuid\n\ninstance DecodeJson Id where\n  decodeJson json = decodeJson json <#> \\id -> maybe' (\\_ -> mkId id) Id (UUID.parseUUID id)\n\nnamespaceTcgCalculator :: UUID\nnamespaceTcgCalculator = UUID.genv5UUID \"tcg-calculator\" UUID.emptyUUID\n\nmkId :: String -> Id\nmkId s = Id $ UUID.genv5UUID s namespaceTcgCalculator\n\ngenerateId :: forall m. MonadEffect m => m Id\ngenerateId = liftEffect $ Id <$> UUID.genUUID\n\ntoString :: Id -> String\ntoString (Id uuid) = UUID.toString uuid\n\nfromString :: String -> Maybe Id\nfromString = map Id <<< UUID.parseUUID\n","module TcgCalculator.Types\n  ( Card\n  , Cards\n  , Condition'\n  , Condition(..)\n  , ConditionMode(..)\n  , Deck\n  , readConditionMode\n  , module Export\n  )\n  where\n\nimport Prelude\n\nimport Data.Argonaut.Decode (class DecodeJson, JsonDecodeError(..), decodeJson)\nimport Data.Argonaut.Encode (class EncodeJson, encodeJson)\nimport Data.Either (note)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Show.Generic (genericShow)\nimport TcgCalculator.Types.Id (Id)\nimport TcgCalculator.Types.Id (Id, generateId) as Export\n\n----------------------------------------------------------------\n\ntype Card = { id :: Id, name :: String, count :: Int }\n\ntype Cards = Array Card\n\ntype Deck = { cards :: Array Card, others :: Int, hand :: Int }\n\n----------------------------------------------------------------\n\ndata ConditionMode\n  = AtLeast\n  | JustDraw\n  | Remains\n  | JustRemains\n  | Choice\n  | LeftOne\n  | LeftAll\n\nderive instance Eq ConditionMode\nderive instance Ord ConditionMode\nderive instance Generic ConditionMode _\n\ninstance Show ConditionMode where\n  show = genericShow\n\ninstance EncodeJson ConditionMode where\n  encodeJson = encodeJson <<< show\n\ninstance DecodeJson ConditionMode where\n  decodeJson json = note (UnexpectedValue json) <<< readConditionMode =<< decodeJson json\n\nreadConditionMode :: String -> Maybe ConditionMode\nreadConditionMode = case _ of\n  \"AtLeast\" -> Just AtLeast\n  \"JustDraw\" -> Just JustDraw\n  \"Remains\" -> Just Remains\n  \"JustRemains\" -> Just JustRemains\n  \"Choice\" -> Just Choice\n  \"LeftOne\" -> Just LeftOne\n  \"LeftAll\" -> Just LeftAll\n  _ -> Nothing\n\n----------------------------------------------------------------\n\ntype Condition' = { mode :: ConditionMode, count :: Int, cards :: Cards }\n\nnewtype Condition = Condition Condition'\n\nderive instance Eq Condition\nderive instance Ord Condition\n\nderive instance Newtype Condition _\n\nderive newtype instance Show Condition\n\nderive newtype instance EncodeJson Condition\nderive newtype instance DecodeJson Condition\n","module Web.UIEvent.FocusEvent\n  ( FocusEvent\n  , fromUIEvent\n  , fromEvent\n  , toUIEvent\n  , toEvent\n  , relatedTarget\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.Event.Event (Event)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\nimport Web.UIEvent.UIEvent (UIEvent)\n\nforeign import data FocusEvent :: Type\n\nfromUIEvent :: UIEvent -> Maybe FocusEvent\nfromUIEvent = unsafeReadProtoTagged \"FocusEvent\"\n\nfromEvent :: Event -> Maybe FocusEvent\nfromEvent = unsafeReadProtoTagged \"FocusEvent\"\n\ntoUIEvent :: FocusEvent -> UIEvent\ntoUIEvent = unsafeCoerce\n\ntoEvent :: FocusEvent -> Event\ntoEvent = unsafeCoerce\n\nforeign import _relatedTarget :: FocusEvent -> Nullable EventTarget\n\nrelatedTarget :: FocusEvent -> Maybe EventTarget\nrelatedTarget = toMaybe <$> _relatedTarget\n","module App.ConditionLine where\n\nimport Prelude\n\nimport App.Selector as Selector\nimport Control.Monad.Maybe.Trans (runMaybeT)\nimport Data.Array as Array\nimport Data.Foldable (traverse_)\nimport Data.Int as Int\nimport Data.Maybe (Maybe(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Newtype (alaF)\nimport Effect.Aff (Aff)\nimport Halogen as H\nimport Halogen.HTML as HH\nimport Halogen.HTML.Events as HE\nimport Halogen.HTML.Properties as HP\nimport TcgCalculator.Types (Cards, Condition(..), Condition', ConditionMode(..), Id, readConditionMode)\nimport Type.Proxy (Proxy(..))\nimport Web.Event.Event as Event\nimport Web.HTML.HTMLInputElement as Input\nimport Web.UIEvent.FocusEvent as Focus\n\n----------------------------------------------------------------\n\ndata Output = Updated\n\ndata Action\n  = Initialize\n  | UpdateConditionMode String\n  | UpdateCardSelected (Array Id)\n  | UpdateCardCount String\n  | Receive Cards\n  | SelectOnFocus Focus.FocusEvent\n\ndata Query a\n  = GetCondition (Condition -> a)\n  | RestoreState Cards Condition a\n\n----------------------------------------------------------------\n\ncomponent :: H.Component Query Cards Output Aff\ncomponent = H.mkComponent\n  { initialState\n  , render\n  , eval: H.mkEval $ H.defaultEval\n      { handleAction = action\n      , handleQuery = runMaybeT <<< query\n      , initialize = Just Initialize\n      , receive = Just <<< Receive\n      }\n  }\n  where\n\n  initialState :: _ -> { cards :: Cards, condition :: Condition', minValue :: Int, maxValue :: Int }\n  initialState = { cards: _, condition: { mode: AtLeast, count: 0, cards: [] }, minValue: 0, maxValue: 0 }\n\n  render { cards, condition: { mode, count }, minValue, maxValue } = do\n    HH.div\n      [ HP.class_ $ H.ClassName \"flex flex-wrap items-center justify-end\" ]\n      [ HH.div\n          [ HP.class_ $ H.ClassName \"w-48 grow rounded border p-0.5\" ]\n          [ renderCardSelector cards ]\n      , HH.div\n          [ HP.class_ $ H.ClassName \"flex items-center\" ]\n          [ HH.div [ HP.class_ $ H.ClassName \"mx-1\" ] [ HH.text \"を\" ]\n          , renderCardCounter count minValue maxValue\n          , renderModeSelector mode\n          ]\n      ]\n\n  renderCardSelector cards = do\n    let cards' = cards <#> \\card -> { id: card.id, value: card.name }\n    HH.slot (Proxy @\"selector\") unit Selector.component cards' UpdateCardSelected\n\n  renderCardCounter count min max =\n    HH.input\n      [ HP.classes\n          [ H.ClassName \"w-12 appearance-none rounded border border-gray-400 bg-transparent p-1 text-right\"\n          , H.ClassName \"transition ease-in-out hover:border-gray-500 focus:border-blue-600 focus:outline-none\"\n          ]\n      , HP.type_ HP.InputNumber\n      , HP.step $ HP.Step 1.0\n      , HP.value $ show count\n      , HP.min $ Int.toNumber min\n      , HP.max $ Int.toNumber max\n      , HE.onFocus SelectOnFocus\n      , HE.onValueChange UpdateCardCount\n      ]\n\n  renderModeSelector mode =\n    HH.select\n      [ HP.classes\n          [ H.ClassName \"w-full appearance-none rounded border border-gray-400 bg-transparent px-3 py-1\"\n          , H.ClassName \"transition ease-in-out hover:border-gray-500 focus:border-blue-600 focus:outline-none\"\n          ]\n      , HP.value $ show mode\n      , HE.onValueChange UpdateConditionMode\n      ]\n      [ HH.option [ HP.value $ show AtLeast ] [ HH.text \"枚以上ドローする\" ]\n      , HH.option [ HP.value $ show JustDraw ] [ HH.text \"枚ちょうどドローする\" ]\n      , HH.option [ HP.value $ show Remains ] [ HH.text \"枚以上デッキに残す\" ]\n      , HH.option [ HP.value $ show JustRemains ] [ HH.text \"枚ちょうどデッキに残す\" ]\n      , HH.option [ HP.value $ show Choice ] [ HH.text \"種類以上ドローする\" ]\n      , HH.option [ HP.value $ show LeftOne ] [ HH.text \"種類以上デッキに残す\" ]\n      , HH.option [ HP.value $ show LeftAll ] [ HH.text \"種類以上ドローしない\" ]\n      ]\n\n  action :: Action -> _\n  action = case _ of\n    Initialize -> do\n      { cards, condition: { mode, count, cards: selected } } <- H.get\n      updateStatus cards selected mode count\n    UpdateCardSelected selected -> do\n      updateCardSelected selected\n      H.raise Updated\n    UpdateConditionMode mode -> do\n      readConditionMode mode # traverse_ \\mode' -> do\n        { cards, condition: { count, cards: selected } } <- H.get\n        updateStatus cards selected mode' count\n        H.raise Updated\n    UpdateCardCount count -> do\n      Int.fromString count # traverse_ \\count' -> do\n        { cards, condition: { mode, cards: selected } } <- H.get\n        updateStatus cards selected mode count'\n        H.raise Updated\n    Receive cards -> do\n      { condition: { cards: selected } } <- H.modify _ { cards = cards }\n      updateCardSelected (selected <#> _.id)\n    SelectOnFocus event -> do\n      let element = Input.fromEventTarget <=< Event.target <<< Focus.toEvent $ event\n      H.liftEffect $ traverse_ Input.select element\n    where\n    updateCardSelected selected = do\n      { cards, condition: { mode, count } } <- H.get\n      let selected' = cards # Array.filter \\{ id } -> Array.elem id selected\n      updateStatus cards selected' mode count\n    updateStatus cards selected mode count = do\n      let { min, max } = getMinMax selected mode\n      H.put { cards, condition: { mode, cards: selected, count: clamp min max count }, minValue: min, maxValue: max }\n\n  getMinMax :: Cards -> ConditionMode -> { min :: Int, max :: Int }\n  getMinMax cards = case _ of\n    AtLeast -> do\n      let max = countCards cards\n      { min: min 1 max, max }\n    JustDraw -> do\n      let max = countCards cards\n      { min: 0, max }\n    Remains -> do\n      let max = countCards cards\n      { min: min 1 max, max }\n    JustRemains -> do\n      let max = countCards cards\n      { min: 0, max }\n    Choice -> do\n      let max = Array.length cards\n      { min: min 1 max, max }\n    LeftOne -> do\n      let max = Array.length cards\n      { min: min 1 max, max }\n    LeftAll -> do\n      let max = Array.length cards\n      { min: min 1 max, max }\n    where\n    countCards = alaF Additive Array.foldMap _.count\n\n  query :: _ ~> _\n  query = case _ of\n    GetCondition reply -> do\n      reply <<< Condition <$> H.gets _.condition\n    RestoreState cards (Condition condition) a -> H.lift do\n      let { min, max } = getMinMax condition.cards condition.mode\n      H.put { cards, condition, minValue: min, maxValue: max }\n      let items = cards <#> \\card -> { id: card.id, value: card.name, selected: Array.elem card condition.cards }\n      H.tell (Proxy @\"selector\") unit (Selector.SetItems items)\n      pure a\n","// module Data.BigInt\n\nimport bigInt from \"big-integer\";\n\nexport function fromTypeLevelInt(str) {\n  return bigInt(str, 10);\n}\n\nexport function fromBaseImpl(just) {\n  return function(nothing) {\n    return function(b) {\n      return function(s) {\n        try {\n          var x = bigInt(s, b);\n          return just(x);\n        } catch (err) {\n          return nothing;\n        }\n      };\n    };\n  };\n}\n\nfunction truncate(n) {\n  if (n > 0) return Math.floor(n);\n  return Math.ceil(n);\n}\n\nexport function fromNumberImpl(just) {\n  return function(nothing) {\n      return function(n) {\n        try {\n          var x = bigInt(truncate(n));\n          return just(x);\n        } catch (err) {\n          return nothing;\n        }\n      };\n  };\n}\n\nexport function fromInt(n) {\n  return bigInt(n);\n}\n\nexport function toBase(base) {\n  return function (x) {\n    return x.toString(base);\n  };\n}\n\nexport function toNumber(x) {\n  return x.toJSNumber();\n}\n\nexport function biAdd(x) {\n  return function(y) {\n    return x.add(y);\n  };\n}\n\nexport function biMul(x) {\n  return function(y) {\n    return x.multiply(y);\n  };\n}\n\nexport function biSub(x) {\n  return function(y) {\n    return x.minus(y);\n  };\n}\n\nexport function biMod(x) {\n  return function(y) {\n    return x.mod(y);\n  };\n}\n\nexport function biDiv(x) {\n  return function(y) {\n    return x.divide(y);\n  };\n}\n\nexport function biEquals(x) {\n  return function(y) {\n    return x.equals(y);\n  };\n}\n\nexport function biCompare(x) {\n  return function(y) {\n    return x.compare(y);\n  };\n}\n\nexport function abs(x) {\n  return x.abs();\n}\n\nexport function even(x) {\n  return x.isEven();\n}\n\nexport function odd(x) {\n  return x.isOdd();\n}\n\nexport function prime(x) {\n  return x.isPrime();\n}\n\nexport function pow(x) {\n  return function(y) {\n    return x.pow(y);\n  };\n}\n\nexport function not(x) {\n  return x.not();\n  }\n\nexport function or(x) {\n  return function(y) {\n    return x.or(y);\n  };\n}\n\nexport function xor(x) {\n  return function(y) {\n    return x.xor(y);\n  };\n}\n\nexport function and(x) {\n  return function(y) {\n    return x.and(y);\n  };\n}\n\nexport function shl(x) {\n  return function(n) {\n    return x.shiftLeft(n);\n  };\n}\n\nexport function shr(x) {\n  return function(n) {\n    return x.shiftRight(n);\n  };\n}\n\nexport function digitsInBase(radix) {\n  return function(x) {\n    return x.toArray(radix);\n  };\n}\n","-- | This module defines a `BigInt` data type for arbitrary length integers.\nmodule Data.BigInt\n  ( BigInt(..)\n  , BaseDigits\n  , fromString\n  , fromBase\n  , fromInt\n  , fromNumber\n  , fromTLInt\n  , toString\n  , toNonEmptyString\n  , toBase\n  , toBase'\n  , digitsInBase\n  , abs\n  , even\n  , odd\n  , prime\n  , pow\n  , not\n  , or\n  , xor\n  , and\n  , shl\n  , shr\n  , quot\n  , rem\n  , toInt\n  , toNumber\n  ) where\n\nimport Prelude\n\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Int (floor)\nimport Data.Int as Int\nimport Data.Maybe (Maybe(..), fromJust)\nimport Data.Reflectable (class Reflectable, reflectType)\nimport Data.String.NonEmpty (NonEmptyString)\nimport Data.String.NonEmpty as NES\nimport Partial.Unsafe (unsafePartial)\nimport Prim.Int (class ToString)\nimport Type.Proxy (Proxy(..))\n\n-- | An arbitrary length integer.\nforeign import data BigInt :: Type\n\ntype BaseDigits =\n  { value :: NonEmptyArray Int\n  , isNegative :: Boolean\n  }\n\n-- | FFI wrapper to parse a String in a given base representation into a BigInt.\nforeign import fromBaseImpl\n  :: forall a\n   . (a -> Maybe a)\n  -> Maybe a\n  -> Int\n  -> String\n  -> Maybe BigInt\n\n-- | Convert an integer to a BigInt.\nforeign import fromInt :: Int -> BigInt\n\ntoInt :: BigInt -> Maybe Int\ntoInt = toNumber >>> Int.fromNumber\n\n-- | FFI wrapper to parse a Number into a BigInt.\nforeign import fromNumberImpl\n  :: forall a\n   . (a -> Maybe a)\n  -> Maybe a\n  -> Number\n  -> Maybe BigInt\n\n-- | Convert a Number to a BigInt. The fractional part is truncated.\nfromNumber :: Number -> Maybe BigInt\nfromNumber = fromNumberImpl Just Nothing\n\n-- | Converts a BigInt to a Number. Loses precision for numbers which are too\n-- | large.\nforeign import toNumber :: BigInt -> Number\n\n-- | Exponentiation for `BigInt`. If the exponent is less than 0, `pow`\n-- | returns 0. Also, `pow zero zero == one`.\nforeign import pow :: BigInt -> BigInt -> BigInt\n\n-- | The absolute value.\nforeign import abs :: BigInt -> BigInt\n\n-- | Returns `true` if the number is even, `false` otherwise.\nforeign import even :: BigInt -> Boolean\n\n-- | Returns `true` if the number is odd, `false` otherwise.\nforeign import odd :: BigInt -> Boolean\n\n-- | Returns `true` if the number is prime, `false` otherwise.\nforeign import prime :: BigInt -> Boolean\n\n-- | Invert the bits.\nforeign import not :: BigInt -> BigInt\n\n-- | or the bits.\nforeign import or :: BigInt -> BigInt -> BigInt\n\n-- | Exlusive or the bits.\nforeign import xor :: BigInt -> BigInt -> BigInt\n\n-- | and the bits.\nforeign import and :: BigInt -> BigInt -> BigInt\n\n-- | shift the bits left and zero fill.\nforeign import shl :: BigInt -> Number -> BigInt\n\n-- | Shift the bits right and maintain pos/neg.\nforeign import shr :: BigInt -> Number -> BigInt\n\n-- Note: this function should not be exported!\n-- It's only safe if used with type-level integers.\nforeign import fromTypeLevelInt :: String -> BigInt\n\n-- | Converts a type-level integer into a `BigInt`:\n-- | ```\n-- | import Type.Proxy (Proxy(..))\n-- | foo = fromTLInt (Proxy :: Proxy 857981209301293808359384092830482)\n-- | ```\nfromTLInt :: forall i sym. ToString i sym => Reflectable sym String => Proxy i -> BigInt\nfromTLInt _ = fromTypeLevelInt (reflectType (Proxy :: Proxy sym))\n\n-- | Parse a string into a `BigInt`, assuming a decimal representation. Returns\n-- | `Nothing` if the parse fails.\n-- |\n-- | Examples:\n-- | ```purescript\n-- | fromString \"42\"\n-- | fromString \"857981209301293808359384092830482\"\n-- | fromString \"1e100\"\n-- | ```\nfromString :: String -> Maybe BigInt\nfromString = fromBase 10\n\n-- | Parse a string into a `BigInt`, assuming a representation in the given base.\n-- | The letters \"a-z\" and \"A-Z\" will be interpreted as the digits `10` to\n-- | `36`. Returns `Nothing` if the parse fails.\n-- |\n-- | ```purescript\n-- | fromBase 2 \"100\" == fromString \"4\"\n-- | fromBase 16 \"ff\" == fromString \"255\"\n-- | ```\nfromBase :: Int -> String -> Maybe BigInt\nfromBase = fromBaseImpl Just Nothing\n\nforeign import biEquals :: BigInt -> BigInt -> Boolean\n\ninstance eqBigInt :: Eq BigInt where\n  eq = biEquals\n\nforeign import biCompare :: BigInt -> BigInt -> Int\n\ninstance ordBigInt :: Ord BigInt where\n  compare x y = case biCompare x y of\n                  1 -> GT\n                  0 -> EQ\n                  _ -> LT\n\n-- | A decimal representation of the `BigInt` as a `String`.\ntoString :: BigInt -> String\ntoString = toBase 10\n\n-- | A decimal representation of the `BigInt` as a `NonEmptyString`.\ntoNonEmptyString :: BigInt -> NonEmptyString\ntoNonEmptyString = toBase' 10\n\n-- | A base N representation of the `BigInt` as an array of digits.\nforeign import digitsInBase :: Int -> BigInt -> BaseDigits\n\n-- | A base N representation of the `BigInt` as a `String`.\nforeign import toBase :: Int -> BigInt -> String\n\n-- | A base N representation of the `BigInt` as a `NonEmptyString`.\ntoBase' :: Int -> BigInt -> NonEmptyString\ntoBase' i bi = unsafePartial fromJust $ NES.fromString $ toBase i bi\n\ninstance showBigInt :: Show BigInt where\n  show x = \"(fromString \\\"\" <> toString x <> \"\\\")\"\n\nforeign import biAdd :: BigInt -> BigInt -> BigInt\nforeign import biMul :: BigInt -> BigInt -> BigInt\n\ninstance semiringBigInt :: Semiring BigInt where\n  add  = biAdd\n  zero = fromInt 0\n  mul  = biMul\n  one  = fromInt 1\n\nforeign import biSub :: BigInt -> BigInt -> BigInt\n\ninstance ringBigInt :: Ring BigInt where\n  sub = biSub\n\nforeign import biDiv :: BigInt -> BigInt -> BigInt\nforeign import biMod :: BigInt -> BigInt -> BigInt\n\ninstance commutativeRingBigInt :: CommutativeRing BigInt\n\ninstance euclideanRingBigInt :: EuclideanRing BigInt where\n  div x y = (x - x `mod` y) `biDiv` y\n\n  mod x y = ((x `biMod` yy) + yy) `biMod` yy\n    where yy = abs y\n\n  degree = floor <<< toNumber <<< abs\n\n-- | Truncating integer division\nquot :: BigInt -> BigInt -> BigInt\nquot = biDiv\n\n-- | The remainder after truncating integer division\nrem :: BigInt -> BigInt -> BigInt\nrem = biMod\n","export function message(e) {\n  return e.message;\n}\n\nexport function fileName(e) {\n  return e.filename;\n}\n\nexport function lineNo(e) {\n  return e.lineno;\n}\n\nexport function colNo(e) {\n  return e.colno;\n}\n","module Web.HTML.Event.ErrorEvent where\n\nimport Data.Maybe (Maybe)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.Event.Event (Event)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data ErrorEvent :: Type\n\nfromEvent :: Event -> Maybe ErrorEvent\nfromEvent = unsafeReadProtoTagged \"ErrorEvent\"\n\ntoEvent :: ErrorEvent -> Event\ntoEvent = unsafeCoerce\n\nforeign import message :: ErrorEvent -> String\n\nforeign import fileName :: ErrorEvent -> String\n\nforeign import lineNo :: ErrorEvent -> Int\n\nforeign import colNo :: ErrorEvent -> Int\n","export function data_(ev) {\n  return ev.data; \n}\n\nexport function origin(ev) {\n  return ev.origin; \n}\n\nexport function lastEventId(ev) {\n  return ev.lastEventId;\n}\n\nexport function ports(ev) {\n  return ev.ports;\n}","export function _new (src) {\n  return function (opts) {\n    return function () {\n      return new Worker(src, opts);\n    };\n  };\n}\n\nexport function postMessageImpl(data) {\n  return function (transfer) {\n    return function (worker) {\n      return function () {\n        worker.postMessage(data, transfer.length > 0 ? transfer : undefined);\n      };\n    };\n  };\n}\n\nexport function terminate (worker) {\n  return function () {\n    worker.terminate();\n  };\n}\n\nexport function onMessage(f) {\n  return function (worker) {\n    return function () {\n      worker.onmessage = function (ev) {\n        f(ev)();\n      };\n    };\n  };\n}\n\nexport function onMessageError(f) {\n  return function (worker) {\n    return function () {\n      worker.onmessageerror = function (ev) {\n        f(ev)();\n      };\n    };\n  };\n}\n\nexport function onError(f) {\n  return function (worker) {\n    return function () {\n      worker.onerror = function (ev) {\n        f(ev)();\n      };\n    };\n  };\n}\n","module Web.Worker.Worker\n  ( Credentials(..)\n  , Worker\n  , WorkerOptions\n  , WorkerType(..)\n  , defaultWorkerOptions\n  , fromEventTarget\n  , new\n  , onMessage\n  , onMessageError\n  , onError\n  , postMessage\n  , postMessage'\n  , terminate\n  , toEventTarget\n  ) where\n\nimport Prelude\nimport Data.Maybe (Maybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.Event.Event (Event)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\nimport Web.Worker.MessageEvent (MessageEvent)\nimport Web.Worker.Types (Transferable)\n\nforeign import data Worker :: Type\n\nfromEventTarget :: EventTarget -> Maybe Worker\nfromEventTarget = unsafeReadProtoTagged \"Worker\"\n\ntoEventTarget :: Worker -> EventTarget\ntoEventTarget = unsafeCoerce\n\ndata WorkerType\n  = Classic\n  | Module\n\ndata Credentials\n  = Omit\n  | SameOrigin\n  | Include\n\ntype WorkerOptions\n  = { credentials :: Credentials\n    , name :: String\n    , type :: WorkerType\n    }\n\ndefaultWorkerOptions :: WorkerOptions\ndefaultWorkerOptions =\n  { name: \"\"\n  , credentials: Omit\n  , type: Classic\n  }\n\nforeign import _new :: String -> { name :: String, credentials :: String, type :: String } -> Effect Worker\n\nnew :: String -> WorkerOptions -> Effect Worker\nnew url { name, type: t, credentials } =\n  _new url\n    { name\n    , credentials: show credentials\n    , type: show t\n    }\n\nforeign import postMessageImpl :: forall msg. msg -> Array Transferable -> Worker -> Effect Unit\n\npostMessage :: forall msg. msg -> Worker -> Effect Unit\npostMessage msg = postMessageImpl msg []\n\npostMessage' :: forall msg. msg -> Array Transferable -> Worker -> Effect Unit\npostMessage' = postMessageImpl\n\nforeign import terminate :: Worker -> Effect Unit\n\nforeign import onMessage :: (MessageEvent -> Effect Unit) -> Worker -> Effect Unit\n\nforeign import onMessageError :: (MessageEvent -> Effect Unit) -> Worker -> Effect Unit\n\nforeign import onError :: (Event -> Effect Unit) -> Worker -> Effect Unit\n\ninstance Show WorkerType where\n  show = case _ of\n    Classic -> \"classic\"\n    Module  -> \"module\"\n\ninstance Show Credentials where\n  show = case _ of\n    Omit       -> \"omit\"\n    SameOrigin -> \"same-origin\"\n    Include    -> \"include\"","module App.Worker where\n\nimport Prelude\n\nimport Control.Monad.Except (runExcept)\nimport Data.Argonaut.Encode (encodeJson)\nimport Data.Bifunctor (lmap)\nimport Data.BigInt (BigInt)\nimport Data.BigInt as BigInt\nimport Data.Either (Either(..), note)\nimport Data.Maybe (maybe)\nimport Data.Semigroup.Foldable (intercalateMap)\nimport Effect.Aff (Aff, effectCanceler, error, makeAff)\nimport Foreign (readString, renderForeignError)\nimport SharedTypes (TcgCalculatorWorkerParam)\nimport Web.HTML.Event.ErrorEvent as ErrorEvent\nimport Web.Worker.MessageEvent as MessageEvent\nimport Web.Worker.Worker as Worker\n\n----------------------------------------------------------------\n\nrun :: TcgCalculatorWorkerParam -> Aff BigInt\nrun param = makeAff \\reply -> do\n  worker <- Worker.new \"bundle/worker.js\" Worker.defaultWorkerOptions { type = Worker.Module }\n  worker # Worker.onMessage \\event -> reply do\n    result <- lmap (error <<< intercalateMap \"\\n\" renderForeignError) <<< runExcept <<< readString $ MessageEvent.data_ event\n    note (error \"BigInt.fromString\") $ BigInt.fromString result\n  worker # Worker.onError \\event -> do\n    Worker.terminate worker\n    let message = maybe \"Unknown worker error\" ErrorEvent.message $ ErrorEvent.fromEvent event\n    reply $ Left (error message)\n  Worker.postMessage (encodeJson param) worker\n  pure $ effectCanceler (Worker.terminate worker)\n","function wrap(method) {\n  return function(d) {\n    return function(num) {\n      return method.apply(num, [d]);\n    };\n  };\n}\n\nexport const toPrecisionNative = wrap(Number.prototype.toPrecision);\nexport const toFixedNative = wrap(Number.prototype.toFixed);\nexport const toExponentialNative = wrap(Number.prototype.toExponential);\nexport function toString(num) { return num.toString(); }\n","-- | A module for formatting numbers as strings.\n-- |\n-- | Usage:\n-- | ``` purs\n-- | > let x = 1234.56789\n-- |\n-- | > toStringWith (precision 6) x\n-- | \"1234.57\"\n-- |\n-- | > toStringWith (fixed 3) x\n-- | \"1234.568\"\n-- |\n-- | > toStringWith (exponential 2) x\n-- | \"1.23e+3\"\n-- | ```\n-- |\n-- | The main method of this module is the `toStringWith` function that accepts\n-- | a `Format` argument which can be constructed through one of the smart\n-- | constructors `precision`, `fixed` and `exponential`. Internally, the\n-- | number will be formatted with JavaScripts `toPrecision`, `toFixed` or\n-- | `toExponential`.\nmodule Data.Number.Format\n  ( Format()\n  , precision\n  , fixed\n  , exponential\n  , toStringWith\n  , toString\n  ) where\n\nimport Prelude\n\nforeign import toPrecisionNative ::   Int -> Number -> String\nforeign import toFixedNative ::       Int -> Number -> String\nforeign import toExponentialNative :: Int -> Number -> String\n\n-- | The `Format` data type specifies how a number will be formatted.\ndata Format\n  = Precision Int\n  | Fixed Int\n  | Exponential Int\n\n-- | Create a `toPrecision`-based format from an integer. Values smaller than\n-- | `1` and larger than `21` will be clamped.\nprecision :: Int -> Format\nprecision = Precision <<< clamp 1 21\n\n-- | Create a `toFixed`-based format from an integer. Values smaller than `0`\n-- | and larger than `20` will be clamped.\nfixed :: Int -> Format\nfixed = Fixed <<< clamp 0 20\n\n-- | Create a `toExponential`-based format from an integer. Values smaller than\n-- | `0` and larger than `20` will be clamped.\nexponential :: Int -> Format\nexponential = Exponential <<< clamp 0 20\n\n-- | Convert a number to a string with a given format.\ntoStringWith :: Format -> Number -> String\ntoStringWith (Precision p)   = toPrecisionNative p\ntoStringWith (Fixed p)       = toFixedNative p\ntoStringWith (Exponential p) = toExponentialNative p\n\n-- | Convert a number to a string via JavaScript's toString method.\n-- |\n-- | ```purs\n-- | > toString 12.34\n-- | \"12.34\"\n-- |\n-- | > toString 1234.0\n-- | \"1234\"\n-- |\n-- | > toString 1.2e-10\n-- | \"1.2e-10\"\n-- | ```\nforeign import toString :: Number -> String\n","module Util.Array where\n\nimport Prelude\n\nimport Control.Monad.ST (ST)\nimport Data.Array.ST (STArray)\nimport Data.Array.ST as STA\nimport Data.Maybe (Maybe(..))\n\n----------------------------------------------------------------\n\nswap :: forall a. Int -> Int -> Array a -> Array a\nswap x y array = STA.run do\n  st <- STA.thaw array\n  swapST x y st\n  pure st\n\nswapST :: forall h a. Int -> Int -> STArray h a -> ST h Unit\nswapST x y st = do\n  a <- STA.peek x st\n  b <- STA.peek y st\n  case a, b of\n    Just a', Just b' -> void do STA.poke x b' st *> STA.poke y a' st\n    _, _ -> pure unit\n\nshiftInsert :: forall a. Int -> Int -> Array a -> Array a\nshiftInsert from to array | from == to = array\nshiftInsert from to array = STA.run do\n  st <- STA.thaw array\n  item <- STA.splice from 1 [] st\n  _ <- STA.splice to 0 item st\n  pure st\n","module TcgCalculator.Math\n  ( Combination\n  , PartitionNumber\n  , PascalTriangle\n  , Permutation\n  , combinationNumber\n  , combinations\n  , createPascalTriangle\n  , distinctPermutations\n  , partitionNumber\n  , partitionNumbers\n  , pascalTriangle\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST)\nimport Data.Array (drop, filter, findLastIndex, fromFoldable, head, length, singleton, uncons, unsafeIndex, zipWith, (!!), (..), (:))\nimport Data.Array.ST (STArray)\nimport Data.Array.ST as STA\nimport Data.BigInt (BigInt)\nimport Data.BigInt as BigInt\nimport Data.Foldable (fold, product)\nimport Data.List as L\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (iterateN, unfoldr1)\nimport Partial.Unsafe (unsafePartial)\nimport Util.Array (swapST)\n\n----------------------------------------------------------------\n\ntype PascalTriangle = Array (Array BigInt)\n\ncreatePascalTriangle :: Int -> PascalTriangle\ncreatePascalTriangle size | size <= 0 = []\ncreatePascalTriangle size = [one] # iterateN size \\r -> zipWith (+) ([zero] <> r) (r <> [zero])\n\nptCacheSize :: Int\nptCacheSize = 64\n\npascalTriangle :: PascalTriangle\npascalTriangle = createPascalTriangle ptCacheSize\n\ncombinationNumber :: Int -> Int -> BigInt\ncombinationNumber n r\n  | n < 0 || r < 0  = zero\n  | r == 0          = one\n  | r == 1          = BigInt.fromInt n\n  | n - r < r       = combinationNumber n (n - r)\n  | n < ptCacheSize = unsafePartial $ pascalTriangle `unsafeIndex` n `unsafeIndex` r -- fast path using cached pascal triangle\n  | otherwise       = product' ((n - r + 1) .. n) / product' (1 .. r)\n  where\n  product' = product <<< map BigInt.fromInt\n\n----------------------------------------------------------------\n\ntype PartitionNumber = Array (Array Int)\n\n-- partitionNumber 4 -> [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]\npartitionNumber :: Int -> PartitionNumber\npartitionNumber n | n < 0 = []\npartitionNumber 0 = [[]]\npartitionNumber n = fold <<< L.head $ buildPartitionNumbers n\n\n-- partitionNumbers 3 -> [partitionNumber 3, partitionNumber 2, paritionNumber 1, partitionNumber 0]\npartitionNumbers :: Int -> Array PartitionNumber\npartitionNumbers n | n < 0 = []\npartitionNumbers 0 = [[[]]]\npartitionNumbers n = fromFoldable $ buildPartitionNumbers n\n\nbuildPartitionNumbers :: Int -> L.List PartitionNumber\nbuildPartitionNumbers 0 = L.singleton [[]]\nbuildPartitionNumbers k = do\n  let prev = buildPartitionNumbers (k - 1)\n  new prev 1 L.: prev\n  where\n  new :: L.List PartitionNumber -> Int -> PartitionNumber\n  new (h L.: t) i = new t (i + 1) <> ((i : _) <$> filter ((_ <= i) <<< fromMaybe 0 <<< head) h)\n  new _         _ = []\n\n----------------------------------------------------------------\n\ntype Permutation a = Array (Array a)\n\n-- distinctPermutations [3, 2, 1] -> [[3, 2, 1], [3, 1, 2], [2, 3, 1], [2, 1, 3], [1, 3, 2], [1, 2, 3]]\n-- permutations for arrays with duplicated items\n-- input array must be sorted in DESCENDING order\n-- https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\ndistinctPermutations :: forall a. Ord a => Array a -> Permutation a\ndistinctPermutations = unfoldr1 \\a -> Tuple a (prevPerm a)\n  where\n  prevPerm :: Array a -> Maybe (Array a)\n  prevPerm a = do\n    k <- findLastIndex identity $ zipWith (>) a (drop 1 a)\n    v <- a !! k\n    l <- findLastIndex (v > _) a\n    pure $ STA.run do\n      st <- STA.thaw a\n      swapST k l st\n      reverseST (k + 1) (length a - 1) st\n      pure st\n  reverseST :: forall h. Int -> Int -> STArray h a -> ST h Unit\n  reverseST x y st = when (x < y) do\n    swapST x y st\n    reverseST (x + 1) (y - 1) st\n\n----------------------------------------------------------------\n\ntype Combination a = Array (Array a)\n\n-- combination 2 [1, 2, 3, 4] -> [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\ncombinations :: forall a. Int -> Array a -> Combination a\ncombinations n a\n  | n == 0        = [[]]\n  | length a == n = [a]\n  | length a < n  = []\n  | n == 1        = singleton <$> a\n  | otherwise     = case uncons a of\n      Just { head, tail } -> ((head : _) <$> combinations (n - 1) tail) <> combinations n tail\n      _ -> []\n","module TcgCalculator where\n\nimport Prelude\n\nimport Control.Alternative (empty)\nimport Data.Array (all, any, concat, concatMap, deleteBy, filter, find, foldMap, foldr, groupAllBy, length, nubByEq, replicate, sortBy, take, zipWith, (!!), (..))\nimport Data.Array.NonEmpty (NonEmptyArray, foldl1, toArray)\nimport Data.BigInt (BigInt)\nimport Data.Foldable (and, fold, maximum, product)\nimport Data.Function (on)\nimport Data.Maybe (fromMaybe, maybe)\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Newtype (alaF, unwrap)\nimport TcgCalculator.Math (Combination, combinationNumber, combinations, distinctPermutations, partitionNumber, partitionNumbers)\nimport TcgCalculator.Types (Card, Cards, Condition(..), ConditionMode(..), Deck)\n\n----------------------------------------------------------------\n\n-- 条件を満たす組み合わせの個数を計算する\ncalculate :: Deck -> Array (NonEmptyArray Condition) -> BigInt\ncalculate deck conditions = do\n  let drawPattern = generateDrawPatterns deck\n  let conditionPattern = buildConditionPattern =<< conditions\n  let pattern = filter (\\dp -> any (satisfyCondition dp) conditionPattern) drawPattern\n  sumBy (calculatePatternCount deck) pattern\n\n-- 指定した条件式で使用していないカードをデッキから取り除く\nnormalizeDeck :: Deck -> Array (NonEmptyArray Condition) -> Deck\nnormalizeDeck deck conditions = do\n  let used = usedCards conditions\n  let unused = diffCards deck.cards used\n  deck { cards = used, others = deck.others + sumBy _.count unused }\n  where\n  usedCards = nubByEq ((==) `on` _.id) <<< concatMap (_.cards <<< unwrap) <<< concatMap toArray\n  diffCards = foldr $ deleteBy ((==) `on` _.id)\n\n-- 確率計算のため、全組み合わせの個数を計算する\ncalculateTotal :: Deck -> BigInt\ncalculateTotal { cards, others, hand } = combinationNumber (sumBy _.count cards + others) hand\n\n----------------------------------------------------------------\n\n-- 各カードをそれぞれ何枚引いているかの状態を表す\ntype DrawPattern = Array { card :: Card, draw :: Int }\n\n-- Deck から再現可能な全ての手札の組み合わせを列挙する\ngenerateDrawPatterns :: Deck -> Array DrawPattern\ngenerateDrawPatterns { cards, others, hand } = do\n  let maxDrawCount = min hand (sumBy _.count cards)\n  let maxPatternLength = maxDrawCount + others - hand + 1 -- others が hand より少ない場合に成り立たないパターンは予めフィルタする\n  mkDrawPattern' cards <<< concat <<< take maxPatternLength $ partitionNumbers maxDrawCount\n\n-- 与えた DrawPattern にマッチする組み合わせの個数を返す\ncalculatePatternCount :: Deck -> DrawPattern -> BigInt\ncalculatePatternCount { others, hand } pattern = do\n  let patternCount = product $ pattern <#> \\{ card: { count }, draw } -> combinationNumber count draw -- 条件のカードを引くときの組み合わせの数\n  patternCount * combinationNumber others (hand - sumBy _.draw pattern) -- 残りの手札に条件外のカードを引く組み合わせの数\n\n----------------------------------------------------------------\n\n-- 各カード毎の引いて良い枚数条件を組み合わせた一つの条件式を表す\ntype ConditionPattern = Array { card :: Card, min :: Int, max :: Int }\n\nsatisfyCondition :: DrawPattern -> ConditionPattern -> Boolean\nsatisfyCondition dp = all \\{ card: { id }, min, max } -> do\n  let draw = maybe 0 _.draw $ find (_.card.id >>> (_ == id)) dp\n  min <= draw && draw <= max\n\n-- 条件式をマージ (AND) して ConditionPattern のリストに変換する\nbuildConditionPattern :: NonEmptyArray Condition -> Array ConditionPattern\nbuildConditionPattern conditions = do\n  let patterns = mkConditionPattern <$> conditions\n  foldl1 <@> patterns $ \\left right -> do\n    l <- left\n    r <- right\n    let merged = mergeConditionPattern l r\n    if isValidConditionPattern merged then pure merged else empty\n\nmergeConditionPattern :: ConditionPattern -> ConditionPattern -> ConditionPattern\nmergeConditionPattern left right = foldl1 merge <$> groupAllBy (comparing _.card.id) (left <> right)\n  where\n  merge { card, min: min1, max: max1 } { min: min2, max: max2 } = { card, min: min1 + min2, max: min max1 max2 }\n\nisValidConditionPattern :: ConditionPattern -> Boolean\nisValidConditionPattern = all \\{ card: { count }, min, max } -> min <= max && min <= count\n\n-- 一つの Condition に対応する全パターンのリストを出力する\nmkConditionPattern :: Condition -> Array ConditionPattern\nmkConditionPattern (Condition { mode, count, cards }) = case mode of\n  -- cards の中から count 枚以上を引くパターン\n  AtLeast -> ado\n    pattern <- mkDrawPattern cards count\n    in pattern <#> \\p -> { card: p.card, min: p.draw, max: p.card.count }\n  -- cards の中からちょうど count 枚を引くパターン\n  JustDraw -> ado\n    pattern <- mkDrawPattern cards count\n    in cards <#> \\card -> do\n      let draw = maybe 0 _.draw $ find (_.card.id >>> (_ == card.id)) pattern\n      { card, min: draw, max: draw }\n  -- count 枚以上デッキに残すパターン\n  Remains -> ado\n    pattern <- mkDrawPattern cards (sumBy _.count cards - count)\n    in cards <#> \\card -> do\n      let draw = maybe 0 _.draw $ find (_.card.id >>> (_ == card.id)) pattern\n      { card, min: 0, max: draw }\n  -- ちょうど count 枚デッキに残すパターン\n  JustRemains ->\n    mkConditionPattern (Condition { mode: JustDraw, count: (sumBy _.count cards - count), cards })\n  -- cards の中から count 種類以上を1枚以上引くパターン\n  Choice -> ado\n    pattern <- mkDrawPattern' cards [replicate count 1]\n    in pattern <#> \\p -> { card: p.card, min: 1, max: p.card.count }\n  -- cards の中から count 種類以上を1枚以上残すパターン\n  LeftOne -> ado\n    pattern <- mkDrawPattern' cards [replicate count 1]\n    in pattern <#> \\p -> { card: p.card, min: 0, max: p.card.count - 1 }\n  -- cards の中から count 種類以上を1枚も引かないパターン\n  LeftAll -> ado\n    pattern <- mkDrawPattern' cards [replicate count 0]\n    in pattern <#> \\p -> { card: p.card, min: 0, max: 0 }\n\n-- カードを指定枚数引く全ての組み合わせを列挙する\nmkDrawPattern :: Cards -> Int -> Array DrawPattern\nmkDrawPattern cards count = mkDrawPattern' cards $ partitionNumber count\n\n-- 指定の枚数パターンに合致するカードの組み合わせを全て列挙する\n-- 引数 pattern の各要素は予め降順にソートされている必要がある\nmkDrawPattern' :: Cards -> Combination Int -> Array DrawPattern\nmkDrawPattern' _ [] = []\nmkDrawPattern' _ [[]] = [[]]\nmkDrawPattern' cards pattern = do\n  let cardsLength = length cards\n  let cardCounts = sortBy (flip compare) $ _.count <$> cards\n  let pattern' = filter (length >>> (_ <= cardsLength) && and <<< zipWith (>=) cardCounts) pattern\n  let maxPatternLength = fromMaybe 0 <<< maximum $ length <$> pattern'\n  let cardCombinations = combinations <@> cards <$> 0 .. maxPatternLength\n  p <- pattern'\n  let con = fold $ cardCombinations !! length p\n  p' <- distinctPermutations p\n  filter (all \\d -> d.draw <= d.card.count) $ zipWith { draw: _, card: _ } p' <$> con\n\n----------------------------------------------------------------\n\nsumBy :: forall a m. Semiring m => (a -> m) -> Array a -> m\nsumBy = alaF Additive foldMap\n","module App.Result where\n\nimport Prelude\n\nimport App.Worker as Worker\nimport Control.Monad.Maybe.Trans (runMaybeT)\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.BigInt (BigInt)\nimport Data.BigInt as BigInt\nimport Data.Either (Either(..))\nimport Data.Foldable (traverse_)\nimport Data.Function (on)\nimport Data.Maybe (Maybe(..))\nimport Data.Number.Format as Format\nimport Effect.Aff (Aff, attempt, throwError)\nimport Halogen as H\nimport Halogen.HTML as HH\nimport Halogen.HTML.Properties as HP\nimport Halogen.Query.HalogenM (ForkId)\nimport TcgCalculator as TC\nimport TcgCalculator.Types (Condition, Deck)\nimport Util.Halogen as HU\n\n----------------------------------------------------------------\n\ndata Query a\n  = Calculate Deck (Array (NonEmptyArray Condition)) a\n\n----------------------------------------------------------------\n\ncomponent :: H.Component Query Unit Void Aff\ncomponent = H.mkComponent\n  { initialState\n  , render\n  , eval: H.mkEval H.defaultEval { handleQuery = runMaybeT <<< query }\n  }\n  where\n\n  initialState :: _ -> { combination :: BigInt, total :: BigInt, calculation :: Maybe ForkId }\n  initialState _ = { combination: zero, total: zero, calculation: Nothing }\n\n  render { combination, total, calculation } =\n    HH.div\n      [ HP.class_ $ H.ClassName \"flex min-w-60 items-center\" ]\n      [ HH.div\n          [ HP.class_ $ H.ClassName \"mx-1 flex w-36 items-center justify-end gap-1\" ]\n          case calculation of\n            Just _ ->\n              [ HH.div [ HP.class_ $ H.ClassName \"text-2xl\" ] [ HH.text \"Calculating\" ]\n              , HU.fa_ \"fa-spinner fa-pulse\"\n              ]\n            _ ->\n              [ HH.div\n                  [ HP.class_ $ H.ClassName \"text-2xl\" ]\n                  [ HH.text if total == zero\n                      then \"N/A\"\n                      else Format.toStringWith (Format.fixed 4) (100.0 * ((/) `on` BigInt.toNumber) combination total) <> \"%\"\n                  ]\n              ]\n      , HH.div\n          [ HP.class_ $ H.ClassName \"mx-1 flex min-w-20 flex-col items-end divide-y divide-gray-400\" ]\n          [ HH.div [ HP.class_ $ H.ClassName \"px-1\" ] [ HH.text $ BigInt.toString combination ]\n          , HH.div [ HP.class_ $ H.ClassName \"px-1\" ] [ HH.text $ BigInt.toString total ]\n          ]\n      ]\n\n  query :: _ ~> _\n  query = case _ of\n    Calculate deck conditions a -> H.lift do\n      newCalculation <- H.fork do\n        let deck' = TC.normalizeDeck deck conditions\n        result <- H.liftAff <<< attempt $ Worker.run { deck: deck', conditions }\n        case result of\n          Left error -> do\n            H.put { combination: zero, total: zero, calculation: Nothing }\n            throwError error\n          Right combination -> do\n            let total = TC.calculateTotal deck'\n            H.put { combination, total, calculation: Nothing }\n      currentCalculation <- H.gets _.calculation\n      H.modify_ _ { calculation = Just newCalculation }\n      traverse_ H.kill currentCalculation\n      pure a\n","module App.Condition where\n\nimport Prelude\n\nimport App.ConditionLine as ConditionLine\nimport App.Result as Result\nimport Control.Alternative (guard)\nimport Control.Monad.Maybe.Trans (MaybeT(..), runMaybeT)\nimport Data.Array as Array\nimport Data.Array.NonEmpty (NonEmptyArray)\nimport Data.Array.NonEmpty as NE\nimport Data.Foldable (for_)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Data.Traversable (for, traverse)\nimport Effect.Aff (Aff)\nimport Halogen as H\nimport Halogen.HTML as HH\nimport Halogen.HTML.Properties as HP\nimport Record as Record\nimport TcgCalculator.Types (Condition(..), ConditionMode, Deck, Id, generateId)\nimport Type.Proxy (Proxy(..))\nimport Util.Halogen as HU\n\n----------------------------------------------------------------\n\ntype Export =\n  { conditions :: Array { mode :: ConditionMode, count :: Int, cards :: Array Id, disabled :: Boolean }\n  , disabled :: Boolean\n  }\n\ndata Output\n  = Updated\n  | AllConditionDeleted\n\ndata Action\n  = Initialize\n  | AddCondition\n  | RemoveCondition Id\n  | ToggleItemDisabled Id\n  | Receive Deck\n  | Calculate\n\ndata Query a\n  = GetConditions (NonEmptyArray Condition -> a)\n  | GetState (Export -> a)\n  | RestoreState Deck Export a\n  | ToggleDisabled a\n\n----------------------------------------------------------------\n\ncomponent :: H.Component Query Deck Output Aff\ncomponent = H.mkComponent\n  { initialState\n  , render\n  , eval: H.mkEval $ H.defaultEval\n      { handleAction = action\n      , handleQuery = runMaybeT <<< query\n      , initialize = Just Initialize\n      , receive = Just <<< Receive\n      }\n  }\n  where\n\n  initialState :: _ -> { conditions :: Array { id :: Id, disabled :: Boolean }, deck :: Deck, disabled :: Boolean }\n  initialState = { conditions: [], deck: _, disabled: false }\n\n  render { conditions, deck, disabled } =\n    HH.div\n      [ HP.classes\n          [ H.ClassName \"grow rounded border-2 border-violet-300 p-1\"\n          , if disabled then H.ClassName \"bg-slate-100 text-gray-400\" else H.ClassName \"bg-white text-gray-700\"\n          ]\n      ]\n      [ renderConditionHeader disabled\n      , HH.ul\n          [ HP.class_ $ H.ClassName \"my-1\" ]\n          $ renderConditionLine deck.cards <$> conditions\n      , renderConditionAddButton\n      ]\n\n  renderConditionHeader disabled = do\n    HH.div\n      [ HP.class_ $ H.ClassName \"flex items-center justify-end gap-1\" ]\n      [ HH.div\n          [ HP.class_ if disabled then H.ClassName \"mr-auto w-0 py-1 pl-3 text-xl\" else H.ClassName \"hidden\" ]\n          [ HH.text \"Disabled\" ]\n      , HH.div\n          [ HP.class_ if disabled then H.ClassName \"text-gray-400\" else H.ClassName \"text-black\" ]\n          [ HH.slot_ (Proxy @\"result\") unit Result.component unit ]\n      ]\n\n  renderConditionLine cards { id, disabled } =\n    HH.li\n      [ HP.classes\n          [ H.ClassName \"flex gap-1 rounded px-1\"\n          , if disabled then H.ClassName \"bg-slate-100 text-gray-400 line-through\" else H.ClassName \"bg-transparent\"\n          ]\n      ]\n      [ HH.div\n          [ HP.class_ $ H.ClassName \"mx-1 flex\" ]\n          [ HU.removeButton (RemoveCondition id)\n          , HU.toggleButton (ToggleItemDisabled id)\n          ]\n      , HH.div\n          [ HP.class_ $ H.ClassName \"min-w-0 grow\" ]\n          [ HH.slot (Proxy @\"line\") id ConditionLine.component cards (const Calculate) ]\n      ]\n\n  renderConditionAddButton =\n    HH.div\n      [ HP.class_ $ H.ClassName \"px-1\" ]\n      [ HU.plusButton AddCondition ]\n\n  action = case _ of\n    Initialize -> do\n      action AddCondition\n      calculate\n    AddCondition -> do\n      conditions <- H.gets _.conditions\n      id <- generateId\n      H.modify_ _ { conditions = Array.snoc conditions { id, disabled: false } }\n    RemoveCondition id -> do\n      { conditions } <- H.modify do\n        conditions <- _.conditions\n        _ { conditions = Array.filter (_.id >>> (_ /= id)) conditions }\n      if Array.null conditions\n        then H.raise AllConditionDeleted\n        else action Calculate\n    ToggleItemDisabled id -> do\n      H.modify_ do\n        conditions <- _.conditions\n        fromMaybe identity do\n          i <- Array.findIndex (_.id >>> (_ == id)) conditions\n          conditions' <- Array.modifyAt i (\\s -> s { disabled = not s.disabled }) conditions\n          pure _ { conditions = conditions' }\n      action Calculate\n    Receive deck -> do\n      current <- H.gets _.deck\n      when (deck /= current) do\n        H.modify_ _ { deck = deck }\n        calculate\n    Calculate -> do\n      calculate\n      H.raise Updated\n\n  getConditions = ado\n    disabled <- map _.id <<< Array.filter _.disabled <$> H.gets _.conditions\n    conditions <- H.requestAll (Proxy @\"line\") ConditionLine.GetCondition\n    in NE.fromFoldable <<< Map.values <<< Map.filterKeys (Array.notElem <@> disabled) $ conditions\n\n  calculate = do\n    deck <- H.gets _.deck\n    conditions <- Array.fromFoldable <$> getConditions\n    H.tell (Proxy @\"result\") unit (Result.Calculate deck conditions)\n\n  query :: _ ~> _\n  query = case _ of\n    GetConditions reply -> ado\n      guard <<< not =<< H.gets _.disabled\n      conditions <- MaybeT getConditions\n      in reply conditions\n    GetState reply -> MaybeT ado\n      { conditions, disabled: parentDisabled } <- H.get\n      lines <- H.requestAll (Proxy @\"line\") ConditionLine.GetCondition\n      in ado\n        conditions' <- for conditions \\{ id, disabled } -> do\n          Map.lookup id lines <#> \\(Condition { mode, count, cards }) -> { mode, count, cards: cards <#> _.id, disabled }\n        in reply { conditions: conditions', disabled: parentDisabled }\n    RestoreState deck { conditions, disabled: parentDisabled } a -> H.lift do\n      conditions' <- traverse (flap $ Record.insert (Proxy @\"id\") <$> generateId) conditions\n      H.put { conditions: conditions' <#> \\{ id, disabled } -> { id, disabled }, deck, disabled: parentDisabled }\n      for_ conditions' \\{ id, mode, count, cards } -> do\n        let cards' = Array.mapMaybe <@> cards $ \\cardId -> Array.find (_.id >>> (_ == cardId)) deck.cards\n        H.tell (Proxy @\"line\") id (ConditionLine.RestoreState deck.cards (Condition { mode, count, cards: cards' }))\n      calculate\n      pure a\n    ToggleDisabled a -> do\n      H.modify_ do\n        disabled <- _.disabled\n        _ { disabled = not disabled }\n      pure a\n","const windowImpl = function () {\n  return window;\n};\nexport { windowImpl as window };\n","export function _documentElement(doc) {\n  return doc.documentElement;\n}\n\nexport function _head(doc) {\n  return doc.head;\n}\n\nexport function _body(doc) {\n  return doc.body;\n}\n\nexport function _readyState(doc) {\n  return doc.readyState;\n}\n\nexport function _visibilityState(doc) {\n  return doc.readyState;\n}\n\nexport function _activeElement(doc) {\n  return doc.activeElement;\n}\n\nexport function _currentScript(doc) {\n  return doc.currentScript;\n}\n\nexport function _referrer(doc) {\n  return doc.referrer;\n}\n\nexport function _title(doc) {\n  return doc.title;\n}\n\nexport function _setTitle(title, doc) {\n  doc.title = title;\n}\n","module Web.HTML.HTMLDocument.ReadyState where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..))\n\ndata ReadyState\n  = Loading\n  | Interactive\n  | Complete\n\nderive instance eqReadyState :: Eq ReadyState\nderive instance ordReadyState :: Ord ReadyState\n\ninstance showReadyState :: Show ReadyState where\n  show = case _ of\n    Loading -> \"Loading\"\n    Interactive -> \"Interactive\"\n    Complete -> \"Complete\"\n\nprint :: ReadyState -> String\nprint = case _ of\n  Loading -> \"loading\"\n  Interactive -> \"interactive\"\n  Complete -> \"complete\"\n\nparse :: String -> Maybe ReadyState\nparse = case _ of\n  \"loading\" -> Just Loading\n  \"interactive\" -> Just Interactive\n  \"complete\" -> Just Complete\n  _ -> Nothing\n","module Web.HTML.HTMLDocument\n  ( HTMLDocument\n  , fromDocument\n  , fromNode\n  , fromParentNode\n  , fromNonElementParentNode\n  , fromEventTarget\n  , toDocument\n  , toNode\n  , toParentNode\n  , toNonElementParentNode\n  , toEventTarget\n  , documentElement\n  , head\n  , body\n  , readyState\n  , visibilityState\n  , activeElement\n  , currentScript\n  , referrer\n  , title\n  , setTitle\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe, fromMaybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Effect.Uncurried (EffectFn1, EffectFn2, runEffectFn1, runEffectFn2)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Document (Document)\nimport Web.DOM.Internal.Types (Node)\nimport Web.DOM.NonElementParentNode (NonElementParentNode)\nimport Web.DOM.ParentNode (ParentNode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLDocument.ReadyState (ReadyState)\nimport Web.HTML.HTMLDocument.ReadyState as ReadyState\nimport Web.HTML.HTMLDocument.VisibilityState (VisibilityState)\nimport Web.HTML.HTMLDocument.VisibilityState as VisibilityState\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLHtmlElement (HTMLHtmlElement)\nimport Web.HTML.HTMLScriptElement (HTMLScriptElement)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data HTMLDocument :: Type\n\nfromDocument :: Document -> Maybe HTMLDocument\nfromDocument = unsafeReadProtoTagged \"HTMLDocument\"\n\nfromNode :: Node -> Maybe HTMLDocument\nfromNode = unsafeReadProtoTagged \"HTMLDocument\"\n\nfromParentNode :: ParentNode -> Maybe HTMLDocument\nfromParentNode = unsafeReadProtoTagged \"HTMLDocument\"\n\nfromNonElementParentNode :: NonElementParentNode -> Maybe HTMLDocument\nfromNonElementParentNode = unsafeReadProtoTagged \"HTMLDocument\"\n\nfromEventTarget :: EventTarget -> Maybe HTMLDocument\nfromEventTarget = unsafeReadProtoTagged \"HTMLDocument\"\n\ntoDocument :: HTMLDocument -> Document\ntoDocument = unsafeCoerce\n\ntoNode :: HTMLDocument -> Node\ntoNode = unsafeCoerce\n\ntoParentNode :: HTMLDocument -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoNonElementParentNode :: HTMLDocument -> NonElementParentNode\ntoNonElementParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLDocument -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import _documentElement :: EffectFn1 HTMLDocument (Nullable HTMLHtmlElement)\n\ndocumentElement :: HTMLDocument -> Effect (Maybe HTMLHtmlElement)\ndocumentElement doc = toMaybe <$> runEffectFn1 _documentElement doc\n\nforeign import _head :: EffectFn1 HTMLDocument (Nullable HTMLElement)\n\nhead :: HTMLDocument -> Effect (Maybe HTMLElement)\nhead doc = toMaybe <$> runEffectFn1 _head doc\n\nforeign import _body :: EffectFn1 HTMLDocument (Nullable HTMLElement)\n\nbody :: HTMLDocument -> Effect (Maybe HTMLElement)\nbody doc = toMaybe <$> runEffectFn1 _body doc\n\nforeign import _readyState :: EffectFn1 HTMLDocument String\n\nreadyState :: HTMLDocument -> Effect ReadyState\nreadyState doc = (fromMaybe ReadyState.Loading <<< ReadyState.parse) <$> (runEffectFn1 _readyState doc)\n\nforeign import _visibilityState :: EffectFn1 HTMLDocument String\n\nvisibilityState :: HTMLDocument -> Effect VisibilityState\nvisibilityState doc = (fromMaybe VisibilityState.Visible <<< VisibilityState.parse) <$> (runEffectFn1 _visibilityState doc)\n\nforeign import _activeElement :: EffectFn1 HTMLDocument (Nullable HTMLElement)\n\nactiveElement :: HTMLDocument -> Effect (Maybe HTMLElement)\nactiveElement doc = toMaybe <$> (runEffectFn1 _activeElement doc)\n\nforeign import _currentScript :: EffectFn1 HTMLDocument (Nullable HTMLScriptElement)\n\ncurrentScript :: HTMLDocument -> Effect (Maybe HTMLScriptElement)\ncurrentScript doc = toMaybe <$> (runEffectFn1 _currentScript doc)\n\nforeign import _referrer :: EffectFn1 HTMLDocument String\n\nreferrer :: HTMLDocument -> Effect String\nreferrer doc = runEffectFn1 _referrer doc\n\nforeign import _title :: EffectFn1 HTMLDocument String\n\ntitle :: HTMLDocument -> Effect String\ntitle doc = runEffectFn1 _title doc\n\nforeign import _setTitle :: EffectFn2 String HTMLDocument Unit\n\nsetTitle :: String -> HTMLDocument -> Effect Unit\nsetTitle newTitle doc = runEffectFn2 _setTitle newTitle doc\n","export function hash(location) {\n  return function () {\n    return location.hash;\n  };\n}\n\nexport function setHash(hash) {\n  return function (location) {\n    return function () {\n      location.hash = hash;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function host(location) {\n  return function () {\n    return location.host;\n  };\n}\n\nexport function setHost(host) {\n  return function (location) {\n    return function () {\n      location.host = host;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function hostname(location) {\n  return function () {\n    return location.hostname;\n  };\n}\n\nexport function setHostname(hostname) {\n  return function (location) {\n    return function () {\n      location.hostname = hostname;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function href(location) {\n  return function () {\n    return location.href;\n  };\n}\n\nexport function setHref(href) {\n  return function (location) {\n    return function () {\n      location.href = href;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function origin(location) {\n  return function () {\n    return location.origin;\n  };\n}\n\nexport function setOrigin(origin) {\n  return function (location) {\n    return function () {\n      location.origin = origin;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function pathname(location) {\n  return function () {\n    return location.pathname;\n  };\n}\n\nexport function setPathname(pathname) {\n  return function (location) {\n    return function () {\n      location.pathname = pathname;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function port(location) {\n  return function () {\n    return location.port;\n  };\n}\n\nexport function setPort(port) {\n  return function (location) {\n    return function () {\n      location.port = port;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function protocol(location) {\n  return function () {\n    return location.protocol;\n  };\n}\n\nexport function setProtocol(protocol) {\n  return function (location) {\n    return function () {\n      location.protocol = protocol;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function search(location) {\n  return function () {\n    return location.search;\n  };\n}\n\nexport function setSearch(search) {\n  return function (location) {\n    return function () {\n      location.search = search;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function assign(url) {\n  return function (location) {\n    return function () {\n      location.assign(url);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function replace(url) {\n  return function (location) {\n    return function () {\n      location.replace(url);\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function reload(location) {\n  return function () {\n    location.reload();\n  };\n}\n","export function document(window) {\n  return function () {\n    return window.document;\n  };\n}\n\nexport function navigator(window) {\n  return function () {\n    return window.navigator;\n  };\n}\n\nexport function location(window) {\n  return function () {\n    return window.location;\n  };\n}\n\nexport function history(window) {\n  return function() {\n    return window.history;\n  };\n}\n\nexport function innerWidth(window) {\n  return function () {\n    return window.innerWidth;\n  };\n}\n\nexport function innerHeight(window) {\n  return function () {\n    return window.innerHeight;\n  };\n}\n\nexport function alert(str) {\n  return function (window) {\n    return function () {\n      window.alert(str);\n    };\n  };\n}\n\nexport function confirm(str) {\n  return function (window) {\n    return function () {\n      return window.confirm(str);\n    };\n  };\n}\n\nexport function moveBy(xDelta) {\n  return function (yDelta) {\n    return function (window) {\n      return function () {\n        window.moveBy(xDelta, yDelta);\n      };\n    };\n  };\n}\n\nexport function moveTo(width) {\n  return function (height) {\n    return function (window) {\n      return function () {\n        window.moveTo(width, height);\n      };\n    };\n  };\n}\n\nexport function _open(url) {\n  return function (name) {\n    return function (features) {\n      return function (window) {\n        return function () {\n          return window.open(url, name, features);\n        };\n      };\n    };\n  };\n}\n\nexport function close(window) {\n  return function () {\n    return window.close();\n  };\n}\n\nexport function outerHeight(window) {\n  return function () {\n    return window.outerHeight;\n  };\n}\n\nexport function outerWidth(window) {\n  return function () {\n    return window.outerWidth;\n  };\n}\n\nexport function print(window) {\n  return function () {\n    window.print();\n  };\n}\n\nexport function _prompt(str) {\n  return function (defaultText) {\n    return function (window) {\n      return function () {\n        return window.prompt(str, defaultText);\n      };\n    };\n  };\n}\n\nexport function resizeBy(xDelta) {\n  return function (yDelta) {\n    return function (window) {\n      return function () {\n        window.resizeBy(xDelta, yDelta);\n      };\n    };\n  };\n}\n\nexport function resizeTo(width) {\n  return function (height) {\n    return function (window) {\n      return function () {\n        window.resizeTo(width, height);\n      };\n    };\n  };\n}\n\nexport function screenX(window) {\n  return function () {\n    return window.screenX;\n  };\n}\n\nexport function screenY(window) {\n  return function () {\n    return window.screenY;\n  };\n}\n\nexport function scroll(xCoord) {\n  return function (yCoord) {\n    return function (window) {\n      return function () {\n        window.scroll(xCoord, yCoord);\n      };\n    };\n  };\n}\n\nexport function scrollBy(xCoord) {\n  return function (yCoord) {\n    return function (window) {\n      return function () {\n        window.scrollBy(xCoord, yCoord);\n      };\n    };\n  };\n}\n\nexport function scrollX(window) {\n  return function () {\n    return window.scrollX;\n  };\n}\n\nexport function scrollY(window) {\n  return function () {\n    return window.scrollY;\n  };\n}\n\nexport function localStorage(window) {\n  return function () {\n    return window.localStorage;\n  };\n}\n\nexport function sessionStorage(window) {\n  return function () {\n    return window.sessionStorage;\n  };\n}\n\nexport function requestAnimationFrame(fn) {\n  return function(window) {\n    return function() {\n      return window.requestAnimationFrame(fn);\n    };\n  };\n}\n\nexport function cancelAnimationFrame(id) {\n  return function(window) {\n    return function() {\n      return window.cancelAnimationFrame(id);\n    };\n  };\n}\n\nexport function requestIdleCallback(opts) {\n  return function(fn) {\n    return function(window) {\n      return function() {\n        return window.requestIdleCallback(fn, opts);\n      };\n    };\n  };\n}\n\nexport function cancelIdleCallback(id) {\n  return function(window) {\n    return function() {\n      return window.cancelIdleCallback(id);\n    };\n  };\n}\n\nexport function parent(window) {\n  return function() {\n    return window.parent;\n  };\n}\n\nexport function _opener(window) {\n  return function() {\n    return window.opener;\n  };\n}\n","module Web.HTML.Window\n  ( Window\n  , toEventTarget\n  , fromEventTarget\n  , document\n  , navigator\n  , location\n  , history\n  , innerWidth\n  , innerHeight\n  , alert\n  , confirm\n  , moveBy\n  , moveTo\n  , open\n  , close\n  , outerHeight\n  , outerWidth\n  , print\n  , prompt\n  , promptDefault\n  , resizeBy\n  , resizeTo\n  , screenX\n  , screenY\n  , scroll\n  , scrollBy\n  , scrollX\n  , scrollY\n  , localStorage\n  , sessionStorage\n  , requestAnimationFrame\n  , cancelAnimationFrame\n  , RequestAnimationFrameId\n  , requestIdleCallback\n  , cancelIdleCallback\n  , RequestIdleCallbackId\n  , parent\n  , opener\n  ) where\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Prelude (class Eq, class Ord, Unit, (<$>))\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLDocument (HTMLDocument)\nimport Web.HTML.History (History)\nimport Web.HTML.Location (Location)\nimport Web.HTML.Navigator (Navigator)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\nimport Web.Storage.Storage (Storage)\n\nforeign import data Window :: Type\n\ntoEventTarget :: Window -> EventTarget\ntoEventTarget = unsafeCoerce\n\nfromEventTarget :: EventTarget -> Maybe Window\nfromEventTarget = unsafeReadProtoTagged \"Window\"\n\nforeign import document :: Window -> Effect HTMLDocument\n\nforeign import navigator :: Window -> Effect Navigator\n\nforeign import location :: Window -> Effect Location\n\nforeign import history :: Window -> Effect History\n\nforeign import innerWidth :: Window -> Effect Int\n\nforeign import innerHeight :: Window -> Effect Int\n\nforeign import alert :: String -> Window -> Effect Unit\n\nforeign import confirm :: String -> Window -> Effect Boolean\n\nforeign import moveBy :: Int -> Int -> Window -> Effect Unit\n\nforeign import moveTo :: Int -> Int -> Window -> Effect Unit\n\nopen :: String -> String -> String -> Window -> Effect (Maybe Window)\nopen url' name features window = toMaybe <$> _open url' name features window\n\nforeign import _open\n  :: String\n  -> String\n  -> String\n  -> Window\n  -> Effect (Nullable Window)\n\nforeign import close :: Window -> Effect Unit\n\nforeign import outerHeight :: Window -> Effect Int\n\nforeign import outerWidth :: Window -> Effect Int\n\nforeign import print :: Window -> Effect Unit\n\nprompt :: String -> Window -> Effect (Maybe String)\nprompt msg window = toMaybe <$> _prompt msg \"\" window\n\npromptDefault :: String -> String -> Window -> Effect (Maybe String)\npromptDefault msg defaultText window = toMaybe <$> _prompt msg defaultText window\n\nforeign import _prompt :: String -> String -> Window -> Effect (Nullable String)\n\nforeign import resizeBy :: Int -> Int -> Window -> Effect Unit\n\nforeign import resizeTo :: Int -> Int -> Window -> Effect Unit\n\nforeign import screenX :: Window -> Effect Int\n\nforeign import screenY :: Window -> Effect Int\n\nforeign import scroll :: Int -> Int -> Window -> Effect Unit\n\nforeign import scrollBy :: Int -> Int -> Window -> Effect Unit\n\nforeign import scrollX :: Window -> Effect Number\n\nforeign import scrollY :: Window -> Effect Number\n\nforeign import localStorage :: Window -> Effect Storage\n\nforeign import sessionStorage :: Window -> Effect Storage\n\nnewtype RequestAnimationFrameId = RequestAnimationFrameId Int\n\nderive instance eqRequestAnimationFrameId :: Eq RequestAnimationFrameId\nderive instance ordRequestAnimationFrameId :: Ord RequestAnimationFrameId\n\nforeign import requestAnimationFrame :: Effect Unit -> Window -> Effect RequestAnimationFrameId\n\nforeign import cancelAnimationFrame :: RequestAnimationFrameId -> Window -> Effect Unit\n\nnewtype RequestIdleCallbackId = RequestIdleCallbackId Int\n\nderive instance eqRequestIdleCallbackId :: Eq RequestIdleCallbackId\nderive instance ordRequestIdleCallbackId :: Ord RequestIdleCallbackId\n\n-- | Set timeout to `0` to get the same behaviour as when it is `undefined` in\n-- | [JavaScript](https://w3c.github.io/requestidlecallback/#h-the-requestidle-callback-method).\nforeign import requestIdleCallback :: { timeout :: Int } -> Effect Unit -> Window -> Effect RequestIdleCallbackId\n\nforeign import cancelIdleCallback :: RequestIdleCallbackId -> Window -> Effect Unit\n\nforeign import parent :: Window -> Effect Window\n\nforeign import _opener :: Window -> Effect (Nullable Window)\n\nopener :: Window -> Effect (Maybe Window)\nopener window = toMaybe <$> _opener window\n","export function _files(dataTransfer) {\n  return dataTransfer.files;\n}\n\nexport function items(dataTransfer) {\n  return dataTransfer.items;\n}\n\nexport function types(dataTransfer) {\n  return dataTransfer.types;\n}\n\nexport function _getData(format) {\n  return function (dataTransfer) {\n    return function () {\n      return dataTransfer.getData(format);\n    };\n  };\n}\n\nexport function _setData(format) {\n  return function (data) {\n    return function (dataTransfer) {\n      return function () {\n        return dataTransfer.setData(format, data);\n      };\n    };\n  };\n}\n\nexport function _setDragImage(dataTransfer) {\n  return function (image) {\n    return function (x) {\n      return function (y) {\n        return function () {\n          return dataTransfer.setDragImage(image, x, y);\n        };\n      };\n    };\n  };\n}\n\nexport function _dropEffect(dataTransfer) {\n  return function () {\n    return dataTransfer.dropEffect;\n  };\n}\n\nexport function _setDropEffect(e) {\n  return function (dataTransfer) {\n    return function () {\n      dataTransfer.dropEffect = e;\n    };\n  };\n}\n","module Web.HTML.Event.DataTransfer\n  ( DataTransfer\n  , files\n  , items\n  , types\n  , getData\n  , setData\n  , setDragImage\n  , DropEffect(..)\n  , dropEffect\n  , setDropEffect\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.MediaType (MediaType(..))\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Web.DOM.Element (Element)\nimport Web.File.FileList (FileList)\nimport Web.HTML.Event.DataTransfer.DataTransferItem (DataTransferItemList)\n\nforeign import data DataTransfer :: Type\n\n-- | Contains a list of all the local files available on the data transfer.\n-- | Empty if the drag operation doesn't involve dragging files.\n-- |\n-- | It's possible that a drag operation may have null files, instead of an\n-- | empty file list. In these cases Nothing is returned.\nfiles :: DataTransfer -> Maybe FileList\nfiles = toMaybe <$> _files\n\nforeign import _files :: DataTransfer -> Nullable FileList\n\n-- | Returns a `DataTransferItemList` object which is a list of all of the drag\n-- | data.\nforeign import items :: DataTransfer -> DataTransferItemList\n\n-- | Returns an array of data formats used in the drag operation.\n-- | If the drag operation included no data, then the array is empty.\nforeign import types :: DataTransfer -> Array String\n\nforeign import _getData\n  :: String\n  -> DataTransfer\n  -> Effect String\n\n-- | Retrieves the data for a given media type, or an empty string if data for\n-- | that type does not exist or the data transfer object contains no data.\ngetData :: MediaType -> DataTransfer -> Effect String\ngetData (MediaType format) dt = _getData format dt\n\nforeign import _setData\n  :: String\n  -> String\n  -> DataTransfer\n  -> Effect Unit\n\n-- | Sets the data transfer object's data for a given media format.\nsetData\n  :: MediaType\n  -> String\n  -> DataTransfer\n  -> Effect Unit\nsetData (MediaType format) dat dt = _setData format dat dt\n\nforeign import _setDragImage :: DataTransfer -> Element -> Int -> Int -> Effect Unit\n\n-- | Sets the image to be used for dragging if a custom one is desired.\n-- | The image will typically be an <image> but could be any other *visible* element.\n-- | The x and y coordinates define where the image appears relative to the mouse.\nsetDragImage :: DataTransfer -> Element -> Int -> Int -> Effect Unit\nsetDragImage = _setDragImage\n\nforeign import _dropEffect :: DataTransfer -> Effect String\n\ndata DropEffect = Copy | Link | Move | None\n\nderive instance eqDropEffect :: Eq DropEffect\nderive instance ordDropEffect :: Ord DropEffect\n\n-- | Gets the data transfer object's drop effect.\ndropEffect :: DataTransfer -> Effect DropEffect\ndropEffect dt =\n  _dropEffect dt <#> case _ of\n    \"copy\" -> Copy\n    \"link\" -> Link\n    \"move\" -> Move\n    \"none\" -> None\n    _ -> None\n\nforeign import _setDropEffect :: String -> DataTransfer -> Effect Unit\n\n-- | Sets the data transfer object's drop effect.\nsetDropEffect :: DropEffect -> DataTransfer -> Effect Unit\nsetDropEffect de = _setDropEffect case de of\n  Copy -> \"copy\"\n  Link -> \"link\"\n  Move -> \"move\"\n  None -> \"none\"\n","export function dataTransfer(e) {\n  return e.dataTransfer;\n}\n","module Web.HTML.Event.DragEvent where\n\nimport Data.Maybe (Maybe)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.Event.Event (Event)\nimport Web.HTML.Event.DataTransfer (DataTransfer)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nforeign import data DragEvent :: Type\n\nfromEvent :: Event -> Maybe DragEvent\nfromEvent = unsafeReadProtoTagged \"DragEvent\"\n\ntoEvent :: DragEvent -> Event\ntoEvent = unsafeCoerce\n\nforeign import dataTransfer :: DragEvent -> DataTransfer\n","module App.Deck where\n\nimport Prelude\n\nimport Control.Monad.Maybe.Trans (runMaybeT)\nimport Data.Array ((!!))\nimport Data.Array as Array\nimport Data.Foldable (fold, traverse_)\nimport Data.Function (on)\nimport Data.Int as Int\nimport Data.Maybe (fromMaybe)\nimport Data.MediaType (MediaType(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Newtype (alaF, collect)\nimport Data.String as String\nimport Effect.Aff (Aff)\nimport Halogen (RefLabel(..))\nimport Halogen as H\nimport Halogen.HTML as HH\nimport Halogen.HTML.Events as HE\nimport Halogen.HTML.Properties as HP\nimport TcgCalculator.Types (Card, Deck, Id, generateId)\nimport TcgCalculator.Types.Id as Id\nimport Util.Array as ArrayUtil\nimport Util.Halogen as HU\nimport Web.Event.Event as Event\nimport Web.HTML (window)\nimport Web.HTML.Event.DataTransfer as DataTransfer\nimport Web.HTML.Event.DragEvent as Drag\nimport Web.HTML.HTMLInputElement as Input\nimport Web.HTML.Window (confirm)\nimport Web.UIEvent.FocusEvent as Focus\n\n----------------------------------------------------------------\n\ntype Index = Int\n\ntype Output = Deck\n\ndata Action\n  = AddCard\n  | RemoveCard Card\n  | UpdateCard Card\n  | UpdateDeck Int\n  | UpdateHand Int\n  | UpdateOthers Int\n  | SelectOnFocus Focus.FocusEvent\n  | StartReorder Id Drag.DragEvent\n  | HandleDragBehavior Drag.DragEvent\n  | ExecuteReorder Id Drag.DragEvent\n\ndata Query a\n  = SetDeck Deck a\n\n----------------------------------------------------------------\n\ncomponent :: H.Component Query Unit Output Aff\ncomponent = H.mkComponent\n  { initialState\n  , render\n  , eval: H.mkEval $ H.defaultEval { handleAction = action, handleQuery = runMaybeT <<< query }\n  }\n  where\n\n  initialState :: _ -> Deck\n  initialState _ = { cards: [], others: 40, hand: 5 }\n\n  render { cards, others, hand } = do\n    let cardCount = countCards cards\n    let deckCount = cardCount + others\n    HH.div\n      [ HP.class_ $ H.ClassName \"rounded border-2 border-amber-500 p-1\" ]\n      [ renderHeader deckCount hand cardCount\n      , renderCardList others cards\n      , renderFooter others cardCount\n      ]\n\n  renderHeader deckCount handCount cardCount =\n    HH.div\n      [ HP.class_ $ H.ClassName \"flex items-baseline gap-1\" ]\n      [ HH.div\n          [ HP.class_ $ H.ClassName \"mx-1 flex grow flex-wrap items-baseline text-sky-900\" ]\n          [ HU.fa \"fa-layer-group\" [ H.ClassName \"m-1 text-2xl\" ]\n          , HH.div [ HP.class_ $ H.ClassName \"m-1\" ] [ HH.text \"デッキ情報\" ]\n          ]\n      , renderIntegerInput \"手札枚数:\" handCount 1 deckCount UpdateHand\n      , renderIntegerInput \"デッキ枚数:\" deckCount cardCount deckLimit UpdateDeck\n      ]\n\n  renderCardList others cards =\n    HH.ul\n      [ HP.class_ $ H.ClassName \"m-1\"\n      , HE.onDragEnter HandleDragBehavior\n      , HE.onDragOver HandleDragBehavior\n      ]\n      $ renderCard others <$> cards\n\n  renderCard others card =\n    HH.li\n      [ HP.class_ $ H.ClassName \"flex\"\n      , HP.ref $ H.RefLabel (Id.toString card.id)\n      , HE.onDrop $ ExecuteReorder card.id\n      ]\n      [ HH.div\n          [ HP.class_ $ H.ClassName \"mx-1 flex items-center\" ]\n          [ HH.div\n              [ HP.class_ $ H.ClassName \"hidden cursor-grab px-1 text-gray-500 active:cursor-grabbing md:block\"\n              , HP.draggable true\n              , HE.onDragStart $ StartReorder card.id\n              ]\n              [ HU.fa_ \"fa-grip-vertical\" ]\n          , HU.removeButton $ RemoveCard card\n          ]\n      , HH.div\n          [ HP.class_ $ H.ClassName \"flex grow border-b border-gray-500\" ]\n          [ HH.input\n              [ HP.classes [ H.ClassName \"grow\", styleFormInput ]\n              , HP.type_ HP.InputText\n              , HP.value card.name\n              , HE.onValueChange $ UpdateCard <<< card { name = _ }\n              ]\n          , HH.input\n              [ HP.class_ styleFormNumber\n              , HP.type_ HP.InputNumber\n              , HP.step $ HP.Step 1.0\n              , HP.value $ show card.count\n              , HP.min 0.0\n              , HP.max if String.null card.name then 0.0 else Int.toNumber (card.count + others)\n              , HE.onFocus SelectOnFocus\n              , HE.onValueChange $ UpdateCard <<< card { count = _ } <<< fromMaybe 0 <<< Int.fromString\n              ]\n          ]\n      ]\n\n  renderFooter otherCount cardCount =\n    HH.div\n      [ HP.class_ $ H.ClassName \"flex items-baseline gap-1\" ]\n      [ HH.div\n          [ HP.class_ $ H.ClassName \"mx-1 grow\" ]\n          [ HU.plusButton AddCard ]\n      , renderIntegerInput \"その他のカード:\" otherCount 0 (deckLimit - cardCount) UpdateOthers\n      ]\n\n  renderIntegerInput text count min max h =\n    HH.div\n      [ HP.class_ $ H.ClassName \"mx-1 flex flex-wrap items-baseline justify-end border-b border-gray-500\" ]\n      [ HH.div [ HP.class_ $ H.ClassName \"m-1\" ] [ HH.text text ]\n      , HH.input\n          [ HP.class_ styleFormNumber\n          , HP.type_ HP.InputNumber\n          , HP.value $ show count\n          , HP.step $ HP.Step 1.0\n          , HP.min $ Int.toNumber min\n          , HP.max $ Int.toNumber max\n          , HE.onFocus SelectOnFocus\n          , HE.onValueChange $ h <<< fromMaybe 0 <<< Int.fromString\n          ]\n      ]\n\n  styleFormNumber = collect H.ClassName (String.joinWith \" \")\n    [ H.ClassName \"w-16 text-right\"\n    , styleFormInput\n    ]\n\n  styleFormInput = collect H.ClassName (String.joinWith \" \")\n    [ H.ClassName \"appearance-none border-b border-transparent bg-white p-1 text-gray-700\"\n    , H.ClassName \"transition-colors duration-75 hover:border-gray-500 focus:border-slate-800 focus:outline-none\"\n    ]\n\n  action = case _ of\n    AddCard -> do\n      id <- generateId\n      H.modify_ do\n        cards <- _.cards\n        _ { cards = Array.snoc cards { id, name: \"\", count: 0 } }\n    RemoveCard card -> void $ H.fork do\n      whenM (if String.null card.name then pure true else H.liftEffect $ confirm (\"カード「\" <> card.name <> \"」を削除します。\") =<< window) do\n        { cards, others } <- H.get\n        let cards' = Array.deleteBy ((==) `on` _.id) card cards\n        raiseUpdated =<< H.modify _ { cards = cards', others = others + card.count }\n    UpdateCard card -> do\n      { cards, others } <- H.get\n      fold do\n        i <- Array.findIndex (_.id >>> (_ == card.id)) cards\n        old <- cards !! i\n        let new = if String.null card.name then card { count = 0 } else card { count = clamp 0 (old.count + others) card.count }\n        cards' <- Array.updateAt i new cards\n        pure $ raiseUpdated =<< H.modify _ { cards = cards', others = others - (new.count - old.count) }\n    UpdateDeck total -> do\n      cards <- H.gets _.cards\n      let cardCount = countCards cards\n      action $ UpdateOthers (total - cardCount)\n    UpdateHand hand -> do\n      raiseUpdated =<< H.modify do\n        { cards, others } <- identity\n        let deckCount = countCards cards + others\n        _ { hand = clamp 1 deckCount hand }\n    UpdateOthers others -> do\n      raiseUpdated =<< H.modify do\n        { cards, hand } <- identity\n        let cardCount = countCards cards\n        let deckCount = clamp cardCount deckLimit (cardCount + others)\n        _ { others = deckCount - cardCount, hand = min hand deckCount }\n    SelectOnFocus event -> do\n      let element = Input.fromEventTarget <=< Event.target <<< Focus.toEvent $ event\n      H.liftEffect $ traverse_ Input.select element\n    StartReorder id event -> do\n      let transfer = Drag.dataTransfer event\n      H.liftEffect $ DataTransfer.setData (MediaType dragItemMediaType) (Id.toString id) transfer\n      elem <- H.getRef $ RefLabel (Id.toString id)\n      H.liftEffect $ elem # traverse_ \\e -> do\n        DataTransfer.setDragImage transfer e 5 15\n    HandleDragBehavior event -> do\n      let transfer = Drag.dataTransfer event\n      when (DataTransfer.types transfer == [dragItemMediaType]) do\n        H.liftEffect <<< Event.preventDefault $ Drag.toEvent event\n    ExecuteReorder destination event -> do\n      let transfer = Drag.dataTransfer event\n      id <- H.liftEffect $ DataTransfer.getData (MediaType dragItemMediaType) transfer\n      unless (String.null id) do\n        raiseUpdated =<< H.modify do\n          cards <- _.cards\n          let cards' = fold do\n                target <- Id.fromString id\n                from <- Array.findIndex (_.id >>> (_ == target)) cards\n                to <- Array.findIndex (_.id >>> (_ == destination)) cards\n                pure $ ArrayUtil.shiftInsert from to cards\n          _ { cards = cards' }\n        H.liftEffect <<< Event.preventDefault $ Drag.toEvent event\n\n  dragItemMediaType = \"tcg-calculator/card\"\n\n  raiseUpdated deck =\n    H.raise deck { cards = Array.filter (_.name >>> not String.null) deck.cards }\n\n  countCards = alaF Additive Array.foldMap _.count\n\n  deckLimit = 255\n\n  query :: _ ~> _\n  query = case _ of\n    SetDeck deck a -> do\n      H.put deck\n      pure a\n","export function _jsonParser(fail, succ, s) {\n  try {\n    return succ(JSON.parse(s));\n  }\n  catch (e) {\n    return fail(e.message);\n  }\n}\n","module Data.Argonaut.Parser (jsonParser) where\n\nimport Data.Argonaut.Core (Json)\nimport Data.Either (Either(..))\nimport Data.Function.Uncurried (Fn3, runFn3)\n\nforeign import _jsonParser :: forall a. Fn3 (String -> a) (Json -> a) String a\n\n-- | Parse a JSON string, constructing the `Json` value described by the string.\n-- | To convert a string into a `Json` string, see `fromString`.\njsonParser :: String -> Either String Json\njsonParser j = runFn3 _jsonParser Left Right j\n","module Data.Argonaut.Decode.Parser where\n\nimport Prelude\n\nimport Data.Argonaut.Core (Json)\nimport Data.Argonaut.Decode.Error (JsonDecodeError(..))\nimport Data.Argonaut.Parser (jsonParser)\nimport Data.Bifunctor (lmap)\nimport Data.Either (Either)\n\n-- | Attempt to parse a string as `Json`, failing with a typed error if the\n-- | JSON string is malformed.\nparseJson :: String -> Either JsonDecodeError Json\nparseJson = lmap (\\_ -> TypeMismatch \"JSON\") <<< jsonParser\n","export const log = function (s) {\n  return function () {\n    console.log(s);\n  };\n};\n\nexport const warn = function (s) {\n  return function () {\n    console.warn(s);\n  };\n};\n\nexport const error = function (s) {\n  return function () {\n    console.error(s);\n  };\n};\n\nexport const info = function (s) {\n  return function () {\n    console.info(s);\n  };\n};\n\nexport const debug = function (s) {\n  return function () {\n    console.debug(s);\n  };\n};\n\nexport const time = function (s) {\n  return function () {\n    console.time(s);\n  };\n};\n\nexport const timeLog = function (s) {\n  return function () {\n    console.timeLog(s);\n  };\n};\n\nexport const timeEnd = function (s) {\n  return function () {\n    console.timeEnd(s);\n  };\n};\n\nexport const clear = function () {\n  console.clear();\n};\n\nexport const group = function (s) {\n  return function () {\n    console.group(s);\n  };\n};\n\nexport const groupCollapsed = function (s) {\n  return function () {\n    console.groupCollapsed(s);\n  };\n};\n\nexport const groupEnd = function () {\n  console.groupEnd();\n};\n","module Effect.Class.Console where\n\nimport Control.Bind (discard, bind, pure)\nimport Data.Function ((<<<))\nimport Data.Show (class Show)\nimport Data.Unit (Unit)\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Console as EffConsole\n\nlog :: forall m. MonadEffect m => String -> m Unit\nlog = liftEffect <<< EffConsole.log\n\nlogShow :: forall m a. MonadEffect m => Show a => a -> m Unit\nlogShow = liftEffect <<< EffConsole.logShow\n\nwarn :: forall m. MonadEffect m => String -> m Unit\nwarn = liftEffect <<< EffConsole.warn\n\nwarnShow :: forall m a. MonadEffect m => Show a => a -> m Unit\nwarnShow = liftEffect <<< EffConsole.warnShow\n\nerror :: forall m. MonadEffect m => String -> m Unit\nerror = liftEffect <<< EffConsole.error\n\nerrorShow :: forall m a. MonadEffect m => Show a => a -> m Unit\nerrorShow = liftEffect <<< EffConsole.errorShow\n\ninfo :: forall m. MonadEffect m => String -> m Unit\ninfo = liftEffect <<< EffConsole.info\n\ninfoShow :: forall m a. MonadEffect m => Show a => a -> m Unit\ninfoShow = liftEffect <<< EffConsole.infoShow\n\ndebug :: forall m. MonadEffect m => String -> m Unit\ndebug = liftEffect <<< EffConsole.debug\n\ndebugShow :: forall m a. MonadEffect m => Show a => a -> m Unit\ndebugShow = liftEffect <<< EffConsole.debugShow\n\ntime :: forall m. MonadEffect m => String -> m Unit\ntime = liftEffect <<< EffConsole.time\n\ntimeLog :: forall m. MonadEffect m => String -> m Unit\ntimeLog = liftEffect <<< EffConsole.timeLog\n\ntimeEnd :: forall m. MonadEffect m => String -> m Unit\ntimeEnd = liftEffect <<< EffConsole.timeEnd\n\nclear :: forall m. MonadEffect m => m Unit\nclear = liftEffect EffConsole.clear\n\ngroup :: forall m. MonadEffect m => String -> m Unit\ngroup = liftEffect <<< EffConsole.group\n\ngroupCollapsed :: forall m. MonadEffect m => String -> m Unit\ngroupCollapsed = liftEffect <<< EffConsole.groupCollapsed\n\ngroupEnd :: forall m. MonadEffect m => m Unit\ngroupEnd = liftEffect EffConsole.groupEnd\n\ngrouped :: forall m a. MonadEffect m => String -> m a -> m a\ngrouped name inner = do\n  group name\n  result <- inner\n  groupEnd\n  pure result\n","// A helper which transforms the result of encodeURIComponent to be compliant\n// with RFC3986, as described in the MDN documentation here:\n//\n// https://web.archive.org/web/20201206001047/https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\nfunction encodeURIComponent_to_RFC3986(input) {\n  return input.replace(/[!'()*]/g, function (c) {\n    return \"%\" + c.charCodeAt(0).toString(16);\n  });\n}\n\n// A helper which transforms the result of encodeURI to be compliant\n// with RFC3986, as described in the MDN documentation here:\n//\n// https://web.archive.org/web/20210117175449/https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI#encoding_for_ipv6\nfunction encodeURI_to_RFC3986(input) {\n  return input.replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n}\n\nexport function _encodeURIComponent(fail, succeed, input) {\n  try {\n    return succeed(encodeURIComponent_to_RFC3986(encodeURIComponent(input)));\n  } catch (err) {\n    return fail(err);\n  }\n}\n\nexport function _encodeFormURLComponent(fail, succeed, input) {\n  try {\n    return succeed(encodeURIComponent_to_RFC3986(encodeURIComponent(input)).replace(/%20/g, \"+\"));\n  } catch (err) {\n    return fail(err);\n  }\n}\n\nexport function _decodeURIComponent(fail, succeed, input) {\n  try {\n    return succeed(decodeURIComponent(input));\n  } catch (err) {\n    return fail(err);\n  }\n}\n\nexport function _decodeFormURLComponent(fail, succeed, input) {\n  return _decodeURIComponent(fail, succeed, input.replace(/\\+/g, \" \"));\n}\n\nexport function _encodeURI(fail, succeed, input) {\n  try {\n    return succeed(encodeURI_to_RFC3986(encodeURI(input)));\n  } catch (err) {\n    return fail(err);\n  }\n}\n\nexport function _decodeURI(fail, succeed, input) {\n  try {\n    return succeed(decodeURI(input));\n  } catch (err) {\n    return fail(err);\n  }\n}\n","module JSURI\n  ( encodeURIComponent\n  , encodeFormURLComponent\n  , encodeURI\n  , decodeURIComponent\n  , decodeFormURLComponent\n  , decodeURI\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..))\n\nforeign import _encodeURIComponent :: Fn3 (String -> Maybe String) (String -> Maybe String) String (Maybe String)\n\n-- | URI-encode a string according to RFC3896. Implemented using JavaScript's\n-- | `encodeURIComponent`.\n-- |\n-- | ```purs\n-- | > encodeURIComponent \"https://purescript.org\"\n-- | Just \"https%3A%2F%2Fpurescript.org\"\n-- | ```\n-- |\n-- | Encoding a URI can fail with a `URIError` if the string contains malformed\n-- | characters. If you are confident you are encoding a well-formed string then\n-- | you can run this function unsafely:\n-- |\n-- | ```purs\n-- | import Partial.Unsafe (unsafePartial)\n-- | import Data.Maybe (fromJust)\n-- |\n-- | unsafeEncode :: String -> String\n-- | unsafeEncode str = unsafePartial $ fromJust $ encodeURIComponent str\n-- | ```\nencodeURIComponent :: String -> Maybe String\nencodeURIComponent = runFn3 _encodeURIComponent (const Nothing) Just\n\nforeign import _encodeFormURLComponent :: Fn3 (String -> Maybe String) (String -> Maybe String) String (Maybe String)\n\n-- | URI-encode a string according to RFC3896, except with spaces encoded using\n-- | '+' instead of '%20' to comply with application/x-www-form-urlencoded.\n-- |\n-- | ```purs\n-- | > encodeURIComponent \"abc ABC\"\n-- | Just \"abc%20ABC\"\n-- |\n-- | > encodeFormURLComponent \"abc ABC\"\n-- | Just \"abc+ABC\"\n-- | ```\nencodeFormURLComponent :: String -> Maybe String\nencodeFormURLComponent = runFn3 _encodeFormURLComponent (const Nothing) Just\n\nforeign import _decodeURIComponent :: Fn3 (String -> Maybe String) (String -> Maybe String) String (Maybe String)\n\n-- | Decode a URI string according to RFC3896. Implemented using JavaScript's\n-- | `decodeURIComponent`.\n-- |\n-- | ```purs\n-- | > decodeURIComponent \"https%3A%2F%2Fpurescript.org\"\n-- | Just \"https://purescript.org\"\n-- | ```\n-- |\n-- | Decoding a URI can fail with a `URIError` if the string contains malformed\n-- | characters. If you are confident you are encoding a well-formed string then\n-- | you can run this function unsafely:\n-- |\n-- | ```purs\n-- | import Partial.Unsafe (unsafePartial)\n-- | import Data.Maybe (fromJust)\n-- |\n-- | unsafeDecode :: String -> String\n-- | unsafeDecode str = unsafePartial $ fromJust $ decodeURIComponent str\n-- | ```\ndecodeURIComponent :: String -> Maybe String\ndecodeURIComponent = runFn3 _decodeURIComponent (const Nothing) Just\n\nforeign import _decodeFormURLComponent :: Fn3 (String -> Maybe String) (String -> Maybe String) String (Maybe String)\n\n-- | Decode a URI according to application/x-www-form-urlencoded (for example,\n-- | a string containing '+' for spaces or query parameters).\n-- |\n-- | ```purs\n-- | > decodeURIComponent \"https%3A%2F%2Fpurescript.org?search+query\"\n-- | Just \"https://purescript.org?search+query\"\n-- |\n-- | > decodeFormURLComponent \"https%3A%2F%2Fpurescript.org?search+query\"\n-- | Just \"https://purescript.org?search query\"\n-- | ```\ndecodeFormURLComponent :: String -> Maybe String\ndecodeFormURLComponent = runFn3 _decodeFormURLComponent (const Nothing) Just\n\nforeign import _encodeURI :: Fn3 (String -> Maybe String) (String -> Maybe String) String (Maybe String)\n\nencodeURI :: String -> Maybe String\nencodeURI = runFn3 _encodeURI (const Nothing) Just\n\nforeign import _decodeURI :: Fn3 (String -> Maybe String) (String -> Maybe String) String (Maybe String)\n\ndecodeURI :: String -> Maybe String\ndecodeURI = runFn3 _decodeURI (const Nothing) Just\n","module Web.HTML.Event.HashChangeEvent.EventTypes where\n\nimport Web.Event.Event (EventType(..))\n\nhashchange :: EventType\nhashchange = EventType \"hashchange\"\n","module Routing.Hash\n  ( getHash\n  , setHash\n  , modifyHash\n  , foldHashes\n  , hashes\n  , matches\n  , matchesWith\n  , module Routing\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable, indexl)\nimport Data.Maybe (Maybe(..), fromMaybe, maybe)\nimport Data.String (Pattern(..), stripPrefix)\nimport Effect (Effect)\nimport Effect.Ref as Ref\nimport Routing (match, matchWith)\nimport Routing.Match (Match)\nimport Web.Event.EventTarget (addEventListener, eventListener, removeEventListener)\nimport Web.HTML (window)\nimport Web.HTML.Event.HashChangeEvent.EventTypes as ET\nimport Web.HTML.Location as L\nimport Web.HTML.Window as Window\n\n-- | Gets the global location hash.\ngetHash :: Effect String\ngetHash = window >>= Window.location >>= L.hash >>> map (stripPrefix (Pattern \"#\") >>> fromMaybe \"\")\n\n-- | Sets the global location hash.\nsetHash :: String -> Effect Unit\nsetHash h = window >>= Window.location >>= L.setHash h\n\n-- | Modifies the global location hash.\nmodifyHash :: (String -> String) -> Effect Unit\nmodifyHash fn = (fn <$> getHash) >>= setHash\n\n-- | Folds effectfully over hash changes given a callback and an initial hash.\n-- | The provided String is the hash portion of the `Location` with the '#'\n-- | prefix stripped. Returns an effect which will remove the listener.\nfoldHashes\n  :: forall a\n   . (a -> String -> Effect a)\n  -> (String -> Effect a)\n  -> Effect (Effect Unit)\nfoldHashes cb init = do\n  ref <- Ref.new =<< init =<< getHash\n  win <- Window.toEventTarget <$> window\n  listener <- eventListener \\_ -> flip Ref.write ref =<< join (cb <$> Ref.read ref <*> getHash)\n  addEventListener ET.hashchange listener false win\n  pure $ removeEventListener ET.hashchange listener false win\n\n-- | Runs the callback on every hash change providing the previous hash and the\n-- | latest hash. The provided String is the hash portion of the `Location` with\n-- | the '#' prefix stripped. Returns an effect which will remove the listener.\nhashes :: (Maybe String -> String -> Effect Unit) -> Effect (Effect Unit)\nhashes = matchesWith Just\n\n-- | Runs the callback on every hash change using a given `Match` parser to\n-- | extract a route from the hash. If a hash fails to parse, it is ignored.\n-- | To avoid dropping hashes, provide a fallback alternative in your parser.\n-- | Returns an effect which will remove the listener.\nmatches\n  :: forall a\n   . Match a\n  -> (Maybe a -> a -> Effect Unit)\n  -> Effect (Effect Unit)\nmatches = matchesWith <<< match\n\n-- | Runs the callback on every hash change using a given custom parser to\n-- | extract a route from the hash. If a hash fails to parse, it is ignored.\n-- | To avoid dropping hashes, provide a fallback alternative in your parser.\n-- | Returns an effect which will remove the listener.\nmatchesWith\n  :: forall f a\n   . Foldable f\n  => (String -> f a)\n  -> (Maybe a -> a -> Effect Unit)\n  -> Effect (Effect Unit)\nmatchesWith parser cb = foldHashes go (go Nothing)\n  where\n  go a =\n    maybe (pure a) (\\b -> Just b <$ cb a b)\n      <<< indexl 0\n      <<< parser\n","module App.App where\n\nimport Prelude\n\nimport App.Condition as Condition\nimport App.Deck as Deck\nimport App.Result as Result\nimport Data.Argonaut.Core (stringify)\nimport Data.Argonaut.Decode (decodeJson, parseJson, printJsonDecodeError)\nimport Data.Argonaut.Encode (encodeJson)\nimport Data.Array as Array\nimport Data.Const (Const)\nimport Data.Either (Either(..))\nimport Data.Foldable (for_)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Data.String as String\nimport Data.Traversable (traverse)\nimport Effect.Aff (Aff)\nimport Effect.Class.Console as Console\nimport Halogen as H\nimport Halogen.HTML as HH\nimport Halogen.HTML.Properties as HP\nimport Halogen.Subscription as HS\nimport JSURI (decodeURIComponent)\nimport Routing.Hash as Hash\nimport TcgCalculator.Types (Deck, Id, generateId)\nimport Type.Proxy (Proxy(..))\nimport Util.Array as ArrayUtil\nimport Util.Halogen as HU\n\n----------------------------------------------------------------\n\ntype Export = { deck :: Deck, conditions :: Array Condition.Export }\n\ntype Index = Int\n\ndata Action\n  = Initialize\n  | PrepareDefaultState\n  | UpdateDeck Deck\n  | AddCondition\n  | RemoveCondition Id\n  | ToggleDisabled Id\n  | Swap Index Index\n  | ReceiveConditionUpdated Id Condition.Output\n  | Calculate\n  | RestoreState String\n  | SaveState\n\n----------------------------------------------------------------\n\ncomponent :: H.Component (Const Void) Unit Void Aff\ncomponent = H.mkComponent\n  { initialState\n  , render\n  , eval: H.mkEval H.defaultEval { handleAction = action, initialize = Just Initialize }\n  }\n  where\n\n  initialState :: _ -> { deck :: Deck, conditions :: Array Id }\n  initialState _ = { deck: { cards: [], others: 0, hand: 0 }, conditions: [] }\n\n  render { deck, conditions } =\n    HH.div\n      [ HP.class_ $ H.ClassName \"relative overflow-x-clip\" ]\n      [ HH.header\n          [ HP.class_ $ H.ClassName \"flex items-baseline px-2\" ]\n          [ HH.h1\n              [ HP.class_ $ H.ClassName \"p-1 text-lg\" ]\n              [ HH.a [ HP.href \".\" ] [ HH.text \"Draw Calculator\" ] ]\n          , HH.text \"-\"\n          , HH.h2\n              [ HP.class_ $ H.ClassName \"p-1\" ]\n              [ HH.text \"TCG 用ドロー確率計算機\" ]\n          ]\n      , HH.main\n          [ HP.class_ $ H.ClassName \"relative mb-[80vh] flex max-w-4xl flex-col gap-3 p-1\" ]\n          [ HH.div\n              [ HP.class_ $ H.ClassName \"flex flex-wrap gap-1\" ]\n              [ renderDeck\n              , renderResult\n              ]\n          , HH.ul\n              [ HP.class_ $ H.ClassName \"flex flex-col gap-1\" ]\n              $ Array.mapWithIndex (renderCondition deck) conditions\n          , renderConditionAddButton\n          ]\n      , HH.footer\n          [ HP.class_ $ H.ClassName \"flex items-baseline px-2\" ]\n          [ HH.a\n              [ HP.class_ $ H.ClassName \"m-1 rounded border border-sky-500 px-2 py-1 text-sm\"\n              , HP.href \"https://github.com/acple/tcg-calculator\", HP.target \"_blank\", HP.rel \"noopener noreferrer\"\n              ]\n              [ HH.text \"→ 使い方とかソース\" ]\n          ]\n      ]\n\n  renderDeck =\n    HH.div\n      [ HP.class_ $ H.ClassName \"grow\" ]\n      [ HH.slot (Proxy @\"deck\") unit Deck.component unit UpdateDeck ]\n\n  renderResult =\n    HH.div\n      [ HP.class_ $ H.ClassName \"flex grow basis-0 items-center rounded border-2 border-cyan-400 p-1\" ]\n      [ HH.div\n          [ HP.class_ $ H.ClassName \"flex w-full justify-end gap-3\" ]\n          [ HH.div_ [ HU.button (HH.text \"Save\") (H.ClassName \"border border-rose-500 hover:bg-rose-100\") SaveState ]\n          , HH.slot_ (Proxy @\"result\") unit Result.component unit\n          ]\n      ]\n\n  renderCondition deck i id =\n    HH.li\n      [ HP.class_ $ H.ClassName \"flex items-start gap-1\" ]\n      [ HH.div\n          [ HP.class_ $ H.ClassName \"flex flex-col\" ]\n          [ HU.upButton (Swap (i - 1) i)\n          , HU.removeButton (RemoveCondition id)\n          , HU.toggleButton (ToggleDisabled id)\n          , HU.downButton (Swap i (i + 1))\n          ]\n      , HH.slot (Proxy @\"condition\") id Condition.component deck (ReceiveConditionUpdated id)\n      ]\n\n  renderConditionAddButton =\n    HH.div_\n      [ HU.plusButton AddCondition ]\n\n  action = case _ of\n    Initialize -> do\n      { emitter, listener } <- H.liftEffect HS.create\n      _ <- H.subscribe emitter\n      void <<< H.liftEffect $ Hash.matchesWith decodeURIComponent \\_ hash -> do\n        HS.notify listener if String.null hash\n          then PrepareDefaultState\n          else RestoreState hash\n    PrepareDefaultState -> do\n      { deck, conditions } <- H.get\n      when (Array.null deck.cards && Array.null conditions) do\n        id <- generateId\n        let defaultDeck = { cards: [{ id, name: \"Card1\", count: 3 }], others: 37, hand: 5 }\n        H.modify_ _ { deck = defaultDeck }\n        H.tell (Proxy @\"deck\") unit (Deck.SetDeck defaultDeck)\n        action AddCondition\n    UpdateDeck deck -> do\n      current <- H.gets _.deck\n      when (deck /= current) do\n        H.modify_ _ { deck = deck }\n        action Calculate\n    AddCondition -> do\n      id <- generateId\n      H.modify_ do\n        conditions <- _.conditions\n        _ { conditions = Array.snoc conditions id }\n      action Calculate\n    RemoveCondition id -> do\n      H.modify_ do\n        conditions <- _.conditions\n        _ { conditions = Array.filter (_ /= id) conditions }\n      action Calculate\n    ToggleDisabled id -> do\n      H.tell (Proxy @\"condition\") id Condition.ToggleDisabled\n      action Calculate\n    Swap x y -> do\n      H.modify_ do\n        conditions <- _.conditions\n        _ { conditions = ArrayUtil.swap x y conditions }\n    ReceiveConditionUpdated _ Condition.Updated -> do\n      action Calculate\n    ReceiveConditionUpdated id Condition.AllConditionDeleted -> do\n      action $ RemoveCondition id\n    Calculate -> do\n      deck <- H.gets _.deck\n      conditions <- H.requestAll (Proxy @\"condition\") Condition.GetConditions\n      let conditions' = Array.fromFoldable <<< Map.values $ conditions\n      H.tell (Proxy @\"result\") unit (Result.Calculate deck conditions')\n    RestoreState json -> do\n      case parseJson json >>= decodeJson @Export of\n        Left error -> do\n          Console.error $ printJsonDecodeError error\n          action PrepareDefaultState\n        Right { deck, conditions } -> do\n          conditions' <- traverse (flap $ { id: _, condition: _ } <$> generateId) conditions\n          H.put { deck, conditions: conditions' <#> _.id }\n          H.tell (Proxy @\"deck\") unit (Deck.SetDeck deck)\n          for_ conditions' \\{ id, condition } -> do\n            H.tell (Proxy @\"condition\") id (Condition.RestoreState deck condition)\n          action Calculate\n    SaveState -> do\n      { deck, conditions: ids } <- H.get\n      conditions <- H.requestAll (Proxy @\"condition\") Condition.GetState\n      let conditions' = Array.mapMaybe (Map.lookup <@> conditions) ids\n      let json = encodeJson { deck, conditions: conditions' }\n      H.liftEffect $ Hash.setHash (stringify json)\n","module Halogen.Aff.Util\n  ( awaitLoad\n  , awaitBody\n  , selectElement\n  , runHalogenAff\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Error.Class (throwError)\nimport Data.Either (Either(..), either)\nimport Data.Maybe (Maybe, maybe)\nimport Effect (Effect)\nimport Effect.Aff (Aff, effectCanceler, makeAff, nonCanceler, runAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Exception (throwException, error)\nimport Web.DOM.ParentNode (QuerySelector(..), querySelector)\nimport Web.Event.EventTarget (addEventListener, eventListener, removeEventListener)\nimport Web.HTML (window)\nimport Web.HTML.Event.EventTypes as ET\nimport Web.HTML.HTMLDocument (readyState)\nimport Web.HTML.HTMLDocument as HTMLDocument\nimport Web.HTML.HTMLDocument.ReadyState (ReadyState(..))\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLElement as HTMLElement\nimport Web.HTML.Window as Window\n\n-- | Waits for the document to load.\nawaitLoad :: Aff Unit\nawaitLoad = makeAff \\callback -> do\n  rs <- readyState =<< Window.document =<< window\n  case rs of\n    Loading -> do\n      et <- Window.toEventTarget <$> window\n      listener <- eventListener (\\_ -> callback (Right unit))\n      addEventListener ET.domcontentloaded listener false et\n      pure $ effectCanceler (removeEventListener ET.domcontentloaded listener false et)\n    _ -> do\n      callback (Right unit)\n      pure nonCanceler\n\n-- | Waits for the document to load and then finds the `body` element.\nawaitBody :: Aff HTMLElement\nawaitBody = do\n  awaitLoad\n  body <- selectElement (QuerySelector \"body\")\n  maybe (throwError (error \"Could not find body\")) pure body\n\n-- | Tries to find an element in the document.\nselectElement :: QuerySelector -> Aff (Maybe HTMLElement)\nselectElement query = do\n  mel <- liftEffect do\n    (querySelector query <<< HTMLDocument.toParentNode <=< Window.document) =<< window\n  pure $ HTMLElement.fromElement =<< mel\n\n-- | Runs an `Aff` value of the type commonly used by Halogen components. Any\n-- | unhandled errors will be re-thrown as exceptions.\nrunHalogenAff :: forall x. Aff x -> Effect Unit\nrunHalogenAff = runAff_ (either throwException (const (pure unit)))\n","module Control.Monad.Fork.Class where\n\nimport Prelude hiding (join)\n\nimport Effect.Aff as Aff\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError)\nimport Control.Monad.Reader.Trans (ReaderT(..), runReaderT)\nimport Control.Monad.Trans.Class (lift)\n\n-- | Represents Monads which can be forked asynchronously.\n-- |\n-- | Laws:\n-- |\n-- | ```purescript\n-- | -- Unjoined suspension is a no-op\n-- | suspend a1 *> suspend a2 = suspend a2\n-- |\n-- | -- Suspend/join is identity\n-- | suspend >=> join = id\n-- |\n-- | -- Fork/join is identity\n-- | fork >=> join = id\n-- |\n-- | -- Join is idempotent\n-- | join t *> join t = join t\n-- | ```\nclass (Monad m, Functor f) <= MonadFork f m | m -> f where\n  suspend :: forall a. m a -> m (f a)\n  fork :: forall a. m a -> m (f a)\n  join :: forall a. f a -> m a\n\ninstance monadForkAff :: MonadFork Aff.Fiber Aff.Aff where\n  suspend = Aff.suspendAff\n  fork = Aff.forkAff\n  join = Aff.joinFiber\n\ninstance monadForkReaderT :: MonadFork f m => MonadFork f (ReaderT r m) where\n  suspend (ReaderT ma) = ReaderT (suspend <<< ma)\n  fork (ReaderT ma) = ReaderT (fork <<< ma)\n  join = lift <<< join\n\n-- | Represents Monads which can be killed after being forked.\n-- |\n-- | Laws:\n-- |\n-- | ```purescript\n-- | -- Killed suspension is an exception\n-- | suspend a >>= \\f -> kill e f *> join f = throwError e\n-- |\n-- | -- Suspend/kill is unit\n-- | suspend a >>= kill e = pure unit\n-- | ```\nclass (MonadFork f m, MonadThrow e m) <= MonadKill e f m | m -> e f where\n  kill :: forall a. e -> f a -> m Unit\n\ninstance monadKillAff :: MonadKill Aff.Error Aff.Fiber Aff.Aff where\n  kill = Aff.killFiber\n\ninstance monadKillReaderT :: MonadKill e f m => MonadKill e f (ReaderT r m) where\n  kill e = lift <<< kill e\n\ndata BracketCondition e a\n  = Completed a\n  | Failed e\n  | Killed e\n\n-- | Represents Monads which support cleanup in the presence of async\n-- | exceptions.\n-- |\n-- | Laws:\n-- | ```purescript\n-- | bracket a k \\_ -> pure r\n-- |   = uninterruptible (a >>= k (Completed r))\n-- |\n-- | -- Release failed\n-- | bracket a k \\_ -> throwError e\n-- |   = uninterruptible (a >>= k (Failed e) *> throwError e)\n-- |\n-- | -- Release killed\n-- | fork (bracket a k \\_ -> never) >>= \\f -> kill e f *> void (try (join f))\n-- |   = uninterruptible (a >>= k (Killed e))\n-- | ```\nclass (MonadKill e f m, MonadError e m) <= MonadBracket e f m | m -> e f where\n  bracket :: forall r a. m r -> (BracketCondition e a -> r -> m Unit) -> (r -> m a) -> m a\n  uninterruptible :: forall a. m a -> m a\n  never :: forall a. m a\n\ninstance monadBracketAff :: MonadBracket Aff.Error Aff.Fiber Aff.Aff where\n  bracket acquire release run =\n    Aff.generalBracket acquire\n      { completed: release <<< Completed\n      , failed: release <<< Failed\n      , killed: release <<< Killed\n      }\n      run\n  uninterruptible = Aff.invincible\n  never = Aff.never\n\ninstance monadBracketReaderT :: MonadBracket e f m => MonadBracket e f (ReaderT r m) where\n  bracket (ReaderT acquire) release run = ReaderT \\r ->\n    bracket (acquire r)\n      (\\c a -> runReaderT (release c a) r)\n      (\\a -> runReaderT (run a) r)\n  uninterruptible k = ReaderT \\r ->\n    uninterruptible (runReaderT k r)\n  never = lift never\n","module Halogen.Aff.Driver.State\n  ( LifecycleHandlers\n  , DriverState(..)\n  , mapDriverState\n  , DriverStateRef(..)\n  , DriverStateRec\n  , DriverStateX\n  , unDriverStateX\n  , mkDriverStateXRef\n  , RenderStateX\n  , renderStateX\n  , renderStateX_\n  , unRenderStateX\n  , initDriverState\n  ) where\n\nimport Prelude\n\nimport Data.List (List(..))\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (traverse_)\nimport Effect (Effect)\nimport Effect.Aff (Aff, Fiber)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen.Component (ComponentSpec)\nimport Halogen.Data.Slot (SlotStorage)\nimport Halogen.Data.Slot as SlotStorage\nimport Halogen.Query.HalogenM (ForkId, SubscriptionId)\nimport Halogen.Subscription as HS\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (Element)\n\ntype LifecycleHandlers =\n  { initializers :: List (Aff Unit)\n  , finalizers :: List (Aff Unit)\n  }\n\nnewtype DriverState r s f act ps i o = DriverState (DriverStateRec r s f act ps i o)\n\ntype DriverStateRec r s f act ps i o =\n  { component :: ComponentSpec s f act ps i o Aff\n  , state :: s\n  , refs :: M.Map String Element\n  , children :: SlotStorage ps (DriverStateRef r)\n  , childrenIn :: Ref (SlotStorage ps (DriverStateRef r))\n  , childrenOut :: Ref (SlotStorage ps (DriverStateRef r))\n  , selfRef :: Ref (DriverState r s f act ps i o)\n  , handlerRef :: Ref (o -> Aff Unit)\n  , pendingQueries :: Ref (Maybe (List (Aff Unit)))\n  , pendingOuts :: Ref (Maybe (List (Aff Unit)))\n  , pendingHandlers :: Ref (Maybe (List (Aff Unit)))\n  , rendering :: Maybe (r s act ps o)\n  , fresh :: Ref Int\n  , subscriptions :: Ref (Maybe (M.Map SubscriptionId HS.Subscription))\n  , forks :: Ref (M.Map ForkId (Fiber Unit))\n  , lifecycleHandlers :: Ref LifecycleHandlers\n  }\n\nmapDriverState\n  :: forall r s f act ps i o\n   . (DriverStateRec r s f act ps i o -> DriverStateRec r s f act ps i o)\n  -> DriverState r s f act ps i o\n  -> DriverState r s f act ps i o\nmapDriverState f (DriverState ds) = DriverState (f ds)\n\nnewtype DriverStateRef r f o = DriverStateRef (Ref (DriverStateX r f o))\n\n-- | A version of `DriverState` with the aspects relating to child components\n-- | existentially hidden.\ndata DriverStateX\n  (r :: Type -> Type -> Row Type -> Type -> Type)\n  (f :: Type -> Type)\n  (o :: Type)\n\nmkDriverStateXRef\n  :: forall r s f act ps i o\n   . Ref (DriverState r s f act ps i o)\n  -> Ref (DriverStateX r f o)\nmkDriverStateXRef = unsafeCoerce\n\nunDriverStateX\n  :: forall r f i o x\n   . (forall s act ps. DriverStateRec r s f act ps i o -> x)\n  -> DriverStateX r f o\n  -> x\nunDriverStateX = unsafeCoerce\n\n-- | A wrapper of `r` from `DriverState` with the aspects relating to child\n-- | components existentially hidden.\ndata RenderStateX (r :: Type -> Type -> Row Type -> Type -> Type)\n\nmkRenderStateX\n  :: forall r s f ps o m\n   . m (r s f ps o)\n  -> m (RenderStateX r)\nmkRenderStateX = unsafeCoerce\n\nunRenderStateX\n  :: forall r x\n   . (forall s f ps o. r s f ps o -> x)\n  -> RenderStateX r\n  -> x\nunRenderStateX = unsafeCoerce\n\nrenderStateX\n  :: forall m r f o\n   . Functor m\n  => (forall s act ps. Maybe (r s act ps o) -> m (r s act ps o))\n  -> DriverStateX r f o\n  -> m (RenderStateX r)\nrenderStateX f = unDriverStateX \\st ->\n  mkRenderStateX (f st.rendering)\n\nrenderStateX_\n  :: forall m r f o\n   . Applicative m\n  => (forall s act ps. r s act ps o -> m Unit)\n  -> DriverStateX r f o\n  -> m Unit\nrenderStateX_ f = unDriverStateX \\st -> traverse_ f st.rendering\n\ninitDriverState\n  :: forall r s f act ps i o\n   . ComponentSpec s f act ps i o Aff\n  -> i\n  -> (o -> Aff Unit)\n  -> Ref LifecycleHandlers\n  -> Effect (Ref (DriverStateX r f o))\ninitDriverState component input handler lchs = do\n  selfRef <- Ref.new (unsafeCoerce {})\n  childrenIn <- Ref.new SlotStorage.empty\n  childrenOut <- Ref.new SlotStorage.empty\n  handlerRef <- Ref.new handler\n  pendingQueries <- Ref.new (Just Nil)\n  pendingOuts <- Ref.new (Just Nil)\n  pendingHandlers <- Ref.new Nothing\n  fresh <- Ref.new 1\n  subscriptions <- Ref.new (Just M.empty)\n  forks <- Ref.new M.empty\n  let\n    ds :: DriverStateRec r s f act ps i o\n    ds =\n      { component\n      , state: component.initialState input\n      , refs: M.empty\n      , children: SlotStorage.empty\n      , childrenIn\n      , childrenOut\n      , selfRef\n      , handlerRef\n      , pendingQueries\n      , pendingOuts\n      , pendingHandlers\n      , rendering: Nothing\n      , fresh\n      , subscriptions\n      , forks\n      , lifecycleHandlers: lchs\n      }\n  Ref.write (DriverState ds) selfRef\n  pure $ mkDriverStateXRef selfRef\n","module Halogen.Aff.Driver.Eval\n  ( Renderer\n  , evalF\n  , evalQ\n  , evalM\n  , handleLifecycle\n  , queueOrRun\n  , handleAff\n  ) where\n\nimport Prelude\n\nimport Control.Applicative.Free (hoistFreeAp, retractFreeAp)\nimport Control.Monad.Fork.Class (fork)\nimport Control.Monad.Free (foldFree)\nimport Control.Parallel (parSequence_, parallel, sequential)\nimport Data.Coyoneda (liftCoyoneda)\nimport Data.Either (either)\nimport Data.Foldable (traverse_)\nimport Data.List (List, (:))\nimport Data.List as L\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple(..))\nimport Effect (Effect)\nimport Effect.Aff (Aff, error, finally, joinFiber, killFiber, runAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Exception (throwException)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen.Aff.Driver.State (DriverState(..), DriverStateRef(..), LifecycleHandlers, mapDriverState, unDriverStateX)\nimport Halogen.Query.ChildQuery as CQ\nimport Halogen.Query.HalogenM (ForkId(..), HalogenAp(..), HalogenF(..), HalogenM(..), SubscriptionId(..))\nimport Halogen.Query.HalogenQ as HQ\nimport Halogen.Query.Input (Input)\nimport Halogen.Query.Input as Input\nimport Halogen.Subscription as HS\nimport Unsafe.Reference (unsafeRefEq)\n\ntype Renderer r =\n  forall s f act ps i o\n   . Ref LifecycleHandlers\n  -> Ref (DriverState r s f act ps i o)\n  -> Effect Unit\n\nevalF\n  :: forall r s f act ps i o\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> Input act\n  -> Aff Unit\nevalF render ref = case _ of\n  Input.RefUpdate (Input.RefLabel p) el -> do\n    liftEffect $ flip Ref.modify_ ref $ mapDriverState \\st ->\n      st { refs = M.alter (const el) p st.refs }\n  Input.Action act -> do\n    DriverState st <- liftEffect (Ref.read ref)\n    evalM render ref (st.component.eval (HQ.Action act unit))\n\nevalQ\n  :: forall r s f act ps i o a\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> f a\n  -> Aff (Maybe a)\nevalQ render ref q = do\n  DriverState st <- liftEffect (Ref.read ref)\n  evalM render ref (st.component.eval (HQ.Query (Just <$> liftCoyoneda q) (const Nothing)))\n\nevalM\n  :: forall r s f act ps i o a\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> HalogenM s act ps o Aff a\n  -> Aff a\nevalM render initRef (HalogenM hm) = foldFree (go initRef) hm\n  where\n  go\n    :: forall s' f' act' ps' i' o' a'\n     . Ref (DriverState r s' f' act' ps' i' o')\n    -> HalogenF s' act' ps' o' Aff a'\n    -> Aff a'\n  go ref = case _ of\n    State f -> do\n      DriverState (st@{ state, lifecycleHandlers }) <- liftEffect (Ref.read ref)\n      case f state of\n        Tuple a state'\n          | unsafeRefEq state state' -> pure a\n          | otherwise -> do\n              liftEffect $ Ref.write (DriverState (st { state = state' })) ref\n              handleLifecycle lifecycleHandlers (render lifecycleHandlers ref)\n              pure a\n    Subscribe fes k -> do\n      sid <- fresh SubscriptionId ref\n      finalize <- liftEffect $ HS.subscribe (fes sid) \\act ->\n        handleAff $ evalF render ref (Input.Action act)\n      DriverState ({ subscriptions }) <- liftEffect (Ref.read ref)\n      liftEffect $ Ref.modify_ (map (M.insert sid finalize)) subscriptions\n      pure (k sid)\n    Unsubscribe sid next -> do\n      liftEffect $ unsubscribe sid ref\n      pure next\n    Lift aff ->\n      aff\n    ChildQuery cq ->\n      evalChildQuery ref cq\n    Raise o a -> do\n      DriverState { handlerRef, pendingOuts } <- liftEffect (Ref.read ref)\n      handler <- liftEffect (Ref.read handlerRef)\n      queueOrRun pendingOuts (handler o)\n      pure a\n    Par (HalogenAp p) ->\n      sequential $ retractFreeAp $ hoistFreeAp (parallel <<< evalM render ref) p\n    Fork hmu k -> do\n      fid <- fresh ForkId ref\n      DriverState ({ forks }) <- liftEffect (Ref.read ref)\n      doneRef <- liftEffect (Ref.new false)\n      fiber <- fork $ finally\n        ( liftEffect do\n            Ref.modify_ (M.delete fid) forks\n            Ref.write true doneRef\n        )\n        (evalM render ref hmu)\n      liftEffect $ unlessM (Ref.read doneRef) do\n        Ref.modify_ (M.insert fid fiber) forks\n      pure (k fid)\n    Join fid a -> do\n      DriverState { forks } <- liftEffect (Ref.read ref)\n      forkMap <- liftEffect (Ref.read forks)\n      traverse_ joinFiber (M.lookup fid forkMap)\n      pure a\n    Kill fid a -> do\n      DriverState ({ forks }) <- liftEffect (Ref.read ref)\n      forkMap <- liftEffect (Ref.read forks)\n      traverse_ (killFiber (error \"Cancelled\")) (M.lookup fid forkMap)\n      pure a\n    GetRef (Input.RefLabel p) k -> do\n      DriverState { refs } <- liftEffect (Ref.read ref)\n      pure $ k $ M.lookup p refs\n\n  evalChildQuery\n    :: forall s' f' act' ps' i' o' a'\n     . Ref (DriverState r s' f' act' ps' i' o')\n    -> CQ.ChildQueryBox ps' a'\n    -> Aff a'\n  evalChildQuery ref cqb = do\n    DriverState st <- liftEffect (Ref.read ref)\n    cqb # CQ.unChildQueryBox \\(CQ.ChildQuery unpack query reply) -> do\n      let\n        evalChild (DriverStateRef var) = parallel do\n          dsx <- liftEffect (Ref.read var)\n          unDriverStateX (\\ds -> evalQ render ds.selfRef query) dsx\n      reply <$> sequential (unpack evalChild st.children)\n\nunsubscribe\n  :: forall r s' f' act' ps' i' o'\n   . SubscriptionId\n  -> Ref (DriverState r s' f' act' ps' i' o')\n  -> Effect Unit\nunsubscribe sid ref = do\n  DriverState ({ subscriptions }) <- Ref.read ref\n  subs <- Ref.read subscriptions\n  traverse_ HS.unsubscribe (M.lookup sid =<< subs)\n\nhandleLifecycle :: Ref LifecycleHandlers -> Effect ~> Aff\nhandleLifecycle lchs f = do\n  liftEffect $ Ref.write { initializers: L.Nil, finalizers: L.Nil } lchs\n  result <- liftEffect f\n  { initializers, finalizers } <- liftEffect $ Ref.read lchs\n  traverse_ fork finalizers\n  parSequence_ initializers\n  pure result\n\nfresh\n  :: forall r s f act ps i o a\n   . (Int -> a)\n  -> Ref (DriverState r s f act ps i o)\n  -> Aff a\nfresh f ref = do\n  DriverState st <- liftEffect (Ref.read ref)\n  liftEffect $ Ref.modify' (\\i -> { state: i + 1, value: f i }) st.fresh\n\nqueueOrRun\n  :: Ref (Maybe (List (Aff Unit)))\n  -> Aff Unit\n  -> Aff Unit\nqueueOrRun ref au =\n  liftEffect (Ref.read ref) >>= case _ of\n    Nothing -> au\n    Just p -> liftEffect $ Ref.write (Just (au : p)) ref\n\n-- We could perhaps do something more intelligent now this isn't baked into\n-- the virtual-dom rendering. It hasn't really been a problem so far though.\nhandleAff :: forall a. Aff a -> Effect Unit\nhandleAff = runAff_ (either throwException (const (pure unit)))\n","module Halogen.Aff.Driver\n  ( RenderSpec\n  , runUI\n  , module Halogen\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Fork.Class (fork)\nimport Control.Monad.Rec.Class (Step(..), tailRecM)\nimport Control.Parallel (parSequence_)\nimport Data.List ((:))\nimport Data.List as L\nimport Data.Map as M\nimport Data.Maybe (Maybe(..), maybe, isJust, isNothing)\nimport Data.Traversable (for_, traverse_)\nimport Data.Tuple (Tuple(..))\nimport Effect (Effect)\nimport Effect.Aff (Aff, killFiber)\nimport Effect.Class (liftEffect)\nimport Effect.Console (warn)\nimport Effect.Exception (error, throw)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen (HalogenIO)\nimport Halogen.Aff.Driver.Eval as Eval\nimport Halogen.Aff.Driver.State (DriverState(..), DriverStateRef(..), DriverStateX, LifecycleHandlers, RenderStateX, initDriverState, mapDriverState, renderStateX, renderStateX_, unDriverStateX)\nimport Halogen.Component (Component, ComponentSlot, ComponentSlotBox, unComponent, unComponentSlot)\nimport Halogen.Data.Slot as Slot\nimport Halogen.HTML.Core as HC\nimport Halogen.Query.HalogenQ as HQ\nimport Halogen.Query.Input (Input)\nimport Halogen.Query.Input as Input\nimport Halogen.Subscription as HS\n\n-- | `RenderSpec` allows for alternative driver implementations without the need\n-- | to provide all of the driver machinery again, focusing just on the code\n-- | needed to render components.\n-- |\n-- | The type variables are as follows:\n-- | - `h` is the type of value being rendered (`Halogen.HTML.Core.HTML`, for\n-- |   example).\n-- | - `r` is the type for the \"render state\" for the driver. This is a value\n-- |   that is stored for each component, that allows the driver to persist\n-- |   state between each rendering of a component. This will differ entirely\n-- |   for each driver. `r` accepts a number of parameters that will be\n-- |   explained below.\n-- |\n-- | The \"inner\" type variables, used by `r` and the other functions are as\n-- | follows:\n-- | - `s` is the state type for the component.\n-- | - `act` is the action type for the component\n-- | - `ps` is the set of slots for addressing child components\n-- | - `o` is the output message type for the component\n-- |\n-- | Note that none of these variables can escape `RenderSpec`'s functions. They\n-- | need to be instantiated with each function call, as the same `RenderSpec`\n-- | is used to deal with all components in the hierarchy.\n-- |\n-- | The `render` function is the main part of the spec, it accepts:\n-- | - A \"handler\" function, for evaluating component queries. This is used to\n-- |   implement event handlers in HTML-based drivers.\n-- | - A \"child\" function for dealing with the rendering of children, returning\n-- |   the render state for the child component in an existentially hidden\n-- |   package. This return value would commonly be used to extract the rendered\n-- |   subtree for the child to graft it in place of the child slot. The\n-- |   existential package can be unwrapped with `Halogen.Aff.Driver.State.unRenderStateX`.\n-- | - The `h` value to render, parameterised by the slot type for the\n-- |   component's children. This slot type is what the \"child\" function\n-- |   accepts.\n-- | - The previous render state for the component. If the component has not\n-- |   previously been initalized, this will be `Nothing`.\n-- |\n-- | The render function then returns the updated (or initial) render state for\n-- | the component, which will be fed back into `render` the next time the\n-- | component needs to update.\n-- |\n-- | The `renderChild` function's behaviour will be highly dependant on the\n-- | particular driver implementing `RenderSpec`. Its purpose is to take a\n-- | driver render state for a component and produce a new one that may remap\n-- | the rendered value to be something more suitable for grafting during\n-- | `render` of the parent. For the built-in `halogen-vdom` driver this is\n-- | just `identity`. For the `virtual-dom` driver it wraps the rendered HTML\n-- | in a widget, to prevent the `virtual-dom` algorithm from re-diffing\n-- | values that we know are unchanged.\n-- |\n-- | The `removeChild` function is for drivers that need to perform some special\n-- | cleanup when removing a component from the hierarchy. In the `halogen-vdom`\n-- | driver this actually performs the `removeChild` from the DOM. For the\n-- | `virtual-dom` driver nothing needs to happen here, so it is\n-- | `const (pure unit)`.\n-- |\n-- | The `dispose` function is called when the top level component is disposed of\n-- | via `HalogenIO`.\ntype RenderSpec r =\n  { render ::\n      forall s act ps o\n       . (Input act -> Effect Unit)\n      -> (ComponentSlotBox ps Aff act -> Effect (RenderStateX r))\n      -> HC.HTML (ComponentSlot ps Aff act) act\n      -> Maybe (r s act ps o)\n      -> Effect (r s act ps o)\n  , renderChild :: forall s act ps o. r s act ps o -> r s act ps o\n  , removeChild :: forall s act ps o. r s act ps o -> Effect Unit\n  , dispose :: forall s act ps o. r s act ps o -> Effect Unit\n  }\n\nrunUI\n  :: forall r f i o\n   . RenderSpec r\n  -> Component f i o Aff\n  -> i\n  -> Aff (HalogenIO f o Aff)\nrunUI renderSpec component i = do\n  lchs <- liftEffect newLifecycleHandlers\n  disposed <- liftEffect $ Ref.new false\n  Eval.handleLifecycle lchs do\n    sio <- HS.create\n    dsx <- Ref.read =<< runComponent lchs (liftEffect <<< HS.notify sio.listener) i component\n    dsx # unDriverStateX \\st -> pure\n      { query: evalDriver disposed st.selfRef\n      , messages: sio.emitter\n      , dispose: dispose disposed lchs dsx\n      }\n  where\n  evalDriver\n    :: forall s f' act ps i' o'\n     . Ref Boolean\n    -> Ref (DriverState r s f' act ps i' o')\n    -> (forall a. f' a -> Aff (Maybe a))\n  evalDriver disposed ref q =\n    liftEffect (Ref.read disposed) >>=\n      if _ then pure Nothing\n      else Eval.evalQ render ref q\n\n  runComponent\n    :: forall f' i' o'\n     . Ref LifecycleHandlers\n    -> (o' -> Aff Unit)\n    -> i'\n    -> Component f' i' o' Aff\n    -> Effect (Ref (DriverStateX r f' o'))\n  runComponent lchs handler j = unComponent \\c -> do\n    lchs' <- newLifecycleHandlers\n    var <- initDriverState c j handler lchs'\n    pre <- Ref.read lchs\n    Ref.write { initializers: L.Nil, finalizers: pre.finalizers } lchs\n    unDriverStateX (render lchs <<< _.selfRef) =<< Ref.read var\n    squashChildInitializers lchs pre.initializers =<< Ref.read var\n    pure var\n\n  render\n    :: forall s f' act ps i' o'\n     . Ref LifecycleHandlers\n    -> Ref (DriverState r s f' act ps i' o')\n    -> Effect Unit\n  render lchs var = Ref.read var >>= \\(DriverState ds) -> do\n    shouldProcessHandlers <- isNothing <$> Ref.read ds.pendingHandlers\n    when shouldProcessHandlers $ Ref.write (Just L.Nil) ds.pendingHandlers\n    Ref.write Slot.empty ds.childrenOut\n    Ref.write ds.children ds.childrenIn\n\n    let\n      -- The following 3 defs are working around a capture bug, see #586\n      pendingHandlers = identity ds.pendingHandlers\n      pendingQueries = identity ds.pendingQueries\n      selfRef = identity ds.selfRef\n\n      handler :: Input act -> Aff Unit\n      handler = Eval.queueOrRun pendingHandlers <<< void <<< Eval.evalF render selfRef\n\n      childHandler :: act -> Aff Unit\n      childHandler = Eval.queueOrRun pendingQueries <<< handler <<< Input.Action\n\n    rendering <-\n      renderSpec.render\n        (Eval.handleAff <<< handler)\n        (renderChild lchs childHandler ds.childrenIn ds.childrenOut)\n        (ds.component.render ds.state)\n        ds.rendering\n\n    children <- Ref.read ds.childrenOut\n    childrenIn <- Ref.read ds.childrenIn\n\n    Slot.foreachSlot childrenIn \\(DriverStateRef childVar) -> do\n      childDS <- Ref.read childVar\n      renderStateX_ renderSpec.removeChild childDS\n      finalize lchs childDS\n\n    flip Ref.modify_ ds.selfRef $ mapDriverState \\ds' ->\n      ds' { rendering = Just rendering, children = children }\n\n    when shouldProcessHandlers do\n      flip tailRecM unit \\_ -> do\n        handlers <- Ref.read pendingHandlers\n        Ref.write (Just L.Nil) pendingHandlers\n        traverse_ (Eval.handleAff <<< traverse_ fork <<< L.reverse) handlers\n        mmore <- Ref.read pendingHandlers\n        if maybe false L.null mmore then Ref.write Nothing pendingHandlers $> Done unit\n        else pure $ Loop unit\n\n  renderChild\n    :: forall ps act\n     . Ref LifecycleHandlers\n    -> (act -> Aff Unit)\n    -> Ref (Slot.SlotStorage ps (DriverStateRef r))\n    -> Ref (Slot.SlotStorage ps (DriverStateRef r))\n    -> ComponentSlotBox ps Aff act\n    -> Effect (RenderStateX r)\n  renderChild lchs handler childrenInRef childrenOutRef =\n    unComponentSlot \\slot -> do\n      childrenIn <- slot.pop <$> Ref.read childrenInRef\n      var <- case childrenIn of\n        Just (Tuple (DriverStateRef existing) childrenIn') -> do\n          Ref.write childrenIn' childrenInRef\n          dsx <- Ref.read existing\n          dsx # unDriverStateX \\st -> do\n            flip Ref.write st.handlerRef $ maybe (pure unit) handler <<< slot.output\n            Eval.handleAff $ Eval.evalM render st.selfRef (st.component.eval (HQ.Receive slot.input unit))\n          pure existing\n        Nothing ->\n          runComponent lchs (maybe (pure unit) handler <<< slot.output) slot.input slot.component\n      isDuplicate <- isJust <<< slot.get <$> Ref.read childrenOutRef\n      when isDuplicate\n        $ warn \"Halogen: Duplicate slot address was detected during rendering, unexpected results may occur\"\n      Ref.modify_ (slot.set $ DriverStateRef var) childrenOutRef\n      Ref.read var >>= renderStateX case _ of\n        Nothing -> throw \"Halogen internal error: child was not initialized in renderChild\"\n        Just r -> pure (renderSpec.renderChild r)\n\n  squashChildInitializers\n    :: forall f' o'\n     . Ref LifecycleHandlers\n    -> L.List (Aff Unit)\n    -> DriverStateX r f' o'\n    -> Effect Unit\n  squashChildInitializers lchs preInits =\n    unDriverStateX \\st -> do\n      let parentInitializer = Eval.evalM render st.selfRef (st.component.eval (HQ.Initialize unit))\n      lchs # Ref.modify_ \\handlers ->\n        { initializers:\n            ( do\n                parSequence_ (L.reverse handlers.initializers)\n                parentInitializer\n                liftEffect do\n                  handlePending st.pendingQueries\n                  handlePending st.pendingOuts\n            ) : preInits\n        , finalizers: handlers.finalizers\n        }\n\n  finalize\n    :: forall f' o'\n     . Ref LifecycleHandlers\n    -> DriverStateX r f' o'\n    -> Effect Unit\n  finalize lchs = do\n    unDriverStateX \\st -> do\n      cleanupSubscriptionsAndForks (DriverState st)\n      let f = Eval.evalM render st.selfRef (st.component.eval (HQ.Finalize unit))\n      lchs # Ref.modify_ \\handlers ->\n        { initializers: handlers.initializers\n        , finalizers: f : handlers.finalizers\n        }\n      Slot.foreachSlot st.children \\(DriverStateRef ref) -> do\n        dsx <- Ref.read ref\n        finalize lchs dsx\n\n  dispose\n    :: forall f' o'\n     . Ref Boolean\n    -> Ref LifecycleHandlers\n    -> DriverStateX r f' o'\n    -> Aff Unit\n  dispose disposed lchs dsx = Eval.handleLifecycle lchs do\n    Ref.read disposed >>=\n      if _ then\n        pure unit\n      else do\n        Ref.write true disposed\n        finalize lchs dsx\n        dsx # unDriverStateX \\{ selfRef } -> do\n          (DriverState ds) <- liftEffect $ Ref.read selfRef\n          for_ ds.rendering renderSpec.dispose\n\nnewLifecycleHandlers :: Effect (Ref LifecycleHandlers)\nnewLifecycleHandlers = Ref.new { initializers: L.Nil, finalizers: L.Nil }\n\nhandlePending :: Ref (Maybe (L.List (Aff Unit))) -> Effect Unit\nhandlePending ref = do\n  queue <- Ref.read ref\n  Ref.write Nothing ref\n  for_ queue (Eval.handleAff <<< traverse_ fork <<< L.reverse)\n\ncleanupSubscriptionsAndForks\n  :: forall r s f act ps i o\n   . DriverState r s f act ps i o\n  -> Effect Unit\ncleanupSubscriptionsAndForks (DriverState ds) = do\n  traverse_ (traverse_ HS.unsubscribe) =<< Ref.read ds.subscriptions\n  Ref.write Nothing ds.subscriptions\n  traverse_ (Eval.handleAff <<< killFiber (error \"finalized\")) =<< Ref.read ds.forks\n  Ref.write M.empty ds.forks\n","var getEffProp = function (name) {\n  return function (node) {\n    return function () {\n      return node[name];\n    };\n  };\n};\n\nexport function nodeTypeIndex(node) {\n  return node.nodeType;\n}\n\nexport function nodeName(node) {\n  return node.nodeName;\n}\n\nexport const baseURI = getEffProp(\"baseURI\");\nexport const _ownerDocument = getEffProp(\"ownerDocument\");\nexport const _parentNode = getEffProp(\"parentNode\");\nexport const _parentElement = getEffProp(\"parentElement\");\n\nexport function hasChildNodes(node) {\n  return function () {\n    return node.hasChildNodes();\n  };\n}\n\nexport const childNodes = getEffProp(\"childNodes\");\nexport const _firstChild = getEffProp(\"firstChild\");\nexport const _lastChild = getEffProp(\"lastChild\");\nexport const _previousSibling = getEffProp(\"previousSibling\");\nexport const _nextSibling = getEffProp(\"nextSibling\");\nexport const _nodeValue = getEffProp(\"nodeValue\");\n\nexport function setNodeValue(value) {\n  return function (node) {\n    return function () {\n      node.nodeValue = value;\n    };\n  };\n}\n\nexport const textContent = getEffProp(\"textContent\");\n\nexport function setTextContent(value) {\n  return function (node) {\n    return function () {\n      node.textContent = value;\n    };\n  };\n}\n\nexport function normalize(node) {\n  return function () {\n    node.normalize();\n  };\n}\n\nexport function clone(node) {\n  return function () {\n    return node.cloneNode(false);\n  };\n}\n\nexport function deepClone(node) {\n  return function () {\n    return node.cloneNode(true);\n  };\n}\n\nexport function isEqualNode(node1) {\n  return function (node2) {\n    return function () {\n      return node1.isEqualNode(node2);\n    };\n  };\n}\n\nexport function compareDocumentPositionBits(node1) {\n  return function (node2) {\n    return function () {\n      return node1.compareDocumentPosition(node2);\n    };\n  };\n}\n\nexport function contains(node1) {\n  return function (node2) {\n    return function () {\n      return node1.contains(node2);\n    };\n  };\n}\n\nexport function _lookupPrefix(prefix) {\n  return function (node) {\n    return function () {\n      return node.lookupPrefix(prefix);\n    };\n  };\n}\n\nexport function _lookupNamespaceURI(ns) {\n  return function (node) {\n    return function () {\n      return node.lookupNamespaceURI(ns);\n    };\n  };\n}\n\nexport function isDefaultNamespace(ns) {\n  return function (node) {\n    return function () {\n      return node.isDefaultNamespace(ns);\n    };\n  };\n}\n\nexport function insertBefore(node1) {\n  return function (node2) {\n    return function (parent) {\n      return function () {\n        parent.insertBefore(node1, node2);\n      };\n    };\n  };\n}\n\nexport function appendChild(node) {\n  return function (parent) {\n    return function () {\n      parent.appendChild(node);\n    };\n  };\n}\n\nexport function replaceChild(newChild) {\n  return function (oldChild) {\n    return function (parent) {\n      return function () {\n        parent.replaceChild(newChild, oldChild);\n      };\n    };\n  };\n}\n\nexport function removeChild(node) {\n  return function (parent) {\n    return function () {\n      parent.removeChild(node);\n    };\n  };\n}\n","module Web.DOM.Node\n  ( module Exports\n  , fromEventTarget\n  , toEventTarget\n  , nodeType\n  , nodeTypeIndex\n  , nodeName\n  , baseURI\n  , ownerDocument\n  , parentNode\n  , parentElement\n  , hasChildNodes\n  , childNodes\n  , firstChild\n  , lastChild\n  , previousSibling\n  , nextSibling\n  , nodeValue\n  , setNodeValue\n  , textContent\n  , setTextContent\n  , normalize\n  , clone\n  , deepClone\n  , isEqualNode\n  , compareDocumentPositionBits\n  , contains\n  , lookupPrefix\n  , lookupNamespaceURI\n  , isDefaultNamespace\n  , insertBefore\n  , appendChild\n  , replaceChild\n  , removeChild\n  ) where\n\nimport Prelude\n\nimport Data.Enum (toEnum)\nimport Data.Maybe (Maybe, fromJust)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Document (Document)\nimport Web.DOM.Element (Element)\nimport Web.DOM.Internal.Types (Node) as Exports\nimport Web.DOM.Internal.Types (Node, NodeList)\nimport Web.DOM.NodeType (NodeType)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nfromEventTarget :: EventTarget -> Maybe Node\nfromEventTarget = unsafeReadProtoTagged \"Node\"\n\ntoEventTarget :: Node -> EventTarget\ntoEventTarget = unsafeCoerce\n\n-- | The type of a node.\nnodeType :: Partial => Node -> NodeType\nnodeType = fromJust <<< toEnum <<< nodeTypeIndex\n\n-- | The numeric value for the type of a node.\nforeign import nodeTypeIndex :: Node -> Int\n\n-- | For elements this is the tag name, for document types this is the doctype\n-- | name, for processing instructions this is the target, for all other nodes\n-- | it is a string like `\"#text\"`, `\"#comment\", etc. depending on the node\n-- | type.\nforeign import nodeName :: Node -> String\n\n-- | The node's base URL.\nforeign import baseURI :: Node -> Effect String\n\n-- | The document the node belongs to, unless the node is a document in which\n-- | case the value is Nothing.\nownerDocument :: Node -> Effect (Maybe Document)\nownerDocument = map toMaybe <<< _ownerDocument\n\nforeign import _ownerDocument :: Node -> Effect (Nullable Document)\n\n-- | The parent node of the node.\nparentNode :: Node -> Effect (Maybe Node)\nparentNode = map toMaybe <<< _parentNode\n\nforeign import _parentNode :: Node -> Effect (Nullable Node)\n\n-- | The parent element of the node.\nparentElement :: Node -> Effect (Maybe Element)\nparentElement = map toMaybe <<< _parentElement\n\nforeign import _parentElement :: Node -> Effect (Nullable Element)\n\n-- | Indicates whether the node has any child nodes.\nforeign import hasChildNodes :: Node -> Effect Boolean\n\n-- | The children of the node.\nforeign import childNodes :: Node -> Effect NodeList\n\n-- | The first child of the node, or Nothing if the node has no children.\nfirstChild :: Node -> Effect (Maybe Node)\nfirstChild = map toMaybe <<< _firstChild\n\nforeign import _firstChild :: Node -> Effect (Nullable Node)\n\n\n-- | The last child of the node, or Nothing if the node has no children.\nlastChild :: Node -> Effect (Maybe Node)\nlastChild = map toMaybe <<< _lastChild\n\nforeign import _lastChild :: Node -> Effect (Nullable Node)\n\n-- | The previous sibling node, or Nothing if there is no previous sibling.\npreviousSibling :: Node -> Effect (Maybe Node)\npreviousSibling = map toMaybe <<< _previousSibling\n\nforeign import _previousSibling :: Node -> Effect (Nullable Node)\n\n-- | The next sibling node, or Nothing if there is no next sibling.\nnextSibling :: Node -> Effect (Maybe Node)\nnextSibling = map toMaybe <<< _nextSibling\n\nforeign import _nextSibling :: Node -> Effect (Nullable Node)\n\n-- | If the node type is text, comment, or processing instruction this is\n-- | `Just` the node's data, or `Nothing` in all other cases.\nnodeValue :: Node -> Effect (Maybe String)\nnodeValue = map toMaybe <<< _nodeValue\n\nforeign import _nodeValue :: Node -> Effect (Nullable String)\n\n-- | If the node type is text, comment, or processing instruction this allows\n-- | the node's data to be changed, or has no effect in all other cases.\nforeign import setNodeValue :: String -> Node -> Effect Unit\n\n-- | If the node type is document fragment, element, text, processing\n-- | instruction, or comment this is the node's data, or null in all other\n-- | cases.\nforeign import textContent :: Node -> Effect String\n\n-- | If the node type is document fragment, element, text, processing\n-- | instruction, or comment this allows the node's data to be changed, or has\n-- | no effect in all other cases.\nforeign import setTextContent :: String -> Node -> Effect Unit\n\n-- | Removes empty text nodes and then combines any remaining text nodes that\n-- | are contiguous.\nforeign import normalize :: Node -> Effect Unit\n\n-- | Clones the node without cloning the node's descendants.\nforeign import clone :: Node -> Effect Node\n\n-- | Clones the node and its descendants.\nforeign import deepClone :: Node -> Effect Node\n\n-- | Checks whether two nodes are equivalent.\nforeign import isEqualNode :: Node -> Node -> Effect Boolean\n\n-- TODO: compareDocumentPosition that returns a semigroup or something instead of the bitmask value\n\n-- | Compares the position of two nodes in the document.\nforeign import compareDocumentPositionBits :: Node -> Node -> Effect Int\n\n-- | Checks whether the second node is contained within the first\nforeign import contains :: Node -> Node -> Effect Boolean\n\nlookupPrefix :: String -> Node -> Effect (Maybe String)\nlookupPrefix p = map toMaybe <<< _lookupPrefix p\n\nforeign import _lookupPrefix :: String -> Node -> Effect (Nullable String)\n\nlookupNamespaceURI :: String -> Node -> Effect (Maybe String)\nlookupNamespaceURI ns = map toMaybe <<< _lookupNamespaceURI ns\n\nforeign import _lookupNamespaceURI :: String -> Node -> Effect (Nullable String)\n\nforeign import isDefaultNamespace :: String -> Node -> Effect Boolean\n\n-- | Inserts the first node before the second as a child of the third node.\nforeign import insertBefore :: Node -> Node -> Node -> Effect Unit\n\n-- | Appends the first node to the child node list of the second node.\nforeign import appendChild :: Node -> Node -> Effect Unit\n\n-- | Uses the first node as a replacement for the second node in the children\n-- | of the third node.\nforeign import replaceChild :: Node -> Node -> Node -> Effect Unit\n\n-- | Removes the first node from the children of the second node.\nforeign import removeChild :: Node -> Node -> Effect Unit\n","module Halogen.VDom.Driver\n  ( runUI\n  , module Halogen.Aff.Driver\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (traverse_)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (unwrap)\nimport Effect (Effect)\nimport Effect.Aff (Aff)\nimport Effect.Class (liftEffect)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Effect.Uncurried as EFn\nimport Halogen.Aff.Driver (HalogenIO)\nimport Halogen.Aff.Driver as AD\nimport Halogen.Aff.Driver.State (RenderStateX, unRenderStateX)\nimport Halogen.Component (Component, ComponentSlot(..), ComponentSlotBox)\nimport Halogen.HTML.Core (HTML(..), Prop)\nimport Halogen.Query.Input (Input)\nimport Halogen.VDom as V\nimport Halogen.VDom.DOM.Prop as VP\nimport Halogen.VDom.Thunk (Thunk)\nimport Halogen.VDom.Thunk as Thunk\nimport Unsafe.Reference (unsafeRefEq)\nimport Web.DOM.Document (Document) as DOM\nimport Web.DOM.Element (Element) as DOM\nimport Web.DOM.Node (Node, appendChild, removeChild, parentNode, nextSibling, insertBefore) as DOM\nimport Web.HTML (window) as DOM\nimport Web.HTML.HTMLDocument as HTMLDocument\nimport Web.HTML.HTMLElement (HTMLElement) as DOM\nimport Web.HTML.HTMLElement as HTMLElement\nimport Web.HTML.Window (document) as DOM\n\ntype VHTML action slots =\n  V.VDom (Array (Prop (Input action))) (ComponentSlot slots Aff action)\n\ntype ChildRenderer action slots = ComponentSlotBox slots Aff action -> Effect (RenderStateX RenderState)\n\nnewtype RenderState state action slots output =\n  RenderState\n    { node :: DOM.Node\n    , machine :: V.Step (VHTML action slots) DOM.Node\n    , renderChildRef :: Ref (ChildRenderer action slots)\n    }\n\ntype HTMLThunk slots action =\n  Thunk (HTML (ComponentSlot slots Aff action)) action\n\ntype WidgetState slots action =\n  Maybe (V.Step (HTMLThunk slots action) DOM.Node)\n\nmkSpec\n  :: forall action slots\n   . (Input action -> Effect Unit)\n  -> Ref (ChildRenderer action slots)\n  -> DOM.Document\n  -> V.VDomSpec\n       (Array (VP.Prop (Input action)))\n       (ComponentSlot slots Aff action)\nmkSpec handler renderChildRef document =\n  V.VDomSpec { buildWidget, buildAttributes, document }\n  where\n\n  buildAttributes\n    :: DOM.Element\n    -> V.Machine (Array (VP.Prop (Input action))) Unit\n  buildAttributes = VP.buildProp handler\n\n  buildWidget\n    :: V.VDomSpec\n         (Array (VP.Prop (Input action)))\n         (ComponentSlot slots Aff action)\n    -> V.Machine\n         (ComponentSlot slots Aff action)\n         DOM.Node\n  buildWidget spec = render\n    where\n\n    render :: V.Machine (ComponentSlot slots Aff action) DOM.Node\n    render = EFn.mkEffectFn1 \\slot ->\n      case slot of\n        ComponentSlot cs ->\n          EFn.runEffectFn1 renderComponentSlot cs\n        ThunkSlot t -> do\n          step <- EFn.runEffectFn1 buildThunk t\n          pure $ V.mkStep $ V.Step (V.extract step) (Just step) patch done\n\n    patch\n      :: EFn.EffectFn2 (WidgetState slots action)\n           (ComponentSlot slots Aff action)\n           (V.Step (ComponentSlot slots Aff action) DOM.Node)\n    patch = EFn.mkEffectFn2 \\st slot ->\n      case st of\n        Just step -> case slot of\n          ComponentSlot cs -> do\n            EFn.runEffectFn1 V.halt step\n            EFn.runEffectFn1 renderComponentSlot cs\n          ThunkSlot t -> do\n            step' <- EFn.runEffectFn2 V.step step t\n            pure $ V.mkStep $ V.Step (V.extract step') (Just step') patch done\n        _ -> EFn.runEffectFn1 render slot\n\n    buildThunk :: V.Machine (HTMLThunk slots action) DOM.Node\n    buildThunk = Thunk.buildThunk unwrap spec\n\n    renderComponentSlot\n      :: EFn.EffectFn1\n           (ComponentSlotBox slots Aff action)\n           (V.Step (ComponentSlot slots Aff action) DOM.Node)\n    renderComponentSlot = EFn.mkEffectFn1 \\cs -> do\n      renderChild <- Ref.read renderChildRef\n      rsx <- renderChild cs\n      let node = getNode rsx\n      pure $ V.mkStep $ V.Step node Nothing patch done\n\n  done :: EFn.EffectFn1 (WidgetState slots action) Unit\n  done = EFn.mkEffectFn1 \\st ->\n    case st of\n      Just step -> EFn.runEffectFn1 V.halt step\n      _ -> pure unit\n\n  getNode :: RenderStateX RenderState -> DOM.Node\n  getNode = unRenderStateX (\\(RenderState { node }) -> node)\n\nrunUI\n  :: forall query input output\n   . Component query input output Aff\n  -> input\n  -> DOM.HTMLElement\n  -> Aff (HalogenIO query output Aff)\nrunUI component i element = do\n  document <- liftEffect $ HTMLDocument.toDocument <$> (DOM.document =<< DOM.window)\n  AD.runUI (renderSpec document element) component i\n\nrenderSpec\n  :: DOM.Document\n  -> DOM.HTMLElement\n  -> AD.RenderSpec RenderState\nrenderSpec document container =\n  { render\n  , renderChild: identity\n  , removeChild\n  , dispose: removeChild\n  }\n  where\n  render\n    :: forall state action slots output\n     . (Input action -> Effect Unit)\n    -> (ComponentSlotBox slots Aff action -> Effect (RenderStateX RenderState))\n    -> HTML (ComponentSlot slots Aff action) action\n    -> Maybe (RenderState state action slots output)\n    -> Effect (RenderState state action slots output)\n  render handler child (HTML vdom) =\n    case _ of\n      Nothing -> do\n        renderChildRef <- Ref.new child\n        let spec = mkSpec handler renderChildRef document\n        machine <- EFn.runEffectFn1 (V.buildVDom spec) vdom\n        let node = V.extract machine\n        void $ DOM.appendChild node (HTMLElement.toNode container)\n        pure $ RenderState { machine, node, renderChildRef }\n      Just (RenderState { machine, node, renderChildRef }) -> do\n        Ref.write child renderChildRef\n        parent <- DOM.parentNode node\n        nextSib <- DOM.nextSibling node\n        machine' <- EFn.runEffectFn2 V.step machine vdom\n        let newNode = V.extract machine'\n        when (not unsafeRefEq node newNode) do\n          substInParent newNode nextSib parent\n        pure $ RenderState { machine: machine', node: newNode, renderChildRef }\n\nremoveChild :: forall state action slots output. RenderState state action slots output -> Effect Unit\nremoveChild (RenderState { node }) = do\n  npn <- DOM.parentNode node\n  traverse_ (\\pn -> DOM.removeChild node pn) npn\n\nsubstInParent :: DOM.Node -> Maybe DOM.Node -> Maybe DOM.Node -> Effect Unit\nsubstInParent newNode (Just sib) (Just pn) = void $ DOM.insertBefore newNode sib pn\nsubstInParent newNode Nothing (Just pn) = void $ DOM.appendChild newNode pn\nsubstInParent _ _ _ = pure unit\n","module Main where\n\nimport Prelude\n\nimport App.App as App\nimport Effect (Effect)\nimport Halogen.Aff (awaitBody, runHalogenAff)\nimport Halogen.VDom.Driver (runUI)\n\n----------------------------------------------------------------\n\nmain :: Effect Unit\nmain = runHalogenAff do\n  body <- awaitBody\n  runUI App.component unit body\n","import { main } from './output/Main/index.js'; main();"],"names":["cb","mod2","compare32","reader","dictMonad","Bind1","bind20","pure18","functorMaybeT1","fromJust4","foldMap4","foldl2","foldr5","eq8","lessThanOrEq1","empty8","dictMonadError","catchError1","Monad0","map35","fail2","from3","foldMap11","$60","unfoldr11","altMaybeT1","traverse22","dictMonoid","semigroupFree1","moduleName","val","state3","fn","foldableNonEmpty1","height8","rotateLeft","rotateRight","compare4","eqTuple1","just","$copy_v","apply12","ns","bind112","$15","$57","$67","$73","$75","$77","$32","$33","$34","$36","def","d","$52","$84","$30","$231","$232","renderAddButton","$83","renderCardSelector","getMinMax","query3","updateStatus","updateCardSelected","$9","monadEffectHalogenM1","$188","$184","$119","elemIndex1","applicativeMaybeT1","plusMaybeT1","dictAlternative","renderConditionAddButton","$218","$219","getConditions","calculate","action2","foldMap22","styleFormInput","styleFormNumber","renderIntegerInput","raiseUpdated","countCards","$3","map112","$18","$19","$16","indexl2","$79","renderResult","renderDeck","unless3","dictMonadRec","tailRecM4","traverse_10","$6","getRandomValues","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","require_BigInteger","exports","module","bigInt2","undefined2","MAX_INT_ARR","smallToArray","DEFAULT_ALPHABET","supportsNativeBigInt","BigInt","Integer","v","radix","alphabet","caseSensitive","parseBase","parseValue","BigInteger","value15","sign2","value","sign","isSmall","SmallInteger","NativeBigInt","isPrecise","n","Math","floor","arrayToSmall","arr","trim2","length8","length","compareAbs","i3","createArray","x","Array","truncate","ceil","add3","a2","b2","sum2","l_a","l_b","r","carry","push","addAny","addSmall","l","subtract","difference3","a_l","b_l","borrow","subtractSmall","multiplyLong","product4","a_i","j","multiplySmall","shiftLeft","concat","multiplySmallAndArray","square","divModSmall","lambda","q2","remainder2","divisor","quotient","divModAny","self","Error","negate","abs4","abs","comparison","divMod1","quotientDigit","shift","result","divisorMostSignificantDigit","base2","divMod2","guess","xlen","highx","highy","check","part","unshift","reverse","qSign","mSign","isBasicPrime","isUnit","equals","isEven","isDivisibleBy","lesser","millerRabinTest","nPrev","prev","divide","next","modPow","mod","add","plus","minus","small2","multiply","l1","l2","multiplyKaratsuba","y","max","slice","c","ac","bd","abcd","times","_multiplyBySmall","divmod","remainder","over","pow","toString","_0","_1","_2","isNegative","exp2","isZero","modInv","isPositive","isOdd","compare","Infinity","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","geq","lesserOrEquals","leq","isPrime","strict","bits","bitLength","logN","log","toJSNumber","t","isProbablePrime","iterations","rng2","randBetween","lastT","lastR","zero","newT","one","newR","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","xSign","ySign","xRem","not","yRem","xDigit","yDigit","xDivMod","yDivMod","roughLOB","max7","min8","gcd","String","shiftRight","remQuo","and","or","xor","integerLogarithm","tmp","p2","p","e","text6","toLowerCase","absBase","alphabetValues","digits","start2","parseBaseFromArray","pow4","toBase2","apply","map","valueOf","neg","Number","out","left","digit","toBaseString","join","parseStringValue","split2","split","decimalPlace","indexOf","test","max8","min9","parseNumberValue","toArray","str","zeros","toJSON","parseInt","i2","minusOne","min","lcm","isInstance","usedRNG","random","low2","range3","high2","restricted","top3","fromArray","define","amd","semigroupoidFn","compose","f2","g","identity","dict","categoryFn","Semigroupoid0","on","flip","$$const","unit","$$Proxy","$$Proxy2","mapFlipped","dictFunctor","fa2","$$void","voidLeft","functorFn","functorArray","flap","ff2","identity2","applyFn","Functor0","applyArray","fs","xs","k","applySecond","dictApply","pure","unless","dictApplicative","v1","constructor","name","when","liftA1","apply4","Apply0","identity3","discard","bindFn","bind","m","bindFlipped","dictBind","composeKleisliFlipped","bindFlipped13","discardUnit","whenM","when8","Applicative0","mb","liftM1","a$prime","ap","f$prime","reflectSymbol","unsafeGet","label5","rec","semigroupUnit","append","semigroupString","s1","s2","semigroupArray","ys","fromCharCode","unsafeCompareImpl","refEq","r1","r2","eqUnit","eqString","eqRowNil","eqRecord","v2","eqRec","dictEqRecord","eqInt","eq2","eqArray","dictEq","eqRowCons","eqRecord1","dictIsSymbol","reflectSymbol2","eq32","ra","rb","tail2","get7","notEq","LT","LT2","GT","GT2","EQ","EQ2","semiringNumber","n1","n2","mul","semiringInt","ringNumber","sub","Semiring0","ordUnit","Eq0","ordString","ordStringImpl","ordInt","ordIntImpl","dictOrd","clamp","min1","max1","hi","boundedInt","top","bottom","showInt","show","Inl","Inl2","value0","Inr","Inr2","NoArguments","NoArguments2","identity4","Nothing","Nothing2","Just","Just2","maybe","isNothing","isJust","functorMaybe","map2","fromMaybe","fromJust","applyMaybe","bindMaybe","applicativeMaybe","Left","Left2","Right","Right2","note","functorEither","map3","either","applyEither","bindEither","applicativeEither","commutativeRingNumber","Ring0","div","mempty","$runtime_lazy","name15","init3","lineNumber","ReferenceError","monadEffect","applicativeEffect","bindEffect","$lazy_applyEffect","$lazy_functorEffect","functorEffect","applyEffect","error","msg","throwException","throwError","functorIdentity","applyIdentity","bindIdentity","applicativeIdentity","monadIdentity","read","ref3","write","$$void2","$$new","modify$prime","state","modify_","s","modify","s$prime","bindFlipped2","map4","Loop","Loop2","Done","Done2","tailRecM","disj","heytingAlgebraBoolean","ff","tt","implies","conj","b1","heytingAlgebraFunction","dictHeytingAlgebra","ff1","tt1","implies1","conj1","disj1","not1","Tuple","Tuple2","value1","snd","fst","put","dictMonadState","state1","modify_2","modify2","gets","get","lift","monadEffectEffect","liftEffect","map5","MaybeT","runMaybeT","monadTransMaybeT","$157","$158","lift3","functorMaybeT","monadMaybeT","applicativeMaybeT","bindMaybeT","applyMaybeT","$159","$160","monadStateMaybeT","lift1","monadMaybeT1","fill","fromFoldableImpl","Cons2","head4","head","tail","emptyList","curryCons","listToArray","list","count","unsafeIndexImpl","functorST","monadST","applicativeST","bindST","$lazy_applyST","applyST","runSTFn1","runSTFn4","bind2","unsafeFreeze","thaw","splice","howMany","bs","run2","st","poke","ret","peek","nothing","empty","identity5","bimap","lmap","dictBifunctor","bimap1","bifunctorEither","unsafeCoerce2","unwrap","unwrap1","alaF","identity6","foldr","traverse_","applySecond3","dictFoldable","foldr22","$454","for_","traverse_15","foldl","foldableMaybe","foldMap","mempty2","foldMapDefaultR","append7","Semigroup0","acc","foldableArray","len","runFn2","runFn3","runFn4","Additive","semigroupAdditive","dictSemiring","monoidAdditive","semigroupAdditive1","mapWithIndex","functorWithIndexArray","traverseArrayImpl","array1","array2","array3","concat2","array","go2","bot","pivot","identity7","traverse","sequenceDefault","dictTraversable","traversableArray","sequence","Foldable1","semigroupJoinWith","dictSemigroup","unfoldable1Array","unfoldr1","unfoldr1ArrayImpl","fst2","snd2","tuple","maybe2","isNothing2","$$void3","map6","map22","fromJust3","when2","foldMap12","zipWith","updateAt","runFn5","unsafeIndex","unsafeIndex1","snoc","withArray","singleton2","range2","end","step4","$$null","mapWithIndex2","index","fromFoldable","foldr2","foldMap2","findIndex","find2","filter","elemIndex","eq22","elem2","deleteAt","deleteBy","concatMap","mapMaybe","$189","$190","any2","all2","CoyonedaF","CoyonedaF2","coyoneda","fi","mkExists","liftCoyoneda","foldr8","mapWithIndex3","foldl8","foldrWithIndex","foldMapWithIndexDefaultR","dictFoldableWithIndex","foldrWithIndex1","foldableWithIndexArray","z","$291","$292","$293","foldlWithIndex","$294","$295","$296","foldMapWithIndex","Foldable0","traverseWithIndexDefault","dictTraversableWithIndex","sequence2","Traversable2","mapWithIndex4","FunctorWithIndex0","sequence12","$174","$175","traversableWithIndexArray","traverseWithIndex","FoldableWithIndex1","NonEmpty","NonEmpty2","Nil","Nil2","Cons","functorList","$copy_v1","$tco_result","$tco_var_v","$tco_done","$tco_loop","reverseUnrolledMap","$copy_v3","$tco_result2","$tco_var_v2","$tco_done1","$tco_loop2","v3","foldableList","rev3","$284","$285","$copy_b","$tco_var_b","append22","$286","$287","foldr3","append1","foldable1NonEmptyList","append13","foldMap13","foldMap1","a1","foldr1","$250","$251","foldl1","altList","alt","plusList","Alt0","$runtime_lazy3","map7","identity8","Leaf","Leaf2","Node","Node2","value22","value32","value42","value52","value2","value3","value4","value5","Split","Split2","SplitLast","SplitLast2","unsafeNode","singleton4","unsafeBalancedNode","rk","rv","rl","rr","lk","lv","ll","lr","$lazy_unsafeSplit","comp","unsafeSplit","$lazy_unsafeSplitLast","unsafeSplitLast","unsafeJoinNodes","$lazy_unsafeUnionWith","app","l$prime","r$prime","unsafeUnionWith","unionWith","m1","m2","lookup","insert","functorMap","foldableMap","$lazy_go","m$prime","z$prime","traversableMap","v$prime","values","empty2","plusMap","altMap1","semigroupAlternate","dictAlt","alt5","monoidAlternate","dictPlus","semigroupAlternate1","OrdBox","OrdBox2","mkOrdBox","eqOrdBox","ordTuple2","ordTuple","dictEq1","eq13","dictOrd1","compare12","eqTuple2","foldSubmap2","appendFn","foldSubmapBy1","memptyValue","kmin","kmax","tooSmall","lessThan1","tooLarge","greaterThan1","inBounds","pop1","lookup1","insert1","lookup2","mkOrdBox2","sym","key","joinWith","$$null2","InputButton","InputButton2","InputCheckbox","InputCheckbox2","InputColor","InputColor2","InputDate","InputDate2","InputDatetimeLocal","InputDatetimeLocal2","InputEmail","InputEmail2","InputFile","InputFile2","InputHidden","InputHidden2","InputImage","InputImage2","InputMonth","InputMonth2","InputNumber","InputNumber2","InputPassword","InputPassword2","InputRadio","InputRadio2","InputRange","InputRange2","InputReset","InputReset2","InputSearch","InputSearch2","InputSubmit","InputSubmit2","InputTel","InputTel2","InputText","InputText2","InputTime","InputTime2","InputUrl","InputUrl2","InputWeek","InputWeek2","renderInputType","show2","isNaN","Any","Any2","Step","Step3","renderStepValue","RefUpdate","RefUpdate2","Action","Action3","toNullable","toMaybe","Step2","step","halt","extract2","unStep","map8","map1","Text","Text2","Elem","Elem2","Keyed","Keyed2","Widget","Widget2","Grafted","Grafted2","Graft","Graft2","unGraft","$61","bimap2","graft","$63","$64","runGraft","strMapWithIxE","as","fk","o","diffWithKeyAndIxE","o1","f1","f3","o2","createElement","doc","createElementNS","insertChildIx","childNodes","item","insertBefore","removeChild","parentNode","setAttribute","attr3","el","setAttributeNS","removeAttribute","removeAttributeNS","jsUndefined","newMutMap","getProp","doctype","getEffProp","node","map9","querySelector","qs","$2","$4","unsafeReadProtoTagged","_unsafeReadProtoTagged","window","ty","obj","proto","constructorName","$runtime_lazy4","haltWidget","widget","$lazy_patchWidget","vdom","res","mkStep","build","patchWidget","haltText","parent2","$lazy_patchText","nextState","textContent","patchText","haltKeyed","forInE","ks","keys","children","attrs","haltElem","forEachE","eqElemSpec","ns1","ns2","$lazy_patchElem","attrs2","children2","diffWithIxE","a3","ix","patchElem","$lazy_patchKeyed","ix$prime","patchKeyed","buildWidget","w","buildText","document","createTextNode","buildKeyed","name1","as1","ch1","toNode","buildAttributes","buildElem","forE2","child","buildVDom","spec","$lazy_build","tagOf","call","map10","ExceptT","functorExceptT","monadExceptT","applicativeExceptT","bindExceptT","$187","applyExceptT","functorExceptT1","monadThrowExceptT","$198","monadExceptT1","$199","toNumber","isFiniteImpl","isFinite","top2","bottom2","fromString","fromStringAs","fromStringAsImpl","pattern2","RegExp","fromNumber","fromNumberImpl","reverse2","$$null3","_crashWith","unsafeCrashWith","crashWith2","singleton5","$201","show3","replace","charCodeAt","show1","ForeignError","ForeignError2","TypeMismatch","TypeMismatch3","ErrorAtIndex","ErrorAtIndex2","ErrorAtProperty","ErrorAtProperty2","renderForeignError","fail","$153","$154","unsafeReadTagged","fail1","tag","unsafeFromForeign","readString","empty4","lookup3","no","yes","eventListener","event","addEventListener2","type","listener","useCapture","target7","addEventListener","removeEventListener2","removeEventListener","$runtime_lazy5","Created","Created2","Removed","Removed2","Attribute","Attribute2","Property","Property2","Handler","Handler2","Ref","Ref2","propToStrKey","ClassName","HTML","$28","text","$29","prop","dictIsProp","toPropValue1","toPropValue","$31","isPropString","isPropInputType","$45","propFromString","handler","identity9","Pure","Pure2","Lift","Lift3","Ap","Ap2","mkAp","fba","fb","liftFreeAp","goLeft","fStack","valStack","nat","func","cons","goApply","vals","gVal","gRes","functorFreeAp","foldFreeAp","goApply1","goLeft1","nextVals","applyFreeAp","foldFreeAp1","CatQueue","CatQueue2","uncons2","empty5","CatNil","CatNil2","CatCons","CatCons2","link","snoc3","uncons3","foldr4","$copy_ys","$tco_var_xs","$copy_v2","$tco_var_v1","empty6","append3","Free","Free2","Return","Return2","Bind","Bind2","toView","concatF","v22","runExpF","fromView","freeMonad","freeApplicative","freeBind","freeFunctor","cat","snoc4","append2","$lazy_freeApply","$191","freeApply","lift22","pure2","liftF","$192","Aff","EMPTY","PURE","THROW","CATCH","SYNC","ASYNC","BIND","BRACKET","FORK","SEQ","APPLY","CONS","RESUME","RELEASE","FINALIZER","FINALIZED","FORKED","Aff2","_3","AffCtr","nonCanceler2","error6","Scheduler","size5","queue","draining","drain","thunk","isDraining","enqueue","Throw","Catch","Sync","Async","Bracket","Fork","Seq","ParMap","ParApply","ParAlt","Fiber","util","supervisor","aff","runTick","status","interrupt","bhead","btail","attempts","bracketCount","joinId","joins","rethrow","run4","localRunTick","attempt2","isLeft","fromRight","right","runSync","eff","runAsync","result2","register","run","sequential3","par","runPar","fiberId","fibers","killId","kills","early","root","kill2","par2","cb2","kid","kills2","loop","kill","fid","onComplete","resolve","fiber","join4","lhs","rhs","killError","killCb","cancel","innerKills","newKills","kid2","fromLeft","killed","failed","completed","runEff","setTimeout","join5","jid","canceler","isSuspended","Supervisor","isEmpty","killAll","killCount","k2","nonCanceler","_pure","_throwError","_fork","immediate","_liftEffect","makeAff","_sequential","sequential","parallel","identity10","parTraverse_","dictParallel","parallel4","$51","$53","parSequence_","parTraverse_1","parTraverse_2","pure3","$$void4","map11","suspendAff","functorParAff","functorAff","map12","forkAff","ffiUtil","makeFiber","applyParAff","aff1","aff2","monadAff","applicativeAff","bindAff","$lazy_applyAff","applyAff","pure22","bind1","bindFlipped3","parallelAff","Apply1","parallel2","applicativeParAff","$76","monadEffectAff","liftEffect2","effectCanceler","joinFiber","functorFiber","killFiber","suspended","monadThrowAff","$$try2","catchError","MonadThrow0","runAff_","monadAffAff","liftAff","MonadEffect0","ChildQuery","ChildQuery3","unsafeRefEq","$$void5","bind3","append4","traverse_1","traverse_2","unsubscribe","notify","subscribers","emitter","identity11","foldrWithIndex2","traverse2","slots2","foldSubmap1","un2","lookup4","SubscriptionId","ForkId","State","State2","Subscribe","Subscribe2","Unsubscribe","Unsubscribe2","Lift2","ChildQuery2","Raise","Raise2","Par","Par2","Fork2","Join","Join2","Kill","Kill2","GetRef","GetRef2","HalogenM","raise","monadStateHalogenM","$181","monadEffectHalogenM","dictMonadEffect","$186","fork","hmu","Initialize","Initialize5","Finalize","Finalize2","Receive","Receive5","Action2","Query","Query3","$runtime_lazy8","runThunk","buildThunk","toVDom","haltThunk","$lazy_patchThunk","t2","refEq2","patchThunk","voidLeft2","traverse_3","map13","pure4","lookup5","pop3","insert4","ComponentSlot","ComponentSlot2","ThunkSlot","ThunkSlot2","mkEval","args","handleAction","initialize","finalize","receive","unCoyoneda","$46","handleQuery","runExists","defaultEval","element2","props","footer","h1","h2","header","i","input","li","main","option","select","ul","div2","div_","button","a","unwrap2","runExcept","preventDefault","target","currentTarget","$5","domcontentloaded","select2","input3","fromEventTarget","map14","composeKleisli2","composeKleisliFlipped2","readProp2","readString2","handler2","et","ev","onClick","mouseHandler","onFocus","$58","focusHandler","onDragEnter","$68","dragHandler","onDragOver","$74","onDragStart","onDrop","$78","onValueChange","$85","unsafeToForeign","unwrap3","prop2","prop1","prop22","prop4","rel","step3","target2","type_3","min4","max4","href","draggable","classes","$35","class_","$37","insert5","unsafeSet","copy2","get2","append12","fa_","empty7","button2","content3","style2","h","downButton","plusButton","removeButton","toggleButton","upButton","not2","mapFlipped2","discard2","put2","pure5","map15","insert6","modify_3","bind4","modify5","whenM2","gets2","bind12","SetItems","SetItems2","EnterEdit","EnterEdit2","LeaveEdit","LeaveEdit2","Toggle","Toggle2","Receive2","componentSlot2","lookup13","pop12","insert13","lookup23","pop22","insert22","output2","mkComponentSlot","pop","set","component","output","slot_","componentSlot1","componentSlot22","component7","slot","outputQuery","$11","fromElement","$$void6","queryAll2","slots1","slots22","insert10","catMapMaybes1","mkChildQueryBox","map42","traverse12","$173","$176","query2","$177","$178","$179","identity12","tell2","query1","query22","slot5","req","requestAll","queryAll1","queryAll22","id2","stringify","JSON","_caseJson","isNull3","isBool","isNum","isStr","isArr","isObj","toJsonType","verbJsonType","toObject","show12","TypeMismatch2","UnexpectedValue","UnexpectedValue2","AtIndex","AtIndex2","AtKey","AtKey2","Named","Named2","MissingValue","MissingValue2","printJsonDecodeError","err","toArray2","Symbol","iterator","fromCodePoint","codePointAt","lmap2","composeKleisliFlipped3","traverseWithIndex2","decodeString","caseJsonString","decodeNumber","caseJsonNumber","decodeJArray","decodeInt","decodeBoolean","caseJsonBoolean","decodeArray","decoder","$89","$90","$92","$93","$91","bind5","lmap3","map17","gDecodeJsonNil","gDecodeJson","decodeRecord","dictGDecodeJson","gDecodeJson1","decodeJson","json","decodeJsonString","gDecodeJsonCons","dictDecodeJsonField","decodeJsonField1","decodeJsonField","object2","fieldName","rest","decodeFieldId","dictDecodeJson","decodeJson1","decodeArray2","map18","encodeArray","encoder","$59","gEncodeJsonNil","gEncodeJson","encodeRecord","dictGEncodeJson","gEncodeJson1","encodeJson","encodeJsonJString","encodeJsonInt","encodeJsonArray","dictEncodeJson","gEncodeJsonCons","encodeJson1","row","insert3","thawST","append5","genericShow$prime","genericShowSum","dictGenericShow","genericShow$prime1","dictGenericShow1","genericShow$prime2","rnds8","Uint8Array","regex_default","validate_default","uuid","byteToHex","unsafeStringify","offset","parse_default","TypeError","native_default","randomUUID","crypto","ROTL","v5","v35","version","hashfunc","generateUUID","namespace","buf","_namespace","stringToBytes","unescape","encodeURIComponent","bytes","DNS","URL","K","H","isArray","N","M","Uint32Array","W","T","f","compare2","toString3","parseUUID","validateV4UUID","genv5UUID","v5_default","genUUID","options2","rnds","rng","eqUUID","eq3","compare3","encodeJson2","mapFlipped3","decodeJson2","map19","Id","eqId","ordId","encodeJsonId","toString4","namespaceTcgCalculator","decodeJsonId","id3","maybe$prime","generateId","fromString3","genericShowConstructor2","ctor","countIsSymbol","gEncodeJsonCons2","bindFlipped4","decodeJson3","AtLeast","AtLeast2","JustDraw","JustDraw2","Remains","Remains2","JustRemains","JustRemains2","Choice","Choice2","LeftOne","LeftOne2","LeftAll","LeftAll2","showConditionMode","genericShow","encodeJsonConditionMode","$233","encodeJsonCondition","readConditionMode","show4","mapFlipped4","selectorIsSymbol","slot2","component1","mkComponent","initialState","items","isEditMode","render","selected","id","items3","items$prime","$69","$70","$72","$80","$86","$87","type_4","show13","alaF2","foldMap3","min5","map20","gets3","lift4","discard3","put3","elem3","tell3","pure6","clamp2","bind6","get3","elem1","traverse_4","modify6","composeKleisliFlipped4","liftEffect3","traverse_12","GetCondition","GetCondition2","RestoreState","RestoreState4","Updated","Updated3","Initialize2","UpdateConditionMode","UpdateConditionMode2","UpdateCardSelected","UpdateCardSelected2","UpdateCardCount","UpdateCardCount2","Receive3","SelectOnFocus","SelectOnFocus3","component2","cards","cards$prime","card","$133","condition","mode","minValue","maxValue","selected2","selected$prime","renderCardCounter","mode$prime","count$prime","$125","$126","element3","$134","toEvent","$135","$136","import_big_integer","__copyProps","to","except2","desc","enumerable","fromInt","default","toNumber2","biMod","toString5","semiringBigInt","add2","ringBigInt","sub3","fromString4","fromBase","fromBaseImpl","commutativeRingBigInt","euclideanRingBigInt","biDiv","yy","degree","$13","CommutativeRing0","message2","message","fromEvent","terminate","worker","Classic","Classic2","Module","Module2","Omit","Omit2","SameOrigin","SameOrigin2","Include","Include2","show5","show14","postMessage","transfer","defaultWorkerOptions","credentials","bind13","lmap4","intercalateMap2","intercalateMap","foldMap122","foldable","joinee","$171","readString3","gEncodeJsonCons3","encodeJson3","wrap2","method2","num","toPrecisionNative","toPrecision","toFixedNative","toFixed","toExponentialNative","toExponential","clamp3","Precision","Precision2","Fixed","Fixed2","Exponential","Exponential2","toStringWith","fixed","$10","$$void7","applySecond2","iterateN2","add1","append6","zero2","one2","map21","unsafeIndex2","product3","product","div3","pascalTriangle","alaF3","eq4","unwrap4","sumBy1","calculateTotal","$copy_n","combinationNumber","others","$copy_r","$tco_var_n","product$prime","hand","eq5","zero3","div4","lift5","bind7","liftAff2","dictMonadAff","discard4","put4","throwError2","$185","gets4","modify_4","traverse_5","pure7","Calculate","Calculate4","component3","deck","deck$prime","param2","attempt","normalizeDeck","conditions","$132","usedCards","foreach","$194","$195","diffCards","used","unused","reply","opts","$$new2","Worker","onMessage","data","onmessage","onerror","combination","total","calculation","newCalculation","currentCalculation","$38","$39","$44","lineIsSymbol","slot3","resultIsSymbol","slot_2","map23","apply2","map110","fromFoldable7","$120","filterKeys2","flap2","notElem3","gets5","requestAll2","bind8","fromFoldable1","tell4","tell1","apply1","map24","bindMaybeT2","bindFlipped5","guard2","Plus1","monadStateMaybeT2","gets1","map32","$$for2","mapFlipped5","lookup6","mapFlipped1","get4","lift6","traverse3","flap1","idIsSymbol2","insert8","generateId2","discard5","discard1","put5","for_2","eq6","tell22","pure8","discard22","modify_5","bind14","pure1","modify_1","modify7","notEq2","identity13","bind22","pure23","when3","eqRec2","eqRowCons2","notEq1","Updated2","AllConditionDeleted","AllConditionDeleted2","GetConditions","GetConditions2","GetState","GetState2","RestoreState2","ToggleDisabled","ToggleDisabled3","Initialize3","AddCondition","AddCondition3","RemoveCondition","RemoveCondition3","ToggleItemDisabled","ToggleItemDisabled2","Receive4","Calculate2","component4","disabled","$220","$221","v42","v52","conditions$prime","cardId","$222","disabled10","$193","$197","$200","$223","$224","modifyAt","$207","$208","$210","$211","current","$214","$215","$225","$226","windowImpl","Loading","Loading2","Interactive","Interactive2","Complete","Complete2","map25","readyState","window2","location","dataTransfer","collect3","type_20","value14","show6","map26","not4","discard6","discard12","put6","pure9","bind9","monadEffectHalogenM2","generateId3","modify_6","bind15","$$void8","whenM3","pure12","liftEffect4","bindFlipped6","get5","eq7","bindFlipped1","modify8","fold2","fold12","bind23","clamp4","pure24","gets6","identity14","min7","composeKleisliFlipped5","traverse_6","discard23","when4","eq12","unless2","fold22","SetDeck","SetDeck2","AddCard","AddCard2","RemoveCard","RemoveCard2","UpdateCard","UpdateCard2","UpdateDeck","UpdateDeck3","UpdateHand","UpdateHand2","UpdateOthers","UpdateOthers2","SelectOnFocus2","StartReorder","StartReorder2","HandleDragBehavior","HandleDragBehavior2","ExecuteReorder","ExecuteReorder2","component5","$129","$130","$101","$102","confirm","old","$$new3","cardCount","deckCount","$137","dat","setData2","dt2","dataTransfer2","setData","elem4","setDragImage","image","types","toEvent2","getData","$138","$139","handCount","otherCount","renderHeader","renderCardList","mel","$131","renderFooter","$140","parseJson","_jsonParser","succ","parse","$$decodeURIComponent","succeed","decodeURIComponent","hashchange","bind10","map27","bindFlipped7","join3","apply3","pure10","voidRight2","getHash","splitAt","before","substring","after","$20","$17","location2","hash","resultIsSymbol2","slot4","deckIsSymbol","conditionIsSymbol","slot1","bind11","monadEffectHalogenM3","liftEffect5","$$void9","matchesWith2","idx","$455","cursor","elem","pos","$456","parser","$21","$22","$23","win","get6","when5","generateId4","discard7","modify_7","tell5","tell12","gets7","eqRec3","eqRowCons3","othersIsSymbol","handIsSymbol","cardsIsSymbol2","nameIsSymbol2","idIsSymbol3","countIsSymbol2","notEq3","bind16","notEq12","tell23","requestAll3","fromFoldable8","tell32","bind24","gDecodeJsonCons2","gDecodeJsonCons1","modeIsSymbol2","disabledIsSymbol","conditionsIsSymbol","decodeJson4","$234","$235","error5","console","traverse4","flap3","map28","put7","mapFlipped6","for_3","flap12","lookup7","gEncodeJsonCons4","gEncodeJsonCons1","encodeJson4","Initialize4","PrepareDefaultState","PrepareDefaultState2","UpdateDeck2","AddCondition2","RemoveCondition2","ToggleDisabled2","Swap","Swap2","ReceiveConditionUpdated","ReceiveConditionUpdated2","Calculate3","RestoreState3","SaveState","SaveState2","component6","v12","es","hash2","defaultDeck","$279","$280","$288","$289","$297","swap","swapST","bind17","liftEffect6","bindFlipped8","composeKleisliFlipped6","pure11","bindFlipped12","pure13","map29","discard8","throwError3","selectElement","toParentNode","runHalogenAff","awaitLoad","callback","rs","awaitBody","body2","monadForkAff","suspend","Functor1","fork2","mapDriverState","traverse_7","bindFlipped9","lookup8","bind18","liftEffect7","discard13","discard9","traverse_13","traverse_22","fork3","parSequence_2","pure14","map30","$180","parallel3","map111","sequential2","map210","insert9","retractFreeAp2","$$delete3","unlessM2","insert12","traverse_32","lookup12","lookup22","foldFree2","alter2","queueOrRun","au","handleLifecycle","lchs","initializers","finalizers","handleAff","fresh","evalQ","evalM","initRef","sid","cqb","refs","childrenIn","childrenOut","selfRef","handlerRef","pendingQueries","pendingOuts","pendingHandlers","rendering","subscriptions","forks","lifecycleHandlers","subscribe","act","evalF","unsubscribe3","subs","unChildQueryBox","dsx","unDriverStateX","ds","handler3","hoistFreeAp","$54","doneRef","fin","$$finally","acquire","bracket","forkMap","bind19","discard10","for_4","traverse_8","fork4","bindFlipped10","traverse_14","traverse_23","traverse_33","discard24","parSequence_3","liftEffect8","pure15","map31","pure16","when6","$$void10","foreachSlot2","renderStateX_2","tailRecM3","fromDone","voidLeft3","bind110","liftEffect1","newLifecycleHandlers","handlePending","getEffProp2","_parentNode","_nextSibling","appendChild","map33","parentNode2","$7","nextSibling","$runtime_lazy9","$$void11","pure17","traverse_9","unwrap5","when7","not5","identity15","bind111","liftEffect9","map34","bindFlipped11","removeChild3","npn","pn","removeChild2","main2","document2","renderSpec2","runUI","getNode","done","renderChildRef","machine","unRenderStateX","buildThunk2","$lazy_patch","$lazy_renderComponentSlot","step$prime","$lazy_render","cs","renderChild","mbEmit","emit","haltProp","applyProp","events","$lazy_patchProp","ps2","prevEvents","onThis","hasAttribute","onThese","v11","onThat","unsafeFreeze2","patchProp","ps1","ps1$prime","toNode2","nextSib","machine$prime","newNode","substInParent","node2","dispose","runComponent","unComponent","preInits","lchs$prime","$$var2","initDriverState","fresh2","mkDriverStateXRef","pre2","parentInitializer","handlers","childrenInRef","$71","shouldProcessHandlers","childHandler","childrenOutRef","unComponentSlot","$65","$66","warn","mkRenderStateX","childDS","ds$prime","mmore","$62","disposed","sio","query","messages","bigInt","undefined","trim","b","base","sum","difference","small","q","exp","low","high","range","toBase","start","fa","label","copy","ref","__do","runSTFn2","runSTFn3","init","unsafeCoerce","go","singleton","find","notElem","any","all","rev","height","extract","forE","attr","parent","pattern","v4","uncons","size","options","$$try","traverse1","element","drop","readProp","composeKleisli","type_","content","style","action","tell","isNull","object","intercalate","_new","src","param","wrap","method","iterateN","filterKeys","dt","collect","fold1","from","setHash","indexl","body","retractFreeAp","renderSpec","pre","$$var","renderStateX"],"version":3,"file":"index.d7634b56.js.map"}